
TYPE INFORMATION LIBRARY CONTENTS
Description: Linux kernel headers for 5.4.0-159-generic
Flags      : 0107 compressed macro_table_present extended_sizeof_info sizeof_long_double
Base tils  : 
Compiler   : GNU C++
sizeof(near*) = 8 sizeof(far*) = 8 near code, near data, cdecl
default_align = 0 sizeof(bool) = 1 sizeof(long)  = 8 sizeof(llong) = 8
sizeof(enum) = 4 sizeof(int) = 4 sizeof(short) = 2
sizeof(long double) = 16

SYMBOLS
00000004 00000001          $8D68C32ED054832757E63F0A732EEA24 ABI_DEFHANDLER_COFF;
00000004 00000002          $8D68C32ED054832757E63F0A732EEA24 ABI_DEFHANDLER_ELF;
00000004 00000003          $8D68C32ED054832757E63F0A732EEA24 ABI_DEFHANDLER_LCALL7;
00000004 00000004          $8D68C32ED054832757E63F0A732EEA24 ABI_DEFHANDLER_LIBCSO;
00000004 00000006          $8D68C32ED054832757E63F0A732EEA24 ABI_FAKE_UTSNAME;
00000004 00000005          $8D68C32ED054832757E63F0A732EEA24 ABI_TRACE;
00000004 00000003          acpi_address_range_id ACPI_ADDRESS_RANGE_ACPI;
00000004 00000005          acpi_address_range_id ACPI_ADDRESS_RANGE_COUNT;
00000004 00000001          acpi_address_range_id ACPI_ADDRESS_RANGE_MEMORY;
00000004 00000004          acpi_address_range_id ACPI_ADDRESS_RANGE_NVS;
00000004 00000002          acpi_address_range_id ACPI_ADDRESS_RANGE_RESERVED;
00000004 00000004          acpi_asf_type ACPI_ASF_TYPE_ADDRESS;
00000004 00000001          acpi_asf_type ACPI_ASF_TYPE_ALERT;
00000004 00000003          acpi_asf_type ACPI_ASF_TYPE_BOOT;
00000004 00000002          acpi_asf_type ACPI_ASF_TYPE_CONTROL;
00000004 00000000          acpi_asf_type ACPI_ASF_TYPE_INFO;
00000004 00000005          acpi_asf_type ACPI_ASF_TYPE_RESERVED;
00000004 00000000          acpi_bert_error_severity ACPI_BERT_ERROR_CORRECTABLE;
00000004 00000002          acpi_bert_error_severity ACPI_BERT_ERROR_CORRECTED;
00000004 00000001          acpi_bert_error_severity ACPI_BERT_ERROR_FATAL;
00000004 00000003          acpi_bert_error_severity ACPI_BERT_ERROR_NONE;
00000004 00000004          acpi_bert_error_severity ACPI_BERT_ERROR_RESERVED;
00000004 00000007          acpi_bus_device_type ACPI_BUS_DEVICE_TYPE_COUNT;
00000004 00000000          acpi_bus_device_type ACPI_BUS_TYPE_DEVICE;
00000004 00000006          acpi_bus_device_type ACPI_BUS_TYPE_ECDT_EC;
00000004 00000001          acpi_bus_device_type ACPI_BUS_TYPE_POWER;
00000004 00000004          acpi_bus_device_type ACPI_BUS_TYPE_POWER_BUTTON;
00000004 00000002          acpi_bus_device_type ACPI_BUS_TYPE_PROCESSOR;
00000004 00000005          acpi_bus_device_type ACPI_BUS_TYPE_SLEEP_BUTTON;
00000004 00000003          acpi_bus_device_type ACPI_BUS_TYPE_THERMAL;
00000004 00000002          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_BRIDGE;
00000004 00000001          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_ENDPOINT;
00000004 00000004          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_HPET;
00000004 00000003          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_IOAPIC;
00000004 00000005          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_NAMESPACE;
00000004 00000000          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_NOT_USED;
00000004 00000006          acpi_dmar_scope_type ACPI_DMAR_SCOPE_TYPE_RESERVED;
00000004 00000003          acpi_dmar_type ACPI_DMAR_TYPE_HARDWARE_AFFINITY;
00000004 00000000          acpi_dmar_type ACPI_DMAR_TYPE_HARDWARE_UNIT;
00000004 00000004          acpi_dmar_type ACPI_DMAR_TYPE_NAMESPACE;
00000004 00000005          acpi_dmar_type ACPI_DMAR_TYPE_RESERVED;
00000004 00000001          acpi_dmar_type ACPI_DMAR_TYPE_RESERVED_MEMORY;
00000004 00000002          acpi_dmar_type ACPI_DMAR_TYPE_ROOT_ATS;
00000004 0000000A          acpi_einj_actions ACPI_EINJ_ACTION_RESERVED;
00000004 00000000          acpi_einj_actions ACPI_EINJ_BEGIN_OPERATION;
00000004 00000006          acpi_einj_actions ACPI_EINJ_CHECK_BUSY_STATUS;
00000004 00000004          acpi_einj_actions ACPI_EINJ_END_OPERATION;
00000004 00000005          acpi_einj_actions ACPI_EINJ_EXECUTE_OPERATION;
00000004 00000001          acpi_einj_command_status ACPI_EINJ_FAILURE;
00000004 00000005          acpi_einj_instructions ACPI_EINJ_FLUSH_CACHELINE;
00000004 00000007          acpi_einj_actions ACPI_EINJ_GET_COMMAND_STATUS;
00000004 00000003          acpi_einj_actions ACPI_EINJ_GET_ERROR_TYPE;
00000004 00000009          acpi_einj_actions ACPI_EINJ_GET_EXECUTE_TIMINGS;
00000004 00000001          acpi_einj_actions ACPI_EINJ_GET_TRIGGER_TABLE;
00000004 00000006          acpi_einj_instructions ACPI_EINJ_INSTRUCTION_RESERVED;
00000004 00000002          acpi_einj_command_status ACPI_EINJ_INVALID_ACCESS;
00000004 00000004          acpi_einj_instructions ACPI_EINJ_NOOP;
00000004 00000000          acpi_einj_instructions ACPI_EINJ_READ_REGISTER;
00000004 00000001          acpi_einj_instructions ACPI_EINJ_READ_REGISTER_VALUE;
00000004 00000002          acpi_einj_actions ACPI_EINJ_SET_ERROR_TYPE;
00000004 00000008          acpi_einj_actions ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS;
00000004 00000003          acpi_einj_command_status ACPI_EINJ_STATUS_RESERVED;
00000004 00000000          acpi_einj_command_status ACPI_EINJ_SUCCESS;
00000004 000000FF          acpi_einj_actions ACPI_EINJ_TRIGGER_ERROR;
00000004 00000002          acpi_einj_instructions ACPI_EINJ_WRITE_REGISTER;
00000004 00000003          acpi_einj_instructions ACPI_EINJ_WRITE_REGISTER_VALUE;
00000004 00000011          acpi_erst_actions ACPI_ERST_ACTION_RESERVED;
00000004 00000008          acpi_erst_instructions ACPI_ERST_ADD;
00000004 0000000A          acpi_erst_instructions ACPI_ERST_ADD_VALUE;
00000004 00000002          acpi_erst_actions ACPI_ERST_BEGIN_CLEAR;
00000004 0000000B          acpi_erst_actions ACPI_ERST_BEGIN_DUMMY_WRIITE;
00000004 00000001          acpi_erst_actions ACPI_ERST_BEGIN_READ;
00000004 00000000          acpi_erst_actions ACPI_ERST_BEGIN_WRITE;
00000004 00000006          acpi_erst_actions ACPI_ERST_CHECK_BUSY_STATUS;
00000004 00000003          acpi_erst_actions ACPI_ERST_END;
00000004 00000005          acpi_erst_actions ACPI_ERST_EXECUTE_OPERATION;
00000004 00000010          acpi_erst_actions ACPI_ERST_EXECUTE_TIMINGS;
00000004 00000003          acpi_erst_command_status ACPI_ERST_FAILURE;
00000004 00000007          acpi_erst_actions ACPI_ERST_GET_COMMAND_STATUS;
00000004 0000000F          acpi_erst_actions ACPI_ERST_GET_ERROR_ATTRIBUTES;
00000004 0000000E          acpi_erst_actions ACPI_ERST_GET_ERROR_LENGTH;
00000004 0000000D          acpi_erst_actions ACPI_ERST_GET_ERROR_RANGE;
00000004 0000000A          acpi_erst_actions ACPI_ERST_GET_RECORD_COUNT;
00000004 00000008          acpi_erst_actions ACPI_ERST_GET_RECORD_ID;
00000004 0000000F          acpi_erst_instructions ACPI_ERST_GOTO;
00000004 00000013          acpi_erst_instructions ACPI_ERST_INSTRUCTION_RESERVED;
00000004 00000005          acpi_erst_instructions ACPI_ERST_LOAD_VAR1;
00000004 00000006          acpi_erst_instructions ACPI_ERST_LOAD_VAR2;
00000004 00000012          acpi_erst_instructions ACPI_ERST_MOVE_DATA;
00000004 00000004          acpi_erst_instructions ACPI_ERST_NOOP;
00000004 00000002          acpi_erst_command_status ACPI_ERST_NOT_AVAILABLE;
00000004 00000005          acpi_erst_command_status ACPI_ERST_NOT_FOUND;
00000004 0000000C          acpi_erst_actions ACPI_ERST_NOT_USED;
00000004 00000001          acpi_erst_command_status ACPI_ERST_NO_SPACE;
00000004 00000000          acpi_erst_instructions ACPI_ERST_READ_REGISTER;
00000004 00000001          acpi_erst_instructions ACPI_ERST_READ_REGISTER_VALUE;
00000004 00000004          acpi_erst_command_status ACPI_ERST_RECORD_EMPTY;
00000004 00000011          acpi_erst_instructions ACPI_ERST_SET_DST_ADDRESS_BASE;
00000004 00000009          acpi_erst_actions ACPI_ERST_SET_RECORD_ID;
00000004 00000004          acpi_erst_actions ACPI_ERST_SET_RECORD_OFFSET;
00000004 00000010          acpi_erst_instructions ACPI_ERST_SET_SRC_ADDRESS_BASE;
00000004 0000000E          acpi_erst_instructions ACPI_ERST_SKIP_NEXT_IF_TRUE;
00000004 0000000C          acpi_erst_instructions ACPI_ERST_STALL;
00000004 0000000D          acpi_erst_instructions ACPI_ERST_STALL_WHILE_TRUE;
00000004 00000006          acpi_erst_command_status ACPI_ERST_STATUS_RESERVED;
00000004 00000007          acpi_erst_instructions ACPI_ERST_STORE_VAR1;
00000004 00000009          acpi_erst_instructions ACPI_ERST_SUBTRACT;
00000004 0000000B          acpi_erst_instructions ACPI_ERST_SUBTRACT_VALUE;
00000004 00000000          acpi_erst_command_status ACPI_ERST_SUCESS;
00000004 00000002          acpi_erst_instructions ACPI_ERST_WRITE_REGISTER;
00000004 00000003          acpi_erst_instructions ACPI_ERST_WRITE_REGISTER_VALUE;
00000004 00000002          acpi_s3pt_type ACPI_FPDT_BOOT_PERFORMANCE;
00000004 00000000          acpi_fpdt_type ACPI_FPDT_TYPE_BOOT;
00000004 00000001          acpi_fpdt_type ACPI_FPDT_TYPE_S3PERF;
00000004 00000002          acpi_gtdt_type ACPI_GTDT_TYPE_RESERVED;
00000004 00000000          acpi_gtdt_type ACPI_GTDT_TYPE_TIMER_BLOCK;
00000004 00000001          acpi_gtdt_type ACPI_GTDT_TYPE_WATCHDOG;
00000004 00000005          acpi_hest_notify_types ACPI_HEST_NOTIFY_CMCI;
00000004 00000001          acpi_hest_notify_types ACPI_HEST_NOTIFY_EXTERNAL;
00000004 00000007          acpi_hest_notify_types ACPI_HEST_NOTIFY_GPIO;
00000004 0000000A          acpi_hest_notify_types ACPI_HEST_NOTIFY_GSIV;
00000004 00000002          acpi_hest_notify_types ACPI_HEST_NOTIFY_LOCAL;
00000004 00000006          acpi_hest_notify_types ACPI_HEST_NOTIFY_MCE;
00000004 00000004          acpi_hest_notify_types ACPI_HEST_NOTIFY_NMI;
00000004 00000000          acpi_hest_notify_types ACPI_HEST_NOTIFY_POLLED;
00000004 0000000C          acpi_hest_notify_types ACPI_HEST_NOTIFY_RESERVED;
00000004 00000003          acpi_hest_notify_types ACPI_HEST_NOTIFY_SCI;
00000004 00000008          acpi_hest_notify_types ACPI_HEST_NOTIFY_SEA;
00000004 00000009          acpi_hest_notify_types ACPI_HEST_NOTIFY_SEI;
00000004 0000000B          acpi_hest_notify_types ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED;
00000004 00000008          acpi_hest_types ACPI_HEST_TYPE_AER_BRIDGE;
00000004 00000007          acpi_hest_types ACPI_HEST_TYPE_AER_ENDPOINT;
00000004 00000006          acpi_hest_types ACPI_HEST_TYPE_AER_ROOT_PORT;
00000004 00000009          acpi_hest_types ACPI_HEST_TYPE_GENERIC_ERROR;
00000004 0000000A          acpi_hest_types ACPI_HEST_TYPE_GENERIC_ERROR_V2;
00000004 00000000          acpi_hest_types ACPI_HEST_TYPE_IA32_CHECK;
00000004 00000001          acpi_hest_types ACPI_HEST_TYPE_IA32_CORRECTED_CHECK;
00000004 0000000B          acpi_hest_types ACPI_HEST_TYPE_IA32_DEFERRED_CHECK;
00000004 00000002          acpi_hest_types ACPI_HEST_TYPE_IA32_NMI;
00000004 00000003          acpi_hest_types ACPI_HEST_TYPE_NOT_USED3;
00000004 00000004          acpi_hest_types ACPI_HEST_TYPE_NOT_USED4;
00000004 00000005          acpi_hest_types ACPI_HEST_TYPE_NOT_USED5;
00000004 0000000C          acpi_hest_types ACPI_HEST_TYPE_RESERVED;
00000004 00000002          acpi_hmat_type ACPI_HMAT_TYPE_CACHE;
00000004 00000001          acpi_hmat_type ACPI_HMAT_TYPE_LOCALITY;
00000004 00000000          acpi_hmat_type ACPI_HMAT_TYPE_PROXIMITY;
00000004 00000003          acpi_hmat_type ACPI_HMAT_TYPE_RESERVED;
00000004 00000000          acpi_hpet_page_protect ACPI_HPET_NO_PAGE_PROTECT;
00000004 00000001          acpi_hpet_page_protect ACPI_HPET_PAGE_PROTECT4;
00000004 00000002          acpi_hpet_page_protect ACPI_HPET_PAGE_PROTECT64;
00000004 00000000          acpi_rasf_capabiliities ACPI_HW_PATROL_SCRUB_SUPPORTED;
00000004 00000001          acpi_ibft_type ACPI_IBFT_TYPE_CONTROL;
00000004 00000005          acpi_ibft_type ACPI_IBFT_TYPE_EXTENSIONS;
00000004 00000002          acpi_ibft_type ACPI_IBFT_TYPE_INITIATOR;
00000004 00000003          acpi_ibft_type ACPI_IBFT_TYPE_NIC;
00000004 00000000          acpi_ibft_type ACPI_IBFT_TYPE_NOT_USED;
00000004 00000006          acpi_ibft_type ACPI_IBFT_TYPE_RESERVED;
00000004 00000004          acpi_ibft_type ACPI_IBFT_TYPE_TARGET;
00000004 00000004          acpi_interrupt_id ACPI_INTERRUPT_COUNT;
00000004 00000003          acpi_interrupt_id ACPI_INTERRUPT_CPEI;
00000004 00000002          acpi_interrupt_id ACPI_INTERRUPT_INIT;
00000004 00000001          acpi_interrupt_id ACPI_INTERRUPT_PMI;
00000004 00000000          acpi_iort_node_type ACPI_IORT_NODE_ITS_GROUP;
00000004 00000001          acpi_iort_node_type ACPI_IORT_NODE_NAMED_COMPONENT;
00000004 00000002          acpi_iort_node_type ACPI_IORT_NODE_PCI_ROOT_COMPLEX;
00000004 00000005          acpi_iort_node_type ACPI_IORT_NODE_PMCG;
00000004 00000003          acpi_iort_node_type ACPI_IORT_NODE_SMMU;
00000004 00000004          acpi_iort_node_type ACPI_IORT_NODE_SMMU_V3;
00000004 00000005          acpi_irq_model_id ACPI_IRQ_MODEL_COUNT;
00000004 00000004          acpi_irq_model_id ACPI_IRQ_MODEL_GIC;
00000004 00000001          acpi_irq_model_id ACPI_IRQ_MODEL_IOAPIC;
00000004 00000002          acpi_irq_model_id ACPI_IRQ_MODEL_IOSAPIC;
00000004 00000000          acpi_irq_model_id ACPI_IRQ_MODEL_PIC;
00000004 00000003          acpi_irq_model_id ACPI_IRQ_MODEL_PLATFORM;
00000004 00000042          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_ALIAS_SELECT;
00000004 00000043          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_ALIAS_START;
00000004 00000001          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_ALL;
00000004 00000004          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_END;
00000004 00000046          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_EXT_SELECT;
00000004 00000047          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_EXT_START;
00000004 00000010          acpi_ivrs_type ACPI_IVRS_TYPE_HARDWARE;
00000004 00000020          acpi_ivrs_type ACPI_IVRS_TYPE_MEMORY1;
00000004 00000021          acpi_ivrs_type ACPI_IVRS_TYPE_MEMORY2;
00000004 00000022          acpi_ivrs_type ACPI_IVRS_TYPE_MEMORY3;
00000004 00000041          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_NOT_USED;
00000004 00000000          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_PAD4;
00000004 00000040          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_PAD8;
00000004 00000002          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_SELECT;
00000004 00000048          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_SPECIAL;
00000004 00000003          acpi_ivrs_device_entry_type ACPI_IVRS_TYPE_START;
00000004 00000000          acpi_lpit_type ACPI_LPIT_TYPE_NATIVE_CSTATE;
00000004 00000001          acpi_lpit_type ACPI_LPIT_TYPE_RESERVED;
00000004 00000000          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_NONE;
00000004 00000005          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_RESERVED;
00000004 00000001          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_V1;
00000004 00000002          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_V2;
00000004 00000003          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_V3;
00000004 00000004          acpi_madt_gic_version ACPI_MADT_GIC_VERSION_V4;
00000004 0000000C          acpi_madt_type ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR;
00000004 0000000B          acpi_madt_type ACPI_MADT_TYPE_GENERIC_INTERRUPT;
00000004 0000000D          acpi_madt_type ACPI_MADT_TYPE_GENERIC_MSI_FRAME;
00000004 0000000E          acpi_madt_type ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR;
00000004 0000000F          acpi_madt_type ACPI_MADT_TYPE_GENERIC_TRANSLATOR;
00000004 00000002          acpi_madt_type ACPI_MADT_TYPE_INTERRUPT_OVERRIDE;
00000004 00000008          acpi_madt_type ACPI_MADT_TYPE_INTERRUPT_SOURCE;
00000004 00000001          acpi_madt_type ACPI_MADT_TYPE_IO_APIC;
00000004 00000006          acpi_madt_type ACPI_MADT_TYPE_IO_SAPIC;
00000004 00000000          acpi_madt_type ACPI_MADT_TYPE_LOCAL_APIC;
00000004 00000004          acpi_madt_type ACPI_MADT_TYPE_LOCAL_APIC_NMI;
00000004 00000005          acpi_madt_type ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE;
00000004 00000007          acpi_madt_type ACPI_MADT_TYPE_LOCAL_SAPIC;
00000004 00000009          acpi_madt_type ACPI_MADT_TYPE_LOCAL_X2APIC;
00000004 0000000A          acpi_madt_type ACPI_MADT_TYPE_LOCAL_X2APIC_NMI;
00000004 00000003          acpi_madt_type ACPI_MADT_TYPE_NMI_SOURCE;
00000004 00000010          acpi_madt_type ACPI_MADT_TYPE_RESERVED;
00000004 00000007          acpi_nfit_type ACPI_NFIT_TYPE_CAPABILITIES;
00000004 00000004          acpi_nfit_type ACPI_NFIT_TYPE_CONTROL_REGION;
00000004 00000005          acpi_nfit_type ACPI_NFIT_TYPE_DATA_REGION;
00000004 00000006          acpi_nfit_type ACPI_NFIT_TYPE_FLUSH_ADDRESS;
00000004 00000002          acpi_nfit_type ACPI_NFIT_TYPE_INTERLEAVE;
00000004 00000001          acpi_nfit_type ACPI_NFIT_TYPE_MEMORY_MAP;
00000004 00000008          acpi_nfit_type ACPI_NFIT_TYPE_RESERVED;
00000004 00000003          acpi_nfit_type ACPI_NFIT_TYPE_SMBIOS;
00000004 00000000          acpi_nfit_type ACPI_NFIT_TYPE_SYSTEM_ADDRESS;
00000004 00000003          acpi_pcct_type ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE;
00000004 00000004          acpi_pcct_type ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE;
00000004 00000000          acpi_pcct_type ACPI_PCCT_TYPE_GENERIC_SUBSPACE;
00000004 00000001          acpi_pcct_type ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE;
00000004 00000002          acpi_pcct_type ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2;
00000004 00000005          acpi_pcct_type ACPI_PCCT_TYPE_RESERVED;
00000004 00000001          acpi_pptt_type ACPI_PPTT_TYPE_CACHE;
00000004 00000002          acpi_pptt_type ACPI_PPTT_TYPE_ID;
00000004 00000000          acpi_pptt_type ACPI_PPTT_TYPE_PROCESSOR;
00000004 00000003          acpi_pptt_type ACPI_PPTT_TYPE_RESERVED;
00000004 00000005          acpi_rasf_status ACPI_RASF_ABORTED;
00000004 00000003          acpi_rasf_status ACPI_RASF_BUSY;
00000004 00000001          acpi_rasf_commands ACPI_RASF_EXECUTE_RASF_COMMAND;
00000004 00000004          acpi_rasf_status ACPI_RASF_FAILED;
00000004 00000001          acpi_rasf_patrol_scrub_commands ACPI_RASF_GET_PATROL_PARAMETERS;
00000004 00000006          acpi_rasf_status ACPI_RASF_INVALID_DATA;
00000004 00000002          acpi_rasf_status ACPI_RASF_NOT_SUPPORTED;
00000004 00000001          acpi_rasf_status ACPI_RASF_NOT_VALID;
00000004 00000002          acpi_rasf_patrol_scrub_commands ACPI_RASF_START_PATROL_SCRUBBER;
00000004 00000003          acpi_rasf_patrol_scrub_commands ACPI_RASF_STOP_PATROL_SCRUBBER;
00000004 00000000          acpi_rasf_status ACPI_RASF_SUCCESS;
00000004 00000000          acpi_reconfig_event ACPI_RECONFIG_DEVICE_ADD;
00000004 00000001          acpi_reconfig_event ACPI_RECONFIG_DEVICE_REMOVE;
00000004 00000000          acpi_s3pt_type ACPI_S3PT_TYPE_RESUME;
00000004 00000001          acpi_s3pt_type ACPI_S3PT_TYPE_SUSPEND;
00000004 00000000          acpi_sdev_type ACPI_SDEV_TYPE_NAMESPACE_DEVICE;
00000004 00000001          acpi_sdev_type ACPI_SDEV_TYPE_PCIE_ENDPOINT_DEVICE;
00000004 00000002          acpi_sdev_type ACPI_SDEV_TYPE_RESERVED;
00000004 00000003          acpi_spmi_interface_types ACPI_SPMI_BLOCK_TRANSFER;
00000004 00000001          acpi_spmi_interface_types ACPI_SPMI_KEYBOARD;
00000004 00000000          acpi_spmi_interface_types ACPI_SPMI_NOT_USED;
00000004 00000005          acpi_spmi_interface_types ACPI_SPMI_RESERVED;
00000004 00000004          acpi_spmi_interface_types ACPI_SPMI_SMBUS;
00000004 00000002          acpi_spmi_interface_types ACPI_SPMI_SMI;
00000004 00000000          acpi_srat_type ACPI_SRAT_TYPE_CPU_AFFINITY;
00000004 00000005          acpi_srat_type ACPI_SRAT_TYPE_GENERIC_AFFINITY;
00000004 00000003          acpi_srat_type ACPI_SRAT_TYPE_GICC_AFFINITY;
00000004 00000004          acpi_srat_type ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;
00000004 00000001          acpi_srat_type ACPI_SRAT_TYPE_MEMORY_AFFINITY;
00000004 00000006          acpi_srat_type ACPI_SRAT_TYPE_RESERVED;
00000004 00000002          acpi_srat_type ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY;
00000004 00000001          acpi_rasf_capabiliities ACPI_SW_PATROL_SCRUB_EXPOSED;
00000004 00000000          acpi_trace_event_type ACPI_TRACE_AML_METHOD;
00000004 00000001          acpi_trace_event_type ACPI_TRACE_AML_OPCODE;
00000004 00000002          acpi_trace_event_type ACPI_TRACE_AML_REGION;
00000004 00000022          acpi_wdat_actions ACPI_WDAT_ACTION_RESERVED;
00000004 00000005          acpi_wdat_actions ACPI_WDAT_GET_COUNTDOWN;
00000004 00000004          acpi_wdat_actions ACPI_WDAT_GET_CURRENT_COUNTDOWN;
00000004 00000010          acpi_wdat_actions ACPI_WDAT_GET_REBOOT;
00000004 00000008          acpi_wdat_actions ACPI_WDAT_GET_RUNNING_STATE;
00000004 00000012          acpi_wdat_actions ACPI_WDAT_GET_SHUTDOWN;
00000004 00000020          acpi_wdat_actions ACPI_WDAT_GET_STATUS;
00000004 0000000A          acpi_wdat_actions ACPI_WDAT_GET_STOPPED_STATE;
00000004 00000004          acpi_wdat_instructions ACPI_WDAT_INSTRUCTION_RESERVED;
00000004 00000080          acpi_wdat_instructions ACPI_WDAT_PRESERVE_REGISTER;
00000004 00000001          acpi_wdat_instructions ACPI_WDAT_READ_COUNTDOWN;
00000004 00000000          acpi_wdat_instructions ACPI_WDAT_READ_VALUE;
00000004 00000001          acpi_wdat_actions ACPI_WDAT_RESET;
00000004 00000006          acpi_wdat_actions ACPI_WDAT_SET_COUNTDOWN;
00000004 00000011          acpi_wdat_actions ACPI_WDAT_SET_REBOOT;
00000004 00000009          acpi_wdat_actions ACPI_WDAT_SET_RUNNING_STATE;
00000004 00000013          acpi_wdat_actions ACPI_WDAT_SET_SHUTDOWN;
00000004 00000021          acpi_wdat_actions ACPI_WDAT_SET_STATUS;
00000004 0000000B          acpi_wdat_actions ACPI_WDAT_SET_STOPPED_STATE;
00000004 00000003          acpi_wdat_instructions ACPI_WDAT_WRITE_COUNTDOWN;
00000004 00000002          acpi_wdat_instructions ACPI_WDAT_WRITE_VALUE;
00000004 00200000          $76602C1D950947A0A79A611E6C37E6C0 ADDR_COMPAT_LAYOUT;
00000004 00800000          $76602C1D950947A0A79A611E6C37E6C0 ADDR_LIMIT_32BIT;
00000004 08000000          $76602C1D950947A0A79A611E6C37E6C0 ADDR_LIMIT_3GB;
00000004 00040000          $76602C1D950947A0A79A611E6C37E6C0 ADDR_NO_RANDOMIZE;
00000004 00000000          alarmtimer_restart ALARMTIMER_NORESTART;
00000004 00000001          alarmtimer_restart ALARMTIMER_RESTART;
00000004 00000001          alarmtimer_type ALARM_BOOTTIME;
00000004 00000004          alarmtimer_type ALARM_BOOTTIME_FREEZER;
00000004 00000002          alarmtimer_type ALARM_NUMTYPE;
00000004 00000000          alarmtimer_type ALARM_REALTIME;
00000004 00000003          alarmtimer_type ALARM_REALTIME_FREEZER;
00000004 00000001          align_flags ALIGN_VA_32;
00000004 00000002          align_flags ALIGN_VA_64;
00000004 00000008          vm_event_item ALLOCSTALL_DMA;
00000004 00000009          vm_event_item ALLOCSTALL_DMA32;
00000004 0000000B          vm_event_item ALLOCSTALL_MOVABLE;
00000004 0000000A          vm_event_item ALLOCSTALL_NORMAL;
00000004 00080001          positive_aop_returns AOP_TRUNCATED_PAGE;
00000004 00080000          positive_aop_returns AOP_WRITEPAGE_ACTIVATE;
00000004 00000000          apic_intr_mode_id APIC_PIC;
00000004 00000003          apic_intr_mode_id APIC_SYMMETRIC_IO;
00000004 00000004          apic_intr_mode_id APIC_SYMMETRIC_IO_NO_ROUTING;
00000004 00000001          apic_intr_mode_id APIC_VIRTUAL_WIRE;
00000004 00000002          apic_intr_mode_id APIC_VIRTUAL_WIRE_NO_CONFIG;
00000004 0000000C          bpf_arg_type ARG_ANYTHING;
00000004 00000001          bpf_arg_type ARG_CONST_MAP_PTR;
00000004 00000009          bpf_arg_type ARG_CONST_SIZE;
00000004 0000000A          bpf_arg_type ARG_CONST_SIZE_OR_ZERO;
00000004 00000000          bpf_arg_type ARG_DONTCARE;
00000004 0000000B          bpf_arg_type ARG_PTR_TO_CTX;
00000004 0000000F          bpf_arg_type ARG_PTR_TO_INT;
00000004 00000010          bpf_arg_type ARG_PTR_TO_LONG;
00000004 00000002          bpf_arg_type ARG_PTR_TO_MAP_KEY;
00000004 00000003          bpf_arg_type ARG_PTR_TO_MAP_VALUE;
00000004 00000005          bpf_arg_type ARG_PTR_TO_MAP_VALUE_OR_NULL;
00000004 00000006          bpf_arg_type ARG_PTR_TO_MEM;
00000004 00000007          bpf_arg_type ARG_PTR_TO_MEM_OR_NULL;
00000004 00000011          bpf_arg_type ARG_PTR_TO_SOCKET;
00000004 0000000E          bpf_arg_type ARG_PTR_TO_SOCK_COMMON;
00000004 0000000D          bpf_arg_type ARG_PTR_TO_SPIN_LOCK;
00000004 00000004          bpf_arg_type ARG_PTR_TO_UNINIT_MAP_VALUE;
00000004 00000008          bpf_arg_type ARG_PTR_TO_UNINIT_MEM;
00000004 00000000          mapping_flags AS_EIO;
00000004 00000001          mapping_flags AS_ENOSPC;
00000004 00000004          mapping_flags AS_EXITING;
00000004 00000002          mapping_flags AS_MM_ALL_LOCKS;
00000004 00000005          mapping_flags AS_NO_WRITEBACK_TAGS;
00000004 00000003          mapping_flags AS_UNEVICTABLE;
00000004 FFFFFFFF          $996A157442774DB15D331DAB676978AB BAD_STACK;
00000004 00000051          vm_event_item BALLOON_DEFLATE;
00000004 00000050          vm_event_item BALLOON_INFLATE;
00000004 00000052          vm_event_item BALLOON_MIGRATE;
00000004 00000001          $ECC0383DEEDD781B0BE9116A0E842892 BIOSET_NEED_BVECS;
00000004 00000002          $ECC0383DEEDD781B0BE9116A0E842892 BIOSET_NEED_RESCUER;
00000004 00000002          $00998310628785E0AEA1159A66AFA631 BIO_BOUNCED;
00000004 00000007          $00998310628785E0AEA1159A66AFA631 BIO_CHAIN;
00000004 00000001          $00998310628785E0AEA1159A66AFA631 BIO_CLONED;
00000004 0000000D          $00998310628785E0AEA1159A66AFA631 BIO_FLAG_LAST;
00000004 00000000          $00998310628785E0AEA1159A66AFA631 BIO_NO_PAGE_REF;
00000004 00000004          $00998310628785E0AEA1159A66AFA631 BIO_NULL_MAPPED;
00000004 0000000B          $00998310628785E0AEA1159A66AFA631 BIO_QUEUE_ENTERED;
00000004 00000006          $00998310628785E0AEA1159A66AFA631 BIO_QUIET;
00000004 00000008          $00998310628785E0AEA1159A66AFA631 BIO_REFFED;
00000004 00000009          $00998310628785E0AEA1159A66AFA631 BIO_THROTTLED;
00000004 0000000A          $00998310628785E0AEA1159A66AFA631 BIO_TRACE_COMPLETION;
00000004 0000000C          $00998310628785E0AEA1159A66AFA631 BIO_TRACKED;
00000004 00000003          $00998310628785E0AEA1159A66AFA631 BIO_USER_MAPPED;
00000004 00000005          $00998310628785E0AEA1159A66AFA631 BIO_WORKINGSET;
00000004 00000001          bip_flags BIP_BLOCK_INTEGRITY;
00000004 00000004          bip_flags BIP_CTRL_NOCHECK;
00000004 00000008          bip_flags BIP_DISK_NOCHECK;
00000004 00000010          bip_flags BIP_IP_CHECKSUM;
00000004 00000002          bip_flags BIP_MAPPED_INTEGRITY;
00000004 00000A00          blk_default_limits BLK_DEF_MAX_SECTORS;
00000004 00000000          blk_eh_timer_return BLK_EH_DONE;
00000004 00000001          blk_eh_timer_return BLK_EH_RESET_TIMER;
00000004 00000004          blk_integrity_flags BLK_INTEGRITY_DEVICE_CAPABLE;
00000004 00000002          blk_integrity_flags BLK_INTEGRITY_GENERATE;
00000004 00000008          blk_integrity_flags BLK_INTEGRITY_IP_CHECKSUM;
00000004 00000001          blk_integrity_flags BLK_INTEGRITY_VERIFY;
00000004 00000080          blk_default_limits BLK_MAX_SEGMENTS;
00000004 00010000          blk_default_limits BLK_MAX_SEGMENT_SIZE;
00000004 00000000          $C596A7A4E478CF6BC6D2869770D6CD05 BLK_RW_ASYNC;
00000004 00000001          $C596A7A4E478CF6BC6D2869770D6CD05 BLK_RW_SYNC;
00000004 000000FF          blk_default_limits BLK_SAFE_MAX_SECTORS;
00000004 FFFFFFFF          blk_default_limits BLK_SEG_BOUNDARY_MASK;
00000004 00000001          blk_zoned_model BLK_ZONED_HA;
00000004 00000002          blk_zoned_model BLK_ZONED_HM;
00000004 00000000          blk_zoned_model BLK_ZONED_NONE;
00000004 00000004          blk_zone_cond BLK_ZONE_COND_CLOSED;
00000004 00000001          blk_zone_cond BLK_ZONE_COND_EMPTY;
00000004 00000003          blk_zone_cond BLK_ZONE_COND_EXP_OPEN;
00000004 0000000E          blk_zone_cond BLK_ZONE_COND_FULL;
00000004 00000002          blk_zone_cond BLK_ZONE_COND_IMP_OPEN;
00000004 00000000          blk_zone_cond BLK_ZONE_COND_NOT_WP;
00000004 0000000F          blk_zone_cond BLK_ZONE_COND_OFFLINE;
00000004 0000000D          blk_zone_cond BLK_ZONE_COND_READONLY;
00000004 00000001          blk_zone_type BLK_ZONE_TYPE_CONVENTIONAL;
00000004 00000003          blk_zone_type BLK_ZONE_TYPE_SEQWRITE_PREF;
00000004 00000002          blk_zone_type BLK_ZONE_TYPE_SEQWRITE_REQ;
00000004 00000004          $DD2FCB3BD885EF085C64DD38A6B8659D BLOCK_SOFTIRQ;
00000004 00000061          reboot_type BOOT_ACPI;
00000004 00000062          reboot_type BOOT_BIOS;
00000004 00000070          reboot_type BOOT_CF9_FORCE;
00000004 00000071          reboot_type BOOT_CF9_SAFE;
00000004 00000065          reboot_type BOOT_EFI;
00000004 0000006B          reboot_type BOOT_KBD;
00000004 00000074          reboot_type BOOT_TRIPLE;
00000004 00000001          bpf_adj_room_mode BPF_ADJ_ROOM_MAC;
00000004 00000000          bpf_adj_room_mode BPF_ADJ_ROOM_NET;
00000004 00000013          bpf_cmd BPF_BTF_GET_FD_BY_ID;
00000004 00000017          bpf_cmd BPF_BTF_GET_NEXT_ID;
00000004 00000012          bpf_cmd BPF_BTF_LOAD;
00000004 00000006          bpf_attach_type BPF_CGROUP_DEVICE;
00000004 00000015          bpf_attach_type BPF_CGROUP_GETSOCKOPT;
00000004 00000008          bpf_attach_type BPF_CGROUP_INET4_BIND;
00000004 0000000A          bpf_attach_type BPF_CGROUP_INET4_CONNECT;
00000004 0000000C          bpf_attach_type BPF_CGROUP_INET4_POST_BIND;
00000004 00000009          bpf_attach_type BPF_CGROUP_INET6_BIND;
00000004 0000000B          bpf_attach_type BPF_CGROUP_INET6_CONNECT;
00000004 0000000D          bpf_attach_type BPF_CGROUP_INET6_POST_BIND;
00000004 00000001          bpf_attach_type BPF_CGROUP_INET_EGRESS;
00000004 00000000          bpf_attach_type BPF_CGROUP_INET_INGRESS;
00000004 00000002          bpf_attach_type BPF_CGROUP_INET_SOCK_CREATE;
00000004 00000016          bpf_attach_type BPF_CGROUP_SETSOCKOPT;
00000004 00000003          bpf_attach_type BPF_CGROUP_SOCK_OPS;
00000004 00000001          bpf_cgroup_storage_type BPF_CGROUP_STORAGE_PERCPU;
00000004 00000000          bpf_cgroup_storage_type BPF_CGROUP_STORAGE_SHARED;
00000004 00000012          bpf_attach_type BPF_CGROUP_SYSCTL;
00000004 00000013          bpf_attach_type BPF_CGROUP_UDP4_RECVMSG;
00000004 0000000E          bpf_attach_type BPF_CGROUP_UDP4_SENDMSG;
00000004 00000014          bpf_attach_type BPF_CGROUP_UDP6_RECVMSG;
00000004 0000000F          bpf_attach_type BPF_CGROUP_UDP6_SENDMSG;
00000004 00000002          bpf_ret_code BPF_DROP;
00000004 00000002          bpf_task_fd_type BPF_FD_TYPE_KPROBE;
00000004 00000003          bpf_task_fd_type BPF_FD_TYPE_KRETPROBE;
00000004 00000000          bpf_task_fd_type BPF_FD_TYPE_RAW_TRACEPOINT;
00000004 00000001          bpf_task_fd_type BPF_FD_TYPE_TRACEPOINT;
00000004 00000004          bpf_task_fd_type BPF_FD_TYPE_UPROBE;
00000004 00000005          bpf_task_fd_type BPF_FD_TYPE_URETPROBE;
00000004 00000001          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_BLACKHOLE;
00000004 00000008          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_FRAG_NEEDED;
00000004 00000005          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_FWD_DISABLED;
00000004 00000004          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_NOT_FWDED;
00000004 00000007          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_NO_NEIGH;
00000004 00000003          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_PROHIBIT;
00000004 00000000          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_SUCCESS;
00000004 00000002          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_UNREACHABLE;
00000004 00000006          $0057655D8FF5A403A412A059E838C320 BPF_FIB_LKUP_RET_UNSUPP_LWT;
00000004 00000011          bpf_attach_type BPF_FLOW_DISSECTOR;
00000004 00000040          bpf_func_id BPF_FUNC_bind;
00000004 0000000D          bpf_func_id BPF_FUNC_clone_redirect;
00000004 0000001C          bpf_func_id BPF_FUNC_csum_diff;
00000004 00000028          bpf_func_id BPF_FUNC_csum_update;
00000004 00000025          bpf_func_id BPF_FUNC_current_task_under_cgroup;
00000004 00000045          bpf_func_id BPF_FUNC_fib_lookup;
00000004 00000011          bpf_func_id BPF_FUNC_get_cgroup_classid;
00000004 00000050          bpf_func_id BPF_FUNC_get_current_cgroup_id;
00000004 00000010          bpf_func_id BPF_FUNC_get_current_comm;
00000004 0000000E          bpf_func_id BPF_FUNC_get_current_pid_tgid;
00000004 00000023          bpf_func_id BPF_FUNC_get_current_task;
00000004 0000000F          bpf_func_id BPF_FUNC_get_current_uid_gid;
00000004 00000022          bpf_func_id BPF_FUNC_get_hash_recalc;
00000004 00000062          bpf_func_id BPF_FUNC_get_listener_sock;
00000004 00000051          bpf_func_id BPF_FUNC_get_local_storage;
00000004 0000002A          bpf_func_id BPF_FUNC_get_numa_node_id;
00000004 00000007          bpf_func_id BPF_FUNC_get_prandom_u32;
00000004 00000018          bpf_func_id BPF_FUNC_get_route_realm;
00000004 00000008          bpf_func_id BPF_FUNC_get_smp_processor_id;
00000004 0000002E          bpf_func_id BPF_FUNC_get_socket_cookie;
00000004 0000002F          bpf_func_id BPF_FUNC_get_socket_uid;
00000004 00000043          bpf_func_id BPF_FUNC_get_stack;
00000004 0000001B          bpf_func_id BPF_FUNC_get_stackid;
00000004 00000039          bpf_func_id BPF_FUNC_getsockopt;
00000004 00000005          bpf_func_id BPF_FUNC_ktime_get_ns;
00000004 0000000A          bpf_func_id BPF_FUNC_l3_csum_replace;
00000004 0000000B          bpf_func_id BPF_FUNC_l4_csum_replace;
00000004 00000049          bpf_func_id BPF_FUNC_lwt_push_encap;
00000004 0000004C          bpf_func_id BPF_FUNC_lwt_seg6_action;
00000004 0000004B          bpf_func_id BPF_FUNC_lwt_seg6_adjust_srh;
00000004 0000004A          bpf_func_id BPF_FUNC_lwt_seg6_store_bytes;
00000004 00000003          bpf_func_id BPF_FUNC_map_delete_elem;
00000004 00000001          bpf_func_id BPF_FUNC_map_lookup_elem;
00000004 00000059          bpf_func_id BPF_FUNC_map_peek_elem;
00000004 00000058          bpf_func_id BPF_FUNC_map_pop_elem;
00000004 00000057          bpf_func_id BPF_FUNC_map_push_elem;
00000004 00000002          bpf_func_id BPF_FUNC_map_update_elem;
00000004 0000003D          bpf_func_id BPF_FUNC_msg_apply_bytes;
00000004 0000003E          bpf_func_id BPF_FUNC_msg_cork_bytes;
00000004 0000005B          bpf_func_id BPF_FUNC_msg_pop_data;
00000004 0000003F          bpf_func_id BPF_FUNC_msg_pull_data;
00000004 0000005A          bpf_func_id BPF_FUNC_msg_push_data;
00000004 00000047          bpf_func_id BPF_FUNC_msg_redirect_hash;
00000004 0000003C          bpf_func_id BPF_FUNC_msg_redirect_map;
00000004 0000003A          bpf_func_id BPF_FUNC_override_return;
00000004 00000019          bpf_func_id BPF_FUNC_perf_event_output;
00000004 00000016          bpf_func_id BPF_FUNC_perf_event_read;
00000004 00000037          bpf_func_id BPF_FUNC_perf_event_read_value;
00000004 00000038          bpf_func_id BPF_FUNC_perf_prog_read_value;
00000004 00000004          bpf_func_id BPF_FUNC_probe_read;
00000004 0000002D          bpf_func_id BPF_FUNC_probe_read_str;
00000004 00000024          bpf_func_id BPF_FUNC_probe_write_user;
00000004 0000004E          bpf_func_id BPF_FUNC_rc_keydown;
00000004 0000005C          bpf_func_id BPF_FUNC_rc_pointer_rel;
00000004 0000004D          bpf_func_id BPF_FUNC_rc_repeat;
00000004 00000017          bpf_func_id BPF_FUNC_redirect;
00000004 00000033          bpf_func_id BPF_FUNC_redirect_map;
00000004 0000006D          bpf_func_id BPF_FUNC_send_signal;
00000004 00000030          bpf_func_id BPF_FUNC_set_hash;
00000004 00000029          bpf_func_id BPF_FUNC_set_hash_invalid;
00000004 00000031          bpf_func_id BPF_FUNC_setsockopt;
00000004 0000005F          bpf_func_id BPF_FUNC_sk_fullsock;
00000004 00000054          bpf_func_id BPF_FUNC_sk_lookup_tcp;
00000004 00000055          bpf_func_id BPF_FUNC_sk_lookup_udp;
00000004 00000048          bpf_func_id BPF_FUNC_sk_redirect_hash;
00000004 00000034          bpf_func_id BPF_FUNC_sk_redirect_map;
00000004 00000056          bpf_func_id BPF_FUNC_sk_release;
00000004 00000052          bpf_func_id BPF_FUNC_sk_select_reuseport;
00000004 0000006C          bpf_func_id BPF_FUNC_sk_storage_delete;
00000004 0000006B          bpf_func_id BPF_FUNC_sk_storage_get;
00000004 00000032          bpf_func_id BPF_FUNC_skb_adjust_room;
00000004 00000053          bpf_func_id BPF_FUNC_skb_ancestor_cgroup_id;
00000004 0000004F          bpf_func_id BPF_FUNC_skb_cgroup_id;
00000004 0000002B          bpf_func_id BPF_FUNC_skb_change_head;
00000004 0000001F          bpf_func_id BPF_FUNC_skb_change_proto;
00000004 00000026          bpf_func_id BPF_FUNC_skb_change_tail;
00000004 00000020          bpf_func_id BPF_FUNC_skb_change_type;
00000004 00000061          bpf_func_id BPF_FUNC_skb_ecn_set_ce;
00000004 00000014          bpf_func_id BPF_FUNC_skb_get_tunnel_key;
00000004 0000001D          bpf_func_id BPF_FUNC_skb_get_tunnel_opt;
00000004 00000042          bpf_func_id BPF_FUNC_skb_get_xfrm_state;
00000004 0000001A          bpf_func_id BPF_FUNC_skb_load_bytes;
00000004 00000044          bpf_func_id BPF_FUNC_skb_load_bytes_relative;
00000004 00000027          bpf_func_id BPF_FUNC_skb_pull_data;
00000004 00000015          bpf_func_id BPF_FUNC_skb_set_tunnel_key;
00000004 0000001E          bpf_func_id BPF_FUNC_skb_set_tunnel_opt;
00000004 00000009          bpf_func_id BPF_FUNC_skb_store_bytes;
00000004 00000021          bpf_func_id BPF_FUNC_skb_under_cgroup;
00000004 00000013          bpf_func_id BPF_FUNC_skb_vlan_pop;
00000004 00000012          bpf_func_id BPF_FUNC_skb_vlan_push;
00000004 00000063          bpf_func_id BPF_FUNC_skc_lookup_tcp;
00000004 00000046          bpf_func_id BPF_FUNC_sock_hash_update;
00000004 00000035          bpf_func_id BPF_FUNC_sock_map_update;
00000004 0000003B          bpf_func_id BPF_FUNC_sock_ops_cb_flags_set;
00000004 0000005D          bpf_func_id BPF_FUNC_spin_lock;
00000004 0000005E          bpf_func_id BPF_FUNC_spin_unlock;
00000004 00000069          bpf_func_id BPF_FUNC_strtol;
00000004 0000006A          bpf_func_id BPF_FUNC_strtoul;
00000004 00000066          bpf_func_id BPF_FUNC_sysctl_get_current_value;
00000004 00000065          bpf_func_id BPF_FUNC_sysctl_get_name;
00000004 00000067          bpf_func_id BPF_FUNC_sysctl_get_new_value;
00000004 00000068          bpf_func_id BPF_FUNC_sysctl_set_new_value;
00000004 0000000C          bpf_func_id BPF_FUNC_tail_call;
00000004 00000064          bpf_func_id BPF_FUNC_tcp_check_syncookie;
00000004 0000006E          bpf_func_id BPF_FUNC_tcp_gen_syncookie;
00000004 00000060          bpf_func_id BPF_FUNC_tcp_sock;
00000004 00000006          bpf_func_id BPF_FUNC_trace_printk;
00000004 00000000          bpf_func_id BPF_FUNC_unspec;
00000004 0000002C          bpf_func_id BPF_FUNC_xdp_adjust_head;
00000004 00000036          bpf_func_id BPF_FUNC_xdp_adjust_meta;
00000004 00000041          bpf_func_id BPF_FUNC_xdp_adjust_tail;
00000004 00000000          bpf_hdr_start_off BPF_HDR_START_MAC;
00000004 00000001          bpf_hdr_start_off BPF_HDR_START_NET;
00000004 00000010          bpf_attach_type BPF_LIRC_MODE2;
00000004 00000002          bpf_lwt_encap_mode BPF_LWT_ENCAP_IP;
00000004 00000000          bpf_lwt_encap_mode BPF_LWT_ENCAP_SEG6;
00000004 00000001          bpf_lwt_encap_mode BPF_LWT_ENCAP_SEG6_INLINE;
00000004 00000080          bpf_ret_code BPF_LWT_REROUTE;
00000004 00000000          bpf_cmd BPF_MAP_CREATE;
00000004 00000003          bpf_cmd BPF_MAP_DELETE_ELEM;
00000004 00000016          bpf_cmd BPF_MAP_FREEZE;
00000004 0000000E          bpf_cmd BPF_MAP_GET_FD_BY_ID;
00000004 0000000C          bpf_cmd BPF_MAP_GET_NEXT_ID;
00000004 00000004          bpf_cmd BPF_MAP_GET_NEXT_KEY;
00000004 00000015          bpf_cmd BPF_MAP_LOOKUP_AND_DELETE_ELEM;
00000004 00000001          bpf_cmd BPF_MAP_LOOKUP_ELEM;
00000004 00000002          bpf_map_type BPF_MAP_TYPE_ARRAY;
00000004 0000000C          bpf_map_type BPF_MAP_TYPE_ARRAY_OF_MAPS;
00000004 00000008          bpf_map_type BPF_MAP_TYPE_CGROUP_ARRAY;
00000004 00000013          bpf_map_type BPF_MAP_TYPE_CGROUP_STORAGE;
00000004 00000010          bpf_map_type BPF_MAP_TYPE_CPUMAP;
00000004 0000000E          bpf_map_type BPF_MAP_TYPE_DEVMAP;
00000004 00000019          bpf_map_type BPF_MAP_TYPE_DEVMAP_HASH;
00000004 00000001          bpf_map_type BPF_MAP_TYPE_HASH;
00000004 0000000D          bpf_map_type BPF_MAP_TYPE_HASH_OF_MAPS;
00000004 0000000B          bpf_map_type BPF_MAP_TYPE_LPM_TRIE;
00000004 00000009          bpf_map_type BPF_MAP_TYPE_LRU_HASH;
00000004 0000000A          bpf_map_type BPF_MAP_TYPE_LRU_PERCPU_HASH;
00000004 00000006          bpf_map_type BPF_MAP_TYPE_PERCPU_ARRAY;
00000004 00000015          bpf_map_type BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE;
00000004 00000005          bpf_map_type BPF_MAP_TYPE_PERCPU_HASH;
00000004 00000004          bpf_map_type BPF_MAP_TYPE_PERF_EVENT_ARRAY;
00000004 00000003          bpf_map_type BPF_MAP_TYPE_PROG_ARRAY;
00000004 00000016          bpf_map_type BPF_MAP_TYPE_QUEUE;
00000004 00000014          bpf_map_type BPF_MAP_TYPE_REUSEPORT_SOCKARRAY;
00000004 00000018          bpf_map_type BPF_MAP_TYPE_SK_STORAGE;
00000004 00000012          bpf_map_type BPF_MAP_TYPE_SOCKHASH;
00000004 0000000F          bpf_map_type BPF_MAP_TYPE_SOCKMAP;
00000004 00000017          bpf_map_type BPF_MAP_TYPE_STACK;
00000004 00000007          bpf_map_type BPF_MAP_TYPE_STACK_TRACE;
00000004 00000000          bpf_map_type BPF_MAP_TYPE_UNSPEC;
00000004 00000011          bpf_map_type BPF_MAP_TYPE_XSKMAP;
00000004 00000002          bpf_cmd BPF_MAP_UPDATE_ELEM;
00000004 00000007          bpf_cmd BPF_OBJ_GET;
00000004 0000000F          bpf_cmd BPF_OBJ_GET_INFO_BY_FD;
00000004 00000006          bpf_cmd BPF_OBJ_PIN;
00000004 00000000          bpf_ret_code BPF_OK;
00000004 00000008          bpf_cmd BPF_PROG_ATTACH;
00000004 00000009          bpf_cmd BPF_PROG_DETACH;
00000004 0000000D          bpf_cmd BPF_PROG_GET_FD_BY_ID;
00000004 0000000B          bpf_cmd BPF_PROG_GET_NEXT_ID;
00000004 00000005          bpf_cmd BPF_PROG_LOAD;
00000004 00000010          bpf_cmd BPF_PROG_QUERY;
00000004 0000000A          bpf_cmd BPF_PROG_TEST_RUN;
00000004 0000000F          bpf_prog_type BPF_PROG_TYPE_CGROUP_DEVICE;
00000004 00000008          bpf_prog_type BPF_PROG_TYPE_CGROUP_SKB;
00000004 00000009          bpf_prog_type BPF_PROG_TYPE_CGROUP_SOCK;
00000004 00000019          bpf_prog_type BPF_PROG_TYPE_CGROUP_SOCKOPT;
00000004 00000012          bpf_prog_type BPF_PROG_TYPE_CGROUP_SOCK_ADDR;
00000004 00000017          bpf_prog_type BPF_PROG_TYPE_CGROUP_SYSCTL;
00000004 00000016          bpf_prog_type BPF_PROG_TYPE_FLOW_DISSECTOR;
00000004 00000002          bpf_prog_type BPF_PROG_TYPE_KPROBE;
00000004 00000014          bpf_prog_type BPF_PROG_TYPE_LIRC_MODE2;
00000004 0000000A          bpf_prog_type BPF_PROG_TYPE_LWT_IN;
00000004 0000000B          bpf_prog_type BPF_PROG_TYPE_LWT_OUT;
00000004 00000013          bpf_prog_type BPF_PROG_TYPE_LWT_SEG6LOCAL;
00000004 0000000C          bpf_prog_type BPF_PROG_TYPE_LWT_XMIT;
00000004 00000007          bpf_prog_type BPF_PROG_TYPE_PERF_EVENT;
00000004 00000011          bpf_prog_type BPF_PROG_TYPE_RAW_TRACEPOINT;
00000004 00000018          bpf_prog_type BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE;
00000004 00000004          bpf_prog_type BPF_PROG_TYPE_SCHED_ACT;
00000004 00000003          bpf_prog_type BPF_PROG_TYPE_SCHED_CLS;
00000004 00000010          bpf_prog_type BPF_PROG_TYPE_SK_MSG;
00000004 00000015          bpf_prog_type BPF_PROG_TYPE_SK_REUSEPORT;
00000004 0000000E          bpf_prog_type BPF_PROG_TYPE_SK_SKB;
00000004 00000001          bpf_prog_type BPF_PROG_TYPE_SOCKET_FILTER;
00000004 0000000D          bpf_prog_type BPF_PROG_TYPE_SOCK_OPS;
00000004 00000005          bpf_prog_type BPF_PROG_TYPE_TRACEPOINT;
00000004 00000000          bpf_prog_type BPF_PROG_TYPE_UNSPEC;
00000004 00000006          bpf_prog_type BPF_PROG_TYPE_XDP;
00000004 00000011          bpf_cmd BPF_RAW_TRACEPOINT_OPEN;
00000004 00000001          bpf_access_type BPF_READ;
00000004 00000007          bpf_ret_code BPF_REDIRECT;
00000004 00000000          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_0;
00000004 00000001          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_1;
00000004 0000000A          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_10;
00000004 00000002          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_2;
00000004 00000003          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_3;
00000004 00000004          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_4;
00000004 00000005          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_5;
00000004 00000006          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_6;
00000004 00000007          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_7;
00000004 00000008          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_8;
00000004 00000009          $33C2810983D6D097EBD64454FBBEAA1D BPF_REG_9;
00000004 00000007          bpf_attach_type BPF_SK_MSG_VERDICT;
00000004 00000004          bpf_attach_type BPF_SK_SKB_STREAM_PARSER;
00000004 00000005          bpf_attach_type BPF_SK_SKB_STREAM_VERDICT;
00000004 00000004          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB;
00000004 00000007          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_BASE_RTT;
00000004 00000006          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_NEEDS_ECN;
00000004 00000005          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB;
00000004 00000009          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_RETRANS_CB;
00000004 00000008          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_RTO_CB;
00000004 0000000C          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_RTT_CB;
00000004 00000002          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_RWND_INIT;
00000004 0000000A          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_STATE_CB;
00000004 00000003          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_TCP_CONNECT_CB;
00000004 0000000B          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_TCP_LISTEN_CB;
00000004 00000001          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_TIMEOUT_INIT;
00000004 00000000          $8AC3DD55B09FDA3ECC26ED8839BEC97F BPF_SOCK_OPS_VOID;
00000004 00000000          bpf_stack_build_id_status BPF_STACK_BUILD_ID_EMPTY;
00000004 00000002          bpf_stack_build_id_status BPF_STACK_BUILD_ID_IP;
00000004 00000001          bpf_stack_build_id_status BPF_STACK_BUILD_ID_VALID;
00000004 00000014          bpf_cmd BPF_TASK_FD_QUERY;
00000004 00000007          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_CLOSE;
00000004 00000008          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_CLOSE_WAIT;
00000004 0000000B          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_CLOSING;
00000004 00000001          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_ESTABLISHED;
00000004 00000004          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_FIN_WAIT1;
00000004 00000005          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_FIN_WAIT2;
00000004 00000009          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_LAST_ACK;
00000004 0000000A          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_LISTEN;
00000004 0000000D          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_MAX_STATES;
00000004 0000000C          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_NEW_SYN_RECV;
00000004 00000003          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_SYN_RECV;
00000004 00000002          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_SYN_SENT;
00000004 00000006          $AD3103F308C2081BDF7D3C1527B29EEA BPF_TCP_TIME_WAIT;
00000004 00000002          bpf_access_type BPF_WRITE;
00000004 000000B7          $8F79D9D84589DB364612B4CE8A4916F1 BSDI_PARTITION;
00000004 00000002          bug_trap_type BUG_TRAP_TYPE_BUG;
00000004 00000000          bug_trap_type BUG_TRAP_TYPE_NONE;
00000004 00000001          bug_trap_type BUG_TRAP_TYPE_WARN;
00000004 00000001          $512660047B55412B2BAF31B0BB49255B BUS_ISA_MEM_BASE;
00000004 00000002          $512660047B55412B2BAF31B0BB49255B BUS_ISA_PORT_BASE;
00000004 00000003          $512660047B55412B2BAF31B0BB49255B BUS_ISA_PORT_SHIFT;
00000004 00000033          vm_event_item COMPACTFAIL;
00000004 00000030          vm_event_item COMPACTFREE_SCANNED;
00000004 00000031          vm_event_item COMPACTISOLATED;
00000004 0000002F          vm_event_item COMPACTMIGRATE_SCANNED;
00000004 00000032          vm_event_item COMPACTSTALL;
00000004 00000034          vm_event_item COMPACTSUCCESS;
00000004 00000001          compound_dtor_id COMPOUND_PAGE_DTOR;
00000004 00000003          bpf_reg_type CONST_PTR_TO_MAP;
00000004 FFFFFFFF          ctx_state CONTEXT_DISABLED;
00000004 00000002          ctx_state CONTEXT_GUEST;
00000004 00000000          ctx_state CONTEXT_KERNEL;
00000004 00000001          ctx_state CONTEXT_USER;
00000004 00000004          cpuid_leafs CPUID_1_ECX;
00000004 00000000          cpuid_leafs CPUID_1_EDX;
00000004 0000000E          cpuid_leafs CPUID_6_EAX;
00000004 00000009          cpuid_leafs CPUID_7_0_EBX;
00000004 0000000C          cpuid_leafs CPUID_7_1_EAX;
00000004 00000010          cpuid_leafs CPUID_7_ECX;
00000004 00000012          cpuid_leafs CPUID_7_EDX;
00000004 00000006          cpuid_leafs CPUID_8000_0001_ECX;
00000004 00000001          cpuid_leafs CPUID_8000_0001_EDX;
00000004 00000011          cpuid_leafs CPUID_8000_0007_EBX;
00000004 0000000D          cpuid_leafs CPUID_8000_0008_EBX;
00000004 0000000F          cpuid_leafs CPUID_8000_000A_EDX;
00000004 00000002          cpuid_leafs CPUID_8086_0001_EDX;
00000004 00000005          cpuid_leafs CPUID_C000_0001_EDX;
00000004 0000000A          cpuid_leafs CPUID_D_1_EAX;
00000004 00000000          cpuid_regs_idx CPUID_EAX;
00000004 00000001          cpuid_regs_idx CPUID_EBX;
00000004 00000002          cpuid_regs_idx CPUID_ECX;
00000004 00000003          cpuid_regs_idx CPUID_EDX;
00000004 00000003          cpuid_leafs CPUID_LNX_1;
00000004 00000007          cpuid_leafs CPUID_LNX_2;
00000004 00000008          cpuid_leafs CPUID_LNX_3;
00000004 0000000B          cpuid_leafs CPUID_LNX_4;
00000004 00000009          $9F1C343F19E43E2C791976B81DDFE73F CTL_ABI;
00000004 000000FE          $9F1C343F19E43E2C791976B81DDFE73F CTL_ARLAN;
00000004 00000008          $9F1C343F19E43E2C791976B81DDFE73F CTL_BUS;
00000004 00000001          $6D848B1F08A515B4F2CE8369AFAA7D22 CTL_BUS_ISA;
00000004 0000000A          $9F1C343F19E43E2C791976B81DDFE73F CTL_CPU;
00000004 00000006          $9F1C343F19E43E2C791976B81DDFE73F CTL_DEBUG;
00000004 00000007          $9F1C343F19E43E2C791976B81DDFE73F CTL_DEV;
00000004 000026AA          $9F1C343F19E43E2C791976B81DDFE73F CTL_FRV;
00000004 00000005          $9F1C343F19E43E2C791976B81DDFE73F CTL_FS;
00000004 00000001          $9F1C343F19E43E2C791976B81DDFE73F CTL_KERN;
00000004 00000003          $9F1C343F19E43E2C791976B81DDFE73F CTL_NET;
00000004 000026AB          $9F1C343F19E43E2C791976B81DDFE73F CTL_PM;
00000004 00000004          $9F1C343F19E43E2C791976B81DDFE73F CTL_PROC;
00000004 0000162D          $9F1C343F19E43E2C791976B81DDFE73F CTL_S390DBF;
00000004 00001C51          $9F1C343F19E43E2C791976B81DDFE73F CTL_SUNRPC;
00000004 00000002          $9F1C343F19E43E2C791976B81DDFE73F CTL_VM;
00000004 00000001          dentry_d_lock_class DENTRY_D_LOCK_NESTED;
00000004 00000000          dentry_d_lock_class DENTRY_D_LOCK_NORMAL;
00000004 00000010          $FE78702B5580ECC83A56568737032F29 DESCTYPE_S;
00000004 00000002          $FE78702B5580ECC83A56568737032F29 DESC_LDT;
00000004 00000009          $FE78702B5580ECC83A56568737032F29 DESC_TSS;
00000004 00000001          $60B62F48899D961D20EBC59F7F1840D8 DEV_CDROM;
00000004 00000002          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_AUTOCLOSE;
00000004 00000003          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_AUTOEJECT;
00000004 00000006          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_CHECK_MEDIA;
00000004 00000004          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_DEBUG;
00000004 00000001          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_INFO;
00000004 00000005          $DD660EA5423A614ACA40036D6D43F5E5 DEV_CDROM_LOCK;
00000004 00000002          dev_dma_attr DEV_DMA_COHERENT;
00000004 00000001          dev_dma_attr DEV_DMA_NON_COHERENT;
00000004 00000000          dev_dma_attr DEV_DMA_NOT_SUPPORTED;
00000004 00000002          $60B62F48899D961D20EBC59F7F1840D8 DEV_HWMON;
00000004 00000007          $60B62F48899D961D20EBC59F7F1840D8 DEV_IPMI;
00000004 00000001          $4428FE6B781B78B25B204D3D56A4B251 DEV_IPMI_POWEROFF_POWERCYCLE;
00000004 00000005          $60B62F48899D961D20EBC59F7F1840D8 DEV_MAC_HID;
00000004 00000006          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES;
00000004 00000002          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES;
00000004 00000001          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES;
00000004 00000004          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE;
00000004 00000005          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE;
00000004 00000003          $24C4792CDD1F41699BBC435C70A94D72 DEV_MAC_HID_MOUSE_BUTTON_EMULATION;
00000004 00000003          $60B62F48899D961D20EBC59F7F1840D8 DEV_PARPORT;
00000004 00000010          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_AUTOPROBE;
00000004 00000002          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_BASE_ADDR;
00000004 FFFFFFFD          $E2802EBDA04C37773D722411B2859A54 DEV_PARPORT_DEFAULT;
00000004 00000002          $9378181ED114762C16D6A0CA075A1AED DEV_PARPORT_DEFAULT_SPINTIME;
00000004 00000001          $9378181ED114762C16D6A0CA075A1AED DEV_PARPORT_DEFAULT_TIMESLICE;
00000004 00000006          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_DEVICES;
00000004 FFFFFFFD          $A053D32692F1695D6D7D85526762485A DEV_PARPORT_DEVICES_ACTIVE;
00000004 00000001          $1BD4E6AB35C1BC0E966A06B79AEB29B4 DEV_PARPORT_DEVICE_TIMESLICE;
00000004 00000004          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_DMA;
00000004 00000003          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_IRQ;
00000004 00000005          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_MODES;
00000004 00000001          $4B65E9CAA671A29AB236B2850E23C880 DEV_PARPORT_SPINTIME;
00000004 00000005          dev_prop_type DEV_PROP_MAX;
00000004 00000004          dev_prop_type DEV_PROP_STRING;
00000004 00000001          dev_prop_type DEV_PROP_U16;
00000004 00000002          dev_prop_type DEV_PROP_U32;
00000004 00000003          dev_prop_type DEV_PROP_U64;
00000004 00000000          dev_prop_type DEV_PROP_U8;
00000004 00000004          $60B62F48899D961D20EBC59F7F1840D8 DEV_RAID;
00000004 00000002          $616F435F032F8A816FE9E5F141D3010F DEV_RAID_SPEED_LIMIT_MAX;
00000004 00000001          $616F435F032F8A816FE9E5F141D3010F DEV_RAID_SPEED_LIMIT_MIN;
00000004 00000006          $60B62F48899D961D20EBC59F7F1840D8 DEV_SCSI;
00000004 00000001          $411DA2B6574699F7D8C6ACF66163E448 DEV_SCSI_LOGGING_LEVEL;
00000004 00000001          $351E6E9B07F7A2F5C3B6E85CED34CA17 DIO_LOCKING;
00000004 00000002          $351E6E9B07F7A2F5C3B6E85CED34CA17 DIO_SKIP_HOLES;
00000004 00000002          $52593586F30D64AE5B28AA59437E3640 DISK_EVENT_EJECT_REQUEST;
00000004 00000001          $84DD7F43B858C66E6EC7FD290C403DAF DISK_EVENT_FLAG_POLL;
00000004 00000002          $84DD7F43B858C66E6EC7FD290C403DAF DISK_EVENT_FLAG_UEVENT;
00000004 00000001          $52593586F30D64AE5B28AA59437E3640 DISK_EVENT_MEDIA_CHANGE;
00000004 00000002          dl_dev_state DL_DEV_DRIVER_BOUND;
00000004 00000000          dl_dev_state DL_DEV_NO_DRIVER;
00000004 00000001          dl_dev_state DL_DEV_PROBING;
00000004 00000003          dl_dev_state DL_DEV_UNBINDING;
00000004 00000003          device_link_state DL_STATE_ACTIVE;
00000004 00000001          device_link_state DL_STATE_AVAILABLE;
00000004 00000002          device_link_state DL_STATE_CONSUMER_PROBE;
00000004 00000000          device_link_state DL_STATE_DORMANT;
00000004 FFFFFFFF          device_link_state DL_STATE_NONE;
00000004 00000004          device_link_state DL_STATE_SUPPLIER_UNBIND;
00000004 00000051          $8F79D9D84589DB364612B4CE8A4916F1 DM6_AUX1PARTITION;
00000004 00000053          $8F79D9D84589DB364612B4CE8A4916F1 DM6_AUX3PARTITION;
00000004 00000054          $8F79D9D84589DB364612B4CE8A4916F1 DM6_PARTITION;
00000004 00000003          dmi_field DMI_BIOS_DATE;
00000004 00000001          dmi_field DMI_BIOS_VENDOR;
00000004 00000002          dmi_field DMI_BIOS_VERSION;
00000004 0000000F          dmi_field DMI_BOARD_ASSET_TAG;
00000004 0000000C          dmi_field DMI_BOARD_NAME;
00000004 0000000E          dmi_field DMI_BOARD_SERIAL;
00000004 0000000B          dmi_field DMI_BOARD_VENDOR;
00000004 0000000D          dmi_field DMI_BOARD_VERSION;
00000004 00000014          dmi_field DMI_CHASSIS_ASSET_TAG;
00000004 00000013          dmi_field DMI_CHASSIS_SERIAL;
00000004 00000011          dmi_field DMI_CHASSIS_TYPE;
00000004 00000010          dmi_field DMI_CHASSIS_VENDOR;
00000004 00000012          dmi_field DMI_CHASSIS_VERSION;
00000004 00000000          dmi_field DMI_NONE;
00000004 00000016          dmi_field DMI_OEM_STRING;
00000004 0000000A          dmi_field DMI_PRODUCT_FAMILY;
00000004 00000005          dmi_field DMI_PRODUCT_NAME;
00000004 00000007          dmi_field DMI_PRODUCT_SERIAL;
00000004 00000009          dmi_field DMI_PRODUCT_SKU;
00000004 00000008          dmi_field DMI_PRODUCT_UUID;
00000004 00000006          dmi_field DMI_PRODUCT_VERSION;
00000004 00000015          dmi_field DMI_STRING_MAX;
00000004 00000004          dmi_field DMI_SYS_VENDOR;
00000004 00000000          irq_domain_bus_token DOMAIN_BUS_ANY;
00000004 00000007          irq_domain_bus_token DOMAIN_BUS_FSL_MC_MSI;
00000004 00000002          irq_domain_bus_token DOMAIN_BUS_GENERIC_MSI;
00000004 00000006          irq_domain_bus_token DOMAIN_BUS_IPI;
00000004 00000005          irq_domain_bus_token DOMAIN_BUS_NEXUS;
00000004 00000003          irq_domain_bus_token DOMAIN_BUS_PCI_MSI;
00000004 00000004          irq_domain_bus_token DOMAIN_BUS_PLATFORM_MSI;
00000004 00000008          irq_domain_bus_token DOMAIN_BUS_TI_SCI_INTA_MSI;
00000004 00000001          irq_domain_bus_token DOMAIN_BUS_WIRED;
00000004 00000005          $8F79D9D84589DB364612B4CE8A4916F1 DOS_EXTENDED_PARTITION;
00000004 00000001          dpm_order DPM_ORDER_DEV_AFTER_PARENT;
00000004 00000003          dpm_order DPM_ORDER_DEV_LAST;
00000004 00000000          dpm_order DPM_ORDER_NONE;
00000004 00000002          dpm_order DPM_ORDER_PARENT_BEFORE_DEV;
00000004 00000011          $D34C68FE13AAA27A261CD86BDC983917 DQF_INFO_DIRTY_B;
00000004 00000011          $05CF1DF5F3AA29F92A37408928E5EB3B DQF_PRIVATE;
00000004 00000000          $05CF1DF5F3AA29F92A37408928E5EB3B DQF_ROOT_SQUASH_B;
00000004 00000010          $05CF1DF5F3AA29F92A37408928E5EB3B DQF_SYS_FILE_B;
00000004 00000005          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_ALLOC_DQUOTS;
00000004 00000004          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_CACHE_HITS;
00000004 00000001          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_DROPS;
00000004 00000006          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_FREE_DQUOTS;
00000004 00000000          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_LOOKUPS;
00000004 00000002          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_READS;
00000004 00000007          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_SYNCS;
00000004 00000003          $C8133BF94EE3AFC5F16AA8508ABCA0FF DQST_WRITES;
00000004 00000025          vm_event_item DROP_PAGECACHE;
00000004 00000026          vm_event_item DROP_SLAB;
00000004 00000001          ftrace_dump_mode DUMP_ALL;
00000004 00000000          ftrace_dump_mode DUMP_NONE;
00000004 00000002          ftrace_dump_mode DUMP_ORIG;
00000004 00000001          $FD885BF279F4D68832B2662A17689723 DUMP_PREFIX_ADDRESS;
00000004 00000000          $FD885BF279F4D68832B2662A17689723 DUMP_PREFIX_NONE;
00000004 00000002          $FD885BF279F4D68832B2662A17689723 DUMP_PREFIX_OFFSET;
00000004 00000009          efi_rts_ids EFI_GET_NEXT_HIGH_MONO_COUNT;
00000004 00000006          efi_rts_ids EFI_GET_NEXT_VARIABLE;
00000004 00000001          efi_rts_ids EFI_GET_TIME;
00000004 00000005          efi_rts_ids EFI_GET_VARIABLE;
00000004 00000003          efi_rts_ids EFI_GET_WAKEUP_TIME;
00000004 00000000          efi_rts_ids EFI_NONE;
00000004 0000000C          efi_rts_ids EFI_QUERY_CAPSULE_CAPS;
00000004 00000008          efi_rts_ids EFI_QUERY_VARIABLE_INFO;
00000004 0000000A          efi_rts_ids EFI_RESET_SYSTEM;
00000004 00000002          efi_rts_ids EFI_SET_TIME;
00000004 00000007          efi_rts_ids EFI_SET_VARIABLE;
00000004 00000004          efi_rts_ids EFI_SET_WAKEUP_TIME;
00000004 0000000B          efi_rts_ids EFI_UPDATE_CAPSULE;
00000004 00000002          $5360083879AC87D5226F57A4A0F46C43 EI_ETYPE_ERRNO;
00000004 00000003          $5360083879AC87D5226F57A4A0F46C43 EI_ETYPE_ERRNO_NULL;
00000004 00000000          $5360083879AC87D5226F57A4A0F46C43 EI_ETYPE_NONE;
00000004 00000001          $5360083879AC87D5226F57A4A0F46C43 EI_ETYPE_NULL;
00000004 00000004          $5360083879AC87D5226F57A4A0F46C43 EI_ETYPE_TRUE;
00000004 00000002          elv_merge ELEVATOR_BACK_MERGE;
00000004 00000003          elv_merge ELEVATOR_DISCARD_MERGE;
00000004 00000001          elv_merge ELEVATOR_FRONT_MERGE;
00000004 00000000          elv_merge ELEVATOR_NO_MERGE;
00000004 00000000          tlb_infos ENTRIES;
00000004 00000055          $8F79D9D84589DB364612B4CE8A4916F1 EZD_PARTITION;
00000004 00000003          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationDisable;
00000004 00000002          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationEnable;
00000004 00000000          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationGet;
00000004 00000005          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationMaximum;
00000004 00000001          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationSet;
00000004 00000004          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION EfiPciIoAttributeOperationSupported;
00000004 00000005          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFifoUint16;
00000004 00000006          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFifoUint32;
00000004 00000007          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFifoUint64;
00000004 00000004          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFifoUint8;
00000004 00000009          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFillUint16;
00000004 0000000A          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFillUint32;
00000004 0000000B          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFillUint64;
00000004 00000008          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthFillUint8;
00000004 0000000C          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthMaximum;
00000004 00000001          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthUint16;
00000004 00000002          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthUint32;
00000004 00000003          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthUint64;
00000004 00000000          EFI_PCI_IO_PROTOCOL_WIDTH EfiPciIoWidthUint8;
00000004 00080000          $76602C1D950947A0A79A611E6C37E6C0 FDPIC_FUNCPTRS;
00000004 00000284          fixed_addresses FIX_APEI_GHES_IRQ;
00000004 00000285          fixed_addresses FIX_APEI_GHES_NMI;
00000004 00000202          fixed_addresses FIX_APIC_BASE;
00000004 000005FF          fixed_addresses FIX_BTMAP_BEGIN;
00000004 00000400          fixed_addresses FIX_BTMAP_END;
00000004 00000200          fixed_addresses FIX_DBGP_BASE;
00000004 00000201          fixed_addresses FIX_EARLYCON_MEM_BASE;
00000004 00000203          fixed_addresses FIX_IO_APIC_BASE_0;
00000004 00000282          fixed_addresses FIX_IO_APIC_BASE_END;
00000004 00000283          fixed_addresses FIX_PARAVIRT_BOOTMAP;
00000004 00000600          fixed_addresses FIX_TBOOT_BASE;
00000004 000000A5          $8F79D9D84589DB364612B4CE8A4916F1 FREEBSD_PARTITION;
00000004 00000013          $3C897483CD60E997325FAB081547E2CD FS_AIO_MAX_NR;
00000004 00000012          $3C897483CD60E997325FAB081547E2CD FS_AIO_NR;
00000004 00000008          $3C897483CD60E997325FAB081547E2CD FS_DENTRY;
00000004 0000000E          $3C897483CD60E997325FAB081547E2CD FS_DIR_NOTIFY;
00000004 00000010          $3C897483CD60E997325FAB081547E2CD FS_DQSTATS;
00000004 00000006          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_ALLOCATED;
00000004 00000005          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_CACHE_HITS;
00000004 00000002          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_DROPS;
00000004 00000007          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_FREE;
00000004 00000001          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_LOOKUPS;
00000004 00000003          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_READS;
00000004 00000008          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_SYNCS;
00000004 00000009          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_WARNINGS;
00000004 00000004          $56043FBF751FA02B184DBBEB9F9EC0C4 FS_DQ_WRITES;
00000004 00000014          $3C897483CD60E997325FAB081547E2CD FS_INOTIFY;
00000004 0000000D          $3C897483CD60E997325FAB081547E2CD FS_LEASES;
00000004 0000000F          $3C897483CD60E997325FAB081547E2CD FS_LEASE_TIME;
00000004 00000005          $3C897483CD60E997325FAB081547E2CD FS_MAXDQUOT;
00000004 00000007          $3C897483CD60E997325FAB081547E2CD FS_MAXFILE;
00000004 00000003          $3C897483CD60E997325FAB081547E2CD FS_MAXINODE;
00000004 0000000A          $3C897483CD60E997325FAB081547E2CD FS_MAXSUPER;
00000004 00000004          $3C897483CD60E997325FAB081547E2CD FS_NRDQUOT;
00000004 00000006          $3C897483CD60E997325FAB081547E2CD FS_NRFILE;
00000004 00000001          $3C897483CD60E997325FAB081547E2CD FS_NRINODE;
00000004 00000009          $3C897483CD60E997325FAB081547E2CD FS_NRSUPER;
00000004 000003DC          $3C897483CD60E997325FAB081547E2CD FS_OCFS2;
00000004 0000000C          $3C897483CD60E997325FAB081547E2CD FS_OVERFLOWGID;
00000004 0000000B          $3C897483CD60E997325FAB081547E2CD FS_OVERFLOWUID;
00000004 00000002          $3C897483CD60E997325FAB081547E2CD FS_STATINODE;
00000004 00000011          $3C897483CD60E997325FAB081547E2CD FS_XFS;
00000004 0000000C          $B67EA7470D2A6AF09336569BE8951073 GATE_CALL;
00000004 0000000E          $B67EA7470D2A6AF09336569BE8951073 GATE_INTERRUPT;
00000004 00000005          $B67EA7470D2A6AF09336569BE8951073 GATE_TASK;
00000004 0000000F          $B67EA7470D2A6AF09336569BE8951073 GATE_TRAP;
00000004 00000001          $996A157442774DB15D331DAB676978AB GOOD_FRAME;
00000004 00000002          $996A157442774DB15D331DAB676978AB GOOD_STACK;
00000004 00000001          symsearch::$918E90F7BDB99030C053413DA08D0BB9 GPL_ONLY;
00000004 00000001          quota_type GRPQUOTA;
00000004 00000000          $DD2FCB3BD885EF085C64DD38A6B8659D HI_SOFTIRQ;
00000004 00000002          hrtimer_base_type HRTIMER_BASE_BOOTTIME;
00000004 00000006          hrtimer_base_type HRTIMER_BASE_BOOTTIME_SOFT;
00000004 00000000          hrtimer_base_type HRTIMER_BASE_MONOTONIC;
00000004 00000004          hrtimer_base_type HRTIMER_BASE_MONOTONIC_SOFT;
00000004 00000001          hrtimer_base_type HRTIMER_BASE_REALTIME;
00000004 00000005          hrtimer_base_type HRTIMER_BASE_REALTIME_SOFT;
00000004 00000003          hrtimer_base_type HRTIMER_BASE_TAI;
00000004 00000007          hrtimer_base_type HRTIMER_BASE_TAI_SOFT;
00000004 00000008          hrtimer_base_type HRTIMER_MAX_CLOCK_BASES;
00000004 00000000          hrtimer_mode HRTIMER_MODE_ABS;
00000004 00000008          hrtimer_mode HRTIMER_MODE_ABS_HARD;
00000004 00000002          hrtimer_mode HRTIMER_MODE_ABS_PINNED;
00000004 0000000A          hrtimer_mode HRTIMER_MODE_ABS_PINNED_HARD;
00000004 00000006          hrtimer_mode HRTIMER_MODE_ABS_PINNED_SOFT;
00000004 00000004          hrtimer_mode HRTIMER_MODE_ABS_SOFT;
00000004 00000008          hrtimer_mode HRTIMER_MODE_HARD;
00000004 00000002          hrtimer_mode HRTIMER_MODE_PINNED;
00000004 00000001          hrtimer_mode HRTIMER_MODE_REL;
00000004 00000009          hrtimer_mode HRTIMER_MODE_REL_HARD;
00000004 00000003          hrtimer_mode HRTIMER_MODE_REL_PINNED;
00000004 0000000B          hrtimer_mode HRTIMER_MODE_REL_PINNED_HARD;
00000004 00000007          hrtimer_mode HRTIMER_MODE_REL_PINNED_SOFT;
00000004 00000005          hrtimer_mode HRTIMER_MODE_REL_SOFT;
00000004 00000004          hrtimer_mode HRTIMER_MODE_SOFT;
00000004 00000000          hrtimer_restart HRTIMER_NORESTART;
00000004 00000001          hrtimer_restart HRTIMER_RESTART;
00000004 00000008          $DD2FCB3BD885EF085C64DD38A6B8659D HRTIMER_SOFTIRQ;
00000004 00000038          vm_event_item HTLB_BUDDY_PGALLOC;
00000004 00000039          vm_event_item HTLB_BUDDY_PGALLOC_FAIL;
00000004 00000002          compound_dtor_id HUGETLB_PAGE_DTOR;
00000004 00000008          $703B5ABC350937E66EAF60AD5B95930B ICQ_DESTROYED;
00000004 00000004          $703B5ABC350937E66EAF60AD5B95930B ICQ_EXITED;
00000004 00000001          idle_boot_override IDLE_HALT;
00000004 00000002          idle_boot_override IDLE_NOMWAIT;
00000004 00000000          idle_boot_override IDLE_NO_OVERRIDE;
00000004 00000003          idle_boot_override IDLE_POLL;
00000004 00000003          $F95B50F6F94511BD921427ED12628368 INOTIFY_MAX_QUEUED_EVENTS;
00000004 00000001          $F95B50F6F94511BD921427ED12628368 INOTIFY_MAX_USER_INSTANCES;
00000004 00000002          $F95B50F6F94511BD921427ED12628368 INOTIFY_MAX_USER_WATCHES;
00000004 00000002          $E078C9ACDA5326FB81275127CAE2B29F IOPRIO_CLASS_BE;
00000004 00000003          $E078C9ACDA5326FB81275127CAE2B29F IOPRIO_CLASS_IDLE;
00000004 00000000          $E078C9ACDA5326FB81275127CAE2B29F IOPRIO_CLASS_NONE;
00000004 00000001          $E078C9ACDA5326FB81275127CAE2B29F IOPRIO_CLASS_RT;
00000004 00000002          $59BCDDE0051E086138E1DDF7B528786B IOPRIO_WHO_PGRP;
00000004 00000001          $59BCDDE0051E086138E1DDF7B528786B IOPRIO_WHO_PROCESS;
00000004 00000003          $59BCDDE0051E086138E1DDF7B528786B IOPRIO_WHO_USER;
00000004 00000003          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_ACPI_NV_STORAGE;
00000004 00000002          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_ACPI_TABLES;
00000004 00000001          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_CRASH_KERNEL;
00000004 00000006          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_DEVICE_PRIVATE_MEMORY;
00000004 00000000          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_NONE;
00000004 00000004          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_PERSISTENT_MEMORY;
00000004 00000005          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_PERSISTENT_MEMORY_LEGACY;
00000004 00000007          $CC4A454E8208181B52210202C2CBA085 IORES_DESC_RESERVED;
00000004 00000002          $920EC0BBA3FEB6A91852241075E3F405 IORES_MAP_ENCRYPTED;
00000004 00000001          $920EC0BBA3FEB6A91852241075E3F405 IORES_MAP_SYSTEM_RAM;
00000004 00000001          $8A312B2D78DB719AC82A393A5A941300 IRQCHIP_FWNODE_NAMED;
00000004 00000002          $8A312B2D78DB719AC82A393A5A941300 IRQCHIP_FWNODE_NAMED_ID;
00000004 00000000          $8A312B2D78DB719AC82A393A5A941300 IRQCHIP_FWNODE_REAL;
00000004 00000001          irqchip_irq_state IRQCHIP_STATE_ACTIVE;
00000004 00000003          irqchip_irq_state IRQCHIP_STATE_LINE_LEVEL;
00000004 00000002          irqchip_irq_state IRQCHIP_STATE_MASKED;
00000004 00000000          irqchip_irq_state IRQCHIP_STATE_PENDING;
00000004 00000000          $61095D04A8B2D7F56ABAF771B351C10B IRQC_IS_HARDIRQ;
00000004 00000001          $61095D04A8B2D7F56ABAF771B351C10B IRQC_IS_NESTED;
00000004 00000001          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_HIERARCHY;
00000004 00000004          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_IPI_PER_CPU;
00000004 00000008          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_IPI_SINGLE;
00000004 00000010          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_MSI;
00000004 00000020          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_MSI_REMAP;
00000004 00010000          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_FLAG_NONCORE;
00000004 00000040          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_MSI_NOMASK_QUIRK;
00000004 00000002          $9B7665AE312985EE65D541D8F377D77E IRQ_DOMAIN_NAME_ALLOCATED;
00000004 00000001          irqreturn IRQ_HANDLED;
00000004 00000000          irqreturn IRQ_NONE;
00000004 00000005          $DD2FCB3BD885EF085C64DD38A6B8659D IRQ_POLL_SOFTIRQ;
00000004 00000002          irqreturn IRQ_WAKE_THREAD;
00000004 00000002          inode_i_mutex_lock_class I_MUTEX_CHILD;
00000004 00000004          inode_i_mutex_lock_class I_MUTEX_NONDIR2;
00000004 00000000          inode_i_mutex_lock_class I_MUTEX_NORMAL;
00000004 00000001          inode_i_mutex_lock_class I_MUTEX_PARENT;
00000004 00000005          inode_i_mutex_lock_class I_MUTEX_PARENT2;
00000004 00000003          inode_i_mutex_lock_class I_MUTEX_XATTR;
00000004 00000001          jump_label_type JUMP_LABEL_JMP;
00000004 00000000          jump_label_type JUMP_LABEL_NOP;
00000004 00000037          vm_event_item KCOMPACTD_FREE_SCANNED;
00000004 00000036          vm_event_item KCOMPACTD_MIGRATE_SCANNED;
00000004 00000035          vm_event_item KCOMPACTD_WAKE;
00000004 00000001          $42AA7968567CB5517F8D3321B22BA7FC KCOV_TRACE_CMP;
00000004 00000000          $42AA7968567CB5517F8D3321B22BA7FC KCOV_TRACE_PC;
00000004 00000002          $86D0ABDFA99038684D0DD91396445982 KERNEL_PARAM_FL_HWPARAM;
00000004 00000001          $86D0ABDFA99038684D0DD91396445982 KERNEL_PARAM_FL_UNSAFE;
00000004 00000001          $77F19FD6E96F4DCDF889CD607B5C3F5D KERNEL_PARAM_OPS_FL_NOARG;
00000004 00000010          kernfs_node_flag KERNFS_ACTIVATED;
00000004 00000001          kernfs_node_type KERNFS_DIR;
00000004 00001000          kernfs_node_flag KERNFS_EMPTY_DIR;
00000004 00000002          kernfs_node_type KERNFS_FILE;
00000004 00000080          kernfs_node_flag KERNFS_HAS_MMAP;
00000004 00002000          kernfs_node_flag KERNFS_HAS_RELEASE;
00000004 00000040          kernfs_node_flag KERNFS_HAS_SEQ_SHOW;
00000004 00000004          kernfs_node_type KERNFS_LINK;
00000004 00000100          kernfs_node_flag KERNFS_LOCKDEP;
00000004 00000020          kernfs_node_flag KERNFS_NS;
00000004 00000001          kernfs_root_flag KERNFS_ROOT_CREATE_DEACTIVATED;
00000004 00000002          kernfs_root_flag KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK;
00000004 00000004          kernfs_root_flag KERNFS_ROOT_SUPPORT_EXPORTOP;
00000004 00000400          kernfs_node_flag KERNFS_SUICIDAL;
00000004 00000800          kernfs_node_flag KERNFS_SUICIDED;
00000004 0000001E          $7A4A42E21375D24B0EC7301047402AA2 KERN_ACCT;
00000004 00000047          $7A4A42E21375D24B0EC7301047402AA2 KERN_ACPI_VIDEO_FLAGS;
00000004 00000043          $7A4A42E21375D24B0EC7301047402AA2 KERN_BOOTLOADER_TYPE;
00000004 00000036          $7A4A42E21375D24B0EC7301047402AA2 KERN_CADPID;
00000004 00000049          $7A4A42E21375D24B0EC7301047402AA2 KERN_COMPAT_LOG;
00000004 00000038          $7A4A42E21375D24B0EC7301047402AA2 KERN_CORE_PATTERN;
00000004 00000034          $7A4A42E21375D24B0EC7301047402AA2 KERN_CORE_USES_PID;
00000004 00000016          $7A4A42E21375D24B0EC7301047402AA2 KERN_CTLALTDEL;
00000004 00000008          $7A4A42E21375D24B0EC7301047402AA2 KERN_DOMAINNAME;
00000004 00000031          $7A4A42E21375D24B0EC7301047402AA2 KERN_HOTPLUG;
00000004 0000003A          $7A4A42E21375D24B0EC7301047402AA2 KERN_HPPA_PWRSW;
00000004 0000003B          $7A4A42E21375D24B0EC7301047402AA2 KERN_HPPA_UNALIGNED;
00000004 00000041          $7A4A42E21375D24B0EC7301047402AA2 KERN_HZ_TIMER;
00000004 00000048          $7A4A42E21375D24B0EC7301047402AA2 KERN_IA64_UNALIGNED;
00000004 00000032          $7A4A42E21375D24B0EC7301047402AA2 KERN_IEEE_EMULATION_WARNINGS;
00000004 0000004A          $7A4A42E21375D24B0EC7301047402AA2 KERN_MAX_LOCK_DEPTH;
00000004 00000027          $7A4A42E21375D24B0EC7301047402AA2 KERN_MAX_THREADS;
00000004 0000001C          $7A4A42E21375D24B0EC7301047402AA2 KERN_MODPROBE;
00000004 00000023          $7A4A42E21375D24B0EC7301047402AA2 KERN_MSGMAX;
00000004 00000024          $7A4A42E21375D24B0EC7301047402AA2 KERN_MSGMNB;
00000004 0000002A          $7A4A42E21375D24B0EC7301047402AA2 KERN_MSGMNI;
00000004 00000025          $7A4A42E21375D24B0EC7301047402AA2 KERN_MSGPOOL;
00000004 00000018          $7A4A42E21375D24B0EC7301047402AA2 KERN_NAMETRANS;
00000004 0000003F          $7A4A42E21375D24B0EC7301047402AA2 KERN_NGROUPS_MAX;
00000004 0000004B          $7A4A42E21375D24B0EC7301047402AA2 KERN_NMI_WATCHDOG;
00000004 00000007          $7A4A42E21375D24B0EC7301047402AA2 KERN_NODENAME;
00000004 00000002          $7A4A42E21375D24B0EC7301047402AA2 KERN_OSRELEASE;
00000004 00000003          $7A4A42E21375D24B0EC7301047402AA2 KERN_OSREV;
00000004 00000001          $7A4A42E21375D24B0EC7301047402AA2 KERN_OSTYPE;
00000004 0000002F          $7A4A42E21375D24B0EC7301047402AA2 KERN_OVERFLOWGID;
00000004 0000002E          $7A4A42E21375D24B0EC7301047402AA2 KERN_OVERFLOWUID;
00000004 0000000F          $7A4A42E21375D24B0EC7301047402AA2 KERN_PANIC;
00000004 0000004C          $7A4A42E21375D24B0EC7301047402AA2 KERN_PANIC_ON_NMI;
00000004 00000039          $7A4A42E21375D24B0EC7301047402AA2 KERN_PANIC_ON_OOPS;
00000004 0000004D          $7A4A42E21375D24B0EC7301047402AA2 KERN_PANIC_ON_WARN;
00000004 0000004E          $7A4A42E21375D24B0EC7301047402AA2 KERN_PANIC_PRINT;
00000004 00000037          $7A4A42E21375D24B0EC7301047402AA2 KERN_PIDMAX;
00000004 00000019          $7A4A42E21375D24B0EC7301047402AA2 KERN_PPC_HTABRECLAIM;
00000004 0000001F          $7A4A42E21375D24B0EC7301047402AA2 KERN_PPC_L2CR;
00000004 0000001B          $7A4A42E21375D24B0EC7301047402AA2 KERN_PPC_POWERSAVE_NAP;
00000004 0000001A          $7A4A42E21375D24B0EC7301047402AA2 KERN_PPC_ZEROPAGED;
00000004 00000017          $7A4A42E21375D24B0EC7301047402AA2 KERN_PRINTK;
00000004 0000003C          $7A4A42E21375D24B0EC7301047402AA2 KERN_PRINTK_RATELIMIT;
00000004 0000003D          $7A4A42E21375D24B0EC7301047402AA2 KERN_PRINTK_RATELIMIT_BURST;
00000004 00000006          $7A4A42E21375D24B0EC7301047402AA2 KERN_PROF;
00000004 0000003E          $7A4A42E21375D24B0EC7301047402AA2 KERN_PTY;
00000004 00000028          $7A4A42E21375D24B0EC7301047402AA2 KERN_RANDOM;
00000004 00000044          $7A4A42E21375D24B0EC7301047402AA2 KERN_RANDOMIZE;
00000004 00000010          $7A4A42E21375D24B0EC7301047402AA2 KERN_REALROOTDEV;
00000004 00000021          $7A4A42E21375D24B0EC7301047402AA2 KERN_RTSIGMAX;
00000004 00000020          $7A4A42E21375D24B0EC7301047402AA2 KERN_RTSIGNR;
00000004 00000033          $7A4A42E21375D24B0EC7301047402AA2 KERN_S390_USER_DEBUG_LOGGING;
00000004 00000005          $7A4A42E21375D24B0EC7301047402AA2 KERN_SECUREMASK;
00000004 0000002B          $7A4A42E21375D24B0EC7301047402AA2 KERN_SEM;
00000004 00000045          $7A4A42E21375D24B0EC7301047402AA2 KERN_SETUID_DUMPABLE;
00000004 0000001D          $7A4A42E21375D24B0EC7301047402AA2 KERN_SG_BIG_BUFF;
00000004 00000029          $7A4A42E21375D24B0EC7301047402AA2 KERN_SHMALL;
00000004 00000022          $7A4A42E21375D24B0EC7301047402AA2 KERN_SHMMAX;
00000004 0000002D          $7A4A42E21375D24B0EC7301047402AA2 KERN_SHMMNI;
00000004 00000030          $7A4A42E21375D24B0EC7301047402AA2 KERN_SHMPATH;
00000004 00000015          $7A4A42E21375D24B0EC7301047402AA2 KERN_SPARC_REBOOT;
00000004 00000040          $7A4A42E21375D24B0EC7301047402AA2 KERN_SPARC_SCONS_PWROFF;
00000004 0000002C          $7A4A42E21375D24B0EC7301047402AA2 KERN_SPARC_STOP_A;
00000004 00000046          $7A4A42E21375D24B0EC7301047402AA2 KERN_SPIN_RETRY;
00000004 00000026          $7A4A42E21375D24B0EC7301047402AA2 KERN_SYSRQ;
00000004 00000035          $7A4A42E21375D24B0EC7301047402AA2 KERN_TAINTED;
00000004 00000042          $7A4A42E21375D24B0EC7301047402AA2 KERN_UNKNOWN_NMI_PANIC;
00000004 00000004          $7A4A42E21375D24B0EC7301047402AA2 KERN_VERSION;
00000004 00000001          key_state KEY_IS_POSITIVE;
00000004 00000000          key_state KEY_IS_UNINSTANTIATED;
00000004 00000002          kmalloc_cache_type KMALLOC_DMA;
00000004 00000000          kmalloc_cache_type KMALLOC_NORMAL;
00000004 00000001          kmalloc_cache_type KMALLOC_RECLAIM;
00000004 00000003          kmsg_dump_reason KMSG_DUMP_EMERG;
00000004 00000005          kmsg_dump_reason KMSG_DUMP_HALT;
00000004 00000002          kmsg_dump_reason KMSG_DUMP_OOPS;
00000004 00000001          kmsg_dump_reason KMSG_DUMP_PANIC;
00000004 00000006          kmsg_dump_reason KMSG_DUMP_POWEROFF;
00000004 00000004          kmsg_dump_reason KMSG_DUMP_RESTART;
00000004 00000000          kmsg_dump_reason KMSG_DUMP_UNDEF;
00000004 00000000          kobject_action KOBJ_ADD;
00000004 00000006          kobject_action KOBJ_BIND;
00000004 00000002          kobject_action KOBJ_CHANGE;
00000004 00000008          kobject_action KOBJ_MAX;
00000004 00000003          kobject_action KOBJ_MOVE;
00000004 00000002          kobj_ns_type KOBJ_NS_TYPES;
00000004 00000001          kobj_ns_type KOBJ_NS_TYPE_NET;
00000004 00000000          kobj_ns_type KOBJ_NS_TYPE_NONE;
00000004 00000005          kobject_action KOBJ_OFFLINE;
00000004 00000004          kobject_action KOBJ_ONLINE;
00000004 00000001          kobject_action KOBJ_REMOVE;
00000004 00000007          kobject_action KOBJ_UNBIND;
00000004 00000022          vm_event_item KSWAPD_HIGH_WMARK_HIT_QUICKLY;
00000004 00000020          vm_event_item KSWAPD_INODESTEAL;
00000004 00000021          vm_event_item KSWAPD_LOW_WMARK_HIT_QUICKLY;
00000004 00000002          l1tf_mitigations L1TF_MITIGATION_FLUSH;
00000004 00000003          l1tf_mitigations L1TF_MITIGATION_FLUSH_NOSMT;
00000004 00000001          l1tf_mitigations L1TF_MITIGATION_FLUSH_NOWARN;
00000004 00000004          l1tf_mitigations L1TF_MITIGATION_FULL;
00000004 00000005          l1tf_mitigations L1TF_MITIGATION_FULL_FORCE;
00000004 00000000          l1tf_mitigations L1TF_MITIGATION_OFF;
00000004 00000083          $8F79D9D84589DB364612B4CE8A4916F1 LINUX_DATA_PARTITION;
00000004 00000085          $8F79D9D84589DB364612B4CE8A4916F1 LINUX_EXTENDED_PARTITION;
00000004 0000008E          $8F79D9D84589DB364612B4CE8A4916F1 LINUX_LVM_PARTITION;
00000004 000000FD          $8F79D9D84589DB364612B4CE8A4916F1 LINUX_RAID_PARTITION;
00000004 00000082          $8F79D9D84589DB364612B4CE8A4916F1 LINUX_SWAP_PARTITION;
00000004 00000001          lockdep_ok LOCKDEP_NOW_UNRELIABLE;
00000004 00000000          lockdep_ok LOCKDEP_STILL_OK;
00000004 00000001          $FA4B264BC8EEF9F64DD8398F93A5E41E LOGIC_PIO_CPU_MMIO;
00000004 00000000          $FA4B264BC8EEF9F64DD8398F93A5E41E LOGIC_PIO_INDIRECT;
00000004 00000001          lru_list LRU_ACTIVE_ANON;
00000004 00000003          lru_list LRU_ACTIVE_FILE;
00000004 00000000          lru_list LRU_INACTIVE_ANON;
00000004 00000002          lru_list LRU_INACTIVE_FILE;
00000004 00000000          lru_status LRU_REMOVED;
00000004 00000001          lru_status LRU_REMOVED_RETRY;
00000004 00000004          lru_status LRU_RETRY;
00000004 00000002          lru_status LRU_ROTATE;
00000004 00000003          lru_status LRU_SKIP;
00000004 00000004          lru_list LRU_UNEVICTABLE;
00000004 00000002          $2E9D172CAA035E0370957B5AF4415823 MAX_ZONELISTS;
00000004 00000001          mds_mitigations MDS_MITIGATION_FULL;
00000004 00000000          mds_mitigations MDS_MITIGATION_OFF;
00000004 00000002          mds_mitigations MDS_MITIGATION_VMWERV;
00000004 00000000          meminit_context MEMINIT_EARLY;
00000004 00000001          meminit_context MEMINIT_HOTPLUG;
00000004 00000003          memory_type MEMORY_DEVICE_DEVDAX;
00000004 00000002          memory_type MEMORY_DEVICE_FS_DAX;
00000004 00000004          memory_type MEMORY_DEVICE_PCI_P2PDMA;
00000004 00000001          memory_type MEMORY_DEVICE_PRIVATE;
00000004 0000000E          $8EE75ACFE4C7E25E8006D062E16DEF3C MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE;
00000004 0000000C          $8EE75ACFE4C7E25E8006D062E16DEF3C MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE;
00000004 00000010          $C3253497E792F022ED6F36DA19188F48 MEMREMAP_DEC;
00000004 00000008          $C3253497E792F022ED6F36DA19188F48 MEMREMAP_ENC;
00000004 00000001          $C3253497E792F022ED6F36DA19188F48 MEMREMAP_WB;
00000004 00000004          $C3253497E792F022ED6F36DA19188F48 MEMREMAP_WC;
00000004 00000002          $C3253497E792F022ED6F36DA19188F48 MEMREMAP_WT;
00000004 00000002          mf_flags MF_ACTION_REQUIRED;
00000004 00000001          mf_flags MF_COUNT_INCREASED;
00000004 00000002          mf_result MF_DELAYED;
00000004 00000001          mf_result MF_FAILED;
00000004 00000000          mf_result MF_IGNORED;
00000004 00000012          mf_action_page_type MF_MSG_BUDDY;
00000004 00000013          mf_action_page_type MF_MSG_BUDDY_2ND;
00000004 00000010          mf_action_page_type MF_MSG_CLEAN_LRU;
00000004 0000000C          mf_action_page_type MF_MSG_CLEAN_MLOCKED_LRU;
00000004 0000000A          mf_action_page_type MF_MSG_CLEAN_SWAPCACHE;
00000004 0000000E          mf_action_page_type MF_MSG_CLEAN_UNEVICTABLE_LRU;
00000004 00000014          mf_action_page_type MF_MSG_DAX;
00000004 00000003          mf_action_page_type MF_MSG_DIFFERENT_COMPOUND;
00000004 0000000F          mf_action_page_type MF_MSG_DIRTY_LRU;
00000004 0000000B          mf_action_page_type MF_MSG_DIRTY_MLOCKED_LRU;
00000004 00000009          mf_action_page_type MF_MSG_DIRTY_SWAPCACHE;
00000004 0000000D          mf_action_page_type MF_MSG_DIRTY_UNEVICTABLE_LRU;
00000004 00000006          mf_action_page_type MF_MSG_FREE_HUGE;
00000004 00000005          mf_action_page_type MF_MSG_HUGE;
00000004 00000000          mf_action_page_type MF_MSG_KERNEL;
00000004 00000001          mf_action_page_type MF_MSG_KERNEL_HIGH_ORDER;
00000004 00000007          mf_action_page_type MF_MSG_NON_PMD_HUGE;
00000004 00000004          mf_action_page_type MF_MSG_POISONED_HUGE;
00000004 00000002          mf_action_page_type MF_MSG_SLAB;
00000004 00000011          mf_action_page_type MF_MSG_TRUNCATED_LRU;
00000004 00000015          mf_action_page_type MF_MSG_UNKNOWN;
00000004 00000008          mf_action_page_type MF_MSG_UNMAP_FAILED;
00000004 00000004          mf_flags MF_MUST_KILL;
00000004 00000003          mf_result MF_RECOVERED;
00000004 00000008          mf_flags MF_SOFT_OFFLINE;
00000004 00000000          migrate_mode MIGRATE_ASYNC;
00000004 00000004          migratetype MIGRATE_CMA;
00000004 00000003          migratetype MIGRATE_HIGHATOMIC;
00000004 00000005          migratetype MIGRATE_ISOLATE;
00000004 00000001          migratetype MIGRATE_MOVABLE;
00000004 00000003          migratetype MIGRATE_PCPTYPES;
00000004 00000002          migratetype MIGRATE_RECLAIMABLE;
00000004 00000002          migrate_mode MIGRATE_SYNC;
00000004 00000001          migrate_mode MIGRATE_SYNC_LIGHT;
00000004 00000003          migrate_mode MIGRATE_SYNC_NO_COPY;
00000004 00000006          migratetype MIGRATE_TYPES;
00000004 00000000          migratetype MIGRATE_UNMOVABLE;
00000004 00000081          $8F79D9D84589DB364612B4CE8A4916F1 MINIX_PARTITION;
00000004 0000000D          $8EE75ACFE4C7E25E8006D062E16DEF3C MIX_SECTION_INFO;
00000004 00100000          $76602C1D950947A0A79A611E6C37E6C0 MMAP_PAGE_ZERO;
00000004 FFFFFFFF          $B125586D9729EEE128612194FB4E81EB MMOP_OFFLINE;
00000004 00000000          $B125586D9729EEE128612194FB4E81EB MMOP_ONLINE_KEEP;
00000004 00000001          $B125586D9729EEE128612194FB4E81EB MMOP_ONLINE_KERNEL;
00000004 00000002          $B125586D9729EEE128612194FB4E81EB MMOP_ONLINE_MOVABLE;
00000004 00000001          $2FD438E2A2F08791E408C294C231390D MM_ANONPAGES;
00000004 00000000          $2FD438E2A2F08791E408C294C231390D MM_FILEPAGES;
00000004 00000003          $2FD438E2A2F08791E408C294C231390D MM_SHMEMPAGES;
00000004 00000002          $2FD438E2A2F08791E408C294C231390D MM_SWAPENTS;
00000004 00000001          module_state MODULE_STATE_COMING;
00000004 00000002          module_state MODULE_STATE_GOING;
00000004 00000000          module_state MODULE_STATE_LIVE;
00000004 00000003          module_state MODULE_STATE_UNFORMED;
00000004 00000002          mp_bustype MP_BUS_EISA;
00000004 00000001          mp_bustype MP_BUS_ISA;
00000004 00000003          mp_bustype MP_BUS_PCI;
00000004 00000002          mq_rq_state MQ_RQ_COMPLETE;
00000004 00000000          mq_rq_state MQ_RQ_IDLE;
00000004 00000001          mq_rq_state MQ_RQ_IN_FLIGHT;
00000004 00000000          mutex_trylock_recursive_enum MUTEX_TRYLOCK_FAILED;
00000004 00000002          mutex_trylock_recursive_enum MUTEX_TRYLOCK_RECURSIVE;
00000004 00000001          mutex_trylock_recursive_enum MUTEX_TRYLOCK_SUCCESS;
00000004 000000A9          $8F79D9D84589DB364612B4CE8A4916F1 NETBSD_PARTITION;
00000004 00000003          $EE881B30B7542CFB3C32B33271ABE56C NET_802;
00000004 00000007          $EE881B30B7542CFB3C32B33271ABE56C NET_ATALK;
00000004 00000001          $14BC4732EFAB4DB3C424C5B74F9B2FA1 NET_ATALK_AARP_EXPIRY_TIME;
00000004 00000004          $14BC4732EFAB4DB3C424C5B74F9B2FA1 NET_ATALK_AARP_RESOLVE_TIME;
00000004 00000003          $14BC4732EFAB4DB3C424C5B74F9B2FA1 NET_ATALK_AARP_RETRANSMIT_LIMIT;
00000004 00000002          $14BC4732EFAB4DB3C424C5B74F9B2FA1 NET_ATALK_AARP_TICK_TIME;
00000004 00000009          $EE881B30B7542CFB3C32B33271ABE56C NET_AX25;
00000004 00000003          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_BACKOFF_TYPE;
00000004 00000004          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_CONNECT_MODE;
00000004 0000000E          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_DAMA_SLAVE_TIMEOUT;
00000004 00000002          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_DEFAULT_MODE;
00000004 00000006          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_EXTENDED_WINDOW;
00000004 0000000A          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_IDLE_TIMEOUT;
00000004 00000001          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_IP_DEFAULT_MODE;
00000004 0000000B          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_N2;
00000004 0000000C          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_PACLEN;
00000004 0000000D          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_PROTOCOL;
00000004 00000005          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_STANDARD_WINDOW;
00000004 00000007          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_T1_TIMEOUT;
00000004 00000008          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_T2_TIMEOUT;
00000004 00000009          $BC115D47C9DDFB8CD40A21C6FB547B3A NET_AX25_T3_TIMEOUT;
00000004 0000000A          $EE881B30B7542CFB3C32B33271ABE56C NET_BRIDGE;
00000004 00000001          $C79E0A93E66CA749659366F31D952A37 NET_BRIDGE_NF_CALL_ARPTABLES;
00000004 00000003          $C79E0A93E66CA749659366F31D952A37 NET_BRIDGE_NF_CALL_IP6TABLES;
00000004 00000002          $C79E0A93E66CA749659366F31D952A37 NET_BRIDGE_NF_CALL_IPTABLES;
00000004 00000005          $C79E0A93E66CA749659366F31D952A37 NET_BRIDGE_NF_FILTER_PPPOE_TAGGED;
00000004 00000004          $C79E0A93E66CA749659366F31D952A37 NET_BRIDGE_NF_FILTER_VLAN_TAGGED;
00000004 00000077          $7CE2251B09B7020AF5AF21F04A24179B NET_CIPSOV4_CACHE_BUCKET_SIZE;
00000004 00000076          $7CE2251B09B7020AF5AF21F04A24179B NET_CIPSOV4_CACHE_ENABLE;
00000004 00000078          $7CE2251B09B7020AF5AF21F04A24179B NET_CIPSOV4_RBM_OPTFMT;
00000004 00000079          $7CE2251B09B7020AF5AF21F04A24179B NET_CIPSOV4_RBM_STRICTVALID;
00000004 00000001          $EE881B30B7542CFB3C32B33271ABE56C NET_CORE;
00000004 00000014          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_AEVENT_ETIME;
00000004 00000015          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_AEVENT_RSEQTH;
00000004 00000013          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_BUDGET;
00000004 00000011          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_DEV_WEIGHT;
00000004 0000000C          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_DIVERT_VERSION;
00000004 00000007          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_FASTROUTE;
00000004 0000000B          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_HOT_LIST_LENGTH;
00000004 0000000F          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_LO_CONG;
00000004 00000006          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_MAX_BACKLOG;
00000004 00000010          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_MOD_CONG;
00000004 00000009          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_MSG_BURST;
00000004 00000008          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_MSG_COST;
00000004 0000000E          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_NO_CONG;
00000004 0000000D          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_NO_CONG_THRESH;
00000004 0000000A          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_OPTMEM_MAX;
00000004 00000004          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_RMEM_DEFAULT;
00000004 00000002          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_RMEM_MAX;
00000004 00000012          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_SOMAXCONN;
00000004 00000016          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_WARNINGS;
00000004 00000003          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_WMEM_DEFAULT;
00000004 00000001          $73F457F405A5D51C3FDDF95473AB392E NET_CORE_WMEM_MAX;
00000004 00000014          $EE881B30B7542CFB3C32B33271ABE56C NET_DCCP;
00000004 00000001          $9DA96C2F69A1683D205BD20C634B5163 NET_DCCP_DEFAULT;
00000004 0000000F          $EE881B30B7542CFB3C32B33271ABE56C NET_DECNET;
00000004 0000000A          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_CONF;
00000004 FFFFFFFD          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_DDCMP;
00000004 00000006          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_BLKSIZE;
00000004 00000005          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_FORWARDING;
00000004 00000001          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_PRIORITY;
00000004 00000007          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_STATE;
00000004 00000002          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_T1;
00000004 00000003          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_T2;
00000004 00000004          $21512D32A1F68B3E2EE322B1CFB51275 NET_DECNET_CONF_DEV_T3;
00000004 FFFFFFF9          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_ETHER;
00000004 FFFFFFFA          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_GRE;
00000004 FFFFFFFE          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_LOOPBACK;
00000004 FFFFFFFC          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_PPP;
00000004 FFFFFFFB          $7CE73F2334FEBC06325C41F1D4EDE363 NET_DECNET_CONF_X25;
00000004 000000FF          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DEBUG_LEVEL;
00000004 00000004          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DEFAULT_DEVICE;
00000004 00000007          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DI_COUNT;
00000004 00000006          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DN_COUNT;
00000004 00000008          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DR_COUNT;
00000004 00000009          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_DST_GC_INTERVAL;
00000004 0000000C          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_MEM;
00000004 00000002          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_NODE_ADDRESS;
00000004 00000003          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_NODE_NAME;
00000004 00000001          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_NODE_TYPE;
00000004 0000000B          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_NO_FC_MAX_CWND;
00000004 0000000D          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_RMEM;
00000004 00000005          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_TIME_WAIT;
00000004 0000000E          $709DF5F3F56DB7DD3E16F05CC6E604B3 NET_DECNET_WMEM;
00000004 00000010          $EE881B30B7542CFB3C32B33271ABE56C NET_ECONET;
00000004 00000002          $EE881B30B7542CFB3C32B33271ABE56C NET_ETHER;
00000004 00000005          $EE881B30B7542CFB3C32B33271ABE56C NET_IPV4;
00000004 00000043          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ALWAYS_DEFRAG;
00000004 00000026          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_AUTOCONFIG;
00000004 00000010          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_CONF;
00000004 00000004          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ACCEPT_REDIRECTS;
00000004 00000009          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE;
00000004 0000000D          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ARPFILTER;
00000004 00000015          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ARP_ACCEPT;
00000004 00000012          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ARP_ANNOUNCE;
00000004 00000013          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ARP_IGNORE;
00000004 00000016          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_ARP_NOTIFY;
00000004 0000000A          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_BOOTP_RELAY;
00000004 00000011          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_FORCE_IGMP_VERSION;
00000004 00000001          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_FORWARDING;
00000004 0000000B          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_LOG_MARTIANS;
00000004 00000002          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_MC_FORWARDING;
00000004 0000000E          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_MEDIUM_ID;
00000004 00000010          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_NOPOLICY;
00000004 0000000F          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_NOXFRM;
00000004 00000014          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_PROMOTE_SECONDARIES;
00000004 00000003          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_PROXY_ARP;
00000004 00000008          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_RP_FILTER;
00000004 00000005          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_SECURE_REDIRECTS;
00000004 00000006          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_SEND_REDIRECTS;
00000004 00000007          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_SHARED_MEDIA;
00000004 0000000C          $564FE539A1D0653776DB6B6580CFEE4D NET_IPV4_CONF_TAG;
00000004 00000025          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_DEFAULT_TTL;
00000004 00000009          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_DYNADDR;
00000004 00000013          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_FIB_HASH;
00000004 00000008          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_FORWARD;
00000004 0000003C          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_DESTUNREACH_RATE;
00000004 0000003F          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_ECHOREPLY_RATE;
00000004 00000039          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_ECHO_IGNORE_ALL;
00000004 0000003A          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS;
00000004 0000006D          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR;
00000004 00000040          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES;
00000004 0000003E          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_PARAMPROB_RATE;
00000004 00000059          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_RATELIMIT;
00000004 0000005A          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_RATEMASK;
00000004 0000003B          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_SOURCEQUENCH_RATE;
00000004 0000003D          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ICMP_TIMEEXCEED_RATE;
00000004 00000041          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IGMP_MAX_MEMBERSHIPS;
00000004 00000060          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IGMP_MAX_MSF;
00000004 00000049          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_INET_PEER_GC_MAXTIME;
00000004 00000048          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_INET_PEER_GC_MINTIME;
00000004 00000047          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_INET_PEER_MAXTTL;
00000004 00000046          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_INET_PEER_MINTTL;
00000004 00000045          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_INET_PEER_THRESHOLD;
00000004 00000029          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IPFRAG_HIGH_THRESH;
00000004 0000002A          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IPFRAG_LOW_THRESH;
00000004 00000070          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IPFRAG_MAX_DIST;
00000004 0000005E          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IPFRAG_SECRET_INTERVAL;
00000004 0000002B          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IPFRAG_TIME;
00000004 00000032          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_IP_MASQ_DEBUG;
00000004 00000038          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_LOCAL_PORT_RANGE;
00000004 00000011          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_NEIGH;
00000004 00000014          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_NETFILTER;
00000004 0000000E          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_BUCKETS;
00000004 0000001C          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_CHECKSUM;
00000004 0000001B          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_COUNT;
00000004 0000000D          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT;
00000004 0000000C          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT;
00000004 0000000F          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_LOG_INVALID;
00000004 00000001          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_MAX;
00000004 00000014          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED;
00000004 00000016          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED;
00000004 00000015          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT;
00000004 00000017          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED;
00000004 0000001A          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT;
00000004 00000019          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD;
00000004 00000018          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT;
00000004 00000012          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL;
00000004 00000011          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_LOOSE;
00000004 00000013          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS;
00000004 00000009          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE;
00000004 00000006          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT;
00000004 00000004          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED;
00000004 00000005          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT;
00000004 00000007          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK;
00000004 00000010          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS;
00000004 00000003          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV;
00000004 00000002          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT;
00000004 00000008          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT;
00000004 0000000A          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT;
00000004 0000000B          $60A10810DFA7A3DBF77266120B2AFEDE NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM;
00000004 00000058          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_NONLOCAL_BIND;
00000004 00000027          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_NO_PMTU_DISC;
00000004 00000012          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_ROUTE;
00000004 0000000D          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_ERROR_BURST;
00000004 0000000C          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_ERROR_COST;
00000004 00000001          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_FLUSH;
00000004 0000000E          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_ELASTICITY;
00000004 00000008          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_INTERVAL;
00000004 00000006          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_MIN_INTERVAL;
00000004 00000013          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS;
00000004 00000004          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_THRESH;
00000004 00000007          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_GC_TIMEOUT;
00000004 00000003          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MAX_DELAY;
00000004 00000005          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MAX_SIZE;
00000004 00000011          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MIN_ADVMSS;
00000004 00000002          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MIN_DELAY;
00000004 00000010          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MIN_PMTU;
00000004 0000000F          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_MTU_EXPIRES;
00000004 00000009          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_REDIRECT_LOAD;
00000004 0000000A          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_REDIRECT_NUMBER;
00000004 0000000B          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_REDIRECT_SILENCE;
00000004 00000012          $D1C6CDD7D7C74B624F76AE5A57ABAF86 NET_IPV4_ROUTE_SECRET_INTERVAL;
00000004 00000031          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_FIN_TIMEOUT;
00000004 00000044          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_KEEPALIVE_INTVL;
00000004 0000002E          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_KEEPALIVE_PROBES;
00000004 0000002D          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_KEEPALIVE_TIME;
00000004 0000002C          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_MAX_KA_PROBES;
00000004 00000024          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_RETRANS_COLLAPSE;
00000004 0000002F          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_RETRIES1;
00000004 00000030          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_RETRIES2;
00000004 00000023          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_SACK;
00000004 00000028          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_SYN_RETRIES;
00000004 00000021          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_TIMESTAMPS;
00000004 00000022          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_WINDOW_SCALING;
00000004 00000073          $7CE2251B09B7020AF5AF21F04A24179B NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS;
00000004 0000000C          $EE881B30B7542CFB3C32B33271ABE56C NET_IPV6;
00000004 00000004          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA;
00000004 00000012          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_DEFRTR;
00000004 0000001A          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_FROM_LOCAL;
00000004 00000013          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_PINFO;
00000004 00000014          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_RTR_PREF;
00000004 00000016          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN;
00000004 0000001B          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN;
00000004 00000005          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_REDIRECTS;
00000004 00000019          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_ACCEPT_SOURCE_ROUTE;
00000004 00000006          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_AUTOCONF;
00000004 00000014          $534583194F03A437CB05609CF180A532 NET_IPV6_BINDV6ONLY;
00000004 00000010          $534583194F03A437CB05609CF180A532 NET_IPV6_CONF;
00000004 00000007          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_DAD_TRANSMITS;
00000004 00000011          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_FORCE_MLD_VERSION;
00000004 00000001          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_FORWARDING;
00000004 00000002          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_HOP_LIMIT;
00000004 00000013          $534583194F03A437CB05609CF180A532 NET_IPV6_ICMP;
00000004 00000002          $E18CBD23AF204134F6C348F22E1A9F58 NET_IPV6_ICMP_ECHO_IGNORE_ALL;
00000004 00000001          $E18CBD23AF204134F6C348F22E1A9F58 NET_IPV6_ICMP_RATELIMIT;
00000004 00000015          $534583194F03A437CB05609CF180A532 NET_IPV6_IP6FRAG_HIGH_THRESH;
00000004 00000016          $534583194F03A437CB05609CF180A532 NET_IPV6_IP6FRAG_LOW_THRESH;
00000004 00000018          $534583194F03A437CB05609CF180A532 NET_IPV6_IP6FRAG_SECRET_INTERVAL;
00000004 00000017          $534583194F03A437CB05609CF180A532 NET_IPV6_IP6FRAG_TIME;
00000004 00000010          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_MAX_ADDRESSES;
00000004 0000000F          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_MAX_DESYNC_FACTOR;
00000004 00000019          $534583194F03A437CB05609CF180A532 NET_IPV6_MLD_MAX_MSF;
00000004 00000003          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_MTU;
00000004 00000011          $534583194F03A437CB05609CF180A532 NET_IPV6_NEIGH;
00000004 00000017          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_PROXY_NDP;
00000004 0000000E          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_REGEN_MAX_RETRY;
00000004 00000012          $534583194F03A437CB05609CF180A532 NET_IPV6_ROUTE;
00000004 00000001          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_FLUSH;
00000004 00000007          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_ELASTICITY;
00000004 00000006          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_INTERVAL;
00000004 00000004          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_MIN_INTERVAL;
00000004 0000000A          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS;
00000004 00000002          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_THRESH;
00000004 00000005          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_GC_TIMEOUT;
00000004 00000003          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_MAX_SIZE;
00000004 00000009          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_MIN_ADVMSS;
00000004 00000008          $E48FB40A2EEEB6009AB0899CAD55E209 NET_IPV6_ROUTE_MTU_EXPIRES;
00000004 00000015          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_RTR_PROBE_INTERVAL;
00000004 00000008          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_RTR_SOLICITS;
00000004 0000000A          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_RTR_SOLICIT_DELAY;
00000004 00000009          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_RTR_SOLICIT_INTERVAL;
00000004 0000000D          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_TEMP_PREFERED_LFT;
00000004 0000000C          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_TEMP_VALID_LFT;
00000004 0000000B          $187884F4088CD9BBE07DDAE7E9FCE777 NET_IPV6_USE_TEMPADDR;
00000004 00000006          $EE881B30B7542CFB3C32B33271ABE56C NET_IPX;
00000004 00000002          $9CD6C74639A446D0BEB3AAB7E9A0E7A0 NET_IPX_FORWARDING;
00000004 00000001          $9CD6C74639A446D0BEB3AAB7E9A0E7A0 NET_IPX_PPROP_BROADCASTING;
00000004 0000019C          $EE881B30B7542CFB3C32B33271ABE56C NET_IRDA;
00000004 00000012          $EE881B30B7542CFB3C32B33271ABE56C NET_LLC;
00000004 00000001          $596FAD39ADBF5BB4571CF5330A90C7F8 NET_LLC2;
00000004 00000001          $1D7DC671811FCBECC9CA03AA95A665D0 NET_LLC2_ACK_TIMEOUT;
00000004 00000004          $1D7DC671811FCBECC9CA03AA95A665D0 NET_LLC2_BUSY_TIMEOUT;
00000004 00000002          $1D7DC671811FCBECC9CA03AA95A665D0 NET_LLC2_P_TIMEOUT;
00000004 00000003          $1D7DC671811FCBECC9CA03AA95A665D0 NET_LLC2_REJ_TIMEOUT;
00000004 00000001          $FB90A9B33AACD20852F8AD06D332219C NET_LLC2_TIMEOUT;
00000004 00000002          $596FAD39ADBF5BB4571CF5330A90C7F8 NET_LLC_STATION;
00000004 00000001          $5999AE35E101408E5D03CC2611A2D199 NET_LLC_STATION_ACK_TIMEOUT;
00000004 0000000A          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_ANYCAST_DELAY;
00000004 00000003          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_APP_SOLICIT;
00000004 00000006          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_DELAY_PROBE_TIME;
00000004 0000000D          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_GC_INTERVAL;
00000004 00000007          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_GC_STALE_TIME;
00000004 0000000E          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_GC_THRESH1;
00000004 0000000F          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_GC_THRESH2;
00000004 00000010          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_GC_THRESH3;
00000004 0000000C          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_LOCKTIME;
00000004 00000001          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_MCAST_SOLICIT;
00000004 0000000B          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_PROXY_DELAY;
00000004 00000009          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_PROXY_QLEN;
00000004 00000005          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_REACHABLE_TIME;
00000004 00000012          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_REACHABLE_TIME_MS;
00000004 00000004          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_RETRANS_TIME;
00000004 00000011          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_RETRANS_TIME_MS;
00000004 00000002          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_UCAST_SOLICIT;
00000004 00000008          $550AAD0D06A2C47FA73759B6530AED52 NET_NEIGH_UNRES_QLEN;
00000004 00000013          $EE881B30B7542CFB3C32B33271ABE56C NET_NETFILTER;
00000004 00000008          $EE881B30B7542CFB3C32B33271ABE56C NET_NETROM;
00000004 00000001          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_DEFAULT_PATH_QUALITY;
00000004 0000000B          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_LINK_FAILS_COUNT;
00000004 00000003          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_NETWORK_TTL_INITIALISER;
00000004 00000002          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER;
00000004 0000000C          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_RESET;
00000004 0000000A          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_ROUTING_CONTROL;
00000004 00000006          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY;
00000004 00000007          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_BUSY_DELAY;
00000004 00000005          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_MAXIMUM_TRIES;
00000004 00000009          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT;
00000004 00000008          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE;
00000004 00000004          $E1E110DEFD816DF1B74D124C6ED67C44 NET_NETROM_TRANSPORT_TIMEOUT;
00000004 0000000E          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_BUCKETS;
00000004 00000020          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_CHECKSUM;
00000004 0000001B          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_COUNT;
00000004 0000001F          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_FRAG6_HIGH_THRESH;
00000004 0000001E          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_FRAG6_LOW_THRESH;
00000004 0000001D          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_FRAG6_TIMEOUT;
00000004 0000000D          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_GENERIC_TIMEOUT;
00000004 0000001C          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_ICMPV6_TIMEOUT;
00000004 0000000C          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_ICMP_TIMEOUT;
00000004 0000000F          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_LOG_INVALID;
00000004 00000001          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_MAX;
00000004 00000014          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED;
00000004 00000016          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED;
00000004 00000015          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT;
00000004 00000017          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED;
00000004 0000001A          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT;
00000004 00000019          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD;
00000004 00000018          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT;
00000004 00000012          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_BE_LIBERAL;
00000004 00000011          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_LOOSE;
00000004 00000013          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_MAX_RETRANS;
00000004 00000009          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE;
00000004 00000006          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT;
00000004 00000004          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED;
00000004 00000005          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT;
00000004 00000007          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK;
00000004 00000010          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS;
00000004 00000003          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV;
00000004 00000002          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT;
00000004 00000008          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT;
00000004 0000000A          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_UDP_TIMEOUT;
00000004 0000000B          $92BBB68DB384BCA758C7B6186973B9DA NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM;
00000004 FFFFFFFE          $E6D6BE9659EDA578D1F3A457560E33EB NET_PROTO_CONF_ALL;
00000004 FFFFFFFD          $E6D6BE9659EDA578D1F3A457560E33EB NET_PROTO_CONF_DEFAULT;
00000004 0000000B          $EE881B30B7542CFB3C32B33271ABE56C NET_ROSE;
00000004 00000005          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_ACK_HOLD_BACK_TIMEOUT;
00000004 00000002          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_CALL_REQUEST_TIMEOUT;
00000004 00000004          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_CLEAR_REQUEST_TIMEOUT;
00000004 00000007          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_LINK_FAIL_TIMEOUT;
00000004 00000008          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_MAX_VCS;
00000004 0000000A          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_NO_ACTIVITY_TIMEOUT;
00000004 00000003          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_RESET_REQUEST_TIMEOUT;
00000004 00000001          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_RESTART_REQUEST_TIMEOUT;
00000004 00000006          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_ROUTING_CONTROL;
00000004 00000009          $F343D6E3F3FA4C251E7C37669AE684EF NET_ROSE_WINDOW_SIZE;
00000004 00000003          $DD2FCB3BD885EF085C64DD38A6B8659D NET_RX_SOFTIRQ;
00000004 00000011          $EE881B30B7542CFB3C32B33271ABE56C NET_SCTP;
00000004 0000000D          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_ADDIP_ENABLE;
00000004 00000007          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_ASSOCIATION_MAX_RETRANS;
00000004 0000000A          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_HB_INTERVAL;
00000004 0000000C          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_MAX_BURST;
00000004 00000009          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_MAX_INIT_RETRANSMITS;
00000004 00000008          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_PATH_MAX_RETRANS;
00000004 0000000B          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_PRESERVE_ENABLE;
00000004 0000000E          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_PRSCTP_ENABLE;
00000004 00000011          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RCVBUF_POLICY;
00000004 00000004          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RTO_ALPHA;
00000004 00000005          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RTO_BETA;
00000004 00000001          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RTO_INITIAL;
00000004 00000003          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RTO_MAX;
00000004 00000002          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_RTO_MIN;
00000004 00000010          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_SACK_TIMEOUT;
00000004 0000000F          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_SNDBUF_POLICY;
00000004 00000006          $B2BE5ADE84BE27CF87124FAAFF70590C NET_SCTP_VALID_COOKIE_LIFE;
00000004 0000006F          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ABC;
00000004 0000004B          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ABORT_ON_OVERFLOW;
00000004 00000057          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ADV_WIN_SCALE;
00000004 0000007B          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ALLOWED_CONG_CONTROL;
00000004 00000056          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_APP_WIN;
00000004 0000007A          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_AVAIL_CONG_CONTROL;
00000004 00000072          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_BASE_MSS;
00000004 0000006C          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_BIC_BETA;
00000004 0000006E          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_CONG_CONTROL;
00000004 00000069          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_DEFAULT_WIN_SCALE;
00000004 00000074          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_DMA_COPYBREAK;
00000004 00000052          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_DSACK;
00000004 00000051          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ECN;
00000004 0000004F          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_FACK;
00000004 0000005C          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_FRTO;
00000004 0000007D          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_FRTO_RESPONSE;
00000004 0000005D          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_LOW_LATENCY;
00000004 0000004D          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MAX_ORPHANS;
00000004 0000007C          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MAX_SSTHRESH;
00000004 00000037          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MAX_SYN_BACKLOG;
00000004 0000004E          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MAX_TW_BUCKETS;
00000004 00000053          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MEM;
00000004 0000006A          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MODERATE_RCVBUF;
00000004 00000071          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_MTU_PROBING;
00000004 00000061          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_NO_METRICS_SAVE;
00000004 0000004A          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_ORPHAN_RETRIES;
00000004 00000050          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_REORDERING;
00000004 00000035          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_RFC1337;
00000004 00000055          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_RMEM;
00000004 00000075          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_SLOW_START_AFTER_IDLE;
00000004 00000034          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_STDURG;
00000004 0000004C          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_SYNACK_RETRIES;
00000004 00000033          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_SYNCOOKIES;
00000004 00000036          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_SYN_TAILDROP;
00000004 0000006B          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_TSO_WIN_DIVISOR;
00000004 00000042          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_TW_RECYCLE;
00000004 0000005B          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_TW_REUSE;
00000004 00000054          $7CE2251B09B7020AF5AF21F04A24179B NET_TCP_WMEM;
00000004 0000000E          $EE881B30B7542CFB3C32B33271ABE56C NET_TR;
00000004 00000001          $FED5731118ACCAE6FA3F89894F713DB9 NET_TR_RIF_TIMEOUT;
00000004 00000002          $DD2FCB3BD885EF085C64DD38A6B8659D NET_TX_SOFTIRQ;
00000004 00000004          $EE881B30B7542CFB3C32B33271ABE56C NET_UNIX;
00000004 00000002          $C613B9654F5A6887C90E6A27E8AC39F0 NET_UNIX_DELETE_DELAY;
00000004 00000001          $C613B9654F5A6887C90E6A27E8AC39F0 NET_UNIX_DESTROY_DELAY;
00000004 00000003          $C613B9654F5A6887C90E6A27E8AC39F0 NET_UNIX_MAX_DGRAM_QLEN;
00000004 0000000D          $EE881B30B7542CFB3C32B33271ABE56C NET_X25;
00000004 00000005          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_ACK_HOLD_BACK_TIMEOUT;
00000004 00000002          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_CALL_REQUEST_TIMEOUT;
00000004 00000004          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_CLEAR_REQUEST_TIMEOUT;
00000004 00000006          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_FORWARD;
00000004 00000003          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_RESET_REQUEST_TIMEOUT;
00000004 00000001          $0E63971FF611EFBC58C5ACB3C2E507C8 NET_X25_RESTART_REQUEST_TIMEOUT;
00000004 000000BF          $8F79D9D84589DB364612B4CE8A4916F1 NEW_SOLARIS_X86_PARTITION;
00000004 0000000E          $8EE75ACFE4C7E25E8006D062E16DEF3C NODE_INFO;
00000004 00000000          symsearch::$918E90F7BDB99030C053413DA08D0BB9 NOT_GPL_ONLY;
00000004 00000000          bpf_reg_type NOT_INIT;
00000004 00000000          $996A157442774DB15D331DAB676978AB NOT_STACK;
00000004 00000001          node_stat_item NR_ACTIVE_ANON;
00000004 00000003          node_stat_item NR_ACTIVE_FILE;
00000004 0000000E          node_stat_item NR_ANON_MAPPED;
00000004 00000019          node_stat_item NR_ANON_THPS;
00000004 0000000A          zone_stat_item NR_BOUNCE;
00000004 00000004          compound_dtor_id NR_COMPOUND_DTORS;
00000004 0000001D          node_stat_item NR_DIRTIED;
00000004 00000011          node_stat_item NR_FILE_DIRTY;
00000004 0000000F          node_stat_item NR_FILE_MAPPED;
00000004 00000010          node_stat_item NR_FILE_PAGES;
00000004 00000018          node_stat_item NR_FILE_PMDMAPPED;
00000004 00000017          node_stat_item NR_FILE_THPS;
00000004 0000000C          zone_stat_item NR_FREE_CMA_PAGES;
00000004 00000000          zone_stat_item NR_FREE_PAGES;
00000004 00000000          node_stat_item NR_INACTIVE_ANON;
00000004 00000002          node_stat_item NR_INACTIVE_FILE;
00000004 00000001          tlb_infos NR_INFO;
00000004 00000007          node_stat_item NR_ISOLATED_ANON;
00000004 00000008          node_stat_item NR_ISOLATED_FILE;
00000004 0000001F          node_stat_item NR_KERNEL_MISC_RECLAIMABLE;
00000004 00000009          zone_stat_item NR_KERNEL_STACK_KB;
00000004 00000003          kmalloc_cache_type NR_KMALLOC_TYPES;
00000004 00000000          node_stat_item NR_LRU_BASE;
00000004 00000005          lru_list NR_LRU_LISTS;
00000004 00000007          zone_stat_item NR_MLOCK;
00000004 00000004          $2FD438E2A2F08791E408C294C231390D NR_MM_COUNTERS;
00000004 00000005          node_states NR_NODE_STATES;
00000004 00000004          pageblock_bits NR_PAGEBLOCK_BITS;
00000004 00000008          zone_stat_item NR_PAGETABLE;
00000004 00000014          node_stat_item NR_SHMEM;
00000004 00000016          node_stat_item NR_SHMEM_PMDMAPPED;
00000004 00000015          node_stat_item NR_SHMEM_THPS;
00000004 00000005          node_stat_item NR_SLAB_RECLAIMABLE;
00000004 00000006          node_stat_item NR_SLAB_UNRECLAIMABLE;
00000004 0000000A          $DD2FCB3BD885EF085C64DD38A6B8659D NR_SOFTIRQS;
00000004 00000003          stat_group NR_STAT_GROUPS;
00000004 00000005          tlb_flush_reason NR_TLB_FLUSH_REASONS;
00000004 00000004          node_stat_item NR_UNEVICTABLE;
00000004 0000001A          node_stat_item NR_UNSTABLE_NFS;
00000004 0000001C          node_stat_item NR_VMSCAN_IMMEDIATE;
00000004 0000001B          node_stat_item NR_VMSCAN_WRITE;
00000004 00000055          vm_event_item NR_VM_EVENT_ITEMS;
00000004 00000020          node_stat_item NR_VM_NODE_STAT_ITEMS;
00000004 00000006          numa_stat_item NR_VM_NUMA_STAT_ITEMS;
00000004 0000000D          zone_stat_item NR_VM_ZONE_STAT_ITEMS;
00000004 00000004          wb_stat_item NR_WB_STAT_ITEMS;
00000004 00000003          zone_watermarks NR_WMARK;
00000004 00000012          node_stat_item NR_WRITEBACK;
00000004 00000013          node_stat_item NR_WRITEBACK_TEMP;
00000004 0000001E          node_stat_item NR_WRITTEN;
00000004 00000002          zone_stat_item NR_ZONE_ACTIVE_ANON;
00000004 00000004          zone_stat_item NR_ZONE_ACTIVE_FILE;
00000004 00000001          zone_stat_item NR_ZONE_INACTIVE_ANON;
00000004 00000003          zone_stat_item NR_ZONE_INACTIVE_FILE;
00000004 00000001          zone_stat_item NR_ZONE_LRU_BASE;
00000004 00000005          zone_stat_item NR_ZONE_UNEVICTABLE;
00000004 00000006          zone_stat_item NR_ZONE_WRITE_PENDING;
00000004 0000000B          zone_stat_item NR_ZSPAGES;
00000004 00000000          compound_dtor_id NULL_COMPOUND_DTOR;
00000004 00000002          numa_stat_item NUMA_FOREIGN;
00000004 0000002A          vm_event_item NUMA_HINT_FAULTS;
00000004 0000002B          vm_event_item NUMA_HINT_FAULTS_LOCAL;
00000004 00000000          numa_stat_item NUMA_HIT;
00000004 00000029          vm_event_item NUMA_HUGE_PTE_UPDATES;
00000004 00000003          numa_stat_item NUMA_INTERLEAVE_HIT;
00000004 00000004          numa_stat_item NUMA_LOCAL;
00000004 00000001          numa_stat_item NUMA_MISS;
00000004 00000005          numa_stat_item NUMA_OTHER;
00000004 0000002C          vm_event_item NUMA_PAGE_MIGRATE;
00000004 00000028          vm_event_item NUMA_PTE_UPDATES;
00000004 00000003          nvmem_type NVMEM_TYPE_BATTERY_BACKED;
00000004 00000001          nvmem_type NVMEM_TYPE_EEPROM;
00000004 00000002          nvmem_type NVMEM_TYPE_OTP;
00000004 00000000          nvmem_type NVMEM_TYPE_UNKNOWN;
00000004 00000004          node_states N_CPU;
00000004 00000002          node_states N_HIGH_MEMORY;
00000004 00000003          node_states N_MEMORY;
00000004 00000002          node_states N_NORMAL_MEMORY;
00000004 00000001          node_states N_ONLINE;
00000004 00000000          node_states N_POSSIBLE;
00000004 00000003          debug_obj_state ODEBUG_STATE_ACTIVE;
00000004 00000004          debug_obj_state ODEBUG_STATE_DESTROYED;
00000004 00000002          debug_obj_state ODEBUG_STATE_INACTIVE;
00000004 00000001          debug_obj_state ODEBUG_STATE_INIT;
00000004 00000006          debug_obj_state ODEBUG_STATE_MAX;
00000004 00000000          debug_obj_state ODEBUG_STATE_NONE;
00000004 00000005          debug_obj_state ODEBUG_STATE_NOTAVAILABLE;
00000004 00000001          of_overlay_notify_action OF_OVERLAY_POST_APPLY;
00000004 00000003          of_overlay_notify_action OF_OVERLAY_POST_REMOVE;
00000004 00000000          of_overlay_notify_action OF_OVERLAY_PRE_APPLY;
00000004 00000002          of_overlay_notify_action OF_OVERLAY_PRE_REMOVE;
00000004 00000001          of_reconfig_change OF_RECONFIG_CHANGE_ADD;
00000004 00000002          of_reconfig_change OF_RECONFIG_CHANGE_REMOVE;
00000004 00000000          of_reconfig_change OF_RECONFIG_NO_CHANGE;
00000004 00000027          vm_event_item OOM_KILL;
00000004 000000A6          $8F79D9D84589DB364612B4CE8A4916F1 OPENBSD_PARTITION;
00000004 00000004          acpi_execute_type OSL_DEBUGGER_EXEC_THREAD;
00000004 00000003          acpi_execute_type OSL_DEBUGGER_MAIN_THREAD;
00000004 00000006          acpi_execute_type OSL_EC_BURST_HANDLER;
00000004 00000005          acpi_execute_type OSL_EC_POLL_HANDLER;
00000004 00000000          acpi_execute_type OSL_GLOBAL_LOCK_HANDLER;
00000004 00000002          acpi_execute_type OSL_GPE_HANDLER;
00000004 00000001          acpi_execute_type OSL_NOTIFY_HANDLER;
00000004 00000023          vm_event_item PAGEOUTRUN;
00000004 00000002          paravirt_lazy_mode PARAVIRT_LAZY_CPU;
00000004 00000001          paravirt_lazy_mode PARAVIRT_LAZY_MMU;
00000004 00000000          paravirt_lazy_mode PARAVIRT_LAZY_NONE;
00000004 00000000          pageblock_bits PB_migrate;
00000004 00000002          pageblock_bits PB_migrate_end;
00000004 00000003          pageblock_bits PB_migrate_skip;
00000004 00000000          pcpu_fc PCPU_FC_AUTO;
00000004 00000001          pcpu_fc PCPU_FC_EMBED;
00000004 00000003          pcpu_fc PCPU_FC_NR;
00000004 00000002          pcpu_fc PCPU_FC_PAGE;
00000004 00000004          $AF0F795171410374A86F54C119508627 PERCPU_REF_ALLOW_REINIT;
00000004 00000001          $AF0F795171410374A86F54C119508627 PERCPU_REF_INIT_ATOMIC;
00000004 00000002          $AF0F795171410374A86F54C119508627 PERCPU_REF_INIT_DEAD;
00000004 00000006          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_BSD;
00000004 00000010          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_HPUX;
00000004 04000009          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_IRIX32;
00000004 0400000B          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_IRIX64;
00000004 0400000A          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_IRIXN32;
00000004 04000005          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_ISCR4;
00000004 00000000          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_LINUX;
00000004 00000008          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_LINUX32;
00000004 08000008          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_LINUX32_3GB;
00000004 00800000          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_LINUX_32BIT;
00000004 00080000          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_LINUX_FDPIC;
00000004 000000FF          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_MASK;
00000004 0000000F          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_OSF4;
00000004 06000003          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_OSR5;
00000004 0000000C          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_RISCOS;
00000004 07000003          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_SCOSVR3;
00000004 0400000D          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_SOLARIS;
00000004 04000006          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_SUNOS;
00000004 05000002          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_SVR3;
00000004 04100001          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_SVR4;
00000004 0410000E          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_UW7;
00000004 05000004          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_WYSEV386;
00000004 05000007          $853ECE93C1DB30EE0E7CFCC8AED03E2B PER_XENIX;
00000004 00000001          page_entry_size PE_SIZE_PMD;
00000004 00000000          page_entry_size PE_SIZE_PTE;
00000004 00000002          page_entry_size PE_SIZE_PUD;
00000004 00000011          vm_event_item PGACTIVATE;
00000004 00000004          vm_event_item PGALLOC_DMA;
00000004 00000005          vm_event_item PGALLOC_DMA32;
00000004 00000007          vm_event_item PGALLOC_MOVABLE;
00000004 00000006          vm_event_item PGALLOC_NORMAL;
00000004 00000000          pgdat_flags PGDAT_CONGESTED;
00000004 00000001          pgdat_flags PGDAT_DIRTY;
00000004 00000003          pgdat_flags PGDAT_RECLAIM_LOCKED;
00000004 00000002          pgdat_flags PGDAT_WRITEBACK;
00000004 00000012          vm_event_item PGDEACTIVATE;
00000004 00000014          vm_event_item PGFAULT;
00000004 00000010          vm_event_item PGFREE;
00000004 0000001E          vm_event_item PGINODESTEAL;
00000004 00000013          vm_event_item PGLAZYFREE;
00000004 00000016          vm_event_item PGLAZYFREED;
00000004 00000015          vm_event_item PGMAJFAULT;
00000004 0000002E          vm_event_item PGMIGRATE_FAIL;
00000004 0000002D          vm_event_item PGMIGRATE_SUCCESS;
00000004 00000000          vm_event_item PGPGIN;
00000004 00000001          vm_event_item PGPGOUT;
00000004 00000017          vm_event_item PGREFILL;
00000004 00000024          vm_event_item PGROTATED;
00000004 0000001B          vm_event_item PGSCAN_DIRECT;
00000004 0000001C          vm_event_item PGSCAN_DIRECT_THROTTLE;
00000004 0000001A          vm_event_item PGSCAN_KSWAPD;
00000004 0000000C          vm_event_item PGSCAN_SKIP_DMA;
00000004 0000000D          vm_event_item PGSCAN_SKIP_DMA32;
00000004 0000000F          vm_event_item PGSCAN_SKIP_MOVABLE;
00000004 0000000E          vm_event_item PGSCAN_SKIP_NORMAL;
00000004 0000001D          vm_event_item PGSCAN_ZONE_RECLAIM_FAILED;
00000004 00000019          vm_event_item PGSTEAL_DIRECT;
00000004 00000018          vm_event_item PGSTEAL_KSWAPD;
00000004 00000003          pg_level PG_LEVEL_1G;
00000004 00000002          pg_level PG_LEVEL_2M;
00000004 00000001          pg_level PG_LEVEL_4K;
00000004 00000004          pg_level PG_LEVEL_512G;
00000004 00000000          pg_level PG_LEVEL_NONE;
00000004 00000005          pg_level PG_LEVEL_NUM;
00000004 00000005          pageflags PG_active;
00000004 0000000B          pageflags PG_arch_1;
00000004 0000000A          pageflags PG_checked;
00000004 00000003          pageflags PG_dirty;
00000004 0000000E          pageflags PG_double_map;
00000004 00000008          pageflags PG_error;
00000004 0000000A          pageflags PG_foreign;
00000004 0000000E          pageflags PG_fscache;
00000004 00000010          pageflags PG_head;
00000004 00000017          pageflags PG_hwpoison;
00000004 00000019          pageflags PG_idle;
00000004 00000012          pageflags PG_isolated;
00000004 00000000          pageflags PG_locked;
00000004 00000004          pageflags PG_lru;
00000004 00000011          pageflags PG_mappedtodisk;
00000004 00000015          pageflags PG_mlocked;
00000004 0000000A          pageflags PG_owner_priv_1;
00000004 0000000A          pageflags PG_pinned;
00000004 0000000D          pageflags PG_private;
00000004 0000000E          pageflags PG_private_2;
00000004 00000012          pageflags PG_reclaim;
00000004 00000001          pageflags PG_referenced;
00000004 0000000C          pageflags PG_reserved;
00000004 00000003          pageflags PG_savepinned;
00000004 00000009          pageflags PG_slab;
00000004 0000000D          pageflags PG_slob_free;
00000004 00000013          pageflags PG_swapbacked;
00000004 0000000A          pageflags PG_swapcache;
00000004 00000016          pageflags PG_uncached;
00000004 00000014          pageflags PG_unevictable;
00000004 00000002          pageflags PG_uptodate;
00000004 00000007          pageflags PG_waiters;
00000004 00000006          pageflags PG_workingset;
00000004 0000000F          pageflags PG_writeback;
00000004 0000000A          pageflags PG_xen_remapped;
00000004 00000018          pageflags PG_young;
00000004 00000004          pid_type PIDTYPE_MAX;
00000004 00000002          pid_type PIDTYPE_PGID;
00000004 00000000          pid_type PIDTYPE_PID;
00000004 00000003          pid_type PIDTYPE_SID;
00000004 00000001          pid_type PIDTYPE_TGID;
00000004 00000006          acpi_preferred_pm_profiles PM_APPLIANCE_PC;
00000004 00000001          acpi_preferred_pm_profiles PM_DESKTOP;
00000004 00000004          acpi_preferred_pm_profiles PM_ENTERPRISE_SERVER;
00000004 00000002          acpi_preferred_pm_profiles PM_MOBILE;
00000004 00000007          acpi_preferred_pm_profiles PM_PERFORMANCE_SERVER;
00000004 00000005          acpi_preferred_pm_profiles PM_SOHO_SERVER;
00000004 00000008          acpi_preferred_pm_profiles PM_TABLET;
00000004 00000000          acpi_preferred_pm_profiles PM_UNSPECIFIED;
00000004 00000003          acpi_preferred_pm_profiles PM_WORKSTATION;
00000004 00000002          quota_type PRJQUOTA;
00000004 00000000          probe_type PROBE_DEFAULT_STRATEGY;
00000004 00000002          probe_type PROBE_FORCE_SYNCHRONOUS;
00000004 00000001          probe_type PROBE_PREFER_ASYNCHRONOUS;
00000004 00000002          pstore_type_id PSTORE_TYPE_CONSOLE;
00000004 00000000          pstore_type_id PSTORE_TYPE_DMESG;
00000004 00000003          pstore_type_id PSTORE_TYPE_FTRACE;
00000004 00000009          pstore_type_id PSTORE_TYPE_MAX;
00000004 00000001          pstore_type_id PSTORE_TYPE_MCE;
00000004 00000007          pstore_type_id PSTORE_TYPE_PMSG;
00000004 00000006          pstore_type_id PSTORE_TYPE_PPC_COMMON;
00000004 00000005          pstore_type_id PSTORE_TYPE_PPC_OF;
00000004 00000008          pstore_type_id PSTORE_TYPE_PPC_OPAL;
00000004 00000004          pstore_type_id PSTORE_TYPE_PPC_RTAS;
00000004 00000002          vm_event_item PSWPIN;
00000004 00000003          vm_event_item PSWPOUT;
00000004 00000002          bpf_reg_type PTR_TO_CTX;
00000004 0000000A          bpf_reg_type PTR_TO_FLOW_KEYS;
00000004 00000004          bpf_reg_type PTR_TO_MAP_VALUE;
00000004 00000005          bpf_reg_type PTR_TO_MAP_VALUE_OR_NULL;
00000004 00000008          bpf_reg_type PTR_TO_PACKET;
00000004 00000009          bpf_reg_type PTR_TO_PACKET_END;
00000004 00000007          bpf_reg_type PTR_TO_PACKET_META;
00000004 0000000B          bpf_reg_type PTR_TO_SOCKET;
00000004 0000000C          bpf_reg_type PTR_TO_SOCKET_OR_NULL;
00000004 0000000D          bpf_reg_type PTR_TO_SOCK_COMMON;
00000004 0000000E          bpf_reg_type PTR_TO_SOCK_COMMON_OR_NULL;
00000004 00000006          bpf_reg_type PTR_TO_STACK;
00000004 0000000F          bpf_reg_type PTR_TO_TCP_SOCK;
00000004 00000010          bpf_reg_type PTR_TO_TCP_SOCK_OR_NULL;
00000004 00000011          bpf_reg_type PTR_TO_TP_BUFFER;
00000004 00000012          bpf_reg_type PTR_TO_XDP_SOCK;
00000004 00000001          $680DC75DD138978FA3CB363B51D0585B PTY_MAX;
00000004 00000002          $680DC75DD138978FA3CB363B51D0585B PTY_NR;
00000004 00000000          $038368816E7FF15918B7FC1B8961DCB5 QIF_BLIMITS_B;
00000004 00000004          $038368816E7FF15918B7FC1B8961DCB5 QIF_BTIME_B;
00000004 00000002          $038368816E7FF15918B7FC1B8961DCB5 QIF_ILIMITS_B;
00000004 00000003          $038368816E7FF15918B7FC1B8961DCB5 QIF_INODES_B;
00000004 00000005          $038368816E7FF15918B7FC1B8961DCB5 QIF_ITIME_B;
00000004 00000001          $038368816E7FF15918B7FC1B8961DCB5 QIF_SPACE_B;
00000004 00000006          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_CAUSED_ID;
00000004 00000004          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_DEV_MAJOR;
00000004 00000005          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_DEV_MINOR;
00000004 00000002          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_EXCESS_ID;
00000004 00000007          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_PAD;
00000004 00000001          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_QTYPE;
00000004 00000000          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_UNSPEC;
00000004 00000003          $D5C7B8FBA1EBE00DBA64C02267B194F4 QUOTA_NL_A_WARNING;
00000004 00000000          $85AB55CAC5A6CED4E63ABAA78F522968 QUOTA_NL_C_UNSPEC;
00000004 00000001          $85AB55CAC5A6CED4E63ABAA78F522968 QUOTA_NL_C_WARNING;
00000004 00000000          blk_queue_state Queue_down;
00000004 00000001          blk_queue_state Queue_up;
00000004 00000020          $F2B463A3EF31DCCBF93B3492CC8C662A RADIX_TREE_ITER_CONTIG;
00000004 00000010          $F2B463A3EF31DCCBF93B3492CC8C662A RADIX_TREE_ITER_TAGGED;
00000004 0000000F          $F2B463A3EF31DCCBF93B3492CC8C662A RADIX_TREE_ITER_TAG_MASK;
00000004 00000005          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_BOOT_ID;
00000004 00000002          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_ENTROPY_COUNT;
00000004 00000001          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_POOLSIZE;
00000004 00000003          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_READ_THRESH;
00000004 00000006          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_UUID;
00000004 00000004          $473A456D5B42351FDD7DD7C07E42ECDE RANDOM_WRITE_THRESH;
00000004 00000009          $DD2FCB3BD885EF085C64DD38A6B8659D RCU_SOFTIRQ;
00000004 00000001          kernel_read_file_id READING_FIRMWARE;
00000004 00000002          kernel_read_file_id READING_FIRMWARE_PREALLOC_BUFFER;
00000004 00000004          kernel_read_file_id READING_KEXEC_IMAGE;
00000004 00000005          kernel_read_file_id READING_KEXEC_INITRAMFS;
00000004 00000008          kernel_read_file_id READING_MAX_ID;
00000004 00000003          kernel_read_file_id READING_MODULE;
00000004 00000006          kernel_read_file_id READING_POLICY;
00000004 00000000          kernel_read_file_id READING_UNKNOWN;
00000004 00000007          kernel_read_file_id READING_X509_CERTIFICATE;
00000004 00400000          $76602C1D950947A0A79A611E6C37E6C0 READ_IMPLIES_EXEC;
00000004 00000000          reboot_mode REBOOT_COLD;
00000004 00000004          reboot_mode REBOOT_GPIO;
00000004 00000002          reboot_mode REBOOT_HARD;
00000004 00000003          reboot_mode REBOOT_SOFT;
00000004 FFFFFFFF          reboot_mode REBOOT_UNDEFINED;
00000004 00000001          reboot_mode REBOOT_WARM;
00000004 00000000          refcount_saturation_type REFCOUNT_ADD_NOT_ZERO_OVF;
00000004 00000001          refcount_saturation_type REFCOUNT_ADD_OVF;
00000004 00000002          refcount_saturation_type REFCOUNT_ADD_UAF;
00000004 00000004          refcount_saturation_type REFCOUNT_DEC_LEAK;
00000004 00000003          refcount_saturation_type REFCOUNT_SUB_UAF;
00000004 00000001          $CE0796B31961C3FB6E01C0482FE4D62D REGION_DISJOINT;
00000004 00000000          $CE0796B31961C3FB6E01C0482FE4D62D REGION_INTERSECTS;
00000004 00000002          $CE0796B31961C3FB6E01C0482FE4D62D REGION_MIXED;
00000004 00000003          req_opf REQ_OP_DISCARD;
00000004 00000022          req_opf REQ_OP_DRV_IN;
00000004 00000023          req_opf REQ_OP_DRV_OUT;
00000004 00000002          req_opf REQ_OP_FLUSH;
00000004 00000024          req_opf REQ_OP_LAST;
00000004 00000000          req_opf REQ_OP_READ;
00000004 00000020          req_opf REQ_OP_SCSI_IN;
00000004 00000021          req_opf REQ_OP_SCSI_OUT;
00000004 00000005          req_opf REQ_OP_SECURE_ERASE;
00000004 00000001          req_opf REQ_OP_WRITE;
00000004 00000007          req_opf REQ_OP_WRITE_SAME;
00000004 00000009          req_opf REQ_OP_WRITE_ZEROES;
00000004 00000006          req_opf REQ_OP_ZONE_RESET;
00000004 00000008          req_opf REQ_OP_ZONE_RESET_ALL;
00000004 00000000          bpf_return_type RET_INTEGER;
00000004 00000002          bpf_return_type RET_PTR_TO_MAP_VALUE;
00000004 00000003          bpf_return_type RET_PTR_TO_MAP_VALUE_OR_NULL;
00000004 00000004          bpf_return_type RET_PTR_TO_SOCKET_OR_NULL;
00000004 00000006          bpf_return_type RET_PTR_TO_SOCK_COMMON_OR_NULL;
00000004 00000005          bpf_return_type RET_PTR_TO_TCP_SOCK_OR_NULL;
00000004 00000001          bpf_return_type RET_VOID;
00000004 00000000          rpm_status RPM_ACTIVE;
00000004 00000003          rpm_request RPM_REQ_AUTOSUSPEND;
00000004 00000001          rpm_request RPM_REQ_IDLE;
00000004 00000000          rpm_request RPM_REQ_NONE;
00000004 00000004          rpm_request RPM_REQ_RESUME;
00000004 00000002          rpm_request RPM_REQ_SUSPEND;
00000004 00000001          rpm_status RPM_RESUMING;
00000004 00000002          rpm_status RPM_SUSPENDED;
00000004 00000003          rpm_status RPM_SUSPENDING;
00000004 00000000          rp_check RP_CHECK_CALL;
00000004 00000001          rp_check RP_CHECK_CHAIN_CALL;
00000004 00000002          rp_check RP_CHECK_RET;
00000004 FFFFFFFE          rseq_cpu_id_state RSEQ_CPU_ID_REGISTRATION_FAILED;
00000004 FFFFFFFF          rseq_cpu_id_state RSEQ_CPU_ID_UNINITIALIZED;
00000004 00000004          rseq_cs_flags RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE;
00000004 00000002          rseq_cs_flags_bit RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT;
00000004 00000001          rseq_cs_flags RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT;
00000004 00000000          rseq_cs_flags_bit RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT;
00000004 00000002          rseq_cs_flags RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL;
00000004 00000001          rseq_cs_flags_bit RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT;
00000004 00000004          rseq_event_mask RSEQ_EVENT_MIGRATE;
00000004 00000002          rseq_event_mask_bits RSEQ_EVENT_MIGRATE_BIT;
00000004 00000001          rseq_event_mask RSEQ_EVENT_PREEMPT;
00000004 00000000          rseq_event_mask_bits RSEQ_EVENT_PREEMPT_BIT;
00000004 00000002          rseq_event_mask RSEQ_EVENT_SIGNAL;
00000004 00000001          rseq_event_mask_bits RSEQ_EVENT_SIGNAL_BIT;
00000004 00000001          rseq_flags RSEQ_FLAG_UNREGISTER;
00000004 00000004          $45D62DEFE14D4A5E97434CC7550C7E75 SB_FREEZE_COMPLETE;
00000004 00000003          $45D62DEFE14D4A5E97434CC7550C7E75 SB_FREEZE_FS;
00000004 00000002          $45D62DEFE14D4A5E97434CC7550C7E75 SB_FREEZE_PAGEFAULT;
00000004 00000001          $45D62DEFE14D4A5E97434CC7550C7E75 SB_FREEZE_WRITE;
00000004 00000000          $45D62DEFE14D4A5E97434CC7550C7E75 SB_UNFROZEN;
00000004 00000001          bpf_reg_type SCALAR_VALUE;
00000004 00000007          $DD2FCB3BD885EF085C64DD38A6B8659D SCHED_SOFTIRQ;
00000004 0000000C          $8EE75ACFE4C7E25E8006D062E16DEF3C SECTION_INFO;
00000004 01000000          $76602C1D950947A0A79A611E6C37E6C0 SHORT_INODE;
00000004 00000000          sk_action SK_DROP;
00000004 00000001          sk_action SK_PASS;
00000004 0000001F          vm_event_item SLABS_SCANNED;
00000004 00000082          $8F79D9D84589DB364612B4CE8A4916F1 SOLARIS_X86_PARTITION;
00000004 00000003          spectre_v2_mitigation SPECTRE_V2_EIBRS;
00000004 00000005          spectre_v2_mitigation SPECTRE_V2_EIBRS_LFENCE;
00000004 00000004          spectre_v2_mitigation SPECTRE_V2_EIBRS_RETPOLINE;
00000004 00000006          spectre_v2_mitigation SPECTRE_V2_IBRS;
00000004 00000002          spectre_v2_mitigation SPECTRE_V2_LFENCE;
00000004 00000000          spectre_v2_mitigation SPECTRE_V2_NONE;
00000004 00000001          spectre_v2_mitigation SPECTRE_V2_RETPOLINE;
00000004 00000000          spectre_v2_user_mitigation SPECTRE_V2_USER_NONE;
00000004 00000003          spectre_v2_user_mitigation SPECTRE_V2_USER_PRCTL;
00000004 00000004          spectre_v2_user_mitigation SPECTRE_V2_USER_SECCOMP;
00000004 00000001          spectre_v2_user_mitigation SPECTRE_V2_USER_STRICT;
00000004 00000002          spectre_v2_user_mitigation SPECTRE_V2_USER_STRICT_PREFERRED;
00000004 00000001          ssb_mitigation SPEC_STORE_BYPASS_DISABLE;
00000004 00000000          ssb_mitigation SPEC_STORE_BYPASS_NONE;
00000004 00000002          ssb_mitigation SPEC_STORE_BYPASS_PRCTL;
00000004 00000003          ssb_mitigation SPEC_STORE_BYPASS_SECCOMP;
00000004 00000002          stat_group STAT_DISCARD;
00000004 00000000          stat_group STAT_READ;
00000004 00000001          stat_group STAT_WRITE;
00000004 04000000          $76602C1D950947A0A79A611E6C37E6C0 STICKY_TIMEOUTS;
00000004 00000005          $8F79D9D84589DB364612B4CE8A4916F1 SUN_WHOLE_DISK;
00000004 00000053          vm_event_item SWAP_RA;
00000004 00000054          vm_event_item SWAP_RA_HIT;
00000004 00000000          system_states SYSTEM_BOOTING;
00000004 00000003          system_states SYSTEM_HALT;
00000004 00000004          system_states SYSTEM_POWER_OFF;
00000004 00000005          system_states SYSTEM_RESTART;
00000004 00000002          system_states SYSTEM_RUNNING;
00000004 00000001          system_states SYSTEM_SCHEDULING;
00000004 00000006          system_states SYSTEM_SUSPEND;
00000004 00000001          file_time_flags S_ATIME;
00000004 00000004          file_time_flags S_CTIME;
00000004 00000002          file_time_flags S_MTIME;
00000004 00000008          file_time_flags S_VERSION;
00000004 00000000          taa_mitigations TAA_MITIGATION_OFF;
00000004 00000003          taa_mitigations TAA_MITIGATION_TSX_DISABLED;
00000004 00000001          taa_mitigations TAA_MITIGATION_UCODE_NEEDED;
00000004 00000002          taa_mitigations TAA_MITIGATION_VERW;
00000004 00000006          $DD2FCB3BD885EF085C64DD38A6B8659D TASKLET_SOFTIRQ;
00000004 00000001          $D747ABAD008AE6BC12062CA0C168DA56 TASKLET_STATE_RUN;
00000004 00000000          $D747ABAD008AE6BC12062CA0C168DA56 TASKLET_STATE_SCHED;
00000004 00000043          vm_event_item THP_COLLAPSE_ALLOC;
00000004 00000044          vm_event_item THP_COLLAPSE_ALLOC_FAILED;
00000004 00000049          vm_event_item THP_DEFERRED_SPLIT_PAGE;
00000004 00000041          vm_event_item THP_FAULT_ALLOC;
00000004 00000042          vm_event_item THP_FAULT_FALLBACK;
00000004 00000045          vm_event_item THP_FILE_ALLOC;
00000004 00000046          vm_event_item THP_FILE_MAPPED;
00000004 00000047          vm_event_item THP_SPLIT_PAGE;
00000004 00000048          vm_event_item THP_SPLIT_PAGE_FAILED;
00000004 0000004A          vm_event_item THP_SPLIT_PMD;
00000004 0000004B          vm_event_item THP_SPLIT_PUD;
00000004 0000004E          vm_event_item THP_SWPOUT;
00000004 0000004F          vm_event_item THP_SWPOUT_FALLBACK;
00000004 0000004C          vm_event_item THP_ZERO_PAGE_ALLOC;
00000004 0000004D          vm_event_item THP_ZERO_PAGE_ALLOC_FAILED;
00000004 00000001          $DD2FCB3BD885EF085C64DD38A6B8659D TIMER_SOFTIRQ;
00000004 00000001          tk_offsets TK_OFFS_BOOT;
00000004 00000003          tk_offsets TK_OFFS_MAX;
00000004 00000000          tk_offsets TK_OFFS_REAL;
00000004 00000002          tk_offsets TK_OFFS_TAI;
00000004 00000000          tlb_flush_reason TLB_FLUSH_ON_TASK_SWITCH;
00000004 00000003          tlb_flush_reason TLB_LOCAL_MM_SHOOTDOWN;
00000004 00000002          tlb_flush_reason TLB_LOCAL_SHOOTDOWN;
00000004 00000004          tlb_flush_reason TLB_REMOTE_SEND_IPI;
00000004 00000001          tlb_flush_reason TLB_REMOTE_SHOOTDOWN;
00000004 00000003          compound_dtor_id TRANSHUGE_PAGE_DTOR;
00000004 00000002          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG;
00000004 00000006          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG;
00000004 00000003          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG;
00000004 00000004          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG;
00000004 00000005          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG;
00000004 00000000          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_FLAG;
00000004 00000001          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG;
00000004 00000007          transparent_hugepage_flag TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG;
00000004 00000002          timespec_type TT_COMPAT;
00000004 00000001          timespec_type TT_NATIVE;
00000004 00000000          timespec_type TT_NONE;
00000004 00000002          uclamp_id UCLAMP_CNT;
00000004 00000001          uclamp_id UCLAMP_MAX;
00000004 00000000          uclamp_id UCLAMP_MIN;
00000004 00000002          umh_disable_depth UMH_DISABLED;
00000004 00000000          umh_disable_depth UMH_ENABLED;
00000004 00000001          umh_disable_depth UMH_FREEZING;
00000004 00020000          $76602C1D950947A0A79A611E6C37E6C0 UNAME26;
00000004 0000003F          vm_event_item UNEVICTABLE_PGCLEARED;
00000004 0000003A          vm_event_item UNEVICTABLE_PGCULLED;
00000004 0000003D          vm_event_item UNEVICTABLE_PGMLOCKED;
00000004 0000003E          vm_event_item UNEVICTABLE_PGMUNLOCKED;
00000004 0000003C          vm_event_item UNEVICTABLE_PGRESCUED;
00000004 0000003B          vm_event_item UNEVICTABLE_PGSCANNED;
00000004 00000040          vm_event_item UNEVICTABLE_PGSTRANDED;
00000004 00000063          $8F79D9D84589DB364612B4CE8A4916F1 UNIXWARE_PARTITION;
00000004 00000002          uprobe_filter_ctx UPROBE_FILTER_MMAP;
00000004 00000000          uprobe_filter_ctx UPROBE_FILTER_REGISTER;
00000004 00000001          uprobe_filter_ctx UPROBE_FILTER_UNREGISTER;
00000004 00000000          usb3_link_state USB3_LPM_U0;
00000004 00000001          usb3_link_state USB3_LPM_U1;
00000004 00000002          usb3_link_state USB3_LPM_U2;
00000004 00000003          usb3_link_state USB3_LPM_U3;
00000004 00000002          usb_device_removable USB_DEVICE_FIXED;
00000004 00000001          usb_device_removable USB_DEVICE_REMOVABLE;
00000004 00000000          usb_device_removable USB_DEVICE_REMOVABLE_UNKNOWN;
00000004 00000001          usb_interface_condition USB_INTERFACE_BINDING;
00000004 00000002          usb_interface_condition USB_INTERFACE_BOUND;
00000004 00000003          usb_interface_condition USB_INTERFACE_UNBINDING;
00000004 00000000          usb_interface_condition USB_INTERFACE_UNBOUND;
00000004 00000001          usb_led_event USB_LED_EVENT_GADGET;
00000004 00000000          usb_led_event USB_LED_EVENT_HOST;
00000004 00000002          usb_port_connect_type USB_PORT_CONNECT_TYPE_HARD_WIRED;
00000004 00000001          usb_port_connect_type USB_PORT_CONNECT_TYPE_HOT_PLUG;
00000004 00000000          usb_port_connect_type USB_PORT_CONNECT_TYPE_UNKNOWN;
00000004 00000003          usb_port_connect_type USB_PORT_NOT_USED;
00000004 00000002          usb_device_speed USB_SPEED_FULL;
00000004 00000003          usb_device_speed USB_SPEED_HIGH;
00000004 00000001          usb_device_speed USB_SPEED_LOW;
00000004 00000005          usb_device_speed USB_SPEED_SUPER;
00000004 00000006          usb_device_speed USB_SPEED_SUPER_PLUS;
00000004 00000000          usb_device_speed USB_SPEED_UNKNOWN;
00000004 00000004          usb_device_speed USB_SPEED_WIRELESS;
00000004 00000006          usb_device_state USB_STATE_ADDRESS;
00000004 00000001          usb_device_state USB_STATE_ATTACHED;
00000004 00000007          usb_device_state USB_STATE_CONFIGURED;
00000004 00000005          usb_device_state USB_STATE_DEFAULT;
00000004 00000000          usb_device_state USB_STATE_NOTATTACHED;
00000004 00000002          usb_device_state USB_STATE_POWERED;
00000004 00000003          usb_device_state USB_STATE_RECONNECTING;
00000004 00000008          usb_device_state USB_STATE_SUSPENDED;
00000004 00000004          usb_device_state USB_STATE_UNAUTHENTICATED;
00000004 00000000          quota_type USRQUOTA;
00000004 00000000          uprobe_task_state UTASK_RUNNING;
00000004 00000001          uprobe_task_state UTASK_SSTEP;
00000004 00000002          uprobe_task_state UTASK_SSTEP_ACK;
00000004 00000003          uprobe_task_state UTASK_SSTEP_TRAPPED;
00000004 00000018          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_BLOCK_DUMP;
00000004 0000000B          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_DIRTY_BACKGROUND;
00000004 0000000E          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_DIRTY_EXPIRE_CS;
00000004 0000000C          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_DIRTY_RATIO;
00000004 0000000D          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_DIRTY_WB_CS;
00000004 0000001D          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_DROP_PAGECACHE;
00000004 00001000          vm_fault_reason VM_FAULT_DONE_COW;
00000004 00000800          vm_fault_reason VM_FAULT_FALLBACK;
00000004 000F0000          vm_fault_reason VM_FAULT_HINDEX_MASK;
00000004 00000010          vm_fault_reason VM_FAULT_HWPOISON;
00000004 00000020          vm_fault_reason VM_FAULT_HWPOISON_LARGE;
00000004 00000200          vm_fault_reason VM_FAULT_LOCKED;
00000004 00000004          vm_fault_reason VM_FAULT_MAJOR;
00000004 00002000          vm_fault_reason VM_FAULT_NEEDDSYNC;
00000004 00000100          vm_fault_reason VM_FAULT_NOPAGE;
00000004 00000001          vm_fault_reason VM_FAULT_OOM;
00000004 00000400          vm_fault_reason VM_FAULT_RETRY;
00000004 00000002          vm_fault_reason VM_FAULT_SIGBUS;
00000004 00000040          vm_fault_reason VM_FAULT_SIGSEGV;
00000004 00000008          vm_fault_reason VM_FAULT_WRITE;
00000004 00000019          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_HUGETLB_GROUP;
00000004 00000012          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_HUGETLB_PAGES;
00000004 00000017          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_LAPTOP_MODE;
00000004 0000001B          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_LEGACY_VA_LAYOUT;
00000004 00000014          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_LOWMEM_RESERVE_RATIO;
00000004 00000016          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_MAX_MAP_COUNT;
00000004 00000015          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_MIN_FREE_KBYTES;
00000004 00000023          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_MIN_SLAB;
00000004 00000020          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_MIN_UNMAPPED;
00000004 0000000F          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_NR_PDFLUSH_THREADS;
00000004 00000005          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_OVERCOMMIT_MEMORY;
00000004 00000010          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_OVERCOMMIT_RATIO;
00000004 00000011          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_PAGEBUF;
00000004 0000000A          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_PAGE_CLUSTER;
00000004 00000021          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_PANIC_ON_OOM;
00000004 0000001E          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_PERCPU_PAGELIST_FRACTION;
00000004 00000013          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_SWAPPINESS;
00000004 0000001C          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_SWAP_TOKEN_TIMEOUT;
00000004 00000001          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED1;
00000004 00000002          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED2;
00000004 00000003          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED3;
00000004 00000004          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED4;
00000004 00000006          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED5;
00000004 00000007          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED7;
00000004 00000008          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED8;
00000004 00000009          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_UNUSED9;
00000004 00000022          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_VDSO_ENABLED;
00000004 0000001A          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_VFS_CACHE_PRESSURE;
00000004 0000001F          $49CB0BD6DF0B9506CA50BC4081F89D9F VM_ZONE_RECLAIM_MODE;
00000004 000001FF          fixed_addresses VSYSCALL_PAGE;
00000004 00000000          vtime_state VTIME_INACTIVE;
00000004 00000002          vtime_state VTIME_SYS;
00000004 00000001          vtime_state VTIME_USER;
00000004 00000002          wb_stat_item WB_DIRTIED;
00000004 00000000          wb_reason WB_REASON_BACKGROUND;
00000004 00000008          wb_reason WB_REASON_FOREIGN_FLUSH;
00000004 00000007          wb_reason WB_REASON_FORKER_THREAD;
00000004 00000005          wb_reason WB_REASON_FREE_MORE_MEM;
00000004 00000006          wb_reason WB_REASON_FS_FREE_SPACE;
00000004 00000004          wb_reason WB_REASON_LAPTOP_TIMER;
00000004 00000009          wb_reason WB_REASON_MAX;
00000004 00000003          wb_reason WB_REASON_PERIODIC;
00000004 00000002          wb_reason WB_REASON_SYNC;
00000004 00000001          wb_reason WB_REASON_VMSCAN;
00000004 00000000          wb_stat_item WB_RECLAIMABLE;
00000004 00000001          wb_stat_item WB_WRITEBACK;
00000004 00000003          wb_stat_item WB_WRITTEN;
00000004 00000000          wb_congested_state WB_async_congested;
00000004 00000002          wb_state WB_has_dirty_io;
00000004 00000000          wb_state WB_registered;
00000004 00000003          wb_state WB_start_all;
00000004 00000001          wb_congested_state WB_sync_congested;
00000004 00000001          wb_state WB_writeback_running;
00000004 02000000          $76602C1D950947A0A79A611E6C37E6C0 WHOLE_SECONDS;
00000004 00000002          symsearch::$918E90F7BDB99030C053413DA08D0BB9 WILL_BE_GPL_ONLY;
00000004 0000000F          $8F79D9D84589DB364612B4CE8A4916F1 WIN98_EXTENDED_PARTITION;
00000004 00000002          zone_watermarks WMARK_HIGH;
00000004 00000001          zone_watermarks WMARK_LOW;
00000004 00000000          zone_watermarks WMARK_MIN;
00000008 0000000000000018          $BADEFA5A81D7C4BA7479B07AE508D21D WORKER_DESC_LEN;
00000004 0000000B          node_stat_item WORKINGSET_ACTIVATE;
00000004 0000000D          node_stat_item WORKINGSET_NODERECLAIM;
00000004 00000009          node_stat_item WORKINGSET_NODES;
00000004 0000000A          node_stat_item WORKINGSET_REFAULT;
00000004 0000000C          node_stat_item WORKINGSET_RESTORE;
00000008 0000000000000001          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_BUSY_PENDING;
00000008 0000000000000002          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_BUSY_RUNNING;
00000008 0000000000002000          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_CPU_UNBOUND;
00000008 000000000000000F          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_NO_COLOR;
00000008 000000000000000F          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_NR_COLORS;
00000008 0000000000000010          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_CANCELING;
00000008 0000000000000004          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_FLAG_BASE;
00000008 0000000000000001          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_FLAG_BITS;
00000008 000000000000003B          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_LEFT;
00000008 000000000000001F          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_POOL_BITS;
00000008 000000007FFFFFFF          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_POOL_NONE;
00000008 0000000000000005          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_OFFQ_POOL_SHIFT;
00000008 0000000000000004          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_COLOR_BITS;
00000008 0000000000000004          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_COLOR_SHIFT;
00000008 0000000000000002          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_DELAYED;
00000008 0000000000000001          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_DELAYED_BIT;
00000008 0000000000000008          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_FLAG_BITS;
00000008 00000000000000FF          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_FLAG_MASK;
00000008 0000000000000008          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_LINKED;
00000008 0000000000000003          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_LINKED_BIT;
00000008 0000000FFFFFFFE0          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_NO_POOL;
00000008 0000000000000001          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_PENDING;
00000008 0000000000000000          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_PENDING_BIT;
00000008 0000000000000004          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_PWQ;
00000008 0000000000000002          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_PWQ_BIT;
00000008 0000000000000000          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_STATIC;
00000008 FFFFFFFFFFFFFF00          $BADEFA5A81D7C4BA7479B07AE508D21D WORK_STRUCT_WQ_DATA_MASK;
00000004 00000020          $4D591E22FE8A11A6C092068C1DE474D5 WQ_CPU_INTENSIVE;
00000004 00000100          $4D591E22FE8A11A6C092068C1DE474D5 WQ_DFL_ACTIVE;
00000004 00000004          $4D591E22FE8A11A6C092068C1DE474D5 WQ_FREEZABLE;
00000004 00000010          $4D591E22FE8A11A6C092068C1DE474D5 WQ_HIGHPRI;
00000004 00000200          $4D591E22FE8A11A6C092068C1DE474D5 WQ_MAX_ACTIVE;
00000004 00000004          $4D591E22FE8A11A6C092068C1DE474D5 WQ_MAX_UNBOUND_PER_CPU;
00000004 00000008          $4D591E22FE8A11A6C092068C1DE474D5 WQ_MEM_RECLAIM;
00000004 00000080          $4D591E22FE8A11A6C092068C1DE474D5 WQ_POWER_EFFICIENT;
00000004 00000040          $4D591E22FE8A11A6C092068C1DE474D5 WQ_SYSFS;
00000004 00000002          $4D591E22FE8A11A6C092068C1DE474D5 WQ_UNBOUND;
00000004 00000005          rw_hint WRITE_LIFE_EXTREME;
00000004 00000004          rw_hint WRITE_LIFE_LONG;
00000004 00000003          rw_hint WRITE_LIFE_MEDIUM;
00000004 00000001          rw_hint WRITE_LIFE_NONE;
00000004 00000000          rw_hint WRITE_LIFE_NOT_SET;
00000004 00000002          rw_hint WRITE_LIFE_SHORT;
00000004 00000002          x86_legacy_i8042_state X86_LEGACY_I8042_EXPECTED_PRESENT;
00000004 00000001          x86_legacy_i8042_state X86_LEGACY_I8042_FIRMWARE_ABSENT;
00000004 00000000          x86_legacy_i8042_state X86_LEGACY_I8042_PLATFORM_ABSENT;
00000004 00000005          x86_hardware_subarch X86_NR_SUBARCHS;
00000004 00000004          x86_hardware_subarch X86_SUBARCH_CE4100;
00000004 00000003          x86_hardware_subarch X86_SUBARCH_INTEL_MID;
00000004 00000001          x86_hardware_subarch X86_SUBARCH_LGUEST;
00000004 00000000          x86_hardware_subarch X86_SUBARCH_PC;
00000004 00000002          x86_hardware_subarch X86_SUBARCH_XEN;
00000004 00001000          $8ABAFD08B9948368318FB033F2287D90 XA_CHECK_SCHED;
00000004 00000002          xa_lock_type XA_LOCK_BH;
00000004 00000001          xa_lock_type XA_LOCK_IRQ;
00000004 00000000          xdp_action XDP_ABORTED;
00000004 00000001          xdp_action XDP_DROP;
00000004 00000002          xdp_action XDP_PASS;
00000004 00000004          xdp_action XDP_REDIRECT;
00000004 00000003          xdp_action XDP_TX;
00000004 00000004          xfeature XFEATURE_BNDCSR;
00000004 00000003          xfeature XFEATURE_BNDREGS;
00000004 00000000          xfeature XFEATURE_FP;
00000004 00000007          xfeature XFEATURE_Hi16_ZMM;
00000004 0000000A          xfeature XFEATURE_MAX;
00000004 00000005          xfeature XFEATURE_OPMASK;
00000004 00000009          xfeature XFEATURE_PKRU;
00000004 00000008          xfeature XFEATURE_PT_UNIMPLEMENTED_SO_FAR;
00000004 00000001          xfeature XFEATURE_SSE;
00000004 00000002          xfeature XFEATURE_YMM;
00000004 00000006          xfeature XFEATURE_ZMM_Hi256;
00000004 00000002          xhlock_context_t XHLOCK_CTX_NR;
00000004 00000000          xhlock_context_t XHLOCK_HARD;
00000004 00000001          xhlock_context_t XHLOCK_SOFT;
00000004 00000000          $2E9D172CAA035E0370957B5AF4415823 ZONELIST_FALLBACK;
00000004 00000001          $2E9D172CAA035E0370957B5AF4415823 ZONELIST_NOFALLBACK;
00000004 00000000          zone_flags ZONE_BOOSTED_WATERMARK;
00000004 00000004          zone_type ZONE_DEVICE;
00000004 00000000          zone_type ZONE_DMA;
00000004 00000001          zone_type ZONE_DMA32;
00000004 00000003          zone_type ZONE_MOVABLE;
00000004 00000002          zone_type ZONE_NORMAL;
00000004 00000000          int C_A_D;
00000004 00000008          $C8133BF94EE3AFC5F16AA8508ABCA0FF _DQST_DQSTAT_LAST;
00000004 00000001          $EE5B2A57A5EB045B93276320FF073840 _DQUOT_LIMITS_ENABLED;
00000004 00000003          $EE5B2A57A5EB045B93276320FF073840 _DQUOT_STATE_FLAGS;
00000004 00000002          $EE5B2A57A5EB045B93276320FF073840 _DQUOT_SUSPENDED;
00000004 00000000          $EE5B2A57A5EB045B93276320FF073840 DQUOT_USAGE_ENABLED;
FFFFFFFF 00000000          int __cdecl IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin);
FFFFFFFF 00000000          block_device *__cdecl I_BDEV(inode *inode);
FFFFFFFF 00000000          unsigned __int64 __cdecl KSTK_ESP(task_struct *task);
00000004 00000008          page_cache_mode _PAGE_CACHE_MODE_NUM;
00000004 00000003          page_cache_mode _PAGE_CACHE_MODE_UC;
00000004 00000002          page_cache_mode _PAGE_CACHE_MODE_UC_MINUS;
00000004 00000000          page_cache_mode PAGE_CACHE_MODE_WB;
00000004 00000001          page_cache_mode _PAGE_CACHE_MODE_WC;
00000004 00000005          page_cache_mode _PAGE_CACHE_MODE_WP;
00000004 00000004          page_cache_mode _PAGE_CACHE_MODE_WT;
FFFFFFFF 00000000          void *__cdecl PDE_DATA(const inode *);
FFFFFFFF 00000000          int __cdecl PageHeadHuge(page *page);
FFFFFFFF 00000000          int __cdecl PageHuge(page *page);
00000004 00000002          bpf_cgroup_storage_type __BPF_CGROUP_STORAGE_MAX;
00000004 0000006F          bpf_func_id __BPF_FUNC_MAX_ID;
00000000 00000000          Elf64_Dyn _DYNAMIC[];
00000004 00000017          bpf_attach_type __MAX_BPF_ATTACH_TYPE;
00000004 0000000B          $33C2810983D6D097EBD64454FBBEAA1D __MAX_BPF_REG;
00000004 00000005          zone_type __MAX_NR_ZONES;
00000004 0000001C          $187884F4088CD9BBE07DDAE7E9FCE777 __NET_IPV6_MAX;
00000004 0000001A          pageflags __NR_PAGEFLAGS;
00000004 00000002          vsyscall_num __NR_vgetcpu;
00000004 00000000          vsyscall_num _NR_vgettimeofday;
00000004 00000001          vsyscall_num __NR_vtime;
00000004 00000001          $05DFF05EFD664B2206B6A34A0C6E8EB7 __PERCPU_REF_ATOMIC;
00000004 00000003          $05DFF05EFD664B2206B6A34A0C6E8EB7 __PERCPU_REF_ATOMIC_DEAD;
00000004 00000002          $05DFF05EFD664B2206B6A34A0C6E8EB7 __PERCPU_REF_DEAD;
00000004 00000002          $05DFF05EFD664B2206B6A34A0C6E8EB7 __PERCPU_REF_FLAG_BITS;
00000004 00000008          $D5C7B8FBA1EBE00DBA64C02267B194F4 __QUOTA_NL_A_MAX;
00000004 00000002          $85AB55CAC5A6CED4E63ABAA78F522968 __QUOTA_NL_C_MAX;
00000004 00000014          req_flag_bits __REQ_BACKGROUND;
00000004 00000017          req_flag_bits __REQ_CGROUP_PUNT;
00000004 0000001A          req_flag_bits __REQ_DRV;
00000004 00000008          req_flag_bits __REQ_FAILFAST_DEV;
00000004 0000000A          req_flag_bits __REQ_FAILFAST_DRIVER;
00000004 00000009          req_flag_bits __REQ_FAILFAST_TRANSPORT;
00000004 00000011          req_flag_bits __REQ_FUA;
00000004 00000019          req_flag_bits __REQ_HIPRI;
00000004 0000000F          req_flag_bits __REQ_IDLE;
00000004 00000010          req_flag_bits __REQ_INTEGRITY;
00000004 0000000C          req_flag_bits __REQ_META;
00000004 0000000E          req_flag_bits __REQ_NOMERGE;
00000004 00000018          req_flag_bits __REQ_NOUNMAP;
00000004 00000015          req_flag_bits __REQ_NOWAIT;
00000004 00000016          req_flag_bits __REQ_NOWAIT_INLINE;
00000004 0000001C          req_flag_bits __REQ_NR_BITS;
00000004 00000012          req_flag_bits __REQ_PREFLUSH;
00000004 0000000D          req_flag_bits __REQ_PRIO;
00000004 00000013          req_flag_bits __REQ_RAHEAD;
00000004 0000001B          req_flag_bits __REQ_SWAP;
00000004 0000000B          req_flag_bits __REQ_SYNC;
00000008 0000000000000004          $BADEFA5A81D7C4BA7479B07AE508D21D __WORK_OFFQ_CANCELING;
00000004 00010000          $4D591E22FE8A11A6C092068C1DE474D5 __WQ_DRAINING;
00000004 00040000          $4D591E22FE8A11A6C092068C1DE474D5 __WQ_LEGACY;
00000004 00020000          $4D591E22FE8A11A6C092068C1DE474D5 __WQ_ORDERED;
00000004 00080000          $4D591E22FE8A11A6C092068C1DE474D5 __WQ_ORDERED_EXPLICIT;
FFFFFFFF 00000000          bool ____wrong_branch_error(void);
FFFFFFFF 00000000          int __cdecl ___ratelimit(ratelimit_state *rs, const char *func);
FFFFFFFF 00000000          unsigned __int64 __cdecl __absent_pages_in_range(int nid, unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          int __cdecl __access_remote_vm(task_struct *tsk, mm_struct *mm, unsigned __int64 addr, void *buf, int len, unsigned int gup_flags);
FFFFFFFF 00000000          int __cdecl __account_locked_vm(mm_struct *mm, unsigned __int64 pages, bool inc, task_struct *task, bool bypass_rlim);
FFFFFFFF 00000000          int __cdecl __acpi_acquire_global_lock(unsigned int *lock);
FFFFFFFF 00000000          void __acpi_handle_debug(_ddebug *descriptor, acpi_handle handle, const char *fmt, ...);
FFFFFFFF 00000000          void *__cdecl __acpi_map_table(unsigned __int64 phys, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl __acpi_node_get_property_reference(const fwnode_handle *fwnode, const char *name, size_t index, size_t num_args, fwnode_reference_args *args);
FFFFFFFF 00000000          int __cdecl __acpi_probe_device_table(acpi_probe_entry *start, int nr);
00000008 0000000000000000          int (__cdecl *__acpi_register_gsi)(device *, u32, int, int);
FFFFFFFF 00000000          int __cdecl __acpi_release_global_lock(unsigned int *lock);
FFFFFFFF 00000000          void __cdecl __acpi_unmap_table(void *map, unsigned __int64 size);
00000008 0000000000000000          void (__cdecl *__acpi_unregister_gsi)(u32);
FFFFFFFF 00000000          int __cdecl __add_memory(int nid, u64 start, u64 size);
FFFFFFFF 00000000          int __cdecl __add_pages(int nid, unsigned __int64 start_pfn, unsigned __int64 nr_pages, mhp_restrictions *restrictions);
FFFFFFFF 00000000          void __add_wrong_size(void);
FFFFFFFF 00000000          int __cdecl __alloc_bucket_spinlocks(spinlock_t **locks, unsigned int *lock_mask, size_t max_size, unsigned int cpu_mult, gfp_t gfp, const char *name, lock_class_key *key);
FFFFFFFF 00000000          gendisk *__cdecl __alloc_disk_node(int minors, int node_id);
FFFFFFFF 00000000          page *__cdecl __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask);
FFFFFFFF 00000000          void *__cdecl __alloc_percpu(size_t size, size_t align);
FFFFFFFF 00000000          void *__cdecl __alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp);
FFFFFFFF 00000000          void *__cdecl __alloc_reserved_percpu(size_t size, size_t align);
00000000 00000000          apic *__apicdrivers[];
00000000 00000000          apic *__apicdrivers_end[];
00010000 00000000          s16 __apicid_to_node[32768];
FFFFFFFF 00000000          int __cdecl __atomic_notifier_call_chain(atomic_notifier_head *nh, unsigned __int64 val, void *v, int nr_to_call, int *nr_calls);
FFFFFFFF 00000000          void __bad_copy_from(void);
FFFFFFFF 00000000          void __bad_copy_to(void);
FFFFFFFF 00000000          void __bad_gid(void);
FFFFFFFF 00000000          void __bad_ndelay(void);
FFFFFFFF 00000000          void __bad_percpu_size(void);
FFFFFFFF 00000000          void __bad_size_call_parameter(void);
FFFFFFFF 00000000          void __bad_udelay(void);
FFFFFFFF 00000000          void __bad_uid(void);
FFFFFFFF 00000000          const char *__cdecl __bdevname(dev_t, char *buffer);
FFFFFFFF 00000000          void __cdecl __bio_add_page(bio *bio, page *page, unsigned int len, unsigned int off);
FFFFFFFF 00000000          void __cdecl __bio_clone_fast(bio *, bio *);
FFFFFFFF 00000000          bool __cdecl __bio_try_merge_page(bio *bio, page *page, unsigned int len, unsigned int off, bool *same_page);
FFFFFFFF 00000000          int __cdecl __bitmap_and(unsigned __int64 *dst, const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_andnot(unsigned __int64 *dst, const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl __bitmap_clear(unsigned __int64 *map, unsigned int start, int len);
FFFFFFFF 00000000          void __cdecl __bitmap_complement(unsigned __int64 *dst, const unsigned __int64 *src, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_empty(const unsigned __int64 *bitmap, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_equal(const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_full(const unsigned __int64 *bitmap, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_intersects(const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl __bitmap_or(unsigned __int64 *dst, const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          bool __cdecl __bitmap_or_equal(const unsigned __int64 *src1, const unsigned __int64 *src2, const unsigned __int64 *src3, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_parse(const char *buf, unsigned int buflen, int is_user, unsigned __int64 *dst, int nbits);
FFFFFFFF 00000000          void __cdecl __bitmap_set(unsigned __int64 *map, unsigned int start, int len);
FFFFFFFF 00000000          void __cdecl __bitmap_shift_left(unsigned __int64 *dst, const unsigned __int64 *src, unsigned int shift, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl __bitmap_shift_right(unsigned __int64 *dst, const unsigned __int64 *src, unsigned int shift, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_subset(const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl __bitmap_weight(const unsigned __int64 *bitmap, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl __bitmap_xor(unsigned __int64 *dst, const unsigned __int64 *bitmap1, const unsigned __int64 *bitmap2, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl __blk_complete_request(request *);
FFFFFFFF 00000000          void __cdecl __blk_req_zone_write_lock(request *rq);
FFFFFFFF 00000000          void __cdecl __blk_req_zone_write_unlock(request *rq);
FFFFFFFF 00000000          int __cdecl __blkdev_driver_ioctl(block_device *, fmode_t, unsigned int, unsigned __int64);
FFFFFFFF 00000000          int __cdecl __blkdev_issue_discard(block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, int flags, bio **biop);
FFFFFFFF 00000000          int __cdecl __blkdev_issue_zeroout(block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, bio **biop, unsigned int flags);
FFFFFFFF 00000000          int __cdecl __blkdev_reread_part(block_device *bdev);
FFFFFFFF 00000000          ssize_t __cdecl __blockdev_direct_IO(kiocb *iocb, inode *inode, block_device *bdev, iov_iter *iter, get_block_t get_block, dio_iodone_t end_io, dio_submit_t submit_io, int flags);
FFFFFFFF 00000000          int __cdecl __blocking_notifier_call_chain(blocking_notifier_head *nh, unsigned __int64 val, void *v, int nr_to_call, int *nr_calls);
00000004 00000000          int __boot_cpu_id;
FFFFFFFF 00000000          bpf_map *__cdecl __bpf_map_get(fd f);
FFFFFFFF 00000000          int __cdecl __bpf_prog_charge(user_struct *user, u32 pages);
FFFFFFFF 00000000          void __cdecl __bpf_prog_uncharge(user_struct *user, u32 pages);
FFFFFFFF 00000000          int __cdecl __break_lease(inode *inode, unsigned int flags, unsigned int type);
00000000 00000000          char __brk_base[];
00000000 00000000          char __brk_limit[];
00000000 00000000          char __bss_start[];
00000000 00000000          char __bss_stop[];
00000010 00000000          uint16_t __cachemode2pte_tbl[8];
FFFFFFFF 00000000          void __cdecl __cancel_dirty_page(page *page);
00000008 0000000000000000          const kernel_cap_t __cap_empty_set;
00000008 0000000000000000          const kernel_cap_t __cap_init_eff_set;
FFFFFFFF 00000000          void __cdecl __check_heap_object(const void *ptr, unsigned __int64 n, page *page, bool to_user);
FFFFFFFF 00000000          void __cdecl __check_object_size(const void *ptr, unsigned __int64 n, bool to_user);
FFFFFFFF 00000000          int __cdecl __check_sticky(inode *dir, inode *inode);
FFFFFFFF 00000000          class *__cdecl __class_create(module *owner, const char *name, lock_class_key *key);
FFFFFFFF 00000000          int __cdecl __class_register(class *class, lock_class_key *key);
FFFFFFFF 00000000          unsigned __int64 __cdecl __clear_user(void *mem, unsigned __int64 len);
FFFFFFFF 00000000          void __cmpxchg_wrong_size(void);
FFFFFFFF 00000000          int __cdecl __compat_only_sysfs_link_entry_to_kobj(kobject *kobj, kobject *target_kobj, const char *target_name);
00000000 00000000          initcall_entry_t __con_initcall_end[];
00000000 00000000          initcall_entry_t __con_initcall_start[];
FFFFFFFF 00000000          int __cdecl __cond_resched_lock(spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl __const_udelay(unsigned __int64 xloops);
FFFFFFFF 00000000          __int64 __cdecl __copy_user_flushcache(void *dst, const void *src, unsigned int size);
FFFFFFFF 00000000          __int64 __cdecl __copy_user_nocache(void *dst, const void *src, unsigned int size, int zerorest);
00000400 00000000          cpumask __cpu_active_mask;
FFFFFFFF 00000000          void __cdecl __cpu_map_flush(bpf_map *map);
FFFFFFFF 00000000          bpf_cpu_map_entry *__cdecl __cpu_map_lookup_elem(bpf_map *map, u32 key);
00000400 00000000          cpumask __cpu_online_mask;
00000400 00000000          cpumask __cpu_possible_mask;
00000400 00000000          cpumask __cpu_present_mask;
00000000 00000000          char __ctors_end[];
00000000 00000000          char __ctors_start[];
FFFFFFFF 00000000          void __cdecl __d_drop(dentry *dentry);
FFFFFFFF 00000000          dentry *__cdecl __d_lookup(const dentry *, const qstr *);
FFFFFFFF 00000000          void __cdecl __d_lookup_done(dentry *);
FFFFFFFF 00000000          dentry *__cdecl __d_lookup_rcu(const dentry *parent, const qstr *name, unsigned int *seq);
FFFFFFFF 00000000          char *__cdecl __d_path(const path *, const path *, char *, int);
FFFFFFFF 00000000          void __cdecl __dec_node_page_state(page *, node_stat_item);
FFFFFFFF 00000000          void __cdecl __dec_node_state(pglist_data *, node_stat_item);
FFFFFFFF 00000000          void __cdecl __dec_zone_page_state(page *, zone_stat_item);
FFFFFFFF 00000000          void __cdecl __dec_zone_state(zone *, zone_stat_item);
00000008 0000000000000000          pteval_t __default_kernel_pte_mask;
FFFFFFFF 00000000          void __cdecl __delay(unsigned __int64 loops);
FFFFFFFF 00000000          void __cdecl __delete_from_page_cache(page *page, void *shadow);
FFFFFFFF 00000000          void __cdecl __delete_partition(percpu_ref *);
FFFFFFFF 00000000          void __cdecl __destroy_inode(inode *);
FFFFFFFF 00000000          void __cdecl __dev_map_flush(bpf_map *map);
FFFFFFFF 00000000          bpf_dtab_netdev *__cdecl __dev_map_hash_lookup_elem(bpf_map *map, u32 key);
FFFFFFFF 00000000          bpf_dtab_netdev *__cdecl __dev_map_lookup_elem(bpf_map *map, u32 key);
FFFFFFFF 00000000          void *__cdecl __devm_alloc_percpu(device *dev, size_t size, size_t align);
FFFFFFFF 00000000          void *__cdecl __devm_memremap_pages(device *dev, resource *res);
FFFFFFFF 00000000          void __cdecl __devm_release_region(device *dev, resource *parent, resource_size_t start, resource_size_t n);
FFFFFFFF 00000000          resource *__cdecl __devm_request_region(device *dev, resource *parent, resource_size_t start, resource_size_t n, const char *name);
FFFFFFFF 00000000          hd_struct *__cdecl __disk_get_part(gendisk *disk, int partno);
FFFFFFFF 00000000          int __cdecl __do_munmap(mm_struct *, unsigned __int64, size_t, list_head *uf, bool downgrade);
FFFFFFFF 00000000          void __do_softirq(void);
FFFFFFFF 00000000          void __cdecl __dump_page(page *page, const char *reason);
FFFFFFFF 00000000          void __dynamic_dev_dbg(_ddebug *descriptor, const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void __dynamic_ibdev_dbg(_ddebug *descriptor, const ib_device *ibdev, const char *fmt, ...);
FFFFFFFF 00000000          void __dynamic_netdev_dbg(_ddebug *descriptor, const net_device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void __dynamic_pr_debug(_ddebug *descriptor, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl __early_make_pgtable(unsigned __int64 address, pmdval_t pmd);
FFFFFFFF 00000000          int __cdecl __early_pfn_to_nid(unsigned __int64 pfn, mminit_pfnnid_cache *state);
FFFFFFFF 00000000          void __cdecl __early_set_fixmap(fixed_addresses idx, phys_addr_t phys, pgprot_t flags);
FFFFFFFF 00000000          int __cdecl __efi_capsule_setup_info(capsule_info *cap_info);
FFFFFFFF 00000000          int __cdecl __efivar_entry_delete(efivar_entry *entry);
FFFFFFFF 00000000          int __cdecl __efivar_entry_get(efivar_entry *entry, u32 *attributes, unsigned __int64 *size, void *data);
FFFFFFFF 00000000          int __cdecl __efivar_entry_iter(int (__cdecl *func)(efivar_entry *, void *), list_head *head, void *data, efivar_entry **prev);
00000000 00000000          char __end_bss_decrypted[];
00000000 00000000          char __end_of_kernel_reserve[];
00000000 00000000          char __end_once[];
00000000 00000000          char __end_opd[];
00000000 00000000          char __end_ro_after_init[];
00000000 00000000          char __end_rodata[];
00000000 00000000          char __end_rodata_aligned[];
00000000 00000000          char __end_rodata_hpage_align[];
00000000 00000000          char __entry_text_end[];
00000000 00000000          char __entry_text_start[];
FFFFFFFF 00000000          void __cdecl __exit_umh(task_struct *tsk);
FFFFFFFF 00000000          void __cdecl __f_setown(file *filp, pid *, pid_type, int force);
FFFFFFFF 00000000          void __cdecl __f_unlock_pos(file *);
FFFFFFFF 00000000          unsigned __int64 __cdecl __fdget(unsigned int fd);
FFFFFFFF 00000000          unsigned __int64 __cdecl __fdget_pos(unsigned int fd);
FFFFFFFF 00000000          unsigned __int64 __cdecl __fdget_raw(unsigned int fd);
FFFFFFFF 00000000          int __cdecl __filemap_fdatawrite_range(address_space *mapping, loff_t start, loff_t end, int sync_mode);
FFFFFFFF 00000000          void __cdecl __filemap_set_wb_err(address_space *mapping, int err);
FFFFFFFF 00000000          void __cdecl __fprop_inc_percpu(fprop_global *p, fprop_local_percpu *pl);
FFFFFFFF 00000000          void __cdecl __fprop_inc_percpu_max(fprop_global *p, fprop_local_percpu *pl, int max_frac);
FFFFFFFF 00000000          void __cdecl __fprop_inc_single(fprop_global *p, fprop_local_single *pl);
FFFFFFFF 00000000          void __cdecl __fput_sync(file *);
FFFFFFFF 00000000          void __cdecl __free_pages(page *page, unsigned int order);
FFFFFFFF 00000000          int __cdecl __ftrace_vbprintk(unsigned __int64 ip, const char *fmt, va_list ap);
FFFFFFFF 00000000          int __cdecl __ftrace_vprintk(unsigned __int64 ip, const char *fmt, va_list ap);
FFFFFFFF 00000000          int __cdecl __generic_block_fiemap(inode *inode, fiemap_extent_info *fieinfo, loff_t start, loff_t len, get_block_t *get_block);
FFFFFFFF 00000000          int __cdecl __generic_file_fsync(file *, loff_t, loff_t, int);
FFFFFFFF 00000000          ssize_t __cdecl __generic_file_write_iter(kiocb *, iov_iter *);
FFFFFFFF 00000000          unsigned __int64 __cdecl __get_free_pages(gfp_t gfp_mask, unsigned int order);
FFFFFFFF 00000000          pte_t *__cdecl __get_locked_pte(mm_struct *mm, unsigned __int64 addr, spinlock_t **ptl);
FFFFFFFF 00000000          char *__cdecl __get_task_comm(char *to, size_t len, task_struct *tsk);
FFFFFFFF 00000000          int __get_user_1(void);
FFFFFFFF 00000000          int __get_user_2(void);
FFFFFFFF 00000000          int __get_user_4(void);
FFFFFFFF 00000000          int __get_user_8(void);
FFFFFFFF 00000000          int __get_user_bad(void);
FFFFFFFF 00000000          int __cdecl __get_user_pages_fast(unsigned __int64 start, int nr_pages, int write, page **pages);
FFFFFFFF 00000000          vm_struct *__cdecl __get_vm_area(unsigned __int64 size, unsigned __int64 flags, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          vm_struct *__cdecl __get_vm_area_caller(unsigned __int64 size, unsigned __int64 flags, unsigned __int64 start, unsigned __int64 end, const void *caller);
00000008 0000000000000000          unsigned __int64 __highest_present_section_nr;
FFFFFFFF 00000000          ktime_t __cdecl __hrtimer_get_remaining(const hrtimer *timer, bool adjust);
FFFFFFFF 00000000          void __cdecl __iget(inode *inode);
FFFFFFFF 00000000          void __cdecl __inc_node_page_state(page *, node_stat_item);
FFFFFFFF 00000000          void __cdecl __inc_node_state(pglist_data *, node_stat_item);
FFFFFFFF 00000000          void __cdecl __inc_numa_state(zone *zone, numa_stat_item item);
FFFFFFFF 00000000          void __cdecl __inc_zone_page_state(page *, zone_stat_item);
FFFFFFFF 00000000          void __cdecl __inc_zone_state(zone *, zone_stat_item);
00000000 00000000          char __indirect_thunk_end[];
00000000 00000000          char __indirect_thunk_start[];
00000000 00000000          char __init_begin[];
00000000 00000000          char __init_end[];
FFFFFFFF 00000000          void __cdecl __init_rwsem(rw_semaphore *sem, const char *name, lock_class_key *key);
FFFFFFFF 00000000          void __cdecl __init_waitqueue_head(wait_queue_head *wq_head, const char *name, lock_class_key *);
FFFFFFFF 00000000          void __cdecl __inode_add_bytes(inode *inode, loff_t bytes);
FFFFFFFF 00000000          void __cdecl __inode_sub_bytes(inode *inode, loff_t bytes);
FFFFFFFF 00000000          void __cdecl __inquire_remote_apic(int apicid);
FFFFFFFF 00000000          void __cdecl __insert_inode_hash(inode *, unsigned __int64 hashval);
00000004 00000000          unsigned int __invalid_size_argument_for_IOC;
FFFFFFFF 00000000          int __cdecl __invalidate_device(block_device *, bool);
FFFFFFFF 00000000          void __cdecl __ioread32_copy(void *to, const void *from, size_t count);
FFFFFFFF 00000000          void __cdecl __iowrite32_copy(void *to, const void *from, size_t count);
FFFFFFFF 00000000          void __cdecl __iowrite64_copy(void *to, const void *from, size_t count);
FFFFFFFF 00000000          irq_domain *__cdecl __irq_domain_add(fwnode_handle *fwnode, unsigned int size, irq_hw_number_t hwirq_max, int direct_max, const irq_domain_ops *ops, void *host_data);
FFFFFFFF 00000000          fwnode_handle *__cdecl __irq_domain_alloc_fwnode(unsigned int type, int id, const char *name, phys_addr_t *pa);
FFFFFFFF 00000000          int __cdecl __irq_domain_alloc_irqs(irq_domain *domain, int irq_base, unsigned int nr_irqs, int node, void *arg, bool realloc, const irq_affinity_desc *affinity);
FFFFFFFF 00000000          int __cdecl __irq_set_affinity(unsigned int irq, const cpumask *cpumask, bool force);
00000000 00000000          char __irqentry_text_end[];
00000000 00000000          char __irqentry_text_start[];
FFFFFFFF 00000000          bool __cdecl __is_kernel_percpu_address(unsigned __int64 addr, unsigned __int64 *can_addr);
FFFFFFFF 00000000          bool __cdecl __is_module_percpu_address(unsigned __int64 addr, unsigned __int64 *can_addr);
FFFFFFFF 00000000          void __cdecl __kernel_map_pages(page *page, int numpages, int enable);
FFFFFFFF 00000000          int __cdecl __kernel_text_address(unsigned __int64 addr);
FFFFFFFF 00000000          ssize_t __cdecl __kernel_write(file *, const void *, size_t, loff_t *);
FFFFFFFF 00000000          kernfs_node *__cdecl __kernfs_create_file(kernfs_node *parent, const char *name, umode_t mode, kuid_t uid, kgid_t gid, loff_t size, const kernfs_ops *ops, void *priv, const void *ns, lock_class_key *key);
FFFFFFFF 00000000          void *__cdecl __kmalloc(size_t size, gfp_t flags);
FFFFFFFF 00000000          void *__cdecl __kmalloc_node(size_t size, gfp_t flags, int node);
FFFFFFFF 00000000          void *__cdecl __kmalloc_node_track_caller(size_t, gfp_t, int, unsigned __int64);
FFFFFFFF 00000000          void *__cdecl __kmalloc_track_caller(size_t, gfp_t, unsigned __int64);
00000000 00000000          char __kprobes_text_end[];
00000000 00000000          char __kprobes_text_start[];
FFFFFFFF 00000000          void *__cdecl __krealloc(const void *, size_t, gfp_t);
FFFFFFFF 00000000          size_t __cdecl __ksize(const void *);
FFFFFFFF 00000000          time64_t __ktime_get_real_seconds(void);
FFFFFFFF 00000000          int __cdecl __list_lru_init(list_lru *lru, bool memcg_aware, lock_class_key *key, shrinker *shrinker);
FFFFFFFF 00000000          void __cdecl __local_bh_enable_ip(unsigned __int64 ip, unsigned int cnt);
FFFFFFFF 00000000          void __cdecl __lock_page(page *page);
FFFFFFFF 00000000          int __cdecl __lock_page_killable(page *page);
FFFFFFFF 00000000          int __cdecl __lock_page_or_retry(page *page, mm_struct *mm, unsigned int flags);
FFFFFFFF 00000000          void __cdecl __mark_inode_dirty(inode *, int);
00000004 00000000          unsigned int __max_die_per_package;
00000004 00000000          unsigned int __max_logical_packages;
00000004 00000000          int __max_smt_threads;
FFFFFFFF 00000000          void **__cdecl __memcat_p(void **a, void **b);
FFFFFFFF 00000000          void *__cdecl __memcpy(void *to, const void *from, size_t len);
FFFFFFFF 00000000          void __cdecl __memcpy_flushcache(void *dst, const void *src, size_t cnt);
FFFFFFFF 00000000          unsigned __int64 __cdecl __memcpy_mcsafe(void *dst, const void *src, size_t cnt);
FFFFFFFF 00000000          void *__cdecl __memmove(void *dest, const void *src, size_t count);
FFFFFFFF 00000000          void *__cdecl __memset(void *s, int c, size_t n);
FFFFFFFF 00000000          int __cdecl __mm_populate(unsigned __int64 addr, unsigned __int64 len, int ignore_errors);
FFFFFFFF 00000000          void __cdecl __mod_node_page_state(pglist_data *, node_stat_item item, __int64);
FFFFFFFF 00000000          void __cdecl __mod_zone_page_state(zone *, zone_stat_item item, __int64);
FFFFFFFF 00000000          module *__cdecl __module_address(unsigned __int64 addr);
FFFFFFFF 00000000          void __cdecl __module_get(module *module);
FFFFFFFF 00000000          void __cdecl __noreturn __module_put_and_exit(module *mod, __int64 code);
FFFFFFFF 00000000          module *__cdecl __module_text_address(unsigned __int64 addr);
FFFFFFFF 00000000          ssize_t __cdecl __modver_version_show(module_attribute *, module_kobject *, char *);
FFFFFFFF 00000000          unsigned __int64 __cdecl __msecs_to_jiffies(const unsigned int m);
FFFFFFFF 00000000          void __cdecl __mutex_init(mutex *lock, const char *name, lock_class_key *key);
FFFFFFFF 00000000          void __cdecl __native_queued_spin_unlock(qspinlock *lock);
FFFFFFFF 00000000          void __cdecl __native_set_fixmap(fixed_addresses idx, pte_t pte);
FFFFFFFF 00000000          bool __cdecl __native_vcpu_is_preempted(__int64 cpu);
FFFFFFFF 00000000          void __cdecl __ndelay(unsigned __int64 nsecs);
FFFFFFFF 00000000          unsigned int __cdecl __next_node_in(int node, const nodemask_t *srcp);
FFFFFFFF 00000000          zoneref *__cdecl __next_zones_zonelist(zoneref *z, zone_type highest_zoneidx, nodemask_t *nodes);
FFFFFFFF 00000000          int __cdecl __node_distance(int, int);
00000000 00000000          char __noinstr_text_end[];
00000000 00000000          char __noinstr_text_start[];
FFFFFFFF 00000000          const void __nosave_begin;
FFFFFFFF 00000000          const void __nosave_end;
00000004 00000000          atomic_t __num_online_cpus;
FFFFFFFF 00000000          unsigned __int64 __cdecl __offline_isolated_pages(unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          void __cdecl __online_page_free(page *page);
FFFFFFFF 00000000          void __cdecl __online_page_increment_counters(page *page);
FFFFFFFF 00000000          void __cdecl __online_page_set_limits(page *page);
FFFFFFFF 00000000          page *__cdecl __page_cache_alloc(gfp_t gfp);
FFFFFFFF 00000000          unsigned __int64 __cdecl __page_file_index(page *page);
FFFFFFFF 00000000          address_space *__cdecl __page_file_mapping(page *);
FFFFFFFF 00000000          void __cdecl __page_frag_cache_drain(page *page, unsigned int count);
FFFFFFFF 00000000          int __cdecl __page_mapcount(page *page);
FFFFFFFF 00000000          int __cdecl __page_symlink(inode *inode, const char *symname, int len, int nofs);
00000000 00000000          paravirt_patch_site __parainstructions[];
00000000 00000000          paravirt_patch_site __parainstructions_end[];
00000000 00000000          char __per_cpu_end[];
00000000 00000000          char __per_cpu_load[];
00010000 00000000          unsigned __int64 __per_cpu_offset[8192];
00000000 00000000          char __per_cpu_start[];
FFFFFFFF 00000000          int __cdecl __percpu_counter_compare(percpu_counter *fbc, s64 rhs, s32 batch);
FFFFFFFF 00000000          int __cdecl __percpu_counter_init(percpu_counter *fbc, s64 amount, gfp_t gfp, lock_class_key *key);
FFFFFFFF 00000000          s64 __cdecl __percpu_counter_sum(percpu_counter *fbc);
FFFFFFFF 00000000          int __cdecl __percpu_down_read(percpu_rw_semaphore *, int);
FFFFFFFF 00000000          int __cdecl __percpu_init_rwsem(percpu_rw_semaphore *, const char *, lock_class_key *);
FFFFFFFF 00000000          void __cdecl __percpu_up_read(percpu_rw_semaphore *);
FFFFFFFF 00000000          void __cdecl __pm_relax(wakeup_source *ws);
FFFFFFFF 00000000          void __cdecl __pm_runtime_disable(device *dev, bool check_resume);
FFFFFFFF 00000000          int __cdecl __pm_runtime_idle(device *dev, int rpmflags);
FFFFFFFF 00000000          int __cdecl __pm_runtime_resume(device *dev, int rpmflags);
FFFFFFFF 00000000          int __cdecl __pm_runtime_set_status(device *dev, unsigned int status);
FFFFFFFF 00000000          int __cdecl __pm_runtime_suspend(device *dev, int rpmflags);
FFFFFFFF 00000000          void __cdecl __pm_runtime_use_autosuspend(device *dev, bool use);
FFFFFFFF 00000000          void __cdecl __pm_stay_awake(wakeup_source *ws);
FFFFFFFF 00000000          int __cdecl __pmd_alloc(mm_struct *mm, pud_t *pud, unsigned __int64 address);
FFFFFFFF 00000000          spinlock_t *__cdecl __pmd_trans_huge_lock(pmd_t *pmd, vm_area_struct *vma);
FFFFFFFF 00000000          page *__cdecl __populate_section_memmap(unsigned __int64 pfn, unsigned __int64 nr_pages, int nid, vmem_altmap *altmap);
00000004 00000000          int __preempt_count;
FFFFFFFF 00000000          int __cdecl __printk_ratelimit(const char *func);
FFFFFFFF 00000000          __int64 __cdecl __probe_kernel_read(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl __probe_kernel_write(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl __probe_user_read(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl __probe_user_write(void *dst, const void *src, size_t size);
00000008 0000000000000000          uint8_t __pte2cachemode_tbl[8];
FFFFFFFF 00000000          int __cdecl __pte_alloc(mm_struct *mm, pmd_t *pmd);
FFFFFFFF 00000000          int __cdecl __pte_alloc_kernel(pmd_t *pmd);
FFFFFFFF 00000000          pgd_t __cdecl __pti_set_user_pgtbl(pgd_t *pgdp, pgd_t pgd);
FFFFFFFF 00000000          int __cdecl __pud_alloc(mm_struct *mm, p4d_t *p4d, unsigned __int64 address);
FFFFFFFF 00000000          spinlock_t *__cdecl __pud_trans_huge_lock(pud_t *pud, vm_area_struct *vma);
FFFFFFFF 00000000          void __cdecl __put_cred(cred *);
FFFFFFFF 00000000          void __cdecl __put_devmap_managed_page(page *page);
FFFFFFFF 00000000          void __cdecl __put_page(page *page);
FFFFFFFF 00000000          void __put_user_1(void);
FFFFFFFF 00000000          void __put_user_2(void);
FFFFFFFF 00000000          void __put_user_4(void);
FFFFFFFF 00000000          void __put_user_8(void);
FFFFFFFF 00000000          void __put_user_bad(void);
FFFFFFFF 00000000          void __pv_init_lock_hash(void);
FFFFFFFF 00000000          void __cdecl __pv_queued_spin_lock_slowpath(qspinlock *lock, u32 val);
FFFFFFFF 00000000          void *__cdecl __radix_tree_lookup(const xarray *, unsigned __int64 index, xa_node **nodep, void ***slotp);
FFFFFFFF 00000000          void __cdecl __radix_tree_replace(xarray *, xa_node *, void **slot, void *entry);
FFFFFFFF 00000000          void __cdecl __raise_softirq_irqoff(unsigned int nr);
FFFFFFFF 00000000          void __cdecl __raw_callee_save___native_queued_spin_unlock(qspinlock *lock);
FFFFFFFF 00000000          bool __cdecl __raw_callee_save___native_vcpu_is_preempted(__int64 cpu);
FFFFFFFF 00000000          void __cdecl __raw_callee_save___pv_queued_spin_unlock(qspinlock *lock);
FFFFFFFF 00000000          int __cdecl __raw_notifier_call_chain(raw_notifier_head *nh, unsigned __int64 val, void *v, int nr_to_call, int *nr_calls);
FFFFFFFF 00000000          void __read_overflow(void);
FFFFFFFF 00000000          void __read_overflow2(void);
FFFFFFFF 00000000          void __read_overflow3(void);
FFFFFFFF 00000000          void *__cdecl __real_kmemdup(const void *src, size_t len, gfp_t gfp);
FFFFFFFF 00000000          void *__cdecl __real_memchr_inv(const void *s, int c, size_t n);
FFFFFFFF 00000000          void *__cdecl __real_memscan(void *, int, __kernel_size_t);
FFFFFFFF 00000000          size_t __cdecl __real_strlcpy(char *, const char *, size_t);
FFFFFFFF 00000000          __kernel_size_t __cdecl __real_strnlen(const char *, __kernel_size_t);
FFFFFFFF 00000000          int __cdecl __register_chrdev(unsigned int major, unsigned int baseminor, unsigned int count, const char *name, const file_operations *fops);
FFFFFFFF 00000000          void __cdecl __register_sysctl_init(const char *path, ctl_table *table, const char *table_name);
FFFFFFFF 00000000          ctl_table_header *__cdecl __register_sysctl_paths(ctl_table_set *set, const ctl_path *path, ctl_table *table);
FFFFFFFF 00000000          ctl_table_header *__cdecl __register_sysctl_table(ctl_table_set *set, const char *path, ctl_table *table);
FFFFFFFF 00000000          void __cdecl __release_region(resource *, resource_size_t, resource_size_t);
FFFFFFFF 00000000          void __cdecl __remove_inode_hash(inode *);
FFFFFFFF 00000000          void __cdecl __remove_memory(int nid, u64 start, u64 size);
FFFFFFFF 00000000          void __cdecl __remove_pages(unsigned __int64 start_pfn, unsigned __int64 nr_pages, vmem_altmap *altmap);
FFFFFFFF 00000000          int __request_module(bool wait, const char *name, ...);
FFFFFFFF 00000000          int __cdecl __request_percpu_irq(unsigned int irq, irq_handler_t handler, unsigned __int64 flags, const char *devname, void *percpu_dev_id);
FFFFFFFF 00000000          resource *__cdecl __request_region(resource *, resource_size_t start, resource_size_t n, const char *name, int flags);
FFFFFFFF 00000000          device *__cdecl __root_device_register(const char *name, module *owner);
FFFFFFFF 00000000          unsigned __int64 __cdecl __round_jiffies(unsigned __int64 j, int cpu);
FFFFFFFF 00000000          unsigned __int64 __cdecl __round_jiffies_relative(unsigned __int64 j, int cpu);
FFFFFFFF 00000000          unsigned __int64 __cdecl __round_jiffies_up(unsigned __int64 j, int cpu);
FFFFFFFF 00000000          unsigned __int64 __cdecl __round_jiffies_up_relative(unsigned __int64 j, int cpu);
FFFFFFFF 00000000          void __cdecl __rseq_handle_notify_resume(ksignal *sig, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl __rtc_read_alarm(rtc_device *rtc, rtc_wkalrm *alarm);
FFFFFFFF 00000000          int __cdecl __rtc_register_device(module *owner, rtc_device *rtc);
FFFFFFFF 00000000          void __cdecl __sb_end_write(super_block *sb, int level);
FFFFFFFF 00000000          int __cdecl __sb_start_write(super_block *sb, int level, bool wait);
00000008 0000000000000000          u64 __sched_clock_offset;
FFFFFFFF 00000000          unsigned __int64 __cdecl __section_nr(mem_section *ms);
FFFFFFFF 00000000          int __cdecl __secure_computing(const seccomp_data *sd);
FFFFFFFF 00000000          void *__cdecl __seq_open_private(file *, const seq_operations *, int);
FFFFFFFF 00000000          void __cdecl __set_page_dirty(page *, address_space *, int warn);
FFFFFFFF 00000000          int __cdecl __set_page_dirty_no_writeback(page *page);
FFFFFFFF 00000000          int __cdecl __set_page_dirty_nobuffers(page *page);
FFFFFFFF 00000000          void __cdecl __set_task_comm(task_struct *tsk, const char *from, bool exec);
FFFFFFFF 00000000          int __cdecl __sg_alloc_table(sg_table *, unsigned int, unsigned int, scatterlist *, unsigned int, gfp_t, sg_alloc_fn *);
FFFFFFFF 00000000          int __cdecl __sg_alloc_table_from_pages(sg_table *sgt, page **pages, unsigned int n_pages, unsigned int offset, unsigned __int64 size, unsigned int max_segment, gfp_t gfp_mask);
FFFFFFFF 00000000          void __cdecl __sg_free_table(sg_table *, unsigned int, unsigned int, sg_free_fn *);
FFFFFFFF 00000000          bool __cdecl __sg_page_iter_dma_next(sg_dma_page_iter *dma_iter);
FFFFFFFF 00000000          bool __cdecl __sg_page_iter_next(sg_page_iter *piter);
FFFFFFFF 00000000          void __cdecl __sg_page_iter_start(sg_page_iter *piter, scatterlist *sglist, unsigned int nents, unsigned __int64 pgoffset);
00000000 00000000          char __softirqentry_text_end[];
00000000 00000000          char __softirqentry_text_start[];
FFFFFFFF 00000000          void __cdecl __split_huge_pmd(vm_area_struct *vma, pmd_t *pmd, unsigned __int64 address, bool freeze, page *page);
FFFFFFFF 00000000          void __cdecl __split_huge_pud(vm_area_struct *vma, pud_t *pud, unsigned __int64 address);
FFFFFFFF 00000000          int __cdecl __split_vma(mm_struct *, vm_area_struct *, unsigned __int64 addr, int new_below);
FFFFFFFF 00000000          int __cdecl __srcu_notifier_call_chain(srcu_notifier_head *nh, unsigned __int64 val, void *v, int nr_to_call, int *nr_calls);
FFFFFFFF 00000000          int __cdecl __srcu_read_lock(srcu_struct *ssp);
FFFFFFFF 00000000          void __cdecl __srcu_read_unlock(srcu_struct *ssp, int idx);
00000000 00000000          jump_entry __start___jump_table[];
00000000 00000000          const kernel_param __start___param[];
00000000 00000000          char __start_bss_decrypted[];
00000000 00000000          char __start_bss_decrypted_unused[];
00000000 00000000          char __start_once[];
00000000 00000000          char __start_opd[];
00000000 00000000          char __start_ro_after_init[];
00000000 00000000          char __start_rodata[];
00000000 00000000          exception_table_entry __stop___ex_table[];
00000000 00000000          jump_entry __stop___jump_table[];
00000000 00000000          const kernel_param __stop___param[];
00000008 0000000000000000          pteval_t __supported_pte_mask;
FFFFFFFF 00000000          void __cdecl __suspend_report_result(const char *function, void *fn, int ret);
FFFFFFFF 00000000          unsigned int __cdecl __sw_hweight16(unsigned int w);
FFFFFFFF 00000000          unsigned int __cdecl __sw_hweight32(unsigned int w);
FFFFFFFF 00000000          unsigned __int64 __cdecl __sw_hweight64(__u64 w);
FFFFFFFF 00000000          unsigned int __cdecl __sw_hweight8(unsigned int w);
FFFFFFFF 00000000          void *__cdecl __symbol_get(const char *symbol);
FFFFFFFF 00000000          void *__cdecl __symbol_get_gpl(const char *symbol);
FFFFFFFF 00000000          void __cdecl __symbol_put(const char *symbol);
FFFFFFFF 00000000          int __cdecl __sync_filesystem(super_block *, int);
FFFFFFFF 00000000          int __cdecl __sysfs_match_string(const char *const *array, size_t n, const char *s);
FFFFFFFF 00000000          pid_t __cdecl __task_pid_nr_ns(task_struct *task, pid_type type, pid_namespace *ns);
FFFFFFFF 00000000          void __cdecl __tasklet_hi_schedule(tasklet_struct *t);
FFFFFFFF 00000000          void __cdecl __tasklet_schedule(tasklet_struct *t);
FFFFFFFF 00000000          int __cdecl __test_set_page_writeback(page *page, bool keep_write);
FFFFFFFF 00000000          int __trace_bprintk(unsigned __int64 ip, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl __trace_bputs(unsigned __int64 ip, const char *str);
FFFFFFFF 00000000          int __trace_printk(unsigned __int64 ip, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl __trace_puts(unsigned __int64 ip, const char *str, int size);
00000030 00000000          tracepoint __tracepoint_page_ref_freeze;
00000030 00000000          tracepoint __tracepoint_page_ref_mod;
00000030 00000000          tracepoint __tracepoint_page_ref_mod_and_return;
00000030 00000000          tracepoint __tracepoint_page_ref_mod_and_test;
00000030 00000000          tracepoint __tracepoint_page_ref_mod_unless;
00000030 00000000          tracepoint __tracepoint_page_ref_set;
00000030 00000000          tracepoint __tracepoint_page_ref_unfreeze;
00000030 00000000          tracepoint __tracepoint_rdpmc;
00000030 00000000          tracepoint __tracepoint_read_msr;
00000030 00000000          tracepoint __tracepoint_write_msr;
FFFFFFFF 00000000          void __try_cmpxchg_user_wrong_size(void);
FFFFFFFF 00000000          void __cdecl __udelay(unsigned __int64 usecs);
FFFFFFFF 00000000          void __cdecl __unregister_chrdev(unsigned int major, unsigned int baseminor, unsigned int count, const char *name);
FFFFFFFF 00000000          int __cdecl __usb_get_extra_descriptor(char *buffer, unsigned int size, unsigned __int8 type, void **ptr, size_t min);
FFFFFFFF 00000000          unsigned __int64 __cdecl __usecs_to_jiffies(const unsigned int u);
FFFFFFFF 00000000          int __cdecl __usermodehelper_disable(umh_disable_depth depth);
FFFFFFFF 00000000          void __cdecl __usermodehelper_set_disable_depth(umh_disable_depth depth);
FFFFFFFF 00000000          wait_queue_head_t *__cdecl __var_waitqueue(void *p);
FFFFFFFF 00000000          ssize_t __cdecl __vfs_read(file *, char *, size_t, loff_t *);
FFFFFFFF 00000000          bool __cdecl __virt_addr_valid(unsigned __int64 kaddr);
FFFFFFFF 00000000          int __cdecl __vm_enough_memory(mm_struct *mm, __int64 pages, int cap_sys_admin);
FFFFFFFF 00000000          int __cdecl __vma_adjust(vm_area_struct *vma, unsigned __int64 start, unsigned __int64 end, unsigned __int64 pgoff, vm_area_struct *insert, vm_area_struct *expand);
FFFFFFFF 00000000          void __cdecl __vma_link_rb(mm_struct *, vm_area_struct *, rb_node **, rb_node *);
FFFFFFFF 00000000          void *__cdecl __vmalloc(unsigned __int64 size, gfp_t gfp_mask, pgprot_t prot);
FFFFFFFF 00000000          void *__cdecl __vmalloc_node_flags_caller(unsigned __int64 size, int node, gfp_t flags, void *caller);
FFFFFFFF 00000000          void *__cdecl __vmalloc_node_range(unsigned __int64 size, unsigned __int64 align, unsigned __int64 start, unsigned __int64 end, gfp_t gfp_mask, pgprot_t prot, unsigned __int64 vm_flags, int node, const void *caller);
FFFFFFFF 00000000          int __cdecl __wait_on_bit(wait_queue_head *wq_head, wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
FFFFFFFF 00000000          int __cdecl __wait_on_bit_lock(wait_queue_head *wq_head, wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);
FFFFFFFF 00000000          void __cdecl __wake_up(wait_queue_head *wq_head, unsigned int mode, int nr, void *key);
FFFFFFFF 00000000          void __cdecl __wake_up_bit(wait_queue_head *wq_head, void *word, int bit);
FFFFFFFF 00000000          void __cdecl __wake_up_locked(wait_queue_head *wq_head, unsigned int mode, int nr);
FFFFFFFF 00000000          void __cdecl __wake_up_locked_key(wait_queue_head *wq_head, unsigned int mode, void *key);
FFFFFFFF 00000000          void __cdecl __wake_up_locked_key_bookmark(wait_queue_head *wq_head, unsigned int mode, void *key, wait_queue_entry_t *bookmark);
FFFFFFFF 00000000          void __cdecl __wake_up_pollfree(wait_queue_head *wq_head);
FFFFFFFF 00000000          void __cdecl __wake_up_sync(wait_queue_head *wq_head, unsigned int mode, int nr);
FFFFFFFF 00000000          void __cdecl __wake_up_sync_key(wait_queue_head *wq_head, unsigned int mode, int nr, void *key);
FFFFFFFF 00000000          void __cdecl __warn(const char *file, int line, void *caller, unsigned int taint, pt_regs *regs, warn_args *args);
FFFFFFFF 00000000          void __warn_printk(const char *fmt, ...);
FFFFFFFF 00000000          void __write_overflow(void);
FFFFFFFF 00000000          int __cdecl __xa_alloc(xarray *, u32 *id, void *entry, xa_limit, gfp_t);
FFFFFFFF 00000000          int __cdecl __xa_alloc_cyclic(xarray *, u32 *id, void *entry, xa_limit, u32 *next, gfp_t);
FFFFFFFF 00000000          void __cdecl __xa_clear_mark(xarray *, unsigned __int64 index, xa_mark_t);
FFFFFFFF 00000000          void *__cdecl __xa_cmpxchg(xarray *, unsigned __int64 index, void *old, void *entry, gfp_t);
FFFFFFFF 00000000          void *__cdecl __xa_erase(xarray *, unsigned __int64 index);
FFFFFFFF 00000000          int __cdecl __xa_insert(xarray *, unsigned __int64 index, void *entry, gfp_t);
FFFFFFFF 00000000          void __cdecl __xa_set_mark(xarray *, unsigned __int64 index, xa_mark_t);
FFFFFFFF 00000000          void *__cdecl __xa_store(xarray *, unsigned __int64 index, void *entry, gfp_t);
FFFFFFFF 00000000          void __xadd_wrong_size(void);
FFFFFFFF 00000000          void *__cdecl __xas_next(xa_state *);
FFFFFFFF 00000000          void *__cdecl __xas_prev(xa_state *);
FFFFFFFF 00000000          void __xchg_wrong_size(void);
FFFFFFFF 00000000          void __cdecl __xsk_map_flush(bpf_map *map);
FFFFFFFF 00000000          xdp_sock *__cdecl __xsk_map_lookup_elem(bpf_map *map, u32 key);
FFFFFFFF 00000000          int __cdecl __xsk_map_redirect(bpf_map *map, xdp_buff *xdp, xdp_sock *xs);
FFFFFFFF 00000000          bool __cdecl __zone_watermark_ok(zone *z, unsigned int order, unsigned __int64 mark, int classzone_idx, unsigned int alloc_flags, __int64 free_pages);
FFFFFFFF 00000000          int __cdecl _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
FFFFFFFF 00000000          int __cdecl _atomic_dec_and_lock_irqsave(atomic_t *atomic, spinlock_t *lock, unsigned __int64 *flags);
FFFFFFFF 00000000          int _cond_resched(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl _copy_from_user(void *, const void *, unsigned __int64);
FFFFFFFF 00000000          unsigned __int64 __cdecl _copy_to_user(void *, const void *, unsigned __int64);
00000000 00000000          const unsigned __int8 _ctype[];
00000000 00000000          char _data[];
00000010 00000000          static_key_false _debug_pagealloc_enabled;
00000001 00000000          bool _debug_pagealloc_enabled_early;
FFFFFFFF 00000000          void _dev_alert(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_crit(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_emerg(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_err(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_info(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_notice(const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          void _dev_warn(const device *dev, const char *fmt, ...);
00000000 00000000          char _edata[];
00000000 00000000          char _einittext[];
00000000 00000000          char _end[];
00000004 00000601          fixed_addresses __end_of_fixed_addresses;
00000004 00000286          fixed_addresses __end_of_permanent_fixed_addresses;
00000000 00000000          char _etext[];
FFFFFFFF 00000000          vm_area_struct *__cdecl _install_special_mapping(mm_struct *mm, unsigned __int64 addr, unsigned __int64 len, unsigned __int64 flags, const vm_special_mapping *spec);
FFFFFFFF 00000000          int __cdecl _kstrtol(const char *s, unsigned int base, __int64 *res);
FFFFFFFF 00000000          int __cdecl _kstrtoul(const char *s, unsigned int base, unsigned __int64 *res);
FFFFFFFF 00000000          void _local_bh_enable(void);
FFFFFFFF 00000000          u64 __cdecl _paravirt_ident_64(u64);
FFFFFFFF 00000000          void _paravirt_nop(void);
FFFFFFFF 00000000          proc_dir_entry *__cdecl _proc_mkdir(const char *, umode_t, proc_dir_entry *, void *, bool);
FFFFFFFF 00000000          void __cdecl _raw_read_lock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_lock_bh(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_lock_irq(rwlock_t *lock);
FFFFFFFF 00000000          unsigned __int64 __cdecl _raw_read_lock_irqsave(rwlock_t *lock);
FFFFFFFF 00000000          int __cdecl _raw_read_trylock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_unlock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_unlock_bh(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_unlock_irq(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned __int64 flags);
FFFFFFFF 00000000          void __cdecl _raw_spin_lock(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_lock_bh(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_lock_irq(raw_spinlock_t *lock);
FFFFFFFF 00000000          unsigned __int64 __cdecl _raw_spin_lock_irqsave(raw_spinlock_t *lock);
FFFFFFFF 00000000          unsigned __int64 __cdecl _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass);
FFFFFFFF 00000000          void __cdecl _raw_spin_lock_nest_lock(raw_spinlock_t *lock, lockdep_map *map);
FFFFFFFF 00000000          void __cdecl _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass);
FFFFFFFF 00000000          int __cdecl _raw_spin_trylock(raw_spinlock_t *lock);
FFFFFFFF 00000000          int __cdecl _raw_spin_trylock_bh(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_unlock(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_unlock_bh(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_unlock_irq(raw_spinlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned __int64 flags);
FFFFFFFF 00000000          void __cdecl _raw_write_lock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_lock_bh(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_lock_irq(rwlock_t *lock);
FFFFFFFF 00000000          unsigned __int64 __cdecl _raw_write_lock_irqsave(rwlock_t *lock);
FFFFFFFF 00000000          int __cdecl _raw_write_trylock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_unlock(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_unlock_bh(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_unlock_irq(rwlock_t *lock);
FFFFFFFF 00000000          void __cdecl _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned __int64 flags);
00000000 00000000          char _sdata[];
00000000 00000000          char _sinittext[];
00000000 00000000          char _stext[];
00000000 00000000          char _text[];
00000008 0000000000000000          atomic_long_t _totalram_pages;
00000080 00000000          nodemask_t _unused_nodemask_arg_;
FFFFFFFF 00000000          void __cdecl abort_creds(cred *);
FFFFFFFF 00000000          unsigned __int64 __cdecl absent_pages_in_range(unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          int __cdecl access_process_vm(task_struct *tsk, unsigned __int64 addr, void *buf, int len, unsigned int gup_flags);
FFFFFFFF 00000000          int __cdecl access_remote_vm(mm_struct *mm, unsigned __int64 addr, void *buf, int len, unsigned int gup_flags);
FFFFFFFF 00000000          int __cdecl account_locked_vm(mm_struct *mm, unsigned __int64 pages, bool inc);
FFFFFFFF 00000000          void __cdecl account_page_cleaned(page *page, address_space *mapping, bdi_writeback *wb);
FFFFFFFF 00000000          void __cdecl account_page_dirtied(page *page, address_space *mapping);
FFFFFFFF 00000000          void __cdecl ack_bad_irq(unsigned int irq);
FFFFFFFF 00000000          acpi_status __cdecl acpi_acquire_global_lock(u16 timeout, u32 *handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_acquire_mutex(acpi_handle handle, acpi_string pathname, u16 timeout);
FFFFFFFF 00000000          acpi_status __cdecl acpi_add_pm_notifier(acpi_device *adev, device *dev, void (__cdecl *func)(acpi_device_wakeup_context *));
FFFFFFFF 00000000          u32 acpi_any_fixed_event_status_set(void);
FFFFFFFF 00000000          u32 __cdecl acpi_any_gpe_status_set(u32 gpe_skip_number);
FFFFFFFF 00000000          bool __cdecl acpi_ata_match(acpi_handle handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_attach_data(acpi_handle object, acpi_object_handler handler, void *data);
FFFFFFFF 00000000          bool __cdecl acpi_bay_match(acpi_handle handle);
FFFFFFFF 00000000          int __cdecl acpi_bind_one(device *dev, acpi_device *adev);
FFFFFFFF 00000000          void acpi_bios_error(const char *module_name, u32 line_number, const char *format, ...);
FFFFFFFF 00000000          void acpi_bios_exception(const char *module_name, u32 line_number, acpi_status status, const char *format, ...);
FFFFFFFF 00000000          void acpi_bios_warning(const char *module_name, u32 line_number, const char *format, ...);
FFFFFFFF 00000000          int acpi_blacklisted(void);
FFFFFFFF 00000000          int acpi_boot_init(void);
FFFFFFFF 00000000          void acpi_boot_table_init(void);
FFFFFFFF 00000000          void acpi_boot_table_prepare(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_buffer_to_resource(u8 *aml_buffer, u16 aml_buffer_length, acpi_resource **resource_ptr);
FFFFFFFF 00000000          int __cdecl acpi_bus_attach_private_data(acpi_handle, void *);
FFFFFFFF 00000000          bool __cdecl acpi_bus_can_wakeup(acpi_handle handle);
FFFFFFFF 00000000          void __cdecl acpi_bus_detach_private_data(acpi_handle);
FFFFFFFF 00000000          int __cdecl acpi_bus_generate_netlink_event(const char *, const char *, u8, int);
FFFFFFFF 00000000          acpi_device *__cdecl acpi_bus_get_acpi_device(acpi_handle handle);
FFFFFFFF 00000000          int __cdecl acpi_bus_get_device(acpi_handle handle, acpi_device **device);
FFFFFFFF 00000000          acpi_status __cdecl acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd);
FFFFFFFF 00000000          int __cdecl acpi_bus_get_private_data(acpi_handle, void **);
FFFFFFFF 00000000          int __cdecl acpi_bus_get_status(acpi_device *device);
FFFFFFFF 00000000          acpi_status __cdecl acpi_bus_get_status_handle(acpi_handle handle, unsigned __int64 *sta);
FFFFFFFF 00000000          int __cdecl acpi_bus_init_power(acpi_device *device);
FFFFFFFF 00000000          bool __cdecl acpi_bus_power_manageable(acpi_handle handle);
FFFFFFFF 00000000          void __cdecl acpi_bus_private_data_handler(acpi_handle, void *);
FFFFFFFF 00000000          void __cdecl acpi_bus_put_acpi_device(acpi_device *adev);
FFFFFFFF 00000000          int __cdecl acpi_bus_register_driver(acpi_driver *driver);
FFFFFFFF 00000000          int __cdecl acpi_bus_scan(acpi_handle handle);
FFFFFFFF 00000000          int __cdecl acpi_bus_set_power(acpi_handle handle, int state);
FFFFFFFF 00000000          void __cdecl acpi_bus_trim(acpi_device *start);
000000A8 00000000          bus_type acpi_bus_type;
FFFFFFFF 00000000          void __cdecl acpi_bus_unregister_driver(acpi_driver *driver);
FFFFFFFF 00000000          int __cdecl acpi_bus_update_power(acpi_handle handle, int *state_p);
FFFFFFFF 00000000          u32 __cdecl acpi_check_address_range(acpi_adr_space_type space_id, acpi_physical_address address, acpi_size length, u8 warn);
FFFFFFFF 00000000          bool __cdecl acpi_check_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 funcs);
FFFFFFFF 00000000          int __cdecl acpi_check_region(resource_size_t start, resource_size_t n, const char *name);
FFFFFFFF 00000000          int __cdecl acpi_check_resource_conflict(const resource *res);
FFFFFFFF 00000000          acpi_status __cdecl acpi_clear_event(u32 event);
FFFFFFFF 00000000          acpi_status __cdecl acpi_clear_gpe(acpi_handle gpe_device, u32 gpe_number);
FFFFFFFF 00000000          int __cdecl acpi_create_dir(acpi_device *);
FFFFFFFF 00000000          platform_device *__cdecl acpi_create_platform_device(acpi_device *, property_entry *);
00000004 00000000          u32 acpi_current_gpe_count;
FFFFFFFF 00000000          acpi_device_properties *__cdecl acpi_data_add_props(acpi_device_data *data, const guid_t *guid, const acpi_object *properties);
00000078 00000000          const fwnode_operations acpi_data_fwnode_ops;
00000004 00000000          u32 acpi_dbg_layer;
00000004 00000000          u32 acpi_dbg_level;
FFFFFFFF 00000000          acpi_status __cdecl acpi_debug_trace(const char *name, u32 debug_level, u32 debug_layer, u32 flags);
FFFFFFFF 00000000          int __cdecl acpi_debugger_create_thread(acpi_osd_exec_callback function, void *context);
FFFFFFFF 00000000          int acpi_debugger_init(void);
FFFFFFFF 00000000          int acpi_debugger_notify_command_complete(void);
FFFFFFFF 00000000          ssize_t __cdecl acpi_debugger_read_cmd(char *buffer, size_t buffer_length);
FFFFFFFF 00000000          int acpi_debugger_wait_command_ready(void);
FFFFFFFF 00000000          ssize_t __cdecl acpi_debugger_write_log(const char *msg);
FFFFFFFF 00000000          acpi_status __cdecl acpi_decode_pld_buffer(u8 *in_buffer, acpi_size length, acpi_pld_info **return_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_detach_data(acpi_handle object, acpi_object_handler handler);
FFFFFFFF 00000000          int __cdecl acpi_dev_filter_resource_type(acpi_resource *ares, unsigned __int64 types);
FFFFFFFF 00000000          bool __cdecl acpi_dev_found(const char *hid);
FFFFFFFF 00000000          void __cdecl acpi_dev_free_resource_list(list_head *list);
FFFFFFFF 00000000          int __cdecl acpi_dev_get_dma_resources(acpi_device *adev, list_head *list);
FFFFFFFF 00000000          acpi_device *__cdecl acpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv);
FFFFFFFF 00000000          unsigned int __cdecl acpi_dev_get_irq_type(int triggering, int polarity);
FFFFFFFF 00000000          int __cdecl acpi_dev_get_property(const acpi_device *adev, const char *name, acpi_object_type type, const acpi_object **obj);
FFFFFFFF 00000000          int __cdecl acpi_dev_get_resources(acpi_device *adev, list_head *list, int (__cdecl *preproc)(acpi_resource *, void *), void *preproc_data);
FFFFFFFF 00000000          int __cdecl acpi_dev_gpio_irq_get(acpi_device *adev, int index);
FFFFFFFF 00000000          unsigned __int64 __cdecl acpi_dev_irq_flags(u8 triggering, u8 polarity, u8 shareable);
FFFFFFFF 00000000          int __cdecl acpi_dev_pm_attach(device *dev, bool power_on);
FFFFFFFF 00000000          bool __cdecl acpi_dev_present(const char *hid, const char *uid, s64 hrv);
FFFFFFFF 00000000          int __cdecl acpi_dev_prop_read(const acpi_device *adev, const char *propname, dev_prop_type proptype, void *val, size_t nval);
FFFFFFFF 00000000          int __cdecl acpi_dev_prop_read_single(acpi_device *adev, const char *propname, dev_prop_type proptype, void *val);
FFFFFFFF 00000000          bool __cdecl acpi_dev_resource_address_space(acpi_resource *ares, resource_win *win);
FFFFFFFF 00000000          bool __cdecl acpi_dev_resource_ext_address_space(acpi_resource *ares, resource_win *win);
FFFFFFFF 00000000          bool __cdecl acpi_dev_resource_interrupt(acpi_resource *ares, int index, resource *res);
FFFFFFFF 00000000          bool __cdecl acpi_dev_resource_io(acpi_resource *ares, resource *res);
FFFFFFFF 00000000          bool __cdecl acpi_dev_resource_memory(acpi_resource *ares, resource *res);
FFFFFFFF 00000000          int __cdecl acpi_dev_resume(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_dev_suspend(device *dev, bool wakeup);
FFFFFFFF 00000000          bool __cdecl acpi_device_always_present(acpi_device *adev);
FFFFFFFF 00000000          int __cdecl acpi_device_fix_up_power(acpi_device *device);
00000078 00000000          const fwnode_operations acpi_device_fwnode_ops;
FFFFFFFF 00000000          const void *__cdecl acpi_device_get_match_data(const device *dev);
FFFFFFFF 00000000          const char *__cdecl acpi_device_hid(acpi_device *device);
FFFFFFFF 00000000          int __cdecl acpi_device_modalias(device *, char *, int);
FFFFFFFF 00000000          int __cdecl acpi_device_power_add_dependent(acpi_device *adev, device *dev);
FFFFFFFF 00000000          void __cdecl acpi_device_power_remove_dependent(acpi_device *adev, device *dev);
FFFFFFFF 00000000          int __cdecl acpi_device_set_power(acpi_device *device, int state);
FFFFFFFF 00000000          int __cdecl acpi_device_uevent_modalias(device *, kobj_uevent_env *);
FFFFFFFF 00000000          int __cdecl acpi_device_update_power(acpi_device *device, int *state_p);
FFFFFFFF 00000000          acpi_status acpi_disable(void);
FFFFFFFF 00000000          acpi_status acpi_disable_all_gpes(void);
00000004 00000000          int acpi_disable_cmcff;
FFFFFFFF 00000000          acpi_status __cdecl acpi_disable_event(u32 event, u32 flags);
FFFFFFFF 00000000          acpi_status __cdecl acpi_disable_gpe(acpi_handle gpe_device, u32 gpe_number);
FFFFFFFF 00000000          int __cdecl acpi_disable_wakeup_device_power(acpi_device *dev);
00000004 00000000          int acpi_disabled;
FFFFFFFF 00000000          u32 __cdecl acpi_dispatch_gpe(acpi_handle gpe_device, u32 gpe_number);
FFFFFFFF 00000000          int __cdecl acpi_dma_configure(device *dev, dev_dma_attr attr);
FFFFFFFF 00000000          int __cdecl acpi_dma_get_range(device *dev, u64 *dma_addr, u64 *offset, u64 *size);
FFFFFFFF 00000000          bool __cdecl acpi_dma_supported(acpi_device *adev);
FFFFFFFF 00000000          bool __cdecl acpi_dock_match(acpi_handle handle);
FFFFFFFF 00000000          bool __cdecl acpi_driver_match_device(device *dev, const device_driver *drv);
FFFFFFFF 00000000          bool __cdecl acpi_duplicate_processor_id(int proc_id);
FFFFFFFF 00000000          void acpi_early_init(void);
FFFFFFFF 00000000          void acpi_ec_mark_gpe_for_wake(void);
FFFFFFFF 00000000          void __cdecl acpi_ec_set_gpe_wake_mask(u8 action);
FFFFFFFF 00000000          acpi_status acpi_enable(void);
FFFFFFFF 00000000          acpi_status acpi_enable_all_runtime_gpes(void);
FFFFFFFF 00000000          acpi_status acpi_enable_all_wakeup_gpes(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_enable_event(u32 event, u32 flags);
FFFFFFFF 00000000          acpi_status __cdecl acpi_enable_gpe(acpi_handle gpe_device, u32 gpe_number);
FFFFFFFF 00000000          acpi_status __cdecl acpi_enable_subsystem(u32 flags);
FFFFFFFF 00000000          int __cdecl acpi_enable_wakeup_device_power(acpi_device *dev, int state);
FFFFFFFF 00000000          acpi_status __cdecl acpi_enter_sleep_state(u8 sleep_state);
FFFFFFFF 00000000          acpi_status __cdecl acpi_enter_sleep_state_prep(u8 sleep_state);
FFFFFFFF 00000000          acpi_status acpi_enter_sleep_state_s4bios(void);
FFFFFFFF 00000000          void acpi_error(const char *module_name, u32 line_number, const char *format, ...);
FFFFFFFF 00000000          acpi_object *__cdecl acpi_evaluate_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 func, acpi_object *argv4);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_ej0(acpi_handle handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_integer(acpi_handle handle, acpi_string pathname, acpi_object_list *arguments, unsigned __int64 *data);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_lck(acpi_handle handle, int lock);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_object(acpi_handle object, acpi_string pathname, acpi_object_list *parameter_objects, acpi_buffer *return_object_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_object_typed(acpi_handle object, acpi_string pathname, acpi_object_list *external_params, acpi_buffer *return_buffer, acpi_object_type return_type);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_ost(acpi_handle handle, u32 source_event, u32 status_code, acpi_buffer *status_buf);
FFFFFFFF 00000000          acpi_status __cdecl acpi_evaluate_reference(acpi_handle handle, acpi_string pathname, acpi_object_list *arguments, acpi_handle_list *list);
FFFFFFFF 00000000          void acpi_exception(const char *module_name, u32 line_number, acpi_status status, const char *format, ...);
FFFFFFFF 00000000          acpi_status __cdecl acpi_execute_simple_method(acpi_handle handle, char *method, u64 arg);
FFFFFFFF 00000000          acpi_status __cdecl acpi_extract_package(acpi_object *package, acpi_buffer *format, acpi_buffer *buffer);
FFFFFFFF 00000000          acpi_device *__cdecl acpi_find_child_device(acpi_device *parent, u64 address, bool check_children);
FFFFFFFF 00000000          acpi_status __cdecl acpi_find_root_pointer(acpi_physical_address *rsdp_address);
FFFFFFFF 00000000          acpi_status __cdecl acpi_finish_gpe(acpi_handle gpe_device, u32 gpe_number);
00000004 00000000          int acpi_fix_pin2_polarity;
FFFFFFFF 00000000          const char *__cdecl acpi_format_exception(acpi_status exception);
00000114 00000000          acpi_table_fadt acpi_gbl_FADT;
00000001 00000000          u8 acpi_gbl_auto_serialize_methods;
00000001 00000000          u8 acpi_gbl_copy_dsdt_locally;
00000001 00000000          u8 acpi_gbl_create_osi_method;
00000200 00000000          char acpi_gbl_db_line_buf[512];
00000001 00000000          u8 acpi_gbl_disable_auto_repair;
00000001 00000000          u8 acpi_gbl_disable_ssdt_table_install;
00000001 00000000          u8 acpi_gbl_display_debug_timer;
00000001 00000000          u8 acpi_gbl_do_not_use_xsdt;
00000001 00000000          u8 acpi_gbl_enable_aml_debug_object;
00000001 00000000          u8 acpi_gbl_enable_interpreter_slack;
00000001 00000000          u8 acpi_gbl_enable_table_validation;
00000001 00000000          u8 acpi_gbl_ignore_package_resolution_errors;
00000004 00000000          u32 acpi_gbl_max_loop_iterations;
00000001 00000000          u8 acpi_gbl_method_executing;
00000001 00000000          u8 acpi_gbl_osi_data;
00000001 00000000          u8 acpi_gbl_reduced_hardware;
00000001 00000000          u8 acpi_gbl_runtime_namespace_override;
00000001 00000000          u8 acpi_gbl_system_awake_and_running;
00000004 00000000          u32 acpi_gbl_trace_dbg_layer;
00000004 00000000          u32 acpi_gbl_trace_dbg_level;
00000004 00000000          u32 acpi_gbl_trace_flags;
00000008 0000000000000000          const char *acpi_gbl_trace_method_name;
00000001 00000000          u8 acpi_gbl_truncate_io_addresses;
00000001 00000000          u8 acpi_gbl_use32_bit_facs_addresses;
00000001 00000000          u8 acpi_gbl_use32_bit_fadt_addresses;
00000001 00000000          u8 acpi_gbl_use_default_register_widths;
FFFFFFFF 00000000          void acpi_generic_reduced_hw_init(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_current_resources(acpi_handle device, acpi_buffer *ret_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_data(acpi_handle object, acpi_object_handler handler, void **data);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_data_full(acpi_handle object, acpi_object_handler handler, void **data, void (__cdecl *callback)(void *));
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_devices(const char *HID, acpi_walk_callback user_function, void *context, void **return_value);
FFFFFFFF 00000000          dev_dma_attr __cdecl acpi_get_dma_attr(acpi_device *adev);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_event_resources(acpi_handle device_handle, acpi_buffer *ret_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_event_status(u32 event, acpi_event_status *event_status);
FFFFFFFF 00000000          device *__cdecl acpi_get_first_physical_node(acpi_device *adev);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_gpe_device(u32 gpe_index, acpi_handle *gpe_device);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_gpe_status(acpi_handle gpe_device, u32 gpe_number, acpi_event_status *event_status);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_handle(acpi_handle parent, acpi_string pathname, acpi_handle *ret_handle);
FFFFFFFF 00000000          int __cdecl acpi_get_ioapic_id(acpi_handle handle, u32 gsi_base, u64 *phys_addr);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_irq_routing_table(acpi_handle device, acpi_buffer *ret_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_name(acpi_handle object, u32 name_type, acpi_buffer *ret_path_ptr);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_next_object(acpi_object_type type, acpi_handle parent, acpi_handle child, acpi_handle *out_handle);
FFFFFFFF 00000000          fwnode_handle *__cdecl acpi_get_next_subnode(const fwnode_handle *fwnode, fwnode_handle *child);
FFFFFFFF 00000000          int __cdecl acpi_get_node(acpi_handle handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_object_info(acpi_handle object, acpi_device_info **return_buffer);
FFFFFFFF 00000000          int __cdecl acpi_get_override_irq(u32 gsi, int *trigger, int *polarity);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_parent(acpi_handle object, acpi_handle *out_handle);
FFFFFFFF 00000000          pci_dev *__cdecl acpi_get_pci_dev(acpi_handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_physical_device_location(acpi_handle handle, acpi_pld_info **pld);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_possible_resources(acpi_handle device, acpi_buffer *ret_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_sleep_type_data(u8 sleep_state, u8 *slp_typ_a, u8 *slp_typ_b);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_statistics(acpi_statistics *stats);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_system_info(acpi_buffer *ret_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_table(acpi_string signature, u32 instance, acpi_table_header **out_table);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_table_by_index(u32 table_index, acpi_table_header **out_table);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_table_header(acpi_string signature, u32 instance, acpi_table_header *out_table_header);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_timer(u32 *ticks);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_timer_duration(u32 start_ticks, u32 end_ticks, u32 *time_elapsed);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_timer_resolution(u32 *resolution);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_type(acpi_handle object, acpi_object_type *out_type);
FFFFFFFF 00000000          acpi_status __cdecl acpi_get_vendor_resource(acpi_handle device, char *name, acpi_vendor_uuid *uuid, acpi_buffer *ret_buffer);
FFFFFFFF 00000000          bool __cdecl acpi_gpio_get_irq_resource(acpi_resource *ares, acpi_resource_gpio **agpio);
FFFFFFFF 00000000          int __cdecl acpi_gsi_to_irq(u32 gsi, unsigned int *irq);
FFFFFFFF 00000000          void acpi_handle_printk(const char *level, acpi_handle handle, const char *fmt, ...);
FFFFFFFF 00000000          bool __cdecl acpi_has_method(acpi_handle handle, char *name);
FFFFFFFF 00000000          bool acpi_has_watchdog(void);
FFFFFFFF 00000000          void acpi_info(const char *format, ...);
FFFFFFFF 00000000          acpi_status acpi_initialize_debugger(void);
FFFFFFFF 00000000          void __cdecl acpi_initialize_hp_context(acpi_device *adev, acpi_hotplug_context *hp, int (__cdecl *notify)(acpi_device *, u32), void (__cdecl *uevent)(acpi_device *, u32));
FFFFFFFF 00000000          acpi_status __cdecl acpi_initialize_objects(u32 flags);
FFFFFFFF 00000000          acpi_status acpi_initialize_subsystem(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_initialize_tables(acpi_table_desc *initial_storage, u32 initial_table_count, u8 allow_resize);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_address_space_handler(acpi_handle device, acpi_adr_space_type space_id, acpi_adr_space_handler handler, acpi_adr_space_setup setup, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_exception_handler(acpi_exception_handler handler);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_fixed_event_handler(u32 acpi_event, acpi_event_handler handler, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_global_event_handler(acpi_gbl_event_handler handler, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_gpe_block(acpi_handle gpe_device, acpi_generic_address *gpe_block_address, u32 register_count, u32 interrupt_number);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_gpe_handler(acpi_handle gpe_device, u32 gpe_number, u32 type, acpi_gpe_handler address, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_gpe_raw_handler(acpi_handle gpe_device, u32 gpe_number, u32 type, acpi_gpe_handler address, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_initialization_handler(acpi_init_handler handler, u32 function);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_interface(acpi_string interface_name);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_interface_handler(acpi_interface_handler handler);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_method(u8 *buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_notify_handler(acpi_handle device, u32 handler_type, acpi_notify_handler handler, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_sci_handler(acpi_sci_handler address, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_table(acpi_physical_address address, u8 physical);
FFFFFFFF 00000000          acpi_status __cdecl acpi_install_table_handler(acpi_table_handler handler, void *context);
00000004 00000000          int acpi_ioapic;
FFFFFFFF 00000000          int __cdecl acpi_ioapic_add(acpi_handle root);
FFFFFFFF 00000000          int __cdecl acpi_ioapic_registered(acpi_handle handle, u32 gsi_base);
FFFFFFFF 00000000          irq_domain *__cdecl acpi_irq_create_hierarchy(unsigned int flags, unsigned int size, fwnode_handle *fwnode, const irq_domain_ops *ops, void *host_data);
00000004 00000000          u32 acpi_irq_handled;
00000004 00000000          acpi_irq_model_id acpi_irq_model;
00000004 00000000          u32 acpi_irq_not_handled;
FFFFFFFF 00000000          int acpi_irq_penalty_init(void);
FFFFFFFF 00000000          void acpi_irq_stats_init(void);
FFFFFFFF 00000000          bool __cdecl acpi_is_pnp_device(acpi_device *);
FFFFFFFF 00000000          int __cdecl acpi_is_root_bridge(acpi_handle);
FFFFFFFF 00000000          __int64 __cdecl acpi_is_video_device(acpi_handle handle);
FFFFFFFF 00000000          bool __cdecl acpi_isa_irq_available(int irq);
FFFFFFFF 00000000          int __cdecl acpi_isa_irq_to_gsi(unsigned int isa_irq, u32 *gsi);
00000008 0000000000000000          kobject *acpi_kobj;
00000004 00000000          int acpi_lapic;
FFFFFFFF 00000000          acpi_status __cdecl acpi_leave_sleep_state(u8 sleep_state);
FFFFFFFF 00000000          acpi_status __cdecl acpi_leave_sleep_state_prep(u8 sleep_state);
FFFFFFFF 00000000          acpi_status __cdecl acpi_load_table(acpi_table_header *table);
FFFFFFFF 00000000          acpi_status acpi_load_tables(void);
FFFFFFFF 00000000          int acpi_locate_initial_tables(void);
FFFFFFFF 00000000          void acpi_lock_hp_context(void);
FFFFFFFF 00000000          int __cdecl acpi_map_cpu(acpi_handle handle, phys_cpuid_t physid, u32 acpi_id, int *pcpu);
FFFFFFFF 00000000          int __cdecl acpi_map_pxm_to_node(int pxm);
FFFFFFFF 00000000          int __cdecl acpi_map_pxm_to_online_node(int pxm);
FFFFFFFF 00000000          acpi_status __cdecl acpi_mark_gpe_for_wake(acpi_handle gpe_device, u32 gpe_number);
FFFFFFFF 00000000          acpi_status __cdecl acpi_mask_gpe(acpi_handle gpe_device, u32 gpe_number, u8 is_masked);
FFFFFFFF 00000000          const acpi_device_id *__cdecl acpi_match_device(const acpi_device_id *ids, const device *dev);
FFFFFFFF 00000000          int __cdecl acpi_match_device_ids(acpi_device *device, const acpi_device_id *ids);
FFFFFFFF 00000000          int __cdecl acpi_match_platform_list(const acpi_platform_list *plat);
FFFFFFFF 00000000          int acpi_mps_check(void);
FFFFFFFF 00000000          void acpi_no_s4_hw_signature(void);
00000001 00000000          bool acpi_no_s5;
FFFFFFFF 00000000          fwnode_handle *__cdecl acpi_node_get_parent(const fwnode_handle *fwnode);
FFFFFFFF 00000000          int __cdecl acpi_node_prop_get(const fwnode_handle *fwnode, const char *propname, void **valptr);
FFFFFFFF 00000000          int __cdecl acpi_node_prop_read(const fwnode_handle *fwnode, const char *propname, dev_prop_type proptype, void *val, size_t nval);
00000004 00000000          int acpi_noirq;
FFFFFFFF 00000000          int __cdecl acpi_notifier_call_chain(acpi_device *, u32, u32);
00000004 00000000          int acpi_numa;
FFFFFFFF 00000000          int acpi_numa_init(void);
FFFFFFFF 00000000          int __cdecl acpi_numa_memory_affinity_init(acpi_srat_mem_affinity *ma);
FFFFFFFF 00000000          void __cdecl acpi_numa_processor_affinity_init(acpi_srat_cpu_affinity *pa);
FFFFFFFF 00000000          void __cdecl acpi_numa_slit_init(acpi_table_slit *slit);
FFFFFFFF 00000000          void __cdecl acpi_numa_x2apic_affinity_init(acpi_srat_x2apic_cpu_affinity *pa);
FFFFFFFF 00000000          int __cdecl acpi_nvs_for_each_region(int (__cdecl *func)(__u64, __u64, void *), void *data);
FFFFFFFF 00000000          void acpi_nvs_nosave(void);
FFFFFFFF 00000000          void acpi_nvs_nosave_s3(void);
FFFFFFFF 00000000          int __cdecl acpi_nvs_register(__u64 start, __u64 size);
FFFFFFFF 00000000          void acpi_old_suspend_ordering(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl acpi_os_acquire_lock(spinlock_t *handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_create_cache(char *cache_name, u16 object_size, u16 max_depth, kmem_cache **return_cache);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_create_semaphore(u32 max_units, u32 initial_units, void **out_handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_delete_cache(kmem_cache *cache);
FFFFFFFF 00000000          void __cdecl acpi_os_delete_lock(spinlock_t *handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_delete_semaphore(void *handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_enter_sleep(u8 sleep_state, u32 rega_value, u32 regb_value);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_execute(acpi_execute_type type, acpi_osd_exec_callback function, void *context);
FFFFFFFF 00000000          void *__cdecl acpi_os_get_iomem(acpi_physical_address phys, unsigned int size);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_get_physical_address(void *logical_address, acpi_physical_address *physical_address);
FFFFFFFF 00000000          acpi_physical_address acpi_os_get_root_pointer(void);
FFFFFFFF 00000000          u64 acpi_os_get_timer(void);
FFFFFFFF 00000000          acpi_status acpi_os_initialize(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_install_interrupt_handler(u32 interrupt_number, acpi_osd_handler service_routine, void *context);
FFFFFFFF 00000000          int __cdecl acpi_os_map_generic_address(acpi_generic_address *addr);
FFFFFFFF 00000000          void *__cdecl acpi_os_map_iomem(acpi_physical_address phys, acpi_size size);
FFFFFFFF 00000000          void *__cdecl acpi_os_map_memory(acpi_physical_address where, acpi_size length);
FFFFFFFF 00000000          acpi_status acpi_os_notify_command_complete(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_physical_table_override(acpi_table_header *existing_table, acpi_physical_address *new_address, u32 *new_table_length);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_predefined_override(const acpi_predefined_names *init_val, acpi_string *new_val);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a, u32 val_b);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_prepare_sleep(u8 sleep_state, u32 pm1a_control, u32 pm1b_control);
FFFFFFFF 00000000          void acpi_os_printf(const char *format, ...);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_purge_cache(kmem_cache *cache);
FFFFFFFF 00000000          int __cdecl acpi_os_read_iomem(void *virt_addr, u64 *value, u32 width);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_read_memory(acpi_physical_address address, u64 *value, u32 width);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_read_pci_configuration(acpi_pci_id *pci_id, u32 reg, u64 *value, u32 width);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_read_port(acpi_io_address address, u32 *value, u32 width);
FFFFFFFF 00000000          void __cdecl acpi_os_release_lock(spinlock_t *handle, unsigned __int64 flags);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_release_object(kmem_cache *cache, void *object);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_remove_interrupt_handler(u32 interrupt_number, acpi_osd_handler service_routine);
FFFFFFFF 00000000          void __cdecl acpi_os_set_prepare_extended_sleep(int (__cdecl *func)(u8, u32, u32));
FFFFFFFF 00000000          void __cdecl acpi_os_set_prepare_sleep(int (__cdecl *func)(u8, u32, u32));
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_signal(u32 function, void *info);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_signal_semaphore(void *handle, u32 units);
FFFFFFFF 00000000          void __cdecl acpi_os_sleep(u64 milliseconds);
FFFFFFFF 00000000          void __cdecl acpi_os_stall(u32 microseconds);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_table_override(acpi_table_header *existing_table, acpi_table_header **new_table);
FFFFFFFF 00000000          acpi_status acpi_os_terminate(void);
FFFFFFFF 00000000          void __cdecl acpi_os_trace_point(acpi_trace_event_type type, u8 begin, u8 *aml, char *pathname);
FFFFFFFF 00000000          void __cdecl acpi_os_unmap_generic_address(acpi_generic_address *addr);
FFFFFFFF 00000000          void __cdecl acpi_os_unmap_iomem(void *virt, acpi_size size);
FFFFFFFF 00000000          void __cdecl acpi_os_unmap_memory(void *logical_address, acpi_size size);
FFFFFFFF 00000000          void __cdecl acpi_os_vprintf(const char *format, va_list args);
FFFFFFFF 00000000          acpi_status acpi_os_wait_command_ready(void);
FFFFFFFF 00000000          void acpi_os_wait_events_complete(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_wait_semaphore(void *handle, u32 units, u16 timeout);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_write_memory(acpi_physical_address address, u64 value, u32 width);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_write_pci_configuration(acpi_pci_id *pci_id, u32 reg, u64 value, u32 width);
FFFFFFFF 00000000          acpi_status __cdecl acpi_os_write_port(acpi_io_address address, u32 value, u32 width);
FFFFFFFF 00000000          bool acpi_osi_is_win8(void);
FFFFFFFF 00000000          void __cdecl acpi_osi_setup(char *str);
FFFFFFFF 00000000          int __cdecl acpi_paddr_to_node(u64 start_addr, u64 size);
FFFFFFFF 00000000          int __cdecl acpi_parse_mcfg(acpi_table_header *header);
FFFFFFFF 00000000          int __cdecl acpi_parse_spcr(bool enable_earlycon, bool enable_console);
00000004 00000000          int acpi_pci_disabled;
FFFFFFFF 00000000          acpi_pci_root *__cdecl acpi_pci_find_root(acpi_handle handle);
FFFFFFFF 00000000          void __cdecl acpi_pci_irq_disable(pci_dev *dev);
FFFFFFFF 00000000          int __cdecl acpi_pci_irq_enable(pci_dev *dev);
FFFFFFFF 00000000          int __cdecl acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering, int *polarity, char **name);
FFFFFFFF 00000000          int __cdecl acpi_pci_link_free_irq(acpi_handle handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_pci_osc_control_set(acpi_handle handle, u32 *mask, u32 req);
FFFFFFFF 00000000          void __cdecl acpi_penalize_isa_irq(int irq, int active);
FFFFFFFF 00000000          void __cdecl acpi_penalize_sci_irq(int irq, int trigger, int polarity);
00000001 00000000          bool acpi_permanent_mmap;
FFFFFFFF 00000000          void __cdecl acpi_pic_sci_set_trigger(unsigned int, u16);
FFFFFFFF 00000000          int __cdecl acpi_platform_notify(device *dev, kobject_action action);
FFFFFFFF 00000000          bool __cdecl acpi_pm_device_can_wakeup(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_pm_device_sleep_state(device *, int *, int);
FFFFFFFF 00000000          int __cdecl acpi_pm_set_device_wakeup(device *dev, bool enable);
FFFFFFFF 00000000          void __cdecl acpi_pm_wakeup_event(device *dev);
FFFFFFFF 00000000          const char *__cdecl acpi_power_state_string(int state);
FFFFFFFF 00000000          acpi_status acpi_purge_cached_objects(void);
FFFFFFFF 00000000          void __cdecl acpi_put_table(acpi_table_header *table);
FFFFFFFF 00000000          acpi_status __cdecl acpi_read(u64 *value, acpi_generic_address *reg);
FFFFFFFF 00000000          acpi_status __cdecl acpi_read_bit_register(u32 register_id, u32 *return_value);
FFFFFFFF 00000000          acpi_status acpi_reallocate_root_table(void);
00000008 0000000000000000          unsigned __int64 acpi_realmode_flags;
FFFFFFFF 00000000          int __cdecl acpi_reconfig_notifier_register(notifier_block *nb);
FFFFFFFF 00000000          int __cdecl acpi_reconfig_notifier_unregister(notifier_block *nb);
FFFFFFFF 00000000          int __cdecl acpi_register_debugger(module *owner, const acpi_debugger_ops *ops);
FFFFFFFF 00000000          int __cdecl acpi_register_gsi(device *dev, u32 gsi, int triggering, int polarity);
FFFFFFFF 00000000          int __cdecl acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base);
FFFFFFFF 00000000          int __cdecl acpi_register_wakeup_handler(int wake_irq, bool (__cdecl *wakeup)(void *), void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_release_global_lock(u32 handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_release_memory(acpi_handle handle, resource *res, u32 level);
FFFFFFFF 00000000          acpi_status __cdecl acpi_release_mutex(acpi_handle handle, acpi_string pathname);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_address_space_handler(acpi_handle device, acpi_adr_space_type space_id, acpi_adr_space_handler handler);
FFFFFFFF 00000000          void __cdecl acpi_remove_dir(acpi_device *);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_fixed_event_handler(u32 acpi_event, acpi_event_handler handler);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_gpe_block(acpi_handle gpe_device);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_gpe_handler(acpi_handle gpe_device, u32 gpe_number, acpi_gpe_handler address);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_interface(acpi_string interface_name);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_notify_handler(acpi_handle device, u32 handler_type, acpi_notify_handler handler);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_pm_notifier(acpi_device *adev);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_sci_handler(acpi_sci_handler address);
FFFFFFFF 00000000          acpi_status __cdecl acpi_remove_table_handler(acpi_table_handler handler);
FFFFFFFF 00000000          void acpi_reserve_initial_tables(void);
FFFFFFFF 00000000          acpi_status acpi_reset(void);
FFFFFFFF 00000000          acpi_device *__cdecl acpi_resource_consumer(resource *res);
FFFFFFFF 00000000          acpi_status __cdecl acpi_resource_to_address64(acpi_resource *resource, acpi_resource_address64 *out);
FFFFFFFF 00000000          int acpi_resources_are_enforced(void);
00000008 0000000000000000          proc_dir_entry *acpi_root_dir;
FFFFFFFF 00000000          void __cdecl acpi_run_debugger(char *batch_buffer);
FFFFFFFF 00000000          acpi_status __cdecl acpi_run_osc(acpi_handle handle, acpi_osc_context *context);
FFFFFFFF 00000000          int __cdecl acpi_scan_add_handler(acpi_scan_handler *handler);
FFFFFFFF 00000000          void acpi_scan_lock_acquire(void);
FFFFFFFF 00000000          void acpi_scan_lock_release(void);
00000001 00000000          u8 acpi_sci_flags;
00000004 00000000          unsigned int acpi_sci_irq;
00000004 00000000          u32 acpi_sci_override_gsi;
FFFFFFFF 00000000          acpi_status __cdecl acpi_set_current_resources(acpi_handle device, acpi_buffer *in_buffer);
FFFFFFFF 00000000          void __cdecl acpi_set_debugger_thread_id(u64 thread_id);
FFFFFFFF 00000000          acpi_status __cdecl acpi_set_firmware_waking_vector(acpi_physical_address physical_address, acpi_physical_address physical_address64);
FFFFFFFF 00000000          acpi_status __cdecl acpi_set_gpe(acpi_handle gpe_device, u32 gpe_number, u8 action);
FFFFFFFF 00000000          acpi_status __cdecl acpi_set_gpe_wake_mask(acpi_handle gpe_device, u32 gpe_number, u8 action);
FFFFFFFF 00000000          void __cdecl acpi_set_irq_model(acpi_irq_model_id model, fwnode_handle *fwnode);
FFFFFFFF 00000000          void __cdecl acpi_set_modalias(acpi_device *adev, const char *default_id, char *modalias, size_t len);
FFFFFFFF 00000000          acpi_status __cdecl acpi_setup_gpe_for_wake(acpi_handle parent_device, acpi_handle gpe_device, u32 gpe_number);
00000004 00000000          int acpi_skip_timer_override;
FFFFFFFF 00000000          void acpi_sleep_no_blacklist(void);
FFFFFFFF 00000000          bool __cdecl acpi_sleep_state_supported(u8 sleep_state);
00000001 00000000          unsigned __int8 acpi_srat_revision;
00000078 00000000          const fwnode_operations acpi_static_fwnode_ops;
00000004 00000000          int acpi_strict;
FFFFFFFF 00000000          void __cdecl acpi_subsys_complete(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_freeze(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_poweroff(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_prepare(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_runtime_resume(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_runtime_suspend(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_suspend(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_suspend_late(device *dev);
FFFFFFFF 00000000          int __cdecl acpi_subsys_suspend_noirq(device *dev);
FFFFFFFF 00000000          void acpi_subsystem_init(void);
FFFFFFFF 00000000          acpi_status acpi_subsystem_status(void);
00000008 0000000000000000          int (*acpi_suspend_lowlevel)(void);
FFFFFFFF 00000000          int acpi_table_init(void);
FFFFFFFF 00000000          void acpi_table_init_complete(void);
FFFFFFFF 00000000          int __cdecl acpi_table_parse(char *id, acpi_tbl_table_handler handler);
FFFFFFFF 00000000          int __cdecl acpi_table_parse_entries(char *id, unsigned __int64 table_size, int entry_id, acpi_tbl_entry_handler handler, unsigned int max_entries);
FFFFFFFF 00000000          int __cdecl acpi_table_parse_entries_array(char *id, unsigned __int64 table_size, acpi_subtable_proc *proc, int proc_num, unsigned int max_entries);
FFFFFFFF 00000000          int __cdecl acpi_table_parse_madt(acpi_madt_type id, acpi_tbl_entry_handler handler, unsigned int max_entries);
FFFFFFFF 00000000          void __cdecl acpi_table_print_madt_entry(acpi_subtable_header *madt);
FFFFFFFF 00000000          void acpi_table_upgrade(void);
FFFFFFFF 00000000          u32 acpi_target_system_state(void);
FFFFFFFF 00000000          acpi_status acpi_terminate(void);
FFFFFFFF 00000000          void acpi_terminate_debugger(void);
FFFFFFFF 00000000          int __cdecl acpi_unbind_one(device *dev);
FFFFFFFF 00000000          acpi_status __cdecl acpi_unload_parent_table(acpi_handle object);
FFFFFFFF 00000000          void acpi_unlock_hp_context(void);
FFFFFFFF 00000000          int __cdecl acpi_unmap_cpu(int cpu);
FFFFFFFF 00000000          void __cdecl acpi_unregister_debugger(const acpi_debugger_ops *ops);
FFFFFFFF 00000000          void __cdecl acpi_unregister_gsi(u32 gsi);
FFFFFFFF 00000000          int __cdecl acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base);
FFFFFFFF 00000000          void __cdecl acpi_unregister_wakeup_handler(bool (__cdecl *wakeup)(void *), void *context);
FFFFFFFF 00000000          acpi_status acpi_update_all_gpes(void);
FFFFFFFF 00000000          acpi_status __cdecl acpi_update_interfaces(u8 action);
00000004 00000000          int acpi_use_timer_override;
00000000 00000000          char acpi_video_backlight_string[];
FFFFFFFF 00000000          void __cdecl acpi_walk_dep_device_list(acpi_handle handle);
FFFFFFFF 00000000          acpi_status __cdecl acpi_walk_namespace(acpi_object_type type, acpi_handle start_object, u32 max_depth, acpi_walk_callback descending_callback, acpi_walk_callback ascending_callback, void *context, void **return_value);
FFFFFFFF 00000000          acpi_status __cdecl acpi_walk_resource_buffer(acpi_buffer *buffer, acpi_walk_resource_callback user_function, void *context);
FFFFFFFF 00000000          acpi_status __cdecl acpi_walk_resources(acpi_handle device, char *name, acpi_walk_resource_callback user_function, void *context);
FFFFFFFF 00000000          void acpi_warning(const char *module_name, u32 line_number, const char *format, ...);
FFFFFFFF 00000000          acpi_status __cdecl acpi_write(u64 value, acpi_generic_address *reg);
FFFFFFFF 00000000          acpi_status __cdecl acpi_write_bit_register(u32 register_id, u32 value);
FFFFFFFF 00000000          void __cdecl add_disk_randomness(gendisk *disk);
FFFFFFFF 00000000          void __cdecl add_dma_domain(dma_domain *domain);
FFFFFFFF 00000000          int __cdecl add_memory(int nid, u64 start, u64 size);
FFFFFFFF 00000000          int __cdecl add_memory_resource(int nid, resource *resource);
FFFFFFFF 00000000          int __cdecl add_one_highpage(page *page, int pfn, int bad_ppro);
FFFFFFFF 00000000          void __cdecl add_page_wait_queue(page *page, wait_queue_entry_t *waiter);
FFFFFFFF 00000000          int __cdecl add_pages(int nid, unsigned __int64 start_pfn, unsigned __int64 nr_pages, mhp_restrictions *restrictions);
FFFFFFFF 00000000          hd_struct *__cdecl add_partition(gendisk *disk, int partno, sector_t start, sector_t len, int flags, partition_meta_info *info);
FFFFFFFF 00000000          int __cdecl add_range(range *range, int az, int nr_range, u64 start, u64 end);
FFFFFFFF 00000000          int __cdecl add_range_with_merge(range *range, int az, int nr_range, u64 start, u64 end);
FFFFFFFF 00000000          void __cdecl add_taint(unsigned int flag, lockdep_ok);
FFFFFFFF 00000000          void __cdecl add_timer(timer_list *timer);
FFFFFFFF 00000000          void __cdecl add_timer_on(timer_list *timer, int cpu);
FFFFFFFF 00000000          void __cdecl add_to_free_area_random(page *page, free_area *area, int migratetype);
FFFFFFFF 00000000          int __cdecl add_to_page_cache_locked(page *page, address_space *mapping, unsigned __int64 index, gfp_t gfp_mask);
FFFFFFFF 00000000          int __cdecl add_to_page_cache_lru(page *page, address_space *mapping, unsigned __int64 index, gfp_t gfp_mask);
FFFFFFFF 00000000          int add_uevent_var(kobj_uevent_env *env, const char *format, ...);
FFFFFFFF 00000000          void __cdecl add_wait_queue(wait_queue_head *wq_head, wait_queue_entry *wq_entry);
FFFFFFFF 00000000          void __cdecl add_wait_queue_exclusive(wait_queue_head *wq_head, wait_queue_entry *wq_entry);
FFFFFFFF 00000000          void __cdecl address_space_init_once(address_space *mapping);
FFFFFFFF 00000000          void __cdecl adjust_managed_page_count(page *page, __int64 count);
FFFFFFFF 00000000          int __cdecl adjust_resource(resource *res, resource_size_t start, resource_size_t size);
FFFFFFFF 00000000          int __cdecl alarm_cancel(alarm *alarm);
FFFFFFFF 00000000          ktime_t __cdecl alarm_expires_remaining(const alarm *alarm);
FFFFFFFF 00000000          u64 __cdecl alarm_forward(alarm *alarm, ktime_t now, ktime_t interval);
FFFFFFFF 00000000          u64 __cdecl alarm_forward_now(alarm *alarm, ktime_t interval);
FFFFFFFF 00000000          void __cdecl alarm_init(alarm *alarm, alarmtimer_type type, alarmtimer_restart (__cdecl *function)(alarm *, ktime_t));
FFFFFFFF 00000000          void __cdecl alarm_restart(alarm *alarm);
FFFFFFFF 00000000          void __cdecl alarm_start(alarm *alarm, ktime_t start);
FFFFFFFF 00000000          void __cdecl alarm_start_relative(alarm *alarm, ktime_t start);
FFFFFFFF 00000000          int __cdecl alarm_try_to_cancel(alarm *alarm);
FFFFFFFF 00000000          rtc_device *alarmtimer_get_rtcdev(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl align_vdso_addr(unsigned __int64);
FFFFFFFF 00000000          void __cdecl all_vm_events(unsigned __int64 *);
FFFFFFFF 00000000          inode *__cdecl alloc_anon_inode(super_block *);
FFFFFFFF 00000000          void __cdecl alloc_bootmem_cpumask_var(cpumask_var_t *mask);
FFFFFFFF 00000000          int __cdecl alloc_chrdev_region(dev_t *, unsigned int, unsigned int, const char *);
FFFFFFFF 00000000          int __cdecl alloc_contig_range(unsigned __int64 start, unsigned __int64 end, unsigned int migratetype, gfp_t gfp_mask);
FFFFFFFF 00000000          bool __cdecl alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
FFFFFFFF 00000000          bool __cdecl alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
FFFFFFFF 00000000          file *__cdecl alloc_file_clone(file *, int flags, const file_operations *);
FFFFFFFF 00000000          file *__cdecl alloc_file_pseudo(inode *, vfsmount *, const char *, int flags, const file_operations *);
FFFFFFFF 00000000          page *__cdecl alloc_pages_current(gfp_t gfp_mask, unsigned int order);
FFFFFFFF 00000000          void *__cdecl alloc_pages_exact(size_t size, gfp_t gfp_mask);
FFFFFFFF 00000000          void *__cdecl alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);
FFFFFFFF 00000000          page *__cdecl alloc_pages_vma(gfp_t gfp_mask, int order, vm_area_struct *vma, unsigned __int64 addr, int node, bool hugepage);
FFFFFFFF 00000000          pid *__cdecl alloc_pid(pid_namespace *ns);
FFFFFFFF 00000000          vm_fault_t __cdecl alloc_set_pte(vm_fault *vmf, mem_cgroup *memcg, page *page);
FFFFFFFF 00000000          user_struct *__cdecl alloc_uid(kuid_t);
FFFFFFFF 00000000          vm_struct *__cdecl alloc_vm_area(size_t size, pte_t **ptes);
FFFFFFFF 00000000          workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active, ...);
FFFFFFFF 00000000          workqueue_attrs *alloc_workqueue_attrs(void);
FFFFFFFF 00000000          int __cdecl allocate_resource(resource *root, resource *new, resource_size_t size, resource_size_t min, resource_size_t max, resource_size_t align, resource_size_t (__cdecl *alignf)(void *, const resource *, resource_size_t, resource_size_t), void *alignf_data);
FFFFFFFF 00000000          bool __cdecl allow_online_pfn_range(int nid, unsigned __int64 pfn, unsigned __int64 nr_pages, int online_type);
FFFFFFFF 00000000          void alternative_instructions(void);
FFFFFFFF 00000000          void alternatives_enable_smp(void);
00000004 00000000          int alternatives_patched;
FFFFFFFF 00000000          void __cdecl alternatives_smp_module_add(module *mod, char *name, void *locks, void *locks_end, void *text, void *text_end);
FFFFFFFF 00000000          void __cdecl alternatives_smp_module_del(module *mod);
FFFFFFFF 00000000          int __cdecl alternatives_text_reserved(void *start, void *end);
FFFFFFFF 00000000          void *__cdecl altmap_alloc_block_buf(unsigned __int64 size, vmem_altmap *altmap);
FFFFFFFF 00000000          int __cdecl always_delete_dentry(const dentry *);
FFFFFFFF 00000000          void amd_e400_c1e_apic_setup(void);
FFFFFFFF 00000000          u16 __cdecl amd_get_nb_id(int cpu);
FFFFFFFF 00000000          u32 amd_get_nodes_per_socket(void);
FFFFFFFF 00000000          void __cdecl anon_vma_interval_tree_insert(anon_vma_chain *node, rb_root_cached *root);
FFFFFFFF 00000000          anon_vma_chain *__cdecl anon_vma_interval_tree_iter_first(rb_root_cached *root, unsigned __int64 start, unsigned __int64 last);
FFFFFFFF 00000000          anon_vma_chain *__cdecl anon_vma_interval_tree_iter_next(anon_vma_chain *node, unsigned __int64 start, unsigned __int64 last);
FFFFFFFF 00000000          void __cdecl anon_vma_interval_tree_remove(anon_vma_chain *node, rb_root_cached *root);
00000008 0000000000000000          apic *apic;
FFFFFFFF 00000000          void __cdecl apic_ack_irq(irq_data *data);
FFFFFFFF 00000000          void apic_ap_setup(void);
FFFFFFFF 00000000          u32 __cdecl apic_default_calc_apicid(unsigned int cpu);
FFFFFFFF 00000000          u32 __cdecl apic_flat_calc_apicid(unsigned int cpu);
FFFFFFFF 00000000          bool __cdecl apic_id_is_primary_thread(unsigned int id);
00000004 00000000          apic_intr_mode_id apic_intr_mode;
FFFFFFFF 00000000          void apic_intr_mode_init(void);
FFFFFFFF 00000000          void apic_intr_mode_select(void);
FFFFFFFF 00000000          int apic_is_clustered_box(void);
FFFFFFFF 00000000          bool apic_needs_pit(void);
00000110 00000000          apic apic_noop;
FFFFFFFF 00000000          void __cdecl apic_send_IPI_allbutself(unsigned int vector);
FFFFFFFF 00000000          void __cdecl apic_set_eoi_write(void (__cdecl *eoi_write)(u32, u32));
FFFFFFFF 00000000          void apic_smt_update(void);
FFFFFFFF 00000000          void apic_soft_disable(void);
00000004 00000000          int apic_verbosity;
00000030 00000000          apm_info apm_info;
FFFFFFFF 00000000          void __cdecl apply_alternatives(alt_instr *start, alt_instr *end);
FFFFFFFF 00000000          int __cdecl apply_to_page_range(mm_struct *mm, unsigned __int64 address, unsigned __int64 size, pte_fn_t fn, void *data);
FFFFFFFF 00000000          int __cdecl apply_workqueue_attrs(workqueue_struct *wq, const workqueue_attrs *attrs);
FFFFFFFF 00000000          int __cdecl arch_add_memory(int nid, u64 start, u64 size, mhp_restrictions *restrictions);
FFFFFFFF 00000000          unsigned __int64 __cdecl arch_align_stack(unsigned __int64 sp);
FFFFFFFF 00000000          void arch_disable_smp_support(void);
FFFFFFFF 00000000          int __cdecl arch_dup_task_struct(task_struct *dst, task_struct *src);
FFFFFFFF 00000000          int arch_early_ioapic_init(void);
FFFFFFFF 00000000          int arch_early_irq_init(void);
FFFFFFFF 00000000          void arch_enable_nonboot_cpus_begin(void);
FFFFFFFF 00000000          void arch_enable_nonboot_cpus_end(void);
FFFFFFFF 00000000          void arch_init_ideal_nops(void);
FFFFFFFF 00000000          void __cdecl arch_io_free_memtype_wc(resource_size_t start, resource_size_t size);
FFFFFFFF 00000000          int __cdecl arch_io_reserve_memtype_wc(resource_size_t start, resource_size_t size);
FFFFFFFF 00000000          int arch_ioremap_p4d_supported(void);
FFFFFFFF 00000000          int arch_ioremap_pmd_supported(void);
FFFFFFFF 00000000          int arch_ioremap_pud_supported(void);
FFFFFFFF 00000000          u64 arch_irq_stat(void);
FFFFFFFF 00000000          u64 __cdecl arch_irq_stat_cpu(unsigned int cpu);
FFFFFFFF 00000000          void __cdecl arch_jump_label_transform(jump_entry *entry, jump_label_type type);
FFFFFFFF 00000000          void arch_jump_label_transform_apply(void);
FFFFFFFF 00000000          bool __cdecl arch_jump_label_transform_queue(jump_entry *entry, jump_label_type type);
FFFFFFFF 00000000          void __cdecl arch_jump_label_transform_static(jump_entry *entry, jump_label_type type);
FFFFFFFF 00000000          bool __cdecl arch_memremap_can_ram_remap(resource_size_t offset, unsigned __int64 size, unsigned __int64 flags);
FFFFFFFF 00000000          int __cdecl arch_phys_wc_add(unsigned __int64 base, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl arch_phys_wc_del(int handle);
FFFFFFFF 00000000          int __cdecl arch_phys_wc_index(int handle);
FFFFFFFF 00000000          void arch_post_acpi_subsys_init(void);
FFFFFFFF 00000000          int arch_probe_nr_irqs(void);
FFFFFFFF 00000000          void __cdecl arch_release_task_struct(task_struct *tsk);
FFFFFFFF 00000000          void __cdecl arch_remove_memory(int nid, u64 start, u64 size, vmem_altmap *altmap);
FFFFFFFF 00000000          void __cdecl arch_remove_reservations(resource *avail);
FFFFFFFF 00000000          void __cdecl arch_report_meminfo(seq_file *m);
FFFFFFFF 00000000          void __cdecl arch_reserve_mem_area(acpi_physical_address addr, size_t size);
FFFFFFFF 00000000          int __cdecl arch_setup_additional_pages(linux_binprm *bprm, int uses_interp);
FFFFFFFF 00000000          void arch_setup_new_exec(void);
FFFFFFFF 00000000          int __cdecl arch_show_interrupts(seq_file *p, int prec);
FFFFFFFF 00000000          void __cdecl arch_stack_walk(stack_trace_consume_fn consume_entry, void *cookie, task_struct *task, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl arch_stack_walk_reliable(stack_trace_consume_fn consume_entry, void *cookie, task_struct *task);
FFFFFFFF 00000000          void __cdecl arch_stack_walk_user(stack_trace_consume_fn consume_entry, void *cookie, const pt_regs *regs);
FFFFFFFF 00000000          void arch_task_cache_init(void);
FFFFFFFF 00000000          void __cdecl arch_trigger_cpumask_backtrace(const cpumask *mask, bool exclude_self);
FFFFFFFF 00000000          int arch_update_cpu_topology(void);
FFFFFFFF 00000000          void __cdecl arch_uprobe_abort_xol(arch_uprobe *aup, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl arch_uprobe_analyze_insn(arch_uprobe *aup, mm_struct *mm, unsigned __int64 addr);
FFFFFFFF 00000000          void __cdecl arch_uprobe_copy_ixol(page *page, unsigned __int64 vaddr, void *src, unsigned __int64 len);
FFFFFFFF 00000000          int __cdecl arch_uprobe_exception_notify(notifier_block *self, unsigned __int64 val, void *data);
FFFFFFFF 00000000          bool __cdecl arch_uprobe_ignore(arch_uprobe *aup, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl arch_uprobe_post_xol(arch_uprobe *aup, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl arch_uprobe_pre_xol(arch_uprobe *aup, pt_regs *regs);
FFFFFFFF 00000000          bool __cdecl arch_uprobe_skip_sstep(arch_uprobe *aup, pt_regs *regs);
FFFFFFFF 00000000          bool __cdecl arch_uprobe_xol_was_trapped(task_struct *tsk);
FFFFFFFF 00000000          unsigned __int64 __cdecl arch_uretprobe_hijack_return_addr(unsigned __int64 trampoline_vaddr, pt_regs *regs);
FFFFFFFF 00000000          bool __cdecl arch_uretprobe_is_alive(return_instance *ret, rp_check ctx, pt_regs *regs);
FFFFFFFF 00000000          const char *__cdecl arch_vma_name(vm_area_struct *vma);
FFFFFFFF 00000000          void __cdecl argv_free(char **argv);
FFFFFFFF 00000000          char **__cdecl argv_split(gfp_t gfp, const char *str, int *argcp);
FFFFFFFF 00000000          int __cdecl array_map_alloc_check(bpf_attr *attr);
000000A8 00000000          const bpf_map_ops array_map_ops;
000000A8 00000000          const bpf_map_ops array_of_maps_map_ops;
FFFFFFFF 00000000          void __cdecl assoc_array_apply_edit(assoc_array_edit *edit);
FFFFFFFF 00000000          void __cdecl assoc_array_cancel_edit(assoc_array_edit *edit);
FFFFFFFF 00000000          assoc_array_edit *__cdecl assoc_array_clear(assoc_array *array, const assoc_array_ops *ops);
FFFFFFFF 00000000          assoc_array_edit *__cdecl assoc_array_delete(assoc_array *array, const assoc_array_ops *ops, const void *index_key);
FFFFFFFF 00000000          void __cdecl assoc_array_destroy(assoc_array *array, const assoc_array_ops *ops);
FFFFFFFF 00000000          void *__cdecl assoc_array_find(const assoc_array *array, const assoc_array_ops *ops, const void *index_key);
FFFFFFFF 00000000          int __cdecl assoc_array_gc(assoc_array *array, const assoc_array_ops *ops, bool (__cdecl *iterator)(void *, void *), void *iterator_data);
FFFFFFFF 00000000          assoc_array_edit *__cdecl assoc_array_insert(assoc_array *array, const assoc_array_ops *ops, const void *index_key, void *object);
FFFFFFFF 00000000          void __cdecl assoc_array_insert_set_object(assoc_array_edit *edit, void *object);
FFFFFFFF 00000000          int __cdecl assoc_array_iterate(const assoc_array *array, int (__cdecl *iterator)(const void *, void *), void *iterator_data);
FFFFFFFF 00000000          bool __cdecl atime_needs_update(const path *, inode *);
FFFFFFFF 00000000          int __cdecl atomic_dec_and_mutex_lock(atomic_t *cnt, mutex *lock);
FFFFFFFF 00000000          int __cdecl atomic_notifier_call_chain(atomic_notifier_head *nh, unsigned __int64 val, void *v);
FFFFFFFF 00000000          int __cdecl atomic_notifier_chain_register(atomic_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          int __cdecl atomic_notifier_chain_unregister(atomic_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          void __cdecl attach_pid(task_struct *task, pid_type);
FFFFFFFF 00000000          int __cdecl autoremove_wake_function(wait_queue_entry *wq_entry, unsigned int mode, int sync, void *key);
FFFFFFFF 00000000          int __cdecl available_idle_cpu(int cpu);
FFFFFFFF 00000000          void bad_srat(void);
FFFFFFFF 00000000          int __cdecl bcmp(const void *, const void *, __kernel_size_t);
FFFFFFFF 00000000          void __cdecl bd_abort_claiming(block_device *bdev, block_device *whole, void *holder);
FFFFFFFF 00000000          void __cdecl bd_finish_claiming(block_device *bdev, block_device *whole, void *holder);
FFFFFFFF 00000000          void __cdecl bd_forget(inode *inode);
FFFFFFFF 00000000          int __cdecl bd_link_disk_holder(block_device *bdev, gendisk *disk);
FFFFFFFF 00000000          void __cdecl bd_set_size(block_device *, loff_t size);
FFFFFFFF 00000000          block_device *__cdecl bd_start_claiming(block_device *bdev, void *holder);
FFFFFFFF 00000000          void __cdecl bd_unlink_disk_holder(block_device *bdev, gendisk *disk);
FFFFFFFF 00000000          int __cdecl bdev_read_only(block_device *);
FFFFFFFF 00000000          int __cdecl bdev_read_page(block_device *, sector_t, page *);
FFFFFFFF 00000000          int __cdecl bdev_stack_limits(queue_limits *t, block_device *bdev, sector_t offset);
FFFFFFFF 00000000          void __cdecl bdev_unhash_inode(dev_t dev);
FFFFFFFF 00000000          int __cdecl bdev_write_page(block_device *, sector_t, page *, writeback_control *);
FFFFFFFF 00000000          const char *__cdecl bdevname(block_device *bdev, char *buffer);
FFFFFFFF 00000000          block_device *__cdecl bdget(dev_t);
FFFFFFFF 00000000          block_device *__cdecl bdget_disk(gendisk *disk, int partno);
FFFFFFFF 00000000          block_device *__cdecl bdgrab(block_device *bdev);
FFFFFFFF 00000000          void __cdecl bdput(block_device *);
FFFFFFFF 00000000          char *__cdecl bin2hex(char *dst, const void *src, size_t count);
FFFFFFFF 00000000          int __cdecl bio_add_page(bio *, page *, unsigned int, unsigned int);
FFFFFFFF 00000000          int __cdecl bio_add_pc_page(request_queue *, bio *, page *, unsigned int, unsigned int);
FFFFFFFF 00000000          void __cdecl bio_advance(bio *, unsigned int);
FFFFFFFF 00000000          bio *__cdecl bio_alloc_bioset(gfp_t, unsigned int, bio_set *);
FFFFFFFF 00000000          void __cdecl bio_associate_blkg(bio *bio);
FFFFFFFF 00000000          void __cdecl bio_associate_blkg_from_css(bio *bio, cgroup_subsys_state *css);
FFFFFFFF 00000000          void __cdecl bio_associate_blkg_from_page(bio *bio, page *page);
FFFFFFFF 00000000          void __cdecl bio_chain(bio *, bio *);
FFFFFFFF 00000000          void __cdecl bio_check_pages_dirty(bio *bio);
FFFFFFFF 00000000          void __cdecl bio_clone_blkg_association(bio *dst, bio *src);
FFFFFFFF 00000000          bio *__cdecl bio_clone_fast(bio *, gfp_t, bio_set *);
FFFFFFFF 00000000          void __cdecl bio_copy_data(bio *dst, bio *src);
FFFFFFFF 00000000          void __cdecl bio_copy_data_iter(bio *dst, bvec_iter *dst_iter, bio *src, bvec_iter *src_iter);
FFFFFFFF 00000000          bio *__cdecl bio_copy_kern(request_queue *, void *, unsigned int, gfp_t, int);
FFFFFFFF 00000000          bio *__cdecl bio_copy_user_iov(request_queue *, rq_map_data *, iov_iter *, gfp_t);
FFFFFFFF 00000000          const char *__cdecl bio_devname(bio *bio, char *buffer);
FFFFFFFF 00000000          void __cdecl bio_disassociate_blkg(bio *bio);
FFFFFFFF 00000000          void __cdecl bio_endio(bio *);
FFFFFFFF 00000000          void __cdecl bio_free_pages(bio *bio);
FFFFFFFF 00000000          void __cdecl bio_init(bio *bio, bio_vec *table, unsigned __int16 max_vecs);
FFFFFFFF 00000000          int __cdecl bio_integrity_add_page(bio *, page *, unsigned int, unsigned int);
FFFFFFFF 00000000          void __cdecl bio_integrity_advance(bio *, unsigned int);
FFFFFFFF 00000000          bio_integrity_payload *__cdecl bio_integrity_alloc(bio *, gfp_t, unsigned int);
FFFFFFFF 00000000          int __cdecl bio_integrity_clone(bio *, bio *, gfp_t);
FFFFFFFF 00000000          void bio_integrity_init(void);
FFFFFFFF 00000000          bool __cdecl bio_integrity_prep(bio *);
FFFFFFFF 00000000          void __cdecl bio_integrity_trim(bio *);
FFFFFFFF 00000000          int __cdecl bio_iov_iter_get_pages(bio *bio, iov_iter *iter);
FFFFFFFF 00000000          void __cdecl bio_list_copy_data(bio *dst, bio *src);
FFFFFFFF 00000000          bio *__cdecl bio_map_kern(request_queue *, void *, unsigned int, gfp_t);
FFFFFFFF 00000000          bio *__cdecl bio_map_user_iov(request_queue *, iov_iter *, gfp_t);
FFFFFFFF 00000000          void __cdecl bio_put(bio *);
FFFFFFFF 00000000          void __cdecl bio_release_pages(bio *bio, bool mark_dirty);
FFFFFFFF 00000000          void __cdecl bio_reset(bio *);
FFFFFFFF 00000000          void __cdecl bio_set_pages_dirty(bio *bio);
FFFFFFFF 00000000          bio *__cdecl bio_split(bio *bio, int sectors, gfp_t gfp, bio_set *bs);
FFFFFFFF 00000000          void __cdecl bio_trim(bio *bio, int offset, int size);
FFFFFFFF 00000000          void __cdecl bio_truncate(bio *bio, unsigned int new_size);
FFFFFFFF 00000000          int __cdecl bio_uncopy_user(bio *);
FFFFFFFF 00000000          void __cdecl bio_uninit(bio *);
FFFFFFFF 00000000          void __cdecl bio_unmap_user(bio *);
FFFFFFFF 00000000          void __cdecl bioset_exit(bio_set *);
FFFFFFFF 00000000          int __cdecl bioset_init(bio_set *, unsigned int, unsigned int, int flags);
FFFFFFFF 00000000          int __cdecl bioset_init_from_src(bio_set *bs, bio_set *src);
FFFFFFFF 00000000          int __cdecl bioset_integrity_create(bio_set *, int);
FFFFFFFF 00000000          void __cdecl bioset_integrity_free(bio_set *);
FFFFFFFF 00000000          int __cdecl biovec_init_pool(mempool_t *pool, int pool_entries);
FFFFFFFF 00000000          int __cdecl bit_wait(wait_bit_key *key, int mode);
FFFFFFFF 00000000          int __cdecl bit_wait_io(wait_bit_key *key, int mode);
FFFFFFFF 00000000          int __cdecl bit_wait_io_timeout(wait_bit_key *key, int mode);
FFFFFFFF 00000000          int __cdecl bit_wait_timeout(wait_bit_key *key, int mode);
FFFFFFFF 00000000          wait_queue_head *__cdecl bit_waitqueue(void *word, int bit);
FFFFFFFF 00000000          unsigned __int64 *__cdecl bitmap_alloc(unsigned int nbits, gfp_t flags);
FFFFFFFF 00000000          int __cdecl bitmap_allocate_region(unsigned __int64 *bitmap, unsigned int pos, int order);
FFFFFFFF 00000000          int __cdecl bitmap_bitremap(int oldbit, const unsigned __int64 *old, const unsigned __int64 *new, int bits);
FFFFFFFF 00000000          int __cdecl bitmap_find_free_region(unsigned __int64 *bitmap, unsigned int bits, int order);
FFFFFFFF 00000000          unsigned __int64 __cdecl bitmap_find_next_zero_area_off(unsigned __int64 *map, unsigned __int64 size, unsigned __int64 start, unsigned int nr, unsigned __int64 align_mask, unsigned __int64 align_offset);
FFFFFFFF 00000000          void __cdecl bitmap_fold(unsigned __int64 *dst, const unsigned __int64 *orig, unsigned int sz, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl bitmap_free(const unsigned __int64 *bitmap);
FFFFFFFF 00000000          void __cdecl bitmap_from_arr32(unsigned __int64 *bitmap, const u32 *buf, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl bitmap_onto(unsigned __int64 *dst, const unsigned __int64 *orig, const unsigned __int64 *relmap, unsigned int bits);
FFFFFFFF 00000000          unsigned int __cdecl bitmap_ord_to_pos(const unsigned __int64 *bitmap, unsigned int ord, unsigned int nbits);
FFFFFFFF 00000000          int __cdecl bitmap_parse_user(const char *ubuf, unsigned int ulen, unsigned __int64 *dst, int nbits);
FFFFFFFF 00000000          int __cdecl bitmap_parselist(const char *buf, unsigned __int64 *maskp, int nmaskbits);
FFFFFFFF 00000000          int __cdecl bitmap_parselist_user(const char *ubuf, unsigned int ulen, unsigned __int64 *dst, int nbits);
FFFFFFFF 00000000          int __cdecl bitmap_print_to_pagebuf(bool list, char *buf, const unsigned __int64 *maskp, int nmaskbits);
FFFFFFFF 00000000          void __cdecl bitmap_release_region(unsigned __int64 *bitmap, unsigned int pos, int order);
FFFFFFFF 00000000          void __cdecl bitmap_remap(unsigned __int64 *dst, const unsigned __int64 *src, const unsigned __int64 *old, const unsigned __int64 *new, unsigned int nbits);
FFFFFFFF 00000000          void __cdecl bitmap_to_arr32(u32 *buf, const unsigned __int64 *bitmap, unsigned int nbits);
FFFFFFFF 00000000          unsigned __int64 *__cdecl bitmap_zalloc(unsigned int nbits, gfp_t flags);
FFFFFFFF 00000000          void __cdecl blk_abort_request(request *);
FFFFFFFF 00000000          int __cdecl blk_alloc_devt(hd_struct *part, dev_t *devt);
FFFFFFFF 00000000          request_queue *__cdecl blk_alloc_queue(gfp_t);
FFFFFFFF 00000000          request_queue *__cdecl blk_alloc_queue_node(gfp_t gfp_mask, int node_id);
FFFFFFFF 00000000          blk_plug_cb *__cdecl blk_check_plugged(blk_plug_cb_fn unplug, void *data, int size);
FFFFFFFF 00000000          void __cdecl blk_cleanup_queue(request_queue *);
FFFFFFFF 00000000          void __cdecl blk_clear_pm_only(request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_dump_rq_flags(request *, char *);
FFFFFFFF 00000000          void __cdecl blk_execute_rq(request_queue *, gendisk *, request *, int);
FFFFFFFF 00000000          void __cdecl blk_execute_rq_nowait(request_queue *, gendisk *, request *, int, rq_end_io_fn *);
FFFFFFFF 00000000          void __cdecl blk_finish_plug(blk_plug *);
FFFFFFFF 00000000          void __cdecl blk_flush_plug_list(blk_plug *, bool);
FFFFFFFF 00000000          void __cdecl blk_free_devt(dev_t devt);
FFFFFFFF 00000000          bool __cdecl blk_get_queue(request_queue *);
FFFFFFFF 00000000          request *__cdecl blk_get_request(request_queue *, unsigned int op, blk_mq_req_flags_t flags);
FFFFFFFF 00000000          blk_status_t __cdecl blk_insert_cloned_request(request_queue *q, request *rq);
FFFFFFFF 00000000          void __cdecl blk_integrity_add(gendisk *);
FFFFFFFF 00000000          int __cdecl blk_integrity_compare(gendisk *, gendisk *);
FFFFFFFF 00000000          void __cdecl blk_integrity_del(gendisk *);
FFFFFFFF 00000000          bool __cdecl blk_integrity_merge_bio(request_queue *, request *, bio *);
FFFFFFFF 00000000          bool __cdecl blk_integrity_merge_rq(request_queue *, request *, request *);
FFFFFFFF 00000000          void __cdecl blk_integrity_register(gendisk *, blk_integrity *);
FFFFFFFF 00000000          void __cdecl blk_integrity_unregister(gendisk *);
FFFFFFFF 00000000          void __cdecl blk_invalidate_devt(dev_t devt);
FFFFFFFF 00000000          void __cdecl blk_limits_io_min(queue_limits *limits, unsigned int min);
FFFFFFFF 00000000          void __cdecl blk_limits_io_opt(queue_limits *limits, unsigned int opt);
FFFFFFFF 00000000          int __cdecl blk_lld_busy(request_queue *q);
FFFFFFFF 00000000          dev_t __cdecl blk_lookup_devt(const char *name, int partno);
00000008 0000000000000000          unsigned __int64 blk_max_low_pfn;
00000008 0000000000000000          unsigned __int64 blk_max_pfn;
FFFFFFFF 00000000          const char *__cdecl blk_op_str(unsigned int op);
FFFFFFFF 00000000          int __cdecl blk_poll(request_queue *q, blk_qc_t cookie, bool spin);
FFFFFFFF 00000000          void __cdecl blk_put_queue(request_queue *);
FFFFFFFF 00000000          void __cdecl blk_put_request(request *);
FFFFFFFF 00000000          void __cdecl blk_queue_alignment_offset(request_queue *q, unsigned int alignment);
FFFFFFFF 00000000          void __cdecl blk_queue_bounce_limit(request_queue *, u64);
FFFFFFFF 00000000          bool __cdecl blk_queue_can_use_dma_map_merging(request_queue *q, device *dev);
FFFFFFFF 00000000          void __cdecl blk_queue_chunk_sectors(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_dma_alignment(request_queue *, int);
FFFFFFFF 00000000          int __cdecl blk_queue_dma_drain(request_queue *q, dma_drain_needed_fn *dma_drain_needed, void *buf, unsigned int size);
FFFFFFFF 00000000          int __cdecl blk_queue_enter(request_queue *q, blk_mq_req_flags_t flags);
FFFFFFFF 00000000          void __cdecl blk_queue_exit(request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_queue_flag_clear(unsigned int flag, request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_queue_flag_set(unsigned int flag, request_queue *q);
FFFFFFFF 00000000          bool __cdecl blk_queue_flag_test_and_set(unsigned int flag, request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_queue_io_min(request_queue *q, unsigned int min);
FFFFFFFF 00000000          void __cdecl blk_queue_io_opt(request_queue *q, unsigned int opt);
FFFFFFFF 00000000          void __cdecl blk_queue_logical_block_size(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_make_request(request_queue *, make_request_fn *);
FFFFFFFF 00000000          void __cdecl blk_queue_max_discard_sectors(request_queue *q, unsigned int max_discard_sectors);
FFFFFFFF 00000000          void __cdecl blk_queue_max_discard_segments(request_queue *, unsigned __int16);
FFFFFFFF 00000000          void __cdecl blk_queue_max_hw_sectors(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_max_segment_size(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_max_segments(request_queue *, unsigned __int16);
FFFFFFFF 00000000          void __cdecl blk_queue_max_write_same_sectors(request_queue *q, unsigned int max_write_same_sectors);
FFFFFFFF 00000000          void __cdecl blk_queue_max_write_zeroes_sectors(request_queue *q, unsigned int max_write_same_sectors);
FFFFFFFF 00000000          void __cdecl blk_queue_physical_block_size(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_required_elevator_features(request_queue *q, unsigned int features);
FFFFFFFF 00000000          void __cdecl blk_queue_rq_timeout(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_segment_boundary(request_queue *, unsigned __int64);
FFFFFFFF 00000000          void __cdecl blk_queue_split(request_queue *, bio **);
FFFFFFFF 00000000          void __cdecl blk_queue_stack_limits(request_queue *t, request_queue *b);
FFFFFFFF 00000000          void __cdecl blk_queue_update_dma_alignment(request_queue *, int);
FFFFFFFF 00000000          void __cdecl blk_queue_update_dma_pad(request_queue *, unsigned int);
FFFFFFFF 00000000          void __cdecl blk_queue_virt_boundary(request_queue *, unsigned __int64);
FFFFFFFF 00000000          void __cdecl blk_queue_write_cache(request_queue *q, bool enabled, bool fua);
FFFFFFFF 00000000          int __cdecl blk_register_queue(gendisk *disk);
FFFFFFFF 00000000          void __cdecl blk_register_region(dev_t devt, unsigned __int64 range, module *module, kobject *(__cdecl *probe)(dev_t, int *, void *), int (__cdecl *lock)(dev_t, void *), void *data);
FFFFFFFF 00000000          bool __cdecl blk_req_needs_zone_write_lock(request *rq);
FFFFFFFF 00000000          int __cdecl blk_revalidate_disk_zones(gendisk *disk);
FFFFFFFF 00000000          int __cdecl blk_rq_append_bio(request *rq, bio **bio);
FFFFFFFF 00000000          int __cdecl blk_rq_count_integrity_sg(request_queue *, bio *);
FFFFFFFF 00000000          unsigned int __cdecl blk_rq_err_bytes(const request *rq);
FFFFFFFF 00000000          void __cdecl blk_rq_init(request_queue *q, request *rq);
FFFFFFFF 00000000          int __cdecl blk_rq_map_integrity_sg(request_queue *, bio *, scatterlist *);
FFFFFFFF 00000000          int __cdecl blk_rq_map_kern(request_queue *, request *, void *, unsigned int, gfp_t);
FFFFFFFF 00000000          int __cdecl blk_rq_map_sg(request_queue *, request *, scatterlist *);
FFFFFFFF 00000000          int __cdecl blk_rq_map_user(request_queue *, request *, rq_map_data *, void *, unsigned __int64, gfp_t);
FFFFFFFF 00000000          int __cdecl blk_rq_map_user_iov(request_queue *, request *, rq_map_data *, const iov_iter *, gfp_t);
FFFFFFFF 00000000          int __cdecl blk_rq_prep_clone(request *rq, request *rq_src, bio_set *bs, gfp_t gfp_mask, int (__cdecl *bio_ctr)(bio *, bio *, void *), void *data);
FFFFFFFF 00000000          int __cdecl blk_rq_unmap_user(bio *);
FFFFFFFF 00000000          void __cdecl blk_rq_unprep_clone(request *rq);
FFFFFFFF 00000000          void __cdecl blk_set_default_limits(queue_limits *lim);
FFFFFFFF 00000000          void __cdecl blk_set_pm_only(request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_set_queue_depth(request_queue *q, unsigned int depth);
FFFFFFFF 00000000          void __cdecl blk_set_queue_dying(request_queue *);
FFFFFFFF 00000000          void __cdecl blk_set_stacking_limits(queue_limits *lim);
FFFFFFFF 00000000          int __cdecl blk_stack_limits(queue_limits *t, queue_limits *b, sector_t offset);
FFFFFFFF 00000000          void __cdecl blk_start_plug(blk_plug *);
FFFFFFFF 00000000          int __cdecl blk_status_to_errno(blk_status_t status);
FFFFFFFF 00000000          void __cdecl blk_steal_bios(bio_list *list, request *rq);
FFFFFFFF 00000000          void __cdecl blk_sync_queue(request_queue *q);
FFFFFFFF 00000000          void __cdecl blk_unregister_queue(gendisk *disk);
FFFFFFFF 00000000          void __cdecl blk_unregister_region(dev_t devt, unsigned __int64 range);
FFFFFFFF 00000000          bool __cdecl blk_update_request(request *rq, blk_status_t error, unsigned int nr_bytes);
FFFFFFFF 00000000          int __cdecl blk_verify_command(unsigned __int8 *cmd, fmode_t mode);
FFFFFFFF 00000000          int __cdecl blkdev_fsync(file *filp, loff_t start, loff_t end, int datasync);
FFFFFFFF 00000000          int __cdecl blkdev_get(block_device *bdev, fmode_t mode, void *holder);
FFFFFFFF 00000000          block_device *__cdecl blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder);
FFFFFFFF 00000000          block_device *__cdecl blkdev_get_by_path(const char *path, fmode_t mode, void *holder);
FFFFFFFF 00000000          int __cdecl blkdev_ioctl(block_device *, fmode_t, unsigned int, unsigned __int64);
FFFFFFFF 00000000          int __cdecl blkdev_issue_discard(block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, unsigned __int64 flags);
FFFFFFFF 00000000          int __cdecl blkdev_issue_flush(block_device *, gfp_t, sector_t *);
FFFFFFFF 00000000          int __cdecl blkdev_issue_write_same(block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, page *page);
FFFFFFFF 00000000          int __cdecl blkdev_issue_zeroout(block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, unsigned int flags);
FFFFFFFF 00000000          unsigned int __cdecl blkdev_nr_zones(block_device *bdev);
FFFFFFFF 00000000          void __cdecl blkdev_put(block_device *bdev, fmode_t mode);
FFFFFFFF 00000000          ssize_t __cdecl blkdev_read_iter(kiocb *iocb, iov_iter *to);
FFFFFFFF 00000000          int __cdecl blkdev_report_zones(block_device *bdev, sector_t sector, blk_zone *zones, unsigned int *nr_zones);
FFFFFFFF 00000000          int __cdecl blkdev_report_zones_ioctl(block_device *bdev, fmode_t mode, unsigned int cmd, unsigned __int64 arg);
FFFFFFFF 00000000          int __cdecl blkdev_reread_part(block_device *bdev);
FFFFFFFF 00000000          int __cdecl blkdev_reset_zones(block_device *bdev, sector_t sectors, sector_t nr_sectors, gfp_t gfp_mask);
FFFFFFFF 00000000          int __cdecl blkdev_reset_zones_ioctl(block_device *bdev, fmode_t mode, unsigned int cmd, unsigned __int64 arg);
FFFFFFFF 00000000          void __cdecl blkdev_show(seq_file *, off_t);
FFFFFFFF 00000000          ssize_t __cdecl blkdev_write_iter(kiocb *iocb, iov_iter *from);
00000078 00000000          class block_class;
00000008 0000000000000000          kobject *block_depr;
FFFFFFFF 00000000          void __cdecl block_sync_page(page *page);
00000008 0000000000000000          super_block *blockdev_superblock;
FFFFFFFF 00000000          int __cdecl blocking_notifier_call_chain(blocking_notifier_head *nh, unsigned __int64 val, void *v);
FFFFFFFF 00000000          int __cdecl blocking_notifier_chain_cond_register(blocking_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          int __cdecl blocking_notifier_chain_register(blocking_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          int __cdecl blocking_notifier_chain_unregister(blocking_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          sector_t __cdecl bmap(inode *, sector_t);
FFFFFFFF 00000000          bool bool_x86_init_noop(void);
00000000 00000000          char boot_command_line[];
00000001 00000000          u8 boot_cpu_apic_version;
000000F0 00000000          cpuinfo_x86 boot_cpu_data;
00000004 00000000          unsigned int boot_cpu_physical_apicid;
00000008 0000000000000000          unsigned __int64 boot_option_idle_override;
00000004 00000000          int bootloader_type;
00000004 00000000          int bootloader_version;
FFFFFFFF 00000000          int __cdecl bpf_check(bpf_prog **fp, bpf_attr *attr, bpf_attr *uattr);
FFFFFFFF 00000000          int __cdecl bpf_check_uarg_tail_zero(void *uaddr, size_t expected_size, size_t actual_size);
FFFFFFFF 00000000          u64 __cdecl bpf_event_output(bpf_map *map, u64 flags, void *meta, u64 meta_size, void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy);
FFFFFFFF 00000000          int __cdecl bpf_fd_array_map_lookup_elem(bpf_map *map, void *key, u32 *value);
FFFFFFFF 00000000          int __cdecl bpf_fd_array_map_update_elem(bpf_map *map, file *map_file, void *key, void *value, u64 map_flags);
FFFFFFFF 00000000          int __cdecl bpf_fd_htab_map_lookup_elem(bpf_map *map, void *key, u32 *value);
FFFFFFFF 00000000          int __cdecl bpf_fd_htab_map_update_elem(bpf_map *map, file *map_file, void *key, void *value, u64 map_flags);
FFFFFFFF 00000000          int __cdecl bpf_fd_reuseport_array_lookup_elem(bpf_map *map, void *key, void *value);
FFFFFFFF 00000000          int __cdecl bpf_fd_reuseport_array_update_elem(bpf_map *map, void *key, void *value, u64 map_flags);
00000028 00000000          const bpf_func_proto bpf_get_current_cgroup_id_proto;
00000028 00000000          const bpf_func_proto bpf_get_current_comm_proto;
00000028 00000000          const bpf_func_proto bpf_get_current_pid_tgid_proto;
00000028 00000000          const bpf_func_proto bpf_get_current_uid_gid_proto;
FFFFFFFF 00000000          int __cdecl bpf_get_file_flag(int flags);
00000028 00000000          const bpf_func_proto bpf_get_local_storage_proto;
00000028 00000000          const bpf_func_proto bpf_get_numa_node_id_proto;
00000028 00000000          const bpf_func_proto bpf_get_prandom_u32_proto;
00000028 00000000          const bpf_func_proto bpf_get_smp_processor_id_proto;
00000028 00000000          const bpf_func_proto bpf_get_stack_proto;
00000028 00000000          const bpf_func_proto bpf_get_stackid_proto;
FFFFFFFF 00000000          const bpf_func_proto *bpf_get_trace_printk_proto(void);
00000028 00000000          const bpf_func_proto bpf_ktime_get_ns_proto;
FFFFFFFF 00000000          void *__cdecl bpf_map_area_alloc(u64 size, int numa_node);
FFFFFFFF 00000000          void __cdecl bpf_map_area_free(void *base);
FFFFFFFF 00000000          void __cdecl bpf_map_charge_finish(bpf_map_memory *mem);
FFFFFFFF 00000000          int __cdecl bpf_map_charge_init(bpf_map_memory *mem, u64 size);
FFFFFFFF 00000000          int __cdecl bpf_map_charge_memlock(bpf_map *map, u32 pages);
FFFFFFFF 00000000          void __cdecl bpf_map_charge_move(bpf_map_memory *dst, bpf_map_memory *src);
00000028 00000000          const bpf_func_proto bpf_map_delete_elem_proto;
00000110 00000000          const file_operations bpf_map_fops;
FFFFFFFF 00000000          void __cdecl bpf_map_free_id(bpf_map *map, bool do_idr_lock);
FFFFFFFF 00000000          bpf_map *__cdecl bpf_map_get_with_uref(u32 ufd);
FFFFFFFF 00000000          bpf_map *__cdecl bpf_map_inc(bpf_map *map, bool uref);
FFFFFFFF 00000000          bpf_map *__cdecl bpf_map_inc_not_zero(bpf_map *map, bool uref);
FFFFFFFF 00000000          void __cdecl bpf_map_init_from_attr(bpf_map *map, bpf_attr *attr);
00000028 00000000          const bpf_func_proto bpf_map_lookup_elem_proto;
FFFFFFFF 00000000          int __cdecl bpf_map_new_fd(bpf_map *map, int flags);
FFFFFFFF 00000000          int __cdecl bpf_map_offload_delete_elem(bpf_map *map, void *key);
FFFFFFFF 00000000          int __cdecl bpf_map_offload_get_next_key(bpf_map *map, void *key, void *next_key);
FFFFFFFF 00000000          int __cdecl bpf_map_offload_info_fill(bpf_map_info *info, bpf_map *map);
FFFFFFFF 00000000          int __cdecl bpf_map_offload_lookup_elem(bpf_map *map, void *key, void *value);
FFFFFFFF 00000000          bpf_map *__cdecl bpf_map_offload_map_alloc(bpf_attr *attr);
FFFFFFFF 00000000          void __cdecl bpf_map_offload_map_free(bpf_map *map);
000000A8 00000000          const bpf_map_ops bpf_map_offload_ops;
FFFFFFFF 00000000          int __cdecl bpf_map_offload_update_elem(bpf_map *map, void *key, void *value, u64 flags);
00000028 00000000          const bpf_func_proto bpf_map_peek_elem_proto;
00000028 00000000          const bpf_func_proto bpf_map_pop_elem_proto;
00000028 00000000          const bpf_func_proto bpf_map_push_elem_proto;
FFFFFFFF 00000000          void __cdecl bpf_map_put(bpf_map *map);
FFFFFFFF 00000000          void __cdecl bpf_map_put_with_uref(bpf_map *map);
FFFFFFFF 00000000          void __cdecl bpf_map_uncharge_memlock(bpf_map *map, u32 pages);
00000028 00000000          const bpf_func_proto bpf_map_update_elem_proto;
00000028 00000000          const bpf_func_proto bpf_msg_redirect_hash_proto;
00000028 00000000          const bpf_func_proto bpf_msg_redirect_map_proto;
FFFFFFFF 00000000          int __cdecl bpf_obj_get_user(const char *pathname, int flags);
FFFFFFFF 00000000          int __cdecl bpf_obj_pin_user(u32 ufd, const char *pathname);
FFFFFFFF 00000000          bpf_offload_dev *__cdecl bpf_offload_dev_create(const bpf_prog_offload_ops *ops, void *priv);
FFFFFFFF 00000000          void __cdecl bpf_offload_dev_destroy(bpf_offload_dev *offdev);
FFFFFFFF 00000000          bool __cdecl bpf_offload_dev_match(bpf_prog *prog, net_device *netdev);
FFFFFFFF 00000000          int __cdecl bpf_offload_dev_netdev_register(bpf_offload_dev *offdev, net_device *netdev);
FFFFFFFF 00000000          void __cdecl bpf_offload_dev_netdev_unregister(bpf_offload_dev *offdev, net_device *netdev);
FFFFFFFF 00000000          void *__cdecl bpf_offload_dev_priv(bpf_offload_dev *offdev);
FFFFFFFF 00000000          bool __cdecl bpf_offload_prog_map_match(bpf_prog *prog, bpf_map *map);
00000008 0000000000000000          const bpf_prog_ops bpf_offload_prog_ops;
FFFFFFFF 00000000          int __cdecl bpf_percpu_array_copy(bpf_map *map, void *key, void *value);
FFFFFFFF 00000000          int __cdecl bpf_percpu_array_update(bpf_map *map, void *key, void *value, u64 flags);
FFFFFFFF 00000000          int __cdecl bpf_percpu_hash_copy(bpf_map *map, void *key, void *value);
FFFFFFFF 00000000          int __cdecl bpf_percpu_hash_update(bpf_map *map, void *key, void *value, u64 flags);
00000004 00000000          int bpf_prog_active;
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_add(bpf_prog *prog, int i);
FFFFFFFF 00000000          bpf_prog_array *__cdecl bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags);
FFFFFFFF 00000000          bool __cdecl bpf_prog_array_compatible(bpf_array *array, const bpf_prog *fp);
FFFFFFFF 00000000          int __cdecl bpf_prog_array_copy(bpf_prog_array *old_array, bpf_prog *exclude_prog, bpf_prog *include_prog, bpf_prog_array **new_array);
FFFFFFFF 00000000          int __cdecl bpf_prog_array_copy_info(bpf_prog_array *array, u32 *prog_ids, u32 request_cnt, u32 *prog_cnt);
FFFFFFFF 00000000          int __cdecl bpf_prog_array_copy_to_user(bpf_prog_array *progs, __u32 *prog_ids, u32 cnt);
FFFFFFFF 00000000          void __cdecl bpf_prog_array_delete_safe(bpf_prog_array *progs, bpf_prog *old_prog);
FFFFFFFF 00000000          void __cdecl bpf_prog_array_free(bpf_prog_array *progs);
FFFFFFFF 00000000          bool __cdecl bpf_prog_array_is_empty(bpf_prog_array *array);
FFFFFFFF 00000000          int __cdecl bpf_prog_array_length(bpf_prog_array *progs);
FFFFFFFF 00000000          int __cdecl bpf_prog_calc_tag(bpf_prog *fp);
00000110 00000000          const file_operations bpf_prog_fops;
FFFFFFFF 00000000          void __cdecl bpf_prog_free_id(bpf_prog *prog, bool do_idr_lock);
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_get(u32 ufd);
FFFFFFFF 00000000          bool __cdecl bpf_prog_get_ok(bpf_prog *, bpf_prog_type *, bool);
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_get_type_dev(u32 ufd, bpf_prog_type type, bool attach_drv);
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_get_type_path(const char *name, bpf_prog_type type);
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_inc(bpf_prog *prog);
FFFFFFFF 00000000          bpf_prog *__cdecl bpf_prog_inc_not_zero(bpf_prog *prog);
FFFFFFFF 00000000          int __cdecl bpf_prog_new_fd(bpf_prog *prog);
FFFFFFFF 00000000          int __cdecl bpf_prog_offload_compile(bpf_prog *prog);
FFFFFFFF 00000000          void __cdecl bpf_prog_offload_destroy(bpf_prog *prog);
FFFFFFFF 00000000          int __cdecl bpf_prog_offload_info_fill(bpf_prog_info *info, bpf_prog *prog);
FFFFFFFF 00000000          int __cdecl bpf_prog_offload_init(bpf_prog *prog, bpf_attr *attr);
FFFFFFFF 00000000          void __cdecl bpf_prog_put(bpf_prog *prog);
FFFFFFFF 00000000          void __cdecl bpf_prog_sub(bpf_prog *prog, int i);
FFFFFFFF 00000000          int __cdecl bpf_prog_test_run_flow_dissector(bpf_prog *prog, const bpf_attr *kattr, bpf_attr *uattr);
FFFFFFFF 00000000          int __cdecl bpf_prog_test_run_skb(bpf_prog *prog, const bpf_attr *kattr, bpf_attr *uattr);
FFFFFFFF 00000000          int __cdecl bpf_prog_test_run_xdp(bpf_prog *prog, const bpf_attr *kattr, bpf_attr *uattr);
00000028 00000000          const bpf_func_proto bpf_sk_redirect_hash_proto;
00000028 00000000          const bpf_func_proto bpf_sk_redirect_map_proto;
FFFFFFFF 00000000          void __cdecl bpf_sk_reuseport_detach(sock *sk);
FFFFFFFF 00000000          bool __cdecl bpf_sock_common_is_valid_access(int off, int size, bpf_access_type type, bpf_insn_access_aux *info);
FFFFFFFF 00000000          u32 __cdecl bpf_sock_convert_ctx_access(bpf_access_type type, const bpf_insn *si, bpf_insn *insn_buf, bpf_prog *prog, u32 *target_size);
00000028 00000000          const bpf_func_proto bpf_sock_hash_update_proto;
FFFFFFFF 00000000          bool __cdecl bpf_sock_is_valid_access(int off, int size, bpf_access_type type, bpf_insn_access_aux *info);
00000028 00000000          const bpf_func_proto bpf_sock_map_update_proto;
00000028 00000000          const bpf_func_proto bpf_spin_lock_proto;
00000028 00000000          const bpf_func_proto bpf_spin_unlock_proto;
FFFFFFFF 00000000          int __cdecl bpf_stackmap_copy(bpf_map *map, void *key, void *value);
00000028 00000000          const bpf_func_proto bpf_strtol_proto;
00000028 00000000          const bpf_func_proto bpf_strtoul_proto;
00000028 00000000          const bpf_func_proto bpf_tail_call_proto;
FFFFFFFF 00000000          u32 __cdecl bpf_tcp_sock_convert_ctx_access(bpf_access_type type, const bpf_insn *si, bpf_insn *insn_buf, bpf_prog *prog, u32 *target_size);
FFFFFFFF 00000000          bool __cdecl bpf_tcp_sock_is_valid_access(int off, int size, bpf_access_type type, bpf_insn_access_aux *info);
00000028 00000000          const bpf_func_proto bpf_tcp_sock_proto;
FFFFFFFF 00000000          void bpf_user_rnd_init_once(void);
FFFFFFFF 00000000          u64 __cdecl bpf_user_rnd_u32(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
FFFFFFFF 00000000          u32 __cdecl bpf_xdp_sock_convert_ctx_access(bpf_access_type type, const bpf_insn *si, bpf_insn *insn_buf, bpf_prog *prog, u32 *target_size);
FFFFFFFF 00000000          bool __cdecl bpf_xdp_sock_is_valid_access(int off, int size, bpf_access_type type, bpf_insn_access_aux *info);
FFFFFFFF 00000000          int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl bsg_register_queue(request_queue *q, device *parent, const char *name, const bsg_ops *ops);
FFFFFFFF 00000000          int __cdecl bsg_scsi_register_queue(request_queue *q, device *parent);
FFFFFFFF 00000000          void __cdecl bsg_unregister_queue(request_queue *q);
FFFFFFFF 00000000          int __cdecl bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);
00000018 00000000          idr btf_idr;
00000004 00000000          spinlock_t btf_idr_lock;
FFFFFFFF 00000000          int __cdecl buffer_migrate_page(address_space *, page *, page *, migrate_mode);
FFFFFFFF 00000000          int __cdecl buffer_migrate_page_norefs(address_space *, page *, page *, migrate_mode);
FFFFFFFF 00000000          void __cdecl build_all_zonelists(pg_data_t *pgdat);
FFFFFFFF 00000000          int __cdecl bus_create_file(bus_type *, bus_attribute *);
FFFFFFFF 00000000          device *__cdecl bus_find_device(bus_type *bus, device *start, const void *data, int (__cdecl *match)(device *, const void *));
FFFFFFFF 00000000          int __cdecl bus_for_each_dev(bus_type *bus, device *start, void *data, int (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          int __cdecl bus_for_each_drv(bus_type *bus, device_driver *start, void *data, int (__cdecl *fn)(device_driver *, void *));
FFFFFFFF 00000000          klist *__cdecl bus_get_device_klist(bus_type *bus);
FFFFFFFF 00000000          kset *__cdecl bus_get_kset(bus_type *bus);
FFFFFFFF 00000000          int __cdecl bus_register(bus_type *bus);
FFFFFFFF 00000000          int __cdecl bus_register_notifier(bus_type *bus, notifier_block *nb);
FFFFFFFF 00000000          void __cdecl bus_remove_file(bus_type *, bus_attribute *);
FFFFFFFF 00000000          int __cdecl bus_rescan_devices(bus_type *bus);
FFFFFFFF 00000000          void __cdecl bus_sort_breadthfirst(bus_type *bus, int (__cdecl *compare)(const device *, const device *));
FFFFFFFF 00000000          void __cdecl bus_unregister(bus_type *bus);
FFFFFFFF 00000000          int __cdecl bus_unregister_notifier(bus_type *bus, notifier_block *nb);
FFFFFFFF 00000000          void __cdecl bust_spinlocks(int yes);
FFFFFFFF 00000000          bio_vec *__cdecl bvec_alloc(gfp_t, int, unsigned __int64 *, mempool_t *);
FFFFFFFF 00000000          void __cdecl bvec_free(mempool_t *, bio_vec *, unsigned int);
FFFFFFFF 00000000          unsigned int __cdecl bvec_nr_vecs(unsigned __int16 idx);
00000008 0000000000000000          pid *cad_pid;
FFFFFFFF 00000000          void calculate_max_logical_packages(void);
FFFFFFFF 00000000          int __cdecl calculate_normal_threshold(zone *zone);
FFFFFFFF 00000000          int __cdecl calculate_pressure_threshold(zone *zone);
FFFFFFFF 00000000          void calibrate_delay(void);
FFFFFFFF 00000000          unsigned __int64 calibrate_delay_is_known(void);
FFFFFFFF 00000000          void calibration_delay_done(void);
FFFFFFFF 00000000          void call_function_init(void);
FFFFFFFF 00000000          void __cdecl call_rcu(callback_head *head, rcu_callback_t func);
FFFFFFFF 00000000          void __cdecl call_rcu_tasks(callback_head *head, rcu_callback_t func);
FFFFFFFF 00000000          void __cdecl call_srcu(srcu_struct *ssp, callback_head *head, void (__cdecl *func)(callback_head *));
FFFFFFFF 00000000          int __cdecl call_usermodehelper(const char *path, char **argv, char **envp, int wait);
FFFFFFFF 00000000          int __cdecl call_usermodehelper_exec(subprocess_info *info, int wait);
FFFFFFFF 00000000          subprocess_info *__cdecl call_usermodehelper_setup(const char *path, char **argv, char **envp, gfp_t gfp_mask, int (__cdecl *init)(subprocess_info *, cred *), void (__cdecl *cleanup)(subprocess_info *), void *data);
FFFFFFFF 00000000          subprocess_info *__cdecl call_usermodehelper_setup_file(file *file, int (__cdecl *init)(subprocess_info *, cred *), void (__cdecl *cleanup)(subprocess_info *), void *data);
FFFFFFFF 00000000          bool can_do_mlock(void);
FFFFFFFF 00000000          int __cdecl can_nice(const task_struct *p, const int nice);
FFFFFFFF 00000000          bool __cdecl can_split_huge_page(page *page, int *pextra_pins);
FFFFFFFF 00000000          bool __cdecl cancel_delayed_work(delayed_work *dwork);
FFFFFFFF 00000000          bool __cdecl cancel_delayed_work_sync(delayed_work *dwork);
FFFFFFFF 00000000          bool __cdecl cancel_work_sync(work_struct *work);
FFFFFFFF 00000000          int __cdecl cap_convert_nscap(dentry *dentry, const void **ivalue, size_t size);
FFFFFFFF 00000000          bool __cdecl capable(int cap);
FFFFFFFF 00000000          bool __cdecl capable_wrt_inode_uidgid(const inode *inode, int cap);
FFFFFFFF 00000000          void __cdecl cd_forget(inode *);
FFFFFFFF 00000000          int __cdecl cdev_add(cdev *, dev_t, unsigned int);
FFFFFFFF 00000000          cdev *cdev_alloc(void);
FFFFFFFF 00000000          void __cdecl cdev_del(cdev *);
FFFFFFFF 00000000          int __cdecl cdev_device_add(cdev *cdev, device *dev);
FFFFFFFF 00000000          void __cdecl cdev_device_del(cdev *cdev, device *dev);
FFFFFFFF 00000000          void __cdecl cdev_init(cdev *, const file_operations *);
FFFFFFFF 00000000          void __cdecl cdev_put(cdev *p);
FFFFFFFF 00000000          void __cdecl cdev_set_parent(cdev *p, kobject *kobj);
00000008 0000000000000000          const bpf_prog_ops cg_dev_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_dev_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops cg_skb_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_skb_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops cg_sock_addr_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_sock_addr_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops cg_sock_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_sock_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops cg_sockopt_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_sockopt_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops cg_sysctl_prog_ops;
00000028 00000000          const bpf_verifier_ops cg_sysctl_verifier_ops;
000000A8 00000000          const bpf_map_ops cgroup_array_map_ops;
000000A8 00000000          const bpf_map_ops cgroup_storage_map_ops;
FFFFFFFF 00000000          int __cdecl change_create_files_as(cred *, inode *);
FFFFFFFF 00000000          int __cdecl change_huge_pmd(vm_area_struct *vma, pmd_t *pmd, unsigned __int64 addr, pgprot_t newprot, int prot_numa);
FFFFFFFF 00000000          void __cdecl change_pid(task_struct *task, pid_type, pid *pid);
FFFFFFFF 00000000          unsigned __int64 __cdecl change_prot_numa(vm_area_struct *vma, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          unsigned __int64 __cdecl change_protection(vm_area_struct *vma, unsigned __int64 start, unsigned __int64 end, pgprot_t newprot, int dirty_accountable, int prot_numa);
FFFFFFFF 00000000          int __cdecl check_disk_change(block_device *);
FFFFFFFF 00000000          void __cdecl check_disk_size_change(gendisk *disk, block_device *bdev, bool verbose);
FFFFFFFF 00000000          void __cdecl check_panic_on_warn(const char *origin);
FFFFFFFF 00000000          int __cdecl check_signature(const void *io_addr, const unsigned __int8 *signature, int length);
FFFFFFFF 00000000          void __cdecl check_tsc_sync_source(int cpu);
FFFFFFFF 00000000          void check_tsc_sync_target(void);
FFFFFFFF 00000000          int check_tsc_unstable(void);
FFFFFFFF 00000000          void check_x2apic(void);
FFFFFFFF 00000000          int __cdecl check_zeroed_user(const void *from, size_t size);
FFFFFFFF 00000000          void __cdecl chrdev_show(seq_file *, off_t);
FFFFFFFF 00000000          int __cdecl class_compat_create_link(class_compat *cls, device *dev, device *device_link);
FFFFFFFF 00000000          class_compat *__cdecl class_compat_register(const char *name);
FFFFFFFF 00000000          void __cdecl class_compat_remove_link(class_compat *cls, device *dev, device *device_link);
FFFFFFFF 00000000          void __cdecl class_compat_unregister(class_compat *cls);
FFFFFFFF 00000000          int __cdecl class_create_file_ns(class *class, const class_attribute *attr, const void *ns);
FFFFFFFF 00000000          void __cdecl class_destroy(class *cls);
FFFFFFFF 00000000          void __cdecl class_dev_iter_exit(class_dev_iter *iter);
FFFFFFFF 00000000          void __cdecl class_dev_iter_init(class_dev_iter *iter, class *class, device *start, const device_type *type);
FFFFFFFF 00000000          device *__cdecl class_dev_iter_next(class_dev_iter *iter);
FFFFFFFF 00000000          device *__cdecl class_find_device(class *class, device *start, const void *data, int (__cdecl *match)(device *, const void *));
FFFFFFFF 00000000          int __cdecl class_for_each_device(class *class, device *start, void *data, int (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          int __cdecl class_interface_register(class_interface *);
FFFFFFFF 00000000          void __cdecl class_interface_unregister(class_interface *);
FFFFFFFF 00000000          void __cdecl class_remove_file_ns(class *class, const class_attribute *attr, const void *ns);
FFFFFFFF 00000000          void __cdecl class_unregister(class *class);
FFFFFFFF 00000000          int __cdecl clean_sort_range(range *range, int az);
FFFFFFFF 00000000          void cleanup_highmap(void);
FFFFFFFF 00000000          void cleanup_module(void);
FFFFFFFF 00000000          void __cdecl cleanup_srcu_struct(srcu_struct *ssp);
FFFFFFFF 00000000          void clear_IO_APIC(void);
FFFFFFFF 00000000          void __cdecl clear_cpu_cap(cpuinfo_x86 *c, unsigned int bit);
FFFFFFFF 00000000          void __cdecl clear_huge_page(page *page, unsigned __int64 addr_hint, unsigned int pages_per_huge_page);
FFFFFFFF 00000000          void __cdecl clear_inode(inode *);
FFFFFFFF 00000000          void clear_local_APIC(void);
FFFFFFFF 00000000          void __cdecl clear_nlink(inode *inode);
FFFFFFFF 00000000          int __cdecl clear_page_dirty_for_io(page *page);
FFFFFFFF 00000000          void __cdecl clear_page_erms(void *page);
FFFFFFFF 00000000          void __cdecl clear_page_orig(void *page);
FFFFFFFF 00000000          void __cdecl clear_page_rep(void *page);
FFFFFFFF 00000000          void clear_sched_clock_stable(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl clear_user(void *mem, unsigned __int64 len);
FFFFFFFF 00000000          void __cdecl clear_wb_congested(bdi_writeback_congested *congested, int sync);
FFFFFFFF 00000000          void __cdecl clear_zone_contiguous(zone *zone);
FFFFFFFF 00000000          void __cdecl clflush_cache_range(void *addr, unsigned int size);
FFFFFFFF 00000000          unsigned __int64 __cdecl clock_t_to_jiffies(unsigned __int64 x);
FFFFFFFF 00000000          vfsmount *__cdecl collect_mounts(const path *);
FFFFFFFF 00000000          int __cdecl commit_creds(cred *);
FFFFFFFF 00000000          int __cdecl common_cpu_die(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl common_cpu_up(unsigned int cpunum, task_struct *tidle);
FFFFFFFF 00000000          int __cdecl compat_arch_setup_additional_pages(linux_binprm *bprm, int uses_interp);
FFFFFFFF 00000000          __int64 __cdecl compat_blkdev_ioctl(file *, unsigned int, unsigned __int64);
FFFFFFFF 00000000          __int64 __cdecl compat_ptr_ioctl(file *file, unsigned int cmd, unsigned __int64 arg);
FFFFFFFF 00000000          void __cdecl compat_start_thread(pt_regs *regs, u32 new_ip, u32 new_sp);
FFFFFFFF 00000000          void __cdecl complete(completion *);
FFFFFFFF 00000000          void __cdecl complete_all(completion *);
FFFFFFFF 00000000          void __cdecl __noreturn complete_and_exit(completion *, __int64);
FFFFFFFF 00000000          bool __cdecl completion_done(completion *x);
00000000 00000000          compound_page_dtor *const compound_page_dtors[];
FFFFFFFF 00000000          void __cdecl cond_synchronize_rcu(unsigned __int64 oldstate);
00000000 00000000          int console_printk[];
FFFFFFFF 00000000          system_counterval_t __cdecl convert_art_ns_to_tsc(u64 art_ns);
FFFFFFFF 00000000          system_counterval_t __cdecl convert_art_to_tsc(u64 art);
FFFFFFFF 00000000          unsigned __int64 __cdecl convert_ip_to_linear(task_struct *child, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl copy_creds(task_struct *, unsigned __int64);
FFFFFFFF 00000000          void __cdecl copy_from_early_mem(void *dest, phys_addr_t src, unsigned __int64 size);
FFFFFFFF 00000000          unsigned __int64 __cdecl copy_from_user_nmi(void *to, const void *from, unsigned __int64 n);
FFFFFFFF 00000000          __int64 __cdecl copy_huge_page_from_user(page *dst_page, const void *usr_src, unsigned int pages_per_huge_page, bool allow_pagefault);
FFFFFFFF 00000000          int __cdecl copy_huge_pmd(mm_struct *dst_mm, mm_struct *src_mm, pmd_t *dst_pmd, pmd_t *src_pmd, unsigned __int64 addr, vm_area_struct *vma);
FFFFFFFF 00000000          int __cdecl copy_huge_pud(mm_struct *dst_mm, mm_struct *src_mm, pud_t *dst_pud, pud_t *src_pud, unsigned __int64 addr, vm_area_struct *vma);
FFFFFFFF 00000000          int __cdecl copy_kernel_to_xstate(xregs_state *xsave, const void *kbuf);
FFFFFFFF 00000000          void __cdecl copy_map_value_locked(bpf_map *map, void *dst, void *src, bool lock_src);
FFFFFFFF 00000000          void __cdecl copy_page(void *to, void *from);
FFFFFFFF 00000000          int __cdecl copy_page_range(mm_struct *dst, mm_struct *src, vm_area_struct *vma);
FFFFFFFF 00000000          int __cdecl copy_semundo(unsigned __int64 clone_flags, task_struct *tsk);
FFFFFFFF 00000000          unsigned __int64 __cdecl copy_user_enhanced_fast_string(void *to, const void *from, unsigned int len);
FFFFFFFF 00000000          unsigned __int64 __cdecl copy_user_generic_string(void *to, const void *from, unsigned int len);
FFFFFFFF 00000000          unsigned __int64 __cdecl copy_user_generic_unrolled(void *to, const void *from, unsigned int len);
FFFFFFFF 00000000          void __cdecl copy_user_huge_page(page *dst, page *src, unsigned __int64 addr_hint, vm_area_struct *vma, unsigned int pages_per_huge_page);
FFFFFFFF 00000000          int __cdecl copy_user_to_xstate(xregs_state *xsave, const void *ubuf);
FFFFFFFF 00000000          vm_area_struct *__cdecl copy_vma(vm_area_struct **, unsigned __int64 addr, unsigned __int64 len, unsigned __int64 pgoff, bool *need_rmap_locks);
FFFFFFFF 00000000          int __cdecl copy_xstate_to_kernel(void *kbuf, xregs_state *xsave, unsigned int offset, unsigned int size);
FFFFFFFF 00000000          int __cdecl copy_xstate_to_user(void *ubuf, xregs_state *xsave, unsigned int offset, unsigned int size);
FFFFFFFF 00000000          int __cdecl core_kernel_data(unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl core_kernel_text(unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl core_sys_select(int n, fd_set *inp, fd_set *outp, fd_set *exp, timespec64 *end_time);
00000400 00000000          const unsigned __int64 cpu_all_bits[128];
00010400 00000000          const unsigned __int64 cpu_bit_bitmap[65][128];
00000008 0000000000000000          cpumask_var_t cpu_callin_mask;
00000008 0000000000000000          cpumask_var_t cpu_callout_mask;
00000050 00000000          __u32 cpu_caps_cleared[20];
00000050 00000000          __u32 cpu_caps_set[20];
00000008 0000000000000000          cpumask *cpu_core_map;
FFFFFFFF 00000000          const cpumask *__cdecl cpu_coregroup_mask(int cpu);
FFFFFFFF 00000000          void __cdecl cpu_detect(cpuinfo_x86 *c);
00000008 0000000000000000          cpumask *cpu_die_map;
FFFFFFFF 00000000          void cpu_disable_common(void);
FFFFFFFF 00000000          int __cdecl cpu_has_xfeatures(u64 xfeatures_mask, const char **feature_name);
000000F0 00000000          cpuinfo_x86 cpu_info;
FFFFFFFF 00000000          void cpu_init(void);
00000008 0000000000000000          cpumask_var_t cpu_initialized_mask;
00000004 00000000          unsigned int cpu_khz;
FFFFFFFF 00000000          unsigned __int64 cpu_khz_from_msr(void);
00000002 00000000          unsigned __int16 cpu_llc_id;
00000008 0000000000000000          cpumask *cpu_llc_shared_map;
FFFFFFFF 00000000          int __cdecl cpu_map_enqueue(bpf_cpu_map_entry *rcpu, xdp_buff *xdp, net_device *dev_rx);
000000A8 00000000          const bpf_map_ops cpu_map_ops;
00000004 00000000          int cpu_number;
00000008 0000000000000000          unsigned __int64 cpu_scale;
00000008 0000000000000000          cpumask *cpu_sibling_map;
00000008 0000000000000000          cpumask_var_t cpu_sibling_setup_mask;
00003000 00000000          tss_struct cpu_tss_rw;
FFFFFFFF 00000000          void __cdecl cpu_vm_stats_fold(int cpu);
00000020 00000000          const seq_operations cpuinfo_op;
FFFFFFFF 00000000          int __cdecl cpumask_any_but(const cpumask *mask, unsigned int cpu);
FFFFFFFF 00000000          unsigned int __cdecl cpumask_local_spread(unsigned int i, int node);
FFFFFFFF 00000000          unsigned int __cdecl cpumask_next(int n, const cpumask *srcp);
FFFFFFFF 00000000          int __cdecl cpumask_next_and(int n, const cpumask *, const cpumask *);
FFFFFFFF 00000000          int __cdecl cpumask_next_wrap(int n, const cpumask *mask, int start, bool wrap);
00000400 00000000          cpumask_t cpus_booted_once_mask;
FFFFFFFF 00000000          int __cdecl cpuset_cpumask_can_shrink(const cpumask *cur, const cpumask *trial);
FFFFFFFF 00000000          void cr4_init(void);
00000001 00000000          bool crash_kexec_post_notifiers;
FFFFFFFF 00000000          cred *cred_alloc_blank(void);
FFFFFFFF 00000000          int __cdecl cred_fscmp(const cred *, const cred *);
FFFFFFFF 00000000          void cred_init(void);
FFFFFFFF 00000000          void ctrl_alt_del(void);
FFFFFFFF 00000000          task_struct *__cdecl curr_task(int cpu);
FFFFFFFF 00000000          bool current_is_workqueue_rescuer(void);
00000008 0000000000000000          unsigned __int64 current_stack_pointer;
00000008 0000000000000000          task_struct *current_task;
FFFFFFFF 00000000          timespec64 __cdecl current_time(inode *inode);
FFFFFFFF 00000000          int current_umask(void);
FFFFFFFF 00000000          work_struct *current_work(void);
FFFFFFFF 00000000          char *__cdecl d_absolute_path(const path *, char *, int);
FFFFFFFF 00000000          void __cdecl d_add(dentry *, inode *);
FFFFFFFF 00000000          dentry *__cdecl d_add_ci(dentry *, inode *, qstr *);
FFFFFFFF 00000000          dentry *__cdecl d_alloc(dentry *, const qstr *);
FFFFFFFF 00000000          dentry *__cdecl d_alloc_anon(super_block *);
FFFFFFFF 00000000          dentry *__cdecl d_alloc_name(dentry *, const char *);
FFFFFFFF 00000000          dentry *__cdecl d_alloc_parallel(dentry *, const qstr *, wait_queue_head_t *);
FFFFFFFF 00000000          dentry *__cdecl d_ancestor(dentry *, dentry *);
FFFFFFFF 00000000          void __cdecl d_delete(dentry *);
FFFFFFFF 00000000          void __cdecl d_drop(dentry *dentry);
FFFFFFFF 00000000          dentry *__cdecl d_exact_alias(dentry *, inode *);
FFFFFFFF 00000000          void __cdecl d_exchange(dentry *, dentry *);
FFFFFFFF 00000000          dentry *__cdecl d_find_alias(inode *);
FFFFFFFF 00000000          dentry *__cdecl d_find_any_alias(inode *inode);
FFFFFFFF 00000000          void __cdecl d_genocide(dentry *);
FFFFFFFF 00000000          dentry *__cdecl d_hash_and_lookup(dentry *, qstr *);
FFFFFFFF 00000000          void __cdecl d_instantiate(dentry *, inode *);
FFFFFFFF 00000000          dentry *__cdecl d_instantiate_anon(dentry *, inode *);
FFFFFFFF 00000000          void __cdecl d_instantiate_new(dentry *, inode *);
FFFFFFFF 00000000          dentry *__cdecl d_instantiate_unique(dentry *, inode *);
FFFFFFFF 00000000          void __cdecl d_invalidate(dentry *);
FFFFFFFF 00000000          dentry *__cdecl d_lookup(const dentry *, const qstr *);
FFFFFFFF 00000000          dentry *__cdecl d_make_root(inode *);
FFFFFFFF 00000000          void __cdecl d_move(dentry *, dentry *);
FFFFFFFF 00000000          dentry *__cdecl d_obtain_alias(inode *);
FFFFFFFF 00000000          dentry *__cdecl d_obtain_root(inode *);
FFFFFFFF 00000000          char *__cdecl d_path(const path *, char *, int);
FFFFFFFF 00000000          void __cdecl d_prune_aliases(inode *);
FFFFFFFF 00000000          void __cdecl d_rehash(dentry *);
FFFFFFFF 00000000          void __cdecl d_set_d_op(dentry *dentry, const dentry_operations *op);
FFFFFFFF 00000000          void __cdecl d_set_fallthru(dentry *dentry);
FFFFFFFF 00000000          dentry *__cdecl d_splice_alias(inode *, dentry *);
FFFFFFFF 00000000          void __cdecl d_tmpfile(dentry *, inode *);
FFFFFFFF 00000000          int __cdecl dcache_dir_close(inode *, file *);
FFFFFFFF 00000000          loff_t __cdecl dcache_dir_lseek(file *, loff_t, int);
FFFFFFFF 00000000          int __cdecl dcache_dir_open(inode *, file *);
FFFFFFFF 00000000          int __cdecl dcache_readdir(file *, dir_context *);
FFFFFFFF 00000000          int __cdecl ddebug_add_module(_ddebug *tab, unsigned int n, const char *modname);
FFFFFFFF 00000000          int __cdecl ddebug_dyndbg_module_param_cb(char *param, char *val, const char *modname);
FFFFFFFF 00000000          int __cdecl ddebug_remove_module(const char *mod_name);
FFFFFFFF 00000000          void __cdecl deactivate_locked_super(super_block *sb);
FFFFFFFF 00000000          void __cdecl deactivate_super(super_block *sb);
00000004 00000000          int debug_locks;
FFFFFFFF 00000000          int debug_locks_off(void);
00000004 00000000          int debug_locks_silent;
FFFFFFFF 00000000          void __cdecl dec_node_page_state(page *, node_stat_item);
FFFFFFFF 00000000          void __cdecl dec_zone_page_state(page *, zone_stat_item);
FFFFFFFF 00000000          void __cdecl dec_zone_state(zone *, zone_stat_item);
00000110 00000000          const file_operations def_blk_fops;
00000110 00000000          const file_operations def_chr_fops;
FFFFFFFF 00000000          root_domain def_root_domain;
FFFFFFFF 00000000          int __cdecl default_acpi_madt_oem_check(char *, char *);
FFFFFFFF 00000000          int __cdecl default_apic_id_valid(u32 apicid);
FFFFFFFF 00000000          void default_banner(void);
FFFFFFFF 00000000          bool __cdecl default_check_apicid_used(physid_mask_t *map, int apicid);
FFFFFFFF 00000000          int __cdecl default_check_phys_apicid_present(int phys_apicid);
FFFFFFFF 00000000          int __cdecl default_cpu_present_to_apicid(int mps_cpu);
FFFFFFFF 00000000          void default_find_smp_config(void);
FFFFFFFF 00000000          void __cdecl default_get_smp_config(unsigned int early);
FFFFFFFF 00000000          void default_idle(void);
FFFFFFFF 00000000          void __cdecl default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap);
FFFFFFFF 00000000          loff_t __cdecl default_llseek(file *file, loff_t offset, int whence);
FFFFFFFF 00000000          int __cdecl default_mpc_apic_id(mpc_cpu *m);
FFFFFFFF 00000000          void __cdecl default_mpc_oem_bus_info(mpc_bus *m, char *str);
FFFFFFFF 00000000          void default_setup_apic_routing(void);
FFFFFFFF 00000000          void __cdecl default_smp_read_mpc_oem(mpc_table *mpc);
FFFFFFFF 00000000          int __cdecl default_wake_function(wait_queue_entry *wq_entry, unsigned int mode, int flags, void *key);
FFFFFFFF 00000000          void __cdecl deferred_split_huge_page(page *page);
FFFFFFFF 00000000          void __cdecl del_dma_domain(dma_domain *domain);
FFFFFFFF 00000000          void __cdecl del_gendisk(gendisk *gp);
FFFFFFFF 00000000          int __cdecl del_timer(timer_list *timer);
FFFFFFFF 00000000          int __cdecl del_timer_sync(timer_list *timer);
FFFFFFFF 00000000          void __cdecl delayed_work_timer_fn(timer_list *t);
FFFFFFFF 00000000          void __cdecl delete_from_page_cache(page *page);
FFFFFFFF 00000000          void __cdecl delete_from_page_cache_batch(address_space *mapping, pagevec *pvec);
FFFFFFFF 00000000          void __cdecl delete_partition(gendisk *, int);
FFFFFFFF 00000000          file *__cdecl dentry_open(const path *, int, const cred *);
FFFFFFFF 00000000          char *__cdecl dentry_path(dentry *, char *, int);
FFFFFFFF 00000000          char *__cdecl dentry_path_raw(dentry *, char *, int);
00000030 00000000          dentry_stat_t dentry_stat;
FFFFFFFF 00000000          void *__cdecl dereference_module_function_descriptor(module *mod, void *ptr);
FFFFFFFF 00000000          void __cdecl destroy_params(const kernel_param *params, unsigned int num);
FFFFFFFF 00000000          void __cdecl destroy_workqueue(workqueue_struct *wq);
FFFFFFFF 00000000          void __cdecl detach_pid(task_struct *task, pid_type);
FFFFFFFF 00000000          const char *__cdecl dev_driver_string(const device *dev);
FFFFFFFF 00000000          fwnode_handle *__cdecl dev_fwnode(device *dev);
FFFFFFFF 00000000          int __cdecl dev_map_enqueue(bpf_dtab_netdev *dst, xdp_buff *xdp, net_device *dev_rx);
FFFFFFFF 00000000          int __cdecl dev_map_generic_redirect(bpf_dtab_netdev *dst, sk_buff *skb, bpf_prog *xdp_prog);
000000A8 00000000          const bpf_map_ops dev_map_hash_ops;
000000A8 00000000          const bpf_map_ops dev_map_ops;
FFFFFFFF 00000000          int __cdecl dev_pm_get_subsys_data(device *dev);
FFFFFFFF 00000000          bool __cdecl dev_pm_may_skip_resume(device *dev);
FFFFFFFF 00000000          void __cdecl dev_pm_put_subsys_data(device *dev);
FFFFFFFF 00000000          bool __cdecl dev_pm_smart_suspend_and_suspended(device *dev);
FFFFFFFF 00000000          void dev_printk(const char *level, const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          int dev_printk_emit(int level, const device *dev, const char *fmt, ...);
FFFFFFFF 00000000          int dev_set_name(device *dev, const char *name, ...);
FFFFFFFF 00000000          int __cdecl dev_vprintk_emit(int level, const device *dev, const char *fmt, va_list args);
FFFFFFFF 00000000          int __cdecl device_add(device *dev);
FFFFFFFF 00000000          void __cdecl device_add_disk(device *parent, gendisk *disk, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl device_add_disk_no_queue_reg(device *parent, gendisk *disk);
FFFFFFFF 00000000          int __cdecl device_add_groups(device *dev, const attribute_group **groups);
FFFFFFFF 00000000          int __cdecl device_add_properties(device *dev, const property_entry *properties);
FFFFFFFF 00000000          int __cdecl device_attach(device *dev);
FFFFFFFF 00000000          int __cdecl device_bind_driver(device *dev);
FFFFFFFF 00000000          int __cdecl device_change_owner(device *dev, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          void __cdecl device_connection_add(device_connection *con);
FFFFFFFF 00000000          device *__cdecl device_connection_find(device *dev, const char *con_id);
FFFFFFFF 00000000          void *__cdecl device_connection_find_match(device *dev, const char *con_id, void *data, devcon_match_fn_t match);
FFFFFFFF 00000000          void __cdecl device_connection_remove(device_connection *con);
FFFFFFFF 00000000          device *device_create(class *cls, device *parent, dev_t devt, void *drvdata, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl device_create_bin_file(device *dev, const bin_attribute *attr);
FFFFFFFF 00000000          int __cdecl device_create_file(device *device, const device_attribute *entry);
FFFFFFFF 00000000          device *__cdecl device_create_vargs(class *cls, device *parent, dev_t devt, void *drvdata, const char *fmt, va_list vargs);
FFFFFFFF 00000000          device *device_create_with_groups(class *cls, device *parent, dev_t devt, void *drvdata, const attribute_group **groups, const char *fmt, ...);
FFFFFFFF 00000000          void __cdecl device_del(device *dev);
FFFFFFFF 00000000          void __cdecl device_destroy(class *cls, dev_t devt);
FFFFFFFF 00000000          bool __cdecl device_dma_supported(device *dev);
FFFFFFFF 00000000          device *__cdecl device_find_child(device *dev, void *data, int (__cdecl *match)(device *, void *));
FFFFFFFF 00000000          device *__cdecl device_find_child_by_name(device *parent, const char *name);
FFFFFFFF 00000000          int __cdecl device_for_each_child(device *dev, void *data, int (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          int __cdecl device_for_each_child_reverse(device *dev, void *data, int (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          unsigned int __cdecl device_get_child_node_count(device *dev);
FFFFFFFF 00000000          const char *__cdecl device_get_devnode(device *dev, umode_t *mode, kuid_t *uid, kgid_t *gid, const char **tmp);
FFFFFFFF 00000000          dev_dma_attr __cdecl device_get_dma_attr(device *dev);
FFFFFFFF 00000000          void *__cdecl device_get_mac_address(device *dev, char *addr, int alen);
FFFFFFFF 00000000          const void *__cdecl device_get_match_data(device *dev);
FFFFFFFF 00000000          fwnode_handle *__cdecl device_get_named_child_node(device *dev, const char *childname);
FFFFFFFF 00000000          fwnode_handle *__cdecl device_get_next_child_node(device *dev, fwnode_handle *child);
FFFFFFFF 00000000          int __cdecl device_get_phy_mode(device *dev);
FFFFFFFF 00000000          int __cdecl device_init_wakeup(device *dev, bool val);
FFFFFFFF 00000000          void __cdecl device_initial_probe(device *dev);
FFFFFFFF 00000000          void __cdecl device_initialize(device *dev);
FFFFFFFF 00000000          bool __cdecl device_is_bound(device *dev);
FFFFFFFF 00000000          device_link *__cdecl device_link_add(device *consumer, device *supplier, u32 flags);
FFFFFFFF 00000000          void __cdecl device_link_del(device_link *link);
FFFFFFFF 00000000          void __cdecl device_link_remove(void *consumer, device *supplier);
FFFFFFFF 00000000          int __cdecl device_match_acpi_dev(device *dev, const void *adev);
FFFFFFFF 00000000          int __cdecl device_match_any(device *dev, const void *unused);
FFFFFFFF 00000000          int __cdecl device_match_devt(device *dev, const void *pdevt);
FFFFFFFF 00000000          int __cdecl device_match_fwnode(device *dev, const void *fwnode);
FFFFFFFF 00000000          int __cdecl device_match_name(device *dev, const void *name);
FFFFFFFF 00000000          int __cdecl device_match_of_node(device *dev, const void *np);
FFFFFFFF 00000000          int __cdecl device_move(device *dev, device *new_parent, dpm_order dpm_order);
FFFFFFFF 00000000          int __cdecl device_offline(device *dev);
FFFFFFFF 00000000          int __cdecl device_online(device *dev);
FFFFFFFF 00000000          void device_pm_lock(void);
FFFFFFFF 00000000          void device_pm_unlock(void);
FFFFFFFF 00000000          int __cdecl device_pm_wait_for_dev(device *sub, device *dev);
FFFFFFFF 00000000          int __cdecl device_property_match_string(device *dev, const char *propname, const char *string);
FFFFFFFF 00000000          bool __cdecl device_property_present(device *dev, const char *propname);
FFFFFFFF 00000000          int __cdecl device_property_read_string(device *dev, const char *propname, const char **val);
FFFFFFFF 00000000          int __cdecl device_property_read_string_array(device *dev, const char *propname, const char **val, size_t nval);
FFFFFFFF 00000000          int __cdecl device_property_read_u16_array(device *dev, const char *propname, u16 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl device_property_read_u32_array(device *dev, const char *propname, u32 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl device_property_read_u64_array(device *dev, const char *propname, u64 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl device_property_read_u8_array(device *dev, const char *propname, u8 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl device_register(device *dev);
FFFFFFFF 00000000          void __cdecl device_release_driver(device *dev);
FFFFFFFF 00000000          void __cdecl device_remove_bin_file(device *dev, const bin_attribute *attr);
FFFFFFFF 00000000          void __cdecl device_remove_file(device *dev, const device_attribute *attr);
FFFFFFFF 00000000          bool __cdecl device_remove_file_self(device *dev, const device_attribute *attr);
FFFFFFFF 00000000          void __cdecl device_remove_groups(device *dev, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl device_remove_properties(device *dev);
FFFFFFFF 00000000          int __cdecl device_rename(device *dev, const char *new_name);
FFFFFFFF 00000000          int __cdecl device_reprobe(device *dev);
FFFFFFFF 00000000          void __cdecl device_set_of_node_from_dev(device *dev, const device *dev2);
FFFFFFFF 00000000          void __cdecl device_set_wakeup_capable(device *dev, bool capable);
FFFFFFFF 00000000          int __cdecl device_set_wakeup_enable(device *dev, bool enable);
FFFFFFFF 00000000          ssize_t __cdecl device_show_bool(device *dev, device_attribute *attr, char *buf);
FFFFFFFF 00000000          ssize_t __cdecl device_show_int(device *dev, device_attribute *attr, char *buf);
FFFFFFFF 00000000          ssize_t __cdecl device_show_ulong(device *dev, device_attribute *attr, char *buf);
FFFFFFFF 00000000          void device_shutdown(void);
FFFFFFFF 00000000          ssize_t __cdecl device_store_bool(device *dev, device_attribute *attr, const char *buf, size_t count);
FFFFFFFF 00000000          ssize_t __cdecl device_store_int(device *dev, device_attribute *attr, const char *buf, size_t count);
FFFFFFFF 00000000          ssize_t __cdecl device_store_ulong(device *dev, device_attribute *attr, const char *buf, size_t count);
FFFFFFFF 00000000          void __cdecl device_unregister(device *dev);
FFFFFFFF 00000000          int __cdecl device_wakeup_disable(device *dev);
FFFFFFFF 00000000          int __cdecl device_wakeup_enable(device *dev);
00000000 00000000          char devkmsg_log_str[];
FFFFFFFF 00000000          int __cdecl devkmsg_sysctl_set_loglvl(ctl_table *table, int write, void *buf, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl devm_add_action(device *dev, void (__cdecl *action)(void *), void *data);
FFFFFFFF 00000000          int __cdecl devm_device_add_group(device *dev, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl devm_device_add_groups(device *dev, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl devm_device_remove_group(device *dev, const attribute_group *grp);
FFFFFFFF 00000000          void __cdecl devm_device_remove_groups(device *dev, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl devm_free_irq(device *dev, unsigned int irq, void *dev_id);
FFFFFFFF 00000000          void __cdecl devm_free_pages(device *dev, unsigned __int64 addr);
FFFFFFFF 00000000          void __cdecl devm_free_percpu(device *dev, void *pdata);
FFFFFFFF 00000000          unsigned __int64 __cdecl devm_get_free_pages(device *dev, gfp_t gfp_mask, unsigned int order);
FFFFFFFF 00000000          void *__cdecl devm_ioport_map(device *dev, unsigned __int64 port, unsigned int nr);
FFFFFFFF 00000000          void __cdecl devm_ioport_unmap(device *dev, void *addr);
FFFFFFFF 00000000          void *__cdecl devm_ioremap(device *dev, resource_size_t offset, resource_size_t size);
FFFFFFFF 00000000          void *__cdecl devm_ioremap_nocache(device *dev, resource_size_t offset, resource_size_t size);
FFFFFFFF 00000000          void __cdecl devm_ioremap_release(device *dev, void *res);
FFFFFFFF 00000000          void *__cdecl devm_ioremap_resource(device *dev, const resource *res);
FFFFFFFF 00000000          void *__cdecl devm_ioremap_uc(device *dev, resource_size_t offset, resource_size_t size);
FFFFFFFF 00000000          void *__cdecl devm_ioremap_wc(device *dev, resource_size_t offset, resource_size_t size);
FFFFFFFF 00000000          void __cdecl devm_iounmap(device *dev, void *addr);
FFFFFFFF 00000000          char *devm_kasprintf(device *dev, gfp_t gfp, const char *fmt, ...);
FFFFFFFF 00000000          void __cdecl devm_kfree(device *dev, const void *p);
FFFFFFFF 00000000          void *__cdecl devm_kmalloc(device *dev, size_t size, gfp_t gfp);
FFFFFFFF 00000000          void *__cdecl devm_kmemdup(device *dev, const void *src, size_t len, gfp_t gfp);
FFFFFFFF 00000000          char *__cdecl devm_kstrdup(device *dev, const char *s, gfp_t gfp);
FFFFFFFF 00000000          const char *__cdecl devm_kstrdup_const(device *dev, const char *s, gfp_t gfp);
FFFFFFFF 00000000          char *__cdecl devm_kvasprintf(device *dev, gfp_t gfp, const char *fmt, va_list ap);
FFFFFFFF 00000000          void *__cdecl devm_memremap(device *dev, resource_size_t offset, size_t size, unsigned __int64 flags);
FFFFFFFF 00000000          void *__cdecl devm_memremap_pages(device *dev, dev_pagemap *pgmap);
FFFFFFFF 00000000          void __cdecl devm_memunmap(device *dev, void *addr);
FFFFFFFF 00000000          void __cdecl devm_memunmap_pages(device *dev, dev_pagemap *pgmap);
FFFFFFFF 00000000          nvmem_device *__cdecl devm_nvmem_register(device *dev, const nvmem_config *cfg);
FFFFFFFF 00000000          int __cdecl devm_nvmem_unregister(device *dev, nvmem_device *nvmem);
FFFFFFFF 00000000          void *__cdecl devm_of_iomap(device *dev, device_node *node, int index, resource_size_t *size);
FFFFFFFF 00000000          int __cdecl devm_register_reboot_notifier(device *, notifier_block *);
FFFFFFFF 00000000          void __cdecl devm_release_action(device *dev, void (__cdecl *action)(void *), void *data);
FFFFFFFF 00000000          void __cdecl devm_release_resource(device *dev, resource *new);
FFFFFFFF 00000000          void __cdecl devm_remove_action(device *dev, void (__cdecl *action)(void *), void *data);
FFFFFFFF 00000000          int __cdecl devm_request_any_context_irq(device *dev, unsigned int irq, irq_handler_t handler, unsigned __int64 irqflags, const char *devname, void *dev_id);
FFFFFFFF 00000000          resource *__cdecl devm_request_free_mem_region(device *dev, resource *base, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl devm_request_resource(device *dev, resource *root, resource *new);
FFFFFFFF 00000000          int __cdecl devm_request_threaded_irq(device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned __int64 irqflags, const char *devname, void *dev_id);
FFFFFFFF 00000000          rtc_device *__cdecl devm_rtc_allocate_device(device *dev);
FFFFFFFF 00000000          rtc_device *__cdecl devm_rtc_device_register(device *dev, const char *name, const rtc_class_ops *ops, module *owner);
00000010 00000000          static_key_false devmap_managed_key;
FFFFFFFF 00000000          int __cdecl devmem_is_allowed(unsigned __int64 pagenr);
FFFFFFFF 00000000          void __cdecl devres_add(device *dev, void *res);
FFFFFFFF 00000000          void *__cdecl devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp, int nid);
FFFFFFFF 00000000          void __cdecl devres_close_group(device *dev, void *id);
FFFFFFFF 00000000          int __cdecl devres_destroy(device *dev, dr_release_t release, dr_match_t match, void *match_data);
FFFFFFFF 00000000          void *__cdecl devres_find(device *dev, dr_release_t release, dr_match_t match, void *match_data);
FFFFFFFF 00000000          void __cdecl devres_for_each_res(device *dev, dr_release_t release, dr_match_t match, void *match_data, void (__cdecl *fn)(device *, void *, void *), void *data);
FFFFFFFF 00000000          void __cdecl devres_free(void *res);
FFFFFFFF 00000000          void *__cdecl devres_get(device *dev, void *new_res, dr_match_t match, void *match_data);
FFFFFFFF 00000000          void *__cdecl devres_open_group(device *dev, void *id, gfp_t gfp);
FFFFFFFF 00000000          int __cdecl devres_release(device *dev, dr_release_t release, dr_match_t match, void *match_data);
FFFFFFFF 00000000          int __cdecl devres_release_group(device *dev, void *id);
FFFFFFFF 00000000          void *__cdecl devres_remove(device *dev, dr_release_t release, dr_match_t match, void *match_data);
FFFFFFFF 00000000          void __cdecl devres_remove_group(device *dev, void *id);
FFFFFFFF 00000000          int __cdecl devtmpfs_create_node(device *dev);
FFFFFFFF 00000000          int __cdecl devtmpfs_delete_node(device *dev);
FFFFFFFF 00000000          int __cdecl devtmpfs_mount(const char *mntdir);
00000004 00000000          raw_spinlock_t devtree_lock;
FFFFFFFF 00000000          void __cdecl df_debug(pt_regs *regs, __int64 error_code);
FFFFFFFF 00000000          dentry *__cdecl dget_parent(dentry *dentry);
FFFFFFFF 00000000          void __cdecl dio_end_io(bio *bio);
FFFFFFFF 00000000          void __cdecl dio_warn_stale_pagecache(file *filp);
00000004 00000000          int direct_gbpages;
FFFFFFFF 00000000          blk_qc_t __cdecl direct_make_request(bio *bio);
FFFFFFFF 00000000          void disable_TSC(void);
00000004 00000000          int disable_apic;
FFFFFFFF 00000000          bool __cdecl disable_hardirq(unsigned int irq);
FFFFFFFF 00000000          void disable_ioapic_support(void);
FFFFFFFF 00000000          void __cdecl disable_irq(unsigned int irq);
FFFFFFFF 00000000          void __cdecl disable_irq_nosync(unsigned int irq);
FFFFFFFF 00000000          void disable_local_APIC(void);
FFFFFFFF 00000000          void __cdecl disable_nmi_nosync(unsigned int irq);
FFFFFFFF 00000000          void __cdecl disable_percpu_irq(unsigned int irq);
FFFFFFFF 00000000          void __cdecl disable_percpu_nmi(unsigned int irq);
FFFFFFFF 00000000          void __cdecl disable_pid_allocation(pid_namespace *ns);
00000004 00000000          unsigned int disabled_cpus;
FFFFFFFF 00000000          void __cdecl discard_new_inode(inode *);
FFFFFFFF 00000000          void __cdecl disconnect_bsp_APIC(int virt_wire_setup);
FFFFFFFF 00000000          void __cdecl disk_block_events(gendisk *disk);
FFFFFFFF 00000000          unsigned int __cdecl disk_clear_events(gendisk *disk, unsigned int mask);
FFFFFFFF 00000000          int __cdecl disk_expand_part_tbl(gendisk *disk, int target);
FFFFFFFF 00000000          void __cdecl disk_flush_events(gendisk *disk, unsigned int mask);
FFFFFFFF 00000000          hd_struct *__cdecl disk_get_part(gendisk *disk, int partno);
FFFFFFFF 00000000          hd_struct *__cdecl disk_map_sector_rcu(gendisk *disk, sector_t sector);
FFFFFFFF 00000000          char *__cdecl disk_name(gendisk *hd, int partno, char *buf);
FFFFFFFF 00000000          void __cdecl disk_part_iter_exit(disk_part_iter *piter);
FFFFFFFF 00000000          void __cdecl disk_part_iter_init(disk_part_iter *piter, gendisk *disk, unsigned int flags);
FFFFFFFF 00000000          hd_struct *__cdecl disk_part_iter_next(disk_part_iter *piter);
FFFFFFFF 00000000          void __cdecl disk_stack_limits(gendisk *disk, block_device *bdev, sector_t offset);
FFFFFFFF 00000000          void __cdecl disk_unblock_events(gendisk *disk);
00000004 00000000          int dmesg_restrict;
FFFFFFFF 00000000          unsigned int __cdecl do_IRQ(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl do_adjtimex(__kernel_timex *);
FFFFFFFF 00000000          int __cdecl do_clock_adjtime(const clockid_t which_clock, __kernel_timex *ktx);
FFFFFFFF 00000000          loff_t __cdecl do_clone_file_range(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags);
FFFFFFFF 00000000          void __cdecl __noreturn do_exit(__int64 error_code);
FFFFFFFF 00000000          int __cdecl do_get_thread_area(task_struct *p, int idx, user_desc *info);
FFFFFFFF 00000000          int __cdecl do_getitimer(int which, itimerval *value);
FFFFFFFF 00000000          vm_fault_t __cdecl do_huge_pmd_anonymous_page(vm_fault *vmf);
FFFFFFFF 00000000          vm_fault_t __cdecl do_huge_pmd_numa_page(vm_fault *vmf, pmd_t orig_pmd);
FFFFFFFF 00000000          vm_fault_t __cdecl do_huge_pmd_wp_page(vm_fault *vmf, pmd_t orig_pmd);
FFFFFFFF 00000000          void __cdecl do_invalidatepage(page *page, unsigned int offset, unsigned int length);
FFFFFFFF 00000000          void __cdecl do_kernel_restart(char *cmd);
FFFFFFFF 00000000          unsigned __int64 __cdecl do_mmap(file *file, unsigned __int64 addr, unsigned __int64 len, unsigned __int64 prot, unsigned __int64 flags, vm_flags_t vm_flags, unsigned __int64 pgoff, unsigned __int64 *populate, list_head *uf);
FFFFFFFF 00000000          __int64 __cdecl do_mount(const char *, const char *, const char *, unsigned __int64, void *);
FFFFFFFF 00000000          int __cdecl do_munmap(mm_struct *, unsigned __int64, size_t, list_head *uf);
FFFFFFFF 00000000          __int64 __cdecl do_no_restart_syscall(restart_block *parm);
FFFFFFFF 00000000          int __cdecl do_one_initcall(initcall_t fn);
FFFFFFFF 00000000          int __cdecl do_pipe_flags(int *, int);
FFFFFFFF 00000000          int __cdecl do_prlimit(task_struct *tsk, unsigned int resource, rlimit *new_rlim, rlimit *old_rlim);
FFFFFFFF 00000000          void __cdecl do_set_cpus_allowed(task_struct *p, const cpumask *new_mask);
FFFFFFFF 00000000          int __cdecl do_set_thread_area(task_struct *p, int idx, user_desc *info, int can_allocate);
FFFFFFFF 00000000          int __cdecl do_setitimer(int which, itimerval *value, itimerval *ovalue);
FFFFFFFF 00000000          int __cdecl do_settimeofday64(const timespec64 *ts);
FFFFFFFF 00000000          __int64 __cdecl do_shmat(int shmid, char *shmaddr, int shmflg, unsigned __int64 *addr, unsigned __int64 shmlba);
FFFFFFFF 00000000          void __cdecl do_signal(pt_regs *regs);
FFFFFFFF 00000000          void do_softirq(void);
FFFFFFFF 00000000          void do_softirq_own_stack(void);
FFFFFFFF 00000000          __int64 __cdecl do_splice_direct(file *in, loff_t *ppos, file *out, loff_t *opos, size_t len, unsigned int flags);
FFFFFFFF 00000000          __int64 __cdecl do_sys_open(int dfd, const char *filename, int flags, umode_t mode);
FFFFFFFF 00000000          int __cdecl do_sys_settimeofday64(const timespec64 *tv, const timezone *tz);
FFFFFFFF 00000000          void __cdecl do_trace_rdpmc(unsigned int msr, u64 val, int failed);
FFFFFFFF 00000000          void __cdecl do_trace_read_msr(unsigned int msr, u64 val, int failed);
FFFFFFFF 00000000          void __cdecl do_trace_write_msr(unsigned int msr, u64 val, int failed);
FFFFFFFF 00000000          int __cdecl do_truncate(dentry *, loff_t start, unsigned int time_attrs, file *filp);
FFFFFFFF 00000000          __int64 __cdecl do_utimes(int dfd, const char *filename, timespec64 *times, int flags);
FFFFFFFF 00000000          int __cdecl do_wait_intr(wait_queue_head_t *, wait_queue_entry_t *);
FFFFFFFF 00000000          int __cdecl do_wait_intr_irq(wait_queue_head_t *, wait_queue_entry_t *);
00000068 00000000          x86_hw_tss doublefault_tss;
FFFFFFFF 00000000          void __cdecl down(semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_interruptible(semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_killable(semaphore *sem);
FFFFFFFF 00000000          void __cdecl down_read(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_read_interruptible(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_read_killable(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_read_trylock(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_timeout(semaphore *sem, __int64 jiffies);
FFFFFFFF 00000000          int __cdecl down_trylock(semaphore *sem);
FFFFFFFF 00000000          void __cdecl down_write(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_write_killable(rw_semaphore *sem);
FFFFFFFF 00000000          int __cdecl down_write_trylock(rw_semaphore *sem);
FFFFFFFF 00000000          void __cdecl downgrade_write(rw_semaphore *sem);
FFFFFFFF 00000000          void __cdecl dpm_complete(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_for_each_dev(void *data, void (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          int __cdecl dpm_prepare(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_resume(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_resume_early(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_resume_end(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_resume_noirq(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dpm_resume_start(pm_message_t state);
FFFFFFFF 00000000          int __cdecl dpm_suspend(pm_message_t state);
FFFFFFFF 00000000          int __cdecl dpm_suspend_end(pm_message_t state);
FFFFFFFF 00000000          int __cdecl dpm_suspend_late(pm_message_t state);
FFFFFFFF 00000000          int __cdecl dpm_suspend_noirq(pm_message_t state);
FFFFFFFF 00000000          int __cdecl dpm_suspend_start(pm_message_t state);
FFFFFFFF 00000000          void __cdecl dput(dentry *);
00000004 00000000          spinlock_t dq_data_lock;
00000180 00000000          dqstats dqstats;
FFFFFFFF 00000000          void __cdecl drain_all_pages(zone *zone);
FFFFFFFF 00000000          void __cdecl drain_local_pages(zone *zone);
FFFFFFFF 00000000          void __cdecl drain_workqueue(workqueue_struct *wq);
FFFFFFFF 00000000          void __cdecl drain_zone_pages(zone *zone, per_cpu_pages *pcp);
FFFFFFFF 00000000          void __cdecl drain_zonestat(zone *zone, per_cpu_pageset *);
FFFFFFFF 00000000          int __cdecl driver_attach(device_driver *drv);
FFFFFFFF 00000000          int __cdecl driver_create_file(device_driver *driver, const driver_attribute *attr);
FFFFFFFF 00000000          void __cdecl driver_deferred_probe_add(device *dev);
FFFFFFFF 00000000          int __cdecl driver_deferred_probe_check_state(device *dev);
FFFFFFFF 00000000          int __cdecl driver_deferred_probe_check_state_continue(device *dev);
FFFFFFFF 00000000          device_driver *__cdecl driver_find(const char *name, bus_type *bus);
FFFFFFFF 00000000          device *__cdecl driver_find_device(device_driver *drv, device *start, const void *data, int (__cdecl *match)(device *, const void *));
FFFFFFFF 00000000          int __cdecl driver_for_each_device(device_driver *drv, device *start, void *data, int (__cdecl *fn)(device *, void *));
FFFFFFFF 00000000          void driver_init(void);
FFFFFFFF 00000000          int driver_probe_done(void);
FFFFFFFF 00000000          int __cdecl driver_register(device_driver *drv);
FFFFFFFF 00000000          void __cdecl driver_remove_file(device_driver *driver, const driver_attribute *attr);
FFFFFFFF 00000000          void __cdecl driver_unregister(device_driver *drv);
FFFFFFFF 00000000          int __cdecl drop_caches_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          void __cdecl drop_collected_mounts(vfsmount *);
FFFFFFFF 00000000          void __cdecl drop_nlink(inode *inode);
FFFFFFFF 00000000          void drop_slab(void);
FFFFFFFF 00000000          void __cdecl drop_slab_node(int nid);
FFFFFFFF 00000000          void __cdecl drop_super(super_block *sb);
FFFFFFFF 00000000          void __cdecl drop_super_exclusive(super_block *sb);
FFFFFFFF 00000000          void __cdecl dump_mm(const mm_struct *mm);
FFFFFFFF 00000000          void __cdecl dump_page(page *page, const char *reason);
FFFFFFFF 00000000          void dump_stack(void);
FFFFFFFF 00000000          void __cdecl dump_stack_print_info(const char *log_lvl);
FFFFFFFF 00000000          void dump_stack_set_arch_desc(const char *fmt, ...);
FFFFFFFF 00000000          void __cdecl dump_vma(const vm_area_struct *vma);
FFFFFFFF 00000000          char *dynamic_dname(dentry *, char *, int, const char *, ...);
FFFFFFFF 00000000          void e820__memblock_alloc_reserved_mpc_new(void);
FFFFFFFF 00000000          bool __cdecl each_symbol_section(bool (__cdecl *fn)(const symsearch *, module *, void *), void *data);
FFFFFFFF 00000000          int early_acpi_boot_init(void);
FFFFFFFF 00000000          void early_alloc_pgt_buf(void);
00000001 00000000          bool early_boot_irqs_disabled;
FFFFFFFF 00000000          void early_cpu_init(void);
FFFFFFFF 00000000          void __cdecl early_fixup_exception(pt_regs *regs, int trapnr);
0000000A 00000000          desc_ptr early_gdt_descr;
00000120 00000000          const char early_idt_handler_array[32][9];
FFFFFFFF 00000000          void early_ignore_irq(void);
FFFFFFFF 00000000          void *__cdecl early_ioremap(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void early_ioremap_init(void);
FFFFFFFF 00000000          void early_ioremap_reset(void);
FFFFFFFF 00000000          void early_ioremap_setup(void);
FFFFFFFF 00000000          void early_ioremap_shutdown(void);
FFFFFFFF 00000000          void __cdecl early_iounmap(void *addr, unsigned __int64 size);
FFFFFFFF 00000000          int early_irq_init(void);
FFFFFFFF 00000000          void *__cdecl early_memremap(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl early_memremap_decrypted(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl early_memremap_decrypted_wp(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl early_memremap_encrypted(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl early_memremap_encrypted_wp(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl early_memremap_prot(resource_size_t phys_addr, unsigned __int64 size, unsigned __int64 prot_val);
FFFFFFFF 00000000          void *__cdecl early_memremap_ro(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl early_memunmap(void *addr, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl early_pfn_to_nid(unsigned __int64 pfn);
00000008 0000000000000000          pmdval_t early_pmd_flags;
FFFFFFFF 00000000          void early_printk(const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl early_set_memory_decrypted(unsigned __int64 vaddr, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl early_set_memory_encrypted(unsigned __int64 vaddr, unsigned __int64 size);
00001000 00000000          pgd_t early_top_pgt[512];
FFFFFFFF 00000000          acpi_handle ec_get_handle(void);
FFFFFFFF 00000000          int __cdecl ec_read(u8 addr, u8 *val);
FFFFFFFF 00000000          int __cdecl ec_transaction(u8 command, const u8 *wdata, unsigned int wdata_len, u8 *rdata, unsigned int rdata_len);
FFFFFFFF 00000000          int __cdecl ec_write(u8 addr, u8 val);
00000230 00000000          edd edd;
00000080 00000000          edid_info edid_info;
00000160 00000000          efi efi;
FFFFFFFF 00000000          void __cdecl efi_call_virt_check_flags(unsigned __int64 flags, const char *call);
FFFFFFFF 00000000          unsigned __int64 efi_call_virt_save_flags(void);
FFFFFFFF 00000000          bool __cdecl efi_capsule_pending(int *reset_type);
FFFFFFFF 00000000          int __cdecl efi_capsule_setup_info(capsule_info *cap_info, void *kbuff, size_t hdr_bytes);
FFFFFFFF 00000000          int __cdecl efi_capsule_supported(efi_guid_t guid, u32 flags, size_t size, int *reset);
FFFFFFFF 00000000          int __cdecl efi_capsule_update(efi_capsule_header_t *capsule, phys_addr_t *pages);
FFFFFFFF 00000000          int __cdecl efi_config_init(efi_config_table_type_t *arch_tables);
FFFFFFFF 00000000          int __cdecl efi_config_parse_tables(void *config_tables, int count, int sz, efi_config_table_type_t *arch_tables);
FFFFFFFF 00000000          char *__cdecl efi_convert_cmdline(efi_system_table_t *sys_table_arg, efi_loaded_image_t *image, int *cmd_line_len);
FFFFFFFF 00000000          void __cdecl efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg);
FFFFFFFF 00000000          void efi_enter_virtual_mode(void);
FFFFFFFF 00000000          void efi_esrt_init(void);
FFFFFFFF 00000000          efi_status_t __cdecl efi_exit_boot_services(efi_system_table_t *sys_table, void *handle, efi_boot_memmap *map, void *priv, efi_exit_boot_map_processing priv_func);
FFFFFFFF 00000000          void efi_find_mirror(void);
FFFFFFFF 00000000          void __cdecl efi_free(efi_system_table_t *sys_table_arg, unsigned __int64 size, unsigned __int64 addr);
FFFFFFFF 00000000          device *__cdecl efi_get_device_by_path(efi_dev_path **node, size_t *len);
FFFFFFFF 00000000          int __cdecl efi_get_fdt_params(efi_fdt_params *params);
FFFFFFFF 00000000          u64 efi_get_iobase(void);
FFFFFFFF 00000000          efi_status_t __cdecl efi_get_memory_map(efi_system_table_t *sys_table_arg, efi_boot_memmap *map);
FFFFFFFF 00000000          void *efi_get_pal_addr(void);
FFFFFFFF 00000000          int efi_get_runtime_map_desc_size(void);
FFFFFFFF 00000000          int efi_get_runtime_map_size(void);
FFFFFFFF 00000000          efi_secureboot_mode __cdecl efi_get_secureboot(efi_system_table_t *sys_table);
FFFFFFFF 00000000          void __cdecl efi_gettimeofday(timespec64 *ts);
FFFFFFFF 00000000          efi_status_t __cdecl efi_high_alloc(efi_system_table_t *sys_table_arg, unsigned __int64 size, unsigned __int64 align, unsigned __int64 *addr, unsigned __int64 max);
FFFFFFFF 00000000          void efi_init(void);
FFFFFFFF 00000000          void __cdecl efi_initialize_iomem_resources(resource *code_resource, resource *data_resource, resource *bss_resource);
00000008 0000000000000000          kobject *efi_kobj;
FFFFFFFF 00000000          void *__cdecl efi_lookup_mapped_addr(u64 phys_addr);
FFFFFFFF 00000000          efi_status_t __cdecl efi_low_alloc_above(efi_system_table_t *sys_table_arg, unsigned __int64 size, unsigned __int64 align, unsigned __int64 *addr, unsigned __int64 min);
FFFFFFFF 00000000          void efi_map_pal_code(void);
FFFFFFFF 00000000          char *__cdecl efi_md_typeattr_format(char *buf, size_t size, const efi_memory_desc_t *md);
FFFFFFFF 00000000          u64 __cdecl efi_mem_attribute(unsigned __int64 phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          u64 __cdecl efi_mem_attributes(unsigned __int64 phys_addr);
FFFFFFFF 00000000          u64 __cdecl efi_mem_desc_end(efi_memory_desc_t *md);
FFFFFFFF 00000000          int __cdecl efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);
FFFFFFFF 00000000          void __cdecl efi_mem_reserve(phys_addr_t addr, u64 size);
FFFFFFFF 00000000          int __cdecl efi_mem_reserve_persistent(phys_addr_t addr, u64 size);
FFFFFFFF 00000000          int __cdecl efi_mem_type(unsigned __int64 phys_addr);
FFFFFFFF 00000000          int __cdecl efi_memattr_apply_permissions(mm_struct *mm, efi_memattr_perm_setter fn);
FFFFFFFF 00000000          int efi_memattr_init(void);
FFFFFFFF 00000000          phys_addr_t __cdecl efi_memmap_alloc(unsigned int num_entries);
FFFFFFFF 00000000          int __cdecl efi_memmap_init_early(efi_memory_map_data *data);
FFFFFFFF 00000000          int __cdecl efi_memmap_init_late(phys_addr_t addr, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl efi_memmap_insert(efi_memory_map *old_memmap, void *buf, efi_mem_range *mem);
FFFFFFFF 00000000          int __cdecl efi_memmap_install(phys_addr_t addr, unsigned int nr_map);
FFFFFFFF 00000000          int __cdecl efi_memmap_split_count(efi_memory_desc_t *md, range *range);
FFFFFFFF 00000000          void efi_memmap_unmap(void);
FFFFFFFF 00000000          void __cdecl efi_memmap_walk(efi_freemem_callback_t callback, void *arg);
00000408 00000000          mm_struct efi_mm;
FFFFFFFF 00000000          efi_mokvar_table_entry *__cdecl efi_mokvar_entry_find(const char *name);
FFFFFFFF 00000000          efi_mokvar_table_entry *__cdecl efi_mokvar_entry_next(efi_mokvar_table_entry **mokvar_entry);
FFFFFFFF 00000000          void efi_mokvar_table_init(void);
FFFFFFFF 00000000          void efi_native_runtime_setup(void);
FFFFFFFF 00000000          efi_status_t __cdecl efi_parse_options(const char *cmdline);
FFFFFFFF 00000000          bool efi_poweroff_required(void);
FFFFFFFF 00000000          void __cdecl efi_printk(efi_system_table_t *sys_table_arg, char *str);
FFFFFFFF 00000000          efi_status_t __cdecl efi_query_variable_store(u32 attributes, unsigned __int64 size, bool nonblocking);
FFFFFFFF 00000000          void __cdecl efi_reboot(reboot_mode reboot_mode, const char *__unused);
00000004 00000000          int efi_reboot_quirk_mode;
FFFFFFFF 00000000          efi_status_t __cdecl efi_relocate_kernel(efi_system_table_t *sys_table_arg, unsigned __int64 *image_addr, unsigned __int64 image_size, unsigned __int64 alloc_size, unsigned __int64 preferred_addr, unsigned __int64 alignment, unsigned __int64 min_addr);
FFFFFFFF 00000000          void __cdecl efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
00000078 00000000          efi_runtime_work efi_rts_work;
00000008 0000000000000000          workqueue_struct *efi_rts_wq;
FFFFFFFF 00000000          bool efi_runtime_disabled(void);
FFFFFFFF 00000000          int __cdecl efi_runtime_map_copy(void *buf, size_t bufsz);
FFFFFFFF 00000000          int __cdecl efi_runtime_map_init(kobject *);
FFFFFFFF 00000000          void __cdecl efi_set_secure_boot(efi_secureboot_mode mode);
FFFFFFFF 00000000          efi_status_t __cdecl efi_setup_gop(efi_system_table_t *sys_table_arg, screen_info *si, efi_guid_t *proto, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl efi_status_to_err(efi_status_t status);
FFFFFFFF 00000000          const char *__cdecl efi_status_to_str(efi_status_t status);
FFFFFFFF 00000000          int efi_tpm_eventlog_init(void);
00000004 00000000          int efi_tpm_final_log_size;
FFFFFFFF 00000000          int efi_uart_console_only(void);
FFFFFFFF 00000000          int __cdecl efivar_entry_add(efivar_entry *entry, list_head *head);
FFFFFFFF 00000000          int __cdecl efivar_entry_delete(efivar_entry *entry);
FFFFFFFF 00000000          efivar_entry *__cdecl efivar_entry_find(efi_char16_t *name, efi_guid_t guid, list_head *head, bool remove);
FFFFFFFF 00000000          int __cdecl efivar_entry_get(efivar_entry *entry, u32 *attributes, unsigned __int64 *size, void *data);
FFFFFFFF 00000000          int __cdecl efivar_entry_iter(int (__cdecl *func)(efivar_entry *, void *), list_head *head, void *data);
FFFFFFFF 00000000          int efivar_entry_iter_begin(void);
FFFFFFFF 00000000          void efivar_entry_iter_end(void);
FFFFFFFF 00000000          int __cdecl efivar_entry_remove(efivar_entry *entry);
FFFFFFFF 00000000          int __cdecl efivar_entry_set(efivar_entry *entry, u32 attributes, unsigned __int64 size, void *data, list_head *head);
FFFFFFFF 00000000          int __cdecl efivar_entry_set_get_size(efivar_entry *entry, u32 attributes, unsigned __int64 *size, void *data, bool *set);
FFFFFFFF 00000000          int __cdecl efivar_entry_set_safe(efi_char16_t *name, efi_guid_t vendor, u32 attributes, bool block, unsigned __int64 size, void *data);
FFFFFFFF 00000000          int __cdecl efivar_entry_size(efivar_entry *entry, unsigned __int64 *size);
FFFFFFFF 00000000          int __cdecl efivar_init(int (__cdecl *func)(efi_char16_t *, efi_guid_t, unsigned __int64, void *), void *data, bool duplicates, list_head *head);
FFFFFFFF 00000000          void efivar_run_worker(void);
00000010 00000000          list_head efivar_sysfs_list;
FFFFFFFF 00000000          bool __cdecl efivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data, unsigned __int64 data_size);
FFFFFFFF 00000000          bool __cdecl efivar_variable_is_removable(efi_guid_t vendor, const char *name, size_t len);
00000020 00000000          work_struct efivar_work;
FFFFFFFF 00000000          kobject *efivars_kobject(void);
FFFFFFFF 00000000          int __cdecl efivars_register(efivars *efivars, const efivar_operations *ops, kobject *kobject);
FFFFFFFF 00000000          int efivars_sysfs_init(void);
FFFFFFFF 00000000          int __cdecl efivars_unregister(efivars *efivars);
FFFFFFFF 00000000          elevator_queue *__cdecl elevator_alloc(request_queue *, elevator_type *);
00000004 00000000          u32 elf_hwcap2;
FFFFFFFF 00000000          bool __cdecl elv_attempt_insert_merge(request_queue *, request *);
FFFFFFFF 00000000          bool __cdecl elv_bio_merge_ok(request *, bio *);
FFFFFFFF 00000000          request *__cdecl elv_former_request(request_queue *, request *);
FFFFFFFF 00000000          ssize_t __cdecl elv_iosched_show(request_queue *, char *);
FFFFFFFF 00000000          ssize_t __cdecl elv_iosched_store(request_queue *, const char *, size_t);
FFFFFFFF 00000000          request *__cdecl elv_latter_request(request_queue *, request *);
FFFFFFFF 00000000          elv_merge __cdecl elv_merge(request_queue *, request **, bio *);
FFFFFFFF 00000000          void __cdecl elv_merge_requests(request_queue *, request *, request *);
FFFFFFFF 00000000          void __cdecl elv_merged_request(request_queue *, request *, elv_merge);
FFFFFFFF 00000000          void __cdecl elv_rb_add(rb_root *, request *);
FFFFFFFF 00000000          void __cdecl elv_rb_del(rb_root *, request *);
FFFFFFFF 00000000          request *__cdecl elv_rb_find(rb_root *, sector_t);
FFFFFFFF 00000000          request *__cdecl elv_rb_former_request(request_queue *, request *);
FFFFFFFF 00000000          request *__cdecl elv_rb_latter_request(request_queue *, request *);
FFFFFFFF 00000000          int __cdecl elv_register(elevator_type *);
FFFFFFFF 00000000          void __cdecl elv_rqhash_add(request_queue *q, request *rq);
FFFFFFFF 00000000          void __cdecl elv_rqhash_del(request_queue *q, request *rq);
FFFFFFFF 00000000          request *__cdecl elv_rqhash_find(request_queue *q, sector_t offset);
FFFFFFFF 00000000          void __cdecl elv_rqhash_reposition(request_queue *q, request *rq);
FFFFFFFF 00000000          void __cdecl elv_unregister(elevator_type *);
FFFFFFFF 00000000          void emergency_remount(void);
FFFFFFFF 00000000          void emergency_restart(void);
FFFFFFFF 00000000          void emergency_sync(void);
FFFFFFFF 00000000          void emergency_thaw_all(void);
FFFFFFFF 00000000          void __cdecl emergency_thaw_bdev(super_block *sb);
000000A8 00000000          const address_space_operations empty_aops;
00000010 00000000          const qstr empty_name;
00001000 00000000          unsigned __int64 empty_zero_page[512];
FFFFFFFF 00000000          void enable_IO_APIC(void);
FFFFFFFF 00000000          void enable_IR_x2apic(void);
FFFFFFFF 00000000          void __cdecl enable_irq(unsigned int irq);
FFFFFFFF 00000000          void __cdecl enable_nmi(unsigned int irq);
FFFFFFFF 00000000          void __cdecl enable_percpu_irq(unsigned int irq, unsigned int type);
FFFFFFFF 00000000          void __cdecl enable_percpu_nmi(unsigned int irq, unsigned int type);
FFFFFFFF 00000000          void enable_sep_cpu(void);
00000004 00000000          int enable_update_mptable;
FFFFFFFF 00000000          void __cdecl end_page_writeback(page *page);
00000000 00000000          ctl_table epoll_table[];
FFFFFFFF 00000000          blk_status_t __cdecl errno_to_blk_status(int errno);
FFFFFFFF 00000000          int __cdecl errseq_check(errseq_t *eseq, errseq_t since);
FFFFFFFF 00000000          int __cdecl errseq_check_and_advance(errseq_t *eseq, errseq_t *since);
FFFFFFFF 00000000          errseq_t __cdecl errseq_sample(errseq_t *eseq);
FFFFFFFF 00000000          errseq_t __cdecl errseq_set(errseq_t *eseq, int err);
FFFFFFFF 00000000          void __cdecl evict_inodes(super_block *sb);
FFFFFFFF 00000000          bool __cdecl ex_has_fault_handler(unsigned __int64 ip);
FFFFFFFF 00000000          int __cdecl execute_in_process_context(work_func_t fn, execute_work *);
FFFFFFFF 00000000          void __cdecl exit_creds(task_struct *);
FFFFFFFF 00000000          void __cdecl exit_io_context(task_struct *task);
FFFFFFFF 00000000          void __cdecl exit_mmap(mm_struct *);
FFFFFFFF 00000000          void exit_rcu(void);
FFFFFFFF 00000000          void __cdecl exit_sem(task_struct *tsk);
FFFFFFFF 00000000          void __cdecl exit_shm(task_struct *task);
FFFFFFFF 00000000          void exit_tasks_rcu_finish(void);
FFFFFFFF 00000000          void exit_tasks_rcu_start(void);
FFFFFFFF 00000000          int __cdecl expand_downwards(vm_area_struct *vma, unsigned __int64 address);
FFFFFFFF 00000000          int __cdecl expand_stack(vm_area_struct *vma, unsigned __int64 address);
FFFFFFFF 00000000          void __cdecl f_delown(file *filp);
FFFFFFFF 00000000          int __cdecl f_dupfd(unsigned int from, file *file, unsigned int flags);
FFFFFFFF 00000000          pid_t __cdecl f_getown(file *filp);
FFFFFFFF 00000000          int __cdecl f_setown(file *filp, unsigned __int64 arg, int force);
FFFFFFFF 00000000          fasync_struct *fasync_alloc(void);
FFFFFFFF 00000000          void __cdecl fasync_free(fasync_struct *);
FFFFFFFF 00000000          int __cdecl fasync_helper(int, file *, int, fasync_struct **);
FFFFFFFF 00000000          fasync_struct *__cdecl fasync_insert_entry(int, file *, fasync_struct **, fasync_struct *);
FFFFFFFF 00000000          int __cdecl fasync_remove_entry(file *, fasync_struct **);
FFFFFFFF 00000000          int __cdecl fcntl_getlease(file *filp);
FFFFFFFF 00000000          int __cdecl fcntl_getlk(file *, unsigned int, flock *);
FFFFFFFF 00000000          int __cdecl fcntl_setlease(unsigned int fd, file *filp, __int64 arg);
FFFFFFFF 00000000          int __cdecl fcntl_setlk(unsigned int, file *, unsigned int, flock *);
FFFFFFFF 00000000          void __cdecl fd_install(unsigned int fd, file *file);
FFFFFFFF 00000000          int __cdecl fd_statfs(int, kstatfs *);
FFFFFFFF 00000000          file *__cdecl fget(unsigned int fd);
FFFFFFFF 00000000          file *__cdecl fget_many(unsigned int fd, unsigned int refs);
FFFFFFFF 00000000          file *__cdecl fget_raw(unsigned int fd);
FFFFFFFF 00000000          int __cdecl fiemap_check_flags(fiemap_extent_info *fieinfo, u32 fs_flags);
FFFFFFFF 00000000          int __cdecl fiemap_fill_next_extent(fiemap_extent_info *info, u64 logical, u64 phys, u64 len, u32 flags);
00000004 00000000          int file_caps_enabled;
FFFFFFFF 00000000          int __cdecl file_check_and_advance_wb_err(file *file);
FFFFFFFF 00000000          int __cdecl file_fdatawait_range(file *file, loff_t lstart, loff_t lend);
FFFFFFFF 00000000          int __cdecl file_modified(file *file);
FFFFFFFF 00000000          bool __cdecl file_ns_capable(const file *file, user_namespace *ns, int cap);
FFFFFFFF 00000000          file *__cdecl file_open_name(filename *, int, umode_t);
FFFFFFFF 00000000          file *__cdecl file_open_root(dentry *, vfsmount *, const char *, int, umode_t);
FFFFFFFF 00000000          char *__cdecl file_path(file *, char *, int);
FFFFFFFF 00000000          void __cdecl file_ra_state_init(file_ra_state *ra, address_space *mapping);
FFFFFFFF 00000000          int __cdecl file_remove_privs(file *);
FFFFFFFF 00000000          int __cdecl file_update_time(file *file);
FFFFFFFF 00000000          int __cdecl file_write_and_wait_range(file *file, loff_t start, loff_t end);
FFFFFFFF 00000000          int __cdecl filemap_check_errors(address_space *mapping);
FFFFFFFF 00000000          vm_fault_t __cdecl filemap_fault(vm_fault *vmf);
FFFFFFFF 00000000          int __cdecl filemap_fdatawait_keep_errors(address_space *mapping);
FFFFFFFF 00000000          int __cdecl filemap_fdatawait_range(address_space *, loff_t lstart, loff_t lend);
FFFFFFFF 00000000          int __cdecl filemap_fdatawait_range_keep_errors(address_space *mapping, loff_t start_byte, loff_t end_byte);
FFFFFFFF 00000000          int __cdecl filemap_fdatawrite(address_space *);
FFFFFFFF 00000000          int __cdecl filemap_fdatawrite_range(address_space *mapping, loff_t start, loff_t end);
FFFFFFFF 00000000          int __cdecl filemap_flush(address_space *);
FFFFFFFF 00000000          void __cdecl filemap_map_pages(vm_fault *vmf, unsigned __int64 start_pgoff, unsigned __int64 end_pgoff);
FFFFFFFF 00000000          vm_fault_t __cdecl filemap_page_mkwrite(vm_fault *vmf);
FFFFFFFF 00000000          bool __cdecl filemap_range_has_page(address_space *, loff_t lstart, loff_t lend);
FFFFFFFF 00000000          int __cdecl filemap_write_and_wait(address_space *mapping);
FFFFFFFF 00000000          int __cdecl filemap_write_and_wait_range(address_space *mapping, loff_t lstart, loff_t lend);
FFFFFFFF 00000000          void files_init(void);
FFFFFFFF 00000000          void files_maxfiles_init(void);
00000018 00000000          files_stat_struct files_stat;
FFFFFFFF 00000000          int __cdecl filp_close(file *, fl_owner_t id);
FFFFFFFF 00000000          file *__cdecl filp_open(const char *, int, umode_t);
FFFFFFFF 00000000          bug_entry *__cdecl find_bug(unsigned __int64 bugaddr);
FFFFFFFF 00000000          vm_area_struct *__cdecl find_extend_vma(mm_struct *, unsigned __int64 addr);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_first_bit(const unsigned __int64 *addr, unsigned __int64 size);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_first_zero_bit(const unsigned __int64 *addr, unsigned __int64 size);
FFFFFFFF 00000000          pid *__cdecl find_ge_pid(int nr, pid_namespace *);
FFFFFFFF 00000000          unsigned int __cdecl find_get_entries(address_space *mapping, unsigned __int64 start, unsigned int nr_entries, page **entries, unsigned __int64 *indices);
FFFFFFFF 00000000          page *__cdecl find_get_entry(address_space *mapping, unsigned __int64 offset);
FFFFFFFF 00000000          unsigned int __cdecl find_get_pages_contig(address_space *mapping, unsigned __int64 start, unsigned int nr_pages, page **pages);
FFFFFFFF 00000000          unsigned int __cdecl find_get_pages_range(address_space *mapping, unsigned __int64 *start, unsigned __int64 end, unsigned int nr_pages, page **pages);
FFFFFFFF 00000000          unsigned int __cdecl find_get_pages_range_tag(address_space *mapping, unsigned __int64 *index, unsigned __int64 end, xa_mark_t tag, unsigned int nr_pages, page **pages);
FFFFFFFF 00000000          pid *__cdecl find_get_pid(int nr);
FFFFFFFF 00000000          task_struct *__cdecl find_get_task_by_vpid(pid_t nr);
FFFFFFFF 00000000          inode *__cdecl find_inode_nowait(super_block *, unsigned __int64, int (__cdecl *match)(inode *, unsigned __int64, void *), void *data);
FFFFFFFF 00000000          logic_pio_hwaddr *__cdecl find_io_range_by_fwnode(fwnode_handle *fwnode);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_last_bit(const unsigned __int64 *addr, unsigned __int64 size);
FFFFFFFF 00000000          page *__cdecl find_lock_entry(address_space *mapping, unsigned __int64 offset);
FFFFFFFF 00000000          anon_vma *__cdecl find_mergeable_anon_vma(vm_area_struct *);
FFFFFFFF 00000000          unsigned __int64 find_min_pfn_with_active_regions(void);
FFFFFFFF 00000000          module *__cdecl find_module(const char *name);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_next_and_bit(const unsigned __int64 *addr1, const unsigned __int64 *addr2, unsigned __int64 size, unsigned __int64 offset);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_next_bit(const unsigned __int64 *addr, unsigned __int64 size, unsigned __int64 offset);
FFFFFFFF 00000000          unsigned __int64 __cdecl find_next_zero_bit(const unsigned __int64 *addr, unsigned __int64 size, unsigned __int64 offset);
FFFFFFFF 00000000          pid *__cdecl find_pid_ns(int nr, pid_namespace *ns);
FFFFFFFF 00000000          const kernel_symbol *__cdecl find_symbol(const char *name, module **owner, const s32 **crc, bool gplok, bool warn);
FFFFFFFF 00000000          task_struct *__cdecl find_task_by_pid_ns(pid_t nr, pid_namespace *ns);
FFFFFFFF 00000000          task_struct *__cdecl find_task_by_vpid(pid_t nr);
FFFFFFFF 00000000          user_struct *__cdecl find_user(kuid_t);
FFFFFFFF 00000000          vm_struct *__cdecl find_vm_area(const void *addr);
FFFFFFFF 00000000          vm_area_struct *__cdecl find_vma(mm_struct *mm, unsigned __int64 addr);
FFFFFFFF 00000000          vm_area_struct *__cdecl find_vma_prev(mm_struct *mm, unsigned __int64 addr, vm_area_struct **pprev);
FFFFFFFF 00000000          pid *__cdecl find_vpid(int nr);
FFFFFFFF 00000000          vm_fault_t __cdecl finish_fault(vm_fault *vmf);
FFFFFFFF 00000000          vm_fault_t __cdecl finish_mkwrite_fault(vm_fault *vmf);
FFFFFFFF 00000000          int __cdecl finish_no_open(file *file, dentry *dentry);
FFFFFFFF 00000000          int __cdecl finish_open(file *file, dentry *dentry, int (__cdecl *open)(inode *, file *));
FFFFFFFF 00000000          void __cdecl finish_wait(wait_queue_head *wq_head, wait_queue_entry *wq_entry);
00000008 0000000000000000          kobject *firmware_kobj;
FFFFFFFF 00000000          pglist_data *first_online_pgdat(void);
00000030 00000000          fixed_percpu_data fixed_percpu_data;
FFFFFFFF 00000000          loff_t __cdecl fixed_size_llseek(file *file, loff_t offset, int whence, loff_t size);
00000004 00000000          int fixmaps_set;
FFFFFFFF 00000000          int __cdecl fixup_bug(pt_regs *regs, int trapnr);
FFFFFFFF 00000000          int __cdecl fixup_exception(pt_regs *regs, int trapnr, unsigned __int64 error_code, unsigned __int64 fault_addr);
FFFFFFFF 00000000          void fixup_irqs(void);
FFFFFFFF 00000000          int __cdecl fixup_user_fault(task_struct *tsk, mm_struct *mm, unsigned __int64 address, unsigned int fault_flags, bool *unlocked);
00000008 0000000000000000          const bpf_prog_ops flow_dissector_prog_ops;
00000028 00000000          const bpf_verifier_ops flow_dissector_verifier_ops;
FFFFFFFF 00000000          void flush_delayed_fput(void);
FFFFFFFF 00000000          bool __cdecl flush_delayed_work(delayed_work *dwork);
FFFFFFFF 00000000          bool __cdecl flush_rcu_work(rcu_work *rwork);
FFFFFFFF 00000000          bool __cdecl flush_work(work_struct *work);
FFFFFFFF 00000000          void __cdecl flush_workqueue(workqueue_struct *wq);
FFFFFFFF 00000000          page *__cdecl follow_devmap_pmd(vm_area_struct *vma, unsigned __int64 addr, pmd_t *pmd, int flags, dev_pagemap **pgmap);
FFFFFFFF 00000000          page *__cdecl follow_devmap_pud(vm_area_struct *vma, unsigned __int64 addr, pud_t *pud, int flags, dev_pagemap **pgmap);
FFFFFFFF 00000000          int __cdecl follow_invalidate_pte(mm_struct *mm, unsigned __int64 address, mmu_notifier_range *range, pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp);
FFFFFFFF 00000000          page *__cdecl follow_page(vm_area_struct *vma, unsigned __int64 address, unsigned int foll_flags);
FFFFFFFF 00000000          int __cdecl follow_pfn(vm_area_struct *vma, unsigned __int64 address, unsigned __int64 *pfn);
FFFFFFFF 00000000          int __cdecl follow_phys(vm_area_struct *vma, unsigned __int64 address, unsigned int flags, unsigned __int64 *prot, resource_size_t *phys);
FFFFFFFF 00000000          int __cdecl follow_pte(mm_struct *mm, unsigned __int64 address, pte_t **ptepp, spinlock_t **ptlp);
FFFFFFFF 00000000          page *__cdecl follow_trans_huge_pmd(vm_area_struct *vma, unsigned __int64 addr, pmd_t *pmd, unsigned int flags);
00000001 00000000          bool force_irqthreads;
FFFFFFFF 00000000          int __cdecl force_page_cache_readahead(address_space *mapping, file *filp, unsigned __int64 offset, unsigned __int64 nr_to_read);
00000004 00000000          int force_personality32;
FFFFFFFF 00000000          int __cdecl fork_usermode_blob(void *data, size_t len, umh_info *info);
FFFFFFFF 00000000          void __cdecl __noreturn fortify_panic(const char *name);
FFFFFFFF 00000000          void fpregs_assert_state_consistent(void);
FFFFFFFF 00000000          void fpregs_mark_activate(void);
FFFFFFFF 00000000          void __cdecl fprop_fraction_percpu(fprop_global *p, fprop_local_percpu *pl, unsigned __int64 *numerator, unsigned __int64 *denominator);
FFFFFFFF 00000000          void __cdecl fprop_fraction_single(fprop_global *p, fprop_local_single *pl, unsigned __int64 *numerator, unsigned __int64 *denominator);
FFFFFFFF 00000000          void __cdecl fprop_global_destroy(fprop_global *p);
FFFFFFFF 00000000          int __cdecl fprop_global_init(fprop_global *p, gfp_t gfp);
FFFFFFFF 00000000          void __cdecl fprop_local_destroy_percpu(fprop_local_percpu *pl);
FFFFFFFF 00000000          void __cdecl fprop_local_destroy_single(fprop_local_single *pl);
FFFFFFFF 00000000          int __cdecl fprop_local_init_percpu(fprop_local_percpu *pl, gfp_t gfp);
FFFFFFFF 00000000          int __cdecl fprop_local_init_single(fprop_local_single *pl);
FFFFFFFF 00000000          bool __cdecl fprop_new_period(fprop_global *p, int periods);
00000004 00000000          unsigned int fpu_kernel_xstate_size;
00000004 00000000          unsigned int fpu_user_xstate_size;
FFFFFFFF 00000000          void __cdecl fput(file *);
FFFFFFFF 00000000          void __cdecl fput_many(file *, unsigned int);
FFFFFFFF 00000000          frame_vector *__cdecl frame_vector_create(unsigned int nr_frames);
FFFFFFFF 00000000          void __cdecl frame_vector_destroy(frame_vector *vec);
FFFFFFFF 00000000          int __cdecl frame_vector_to_pages(frame_vector *vec);
FFFFFFFF 00000000          void __cdecl frame_vector_to_pfns(frame_vector *vec);
FFFFFFFF 00000000          void __cdecl free_anon_bdev(dev_t);
FFFFFFFF 00000000          void __cdecl free_area_init(unsigned __int64 *zones_size);
FFFFFFFF 00000000          void __cdecl free_area_init_core_hotplug(int nid);
FFFFFFFF 00000000          void __cdecl free_area_init_node(int nid, unsigned __int64 *zones_size, unsigned __int64 zone_start_pfn, unsigned __int64 *zholes_size);
FFFFFFFF 00000000          void __cdecl free_area_init_nodes(unsigned __int64 *max_zone_pfn);
FFFFFFFF 00000000          void __cdecl free_bootmem_cpumask_var(cpumask_var_t mask);
FFFFFFFF 00000000          void __cdecl free_bootmem_with_active_regions(int nid, unsigned __int64 max_low_pfn);
FFFFFFFF 00000000          void __cdecl free_bucket_spinlocks(spinlock_t *locks);
FFFFFFFF 00000000          void __cdecl free_compound_page(page *page);
FFFFFFFF 00000000          void __cdecl free_contig_range(unsigned __int64 pfn, unsigned int nr_pages);
FFFFFFFF 00000000          void __cdecl free_cpumask_var(cpumask_var_t mask);
FFFFFFFF 00000000          void __cdecl free_init_pages(const char *what, unsigned __int64 begin, unsigned __int64 end);
FFFFFFFF 00000000          void free_initmem(void);
FFFFFFFF 00000000          void __cdecl free_inode_nonrcu(inode *inode);
FFFFFFFF 00000000          const void *__cdecl free_irq(unsigned int, void *);
FFFFFFFF 00000000          void __cdecl free_kernel_image_pages(void *begin, void *end);
FFFFFFFF 00000000          const void *__cdecl free_nmi(unsigned int irq, void *dev_id);
FFFFFFFF 00000000          void __cdecl free_pages(unsigned __int64 addr, unsigned int order);
FFFFFFFF 00000000          void __cdecl free_pages_exact(void *virt, size_t size);
FFFFFFFF 00000000          void __cdecl free_percpu(void *__pdata);
FFFFFFFF 00000000          void __cdecl free_percpu_irq(unsigned int, void *);
FFFFFFFF 00000000          void __cdecl free_percpu_nmi(unsigned int irq, void *percpu_dev_id);
FFFFFFFF 00000000          void __cdecl free_pgd_range(mmu_gather *tlb, unsigned __int64 addr, unsigned __int64 end, unsigned __int64 floor, unsigned __int64 ceiling);
FFFFFFFF 00000000          void __cdecl free_pid(pid *pid);
FFFFFFFF 00000000          void __cdecl free_prealloced_shrinker(shrinker *shrinker);
FFFFFFFF 00000000          unsigned __int64 __cdecl free_reserved_area(void *start, void *end, int poison, const char *s);
FFFFFFFF 00000000          void __cdecl free_transhuge_page(page *page);
FFFFFFFF 00000000          void __cdecl free_uid(user_struct *);
FFFFFFFF 00000000          void __cdecl free_unref_page(page *page);
FFFFFFFF 00000000          void __cdecl free_unref_page_list(list_head *list);
FFFFFFFF 00000000          void __cdecl free_vm_area(vm_struct *area);
FFFFFFFF 00000000          void __cdecl free_workqueue_attrs(workqueue_attrs *attrs);
FFFFFFFF 00000000          super_block *__cdecl freeze_bdev(block_device *);
FFFFFFFF 00000000          int __cdecl freeze_super(super_block *super);
FFFFFFFF 00000000          void freeze_workqueues_begin(void);
FFFFFFFF 00000000          bool freeze_workqueues_busy(void);
00000008 0000000000000000          unsigned __int64 freq_scale;
FFFFFFFF 00000000          gid_t __cdecl from_kgid(user_namespace *to, kgid_t gid);
FFFFFFFF 00000000          gid_t __cdecl from_kgid_munged(user_namespace *to, kgid_t gid);
FFFFFFFF 00000000          projid_t __cdecl from_kprojid(user_namespace *to, kprojid_t projid);
FFFFFFFF 00000000          projid_t __cdecl from_kprojid_munged(user_namespace *to, kprojid_t projid);
FFFFFFFF 00000000          qid_t __cdecl from_kqid(user_namespace *to, kqid qid);
FFFFFFFF 00000000          qid_t __cdecl from_kqid_munged(user_namespace *to, kqid qid);
FFFFFFFF 00000000          uid_t __cdecl from_kuid(user_namespace *to, kuid_t uid);
FFFFFFFF 00000000          uid_t __cdecl from_kuid_munged(user_namespace *to, kuid_t uid);
00000170 00000000          bio_set fs_bio_set;
FFFFFFFF 00000000          unsigned __int8 __cdecl fs_ftype_to_dtype(unsigned int filetype);
00000008 0000000000000000          kobject *fs_kobj;
00000004 00000000          int fs_overflowgid;
00000004 00000000          int fs_overflowuid;
FFFFFFFF 00000000          unsigned __int8 __cdecl fs_umode_to_dtype(umode_t mode);
FFFFFFFF 00000000          unsigned __int8 __cdecl fs_umode_to_ftype(umode_t mode);
FFFFFFFF 00000000          int __cdecl fsync_bdev(block_device *);
FFFFFFFF 00000000          void __cdecl ftrace_dump(ftrace_dump_mode oops_dump_mode);
FFFFFFFF 00000000          unsigned int __cdecl full_name_hash(const void *salt, const char *, unsigned int);
FFFFFFFF 00000000          int __cdecl func_ptr_is_kernel_text(void *ptr);
FFFFFFFF 00000000          void *__cdecl fwnode_connection_find_match(fwnode_handle *fwnode, const char *con_id, void *data, devcon_match_fn_t match);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_create_software_node(const property_entry *properties, const fwnode_handle *parent);
FFFFFFFF 00000000          bool __cdecl fwnode_device_is_available(const fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_find_reference(const fwnode_handle *fwnode, const char *name, unsigned int index);
FFFFFFFF 00000000          void *__cdecl fwnode_get_mac_address(fwnode_handle *fwnode, char *addr, int alen);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_get_named_child_node(const fwnode_handle *fwnode, const char *childname);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_get_next_available_child_node(const fwnode_handle *fwnode, fwnode_handle *child);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_get_next_child_node(const fwnode_handle *fwnode, fwnode_handle *child);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_get_next_parent(fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_get_parent(const fwnode_handle *fwnode);
FFFFFFFF 00000000          int __cdecl fwnode_get_phy_mode(fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_endpoint_by_id(const fwnode_handle *fwnode, u32 port, u32 endpoint, unsigned __int64 flags);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_next_endpoint(const fwnode_handle *fwnode, fwnode_handle *prev);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_port_parent(const fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_remote_endpoint(const fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_remote_node(const fwnode_handle *fwnode, u32 port, u32 endpoint);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_remote_port(const fwnode_handle *fwnode);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_graph_get_remote_port_parent(const fwnode_handle *fwnode);
FFFFFFFF 00000000          int __cdecl fwnode_graph_parse_endpoint(const fwnode_handle *fwnode, fwnode_endpoint *endpoint);
FFFFFFFF 00000000          fwnode_handle *__cdecl fwnode_handle_get(fwnode_handle *fwnode);
FFFFFFFF 00000000          void __cdecl fwnode_handle_put(fwnode_handle *fwnode);
FFFFFFFF 00000000          int __cdecl fwnode_irq_get(fwnode_handle *fwnode, unsigned int index);
FFFFFFFF 00000000          int __cdecl fwnode_property_get_reference_args(const fwnode_handle *fwnode, const char *prop, const char *nargs_prop, unsigned int nargs, unsigned int index, fwnode_reference_args *args);
FFFFFFFF 00000000          int __cdecl fwnode_property_match_string(const fwnode_handle *fwnode, const char *propname, const char *string);
FFFFFFFF 00000000          bool __cdecl fwnode_property_present(const fwnode_handle *fwnode, const char *propname);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_string(const fwnode_handle *fwnode, const char *propname, const char **val);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_string_array(const fwnode_handle *fwnode, const char *propname, const char **val, size_t nval);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_u16_array(const fwnode_handle *fwnode, const char *propname, u16 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_u32_array(const fwnode_handle *fwnode, const char *propname, u32 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_u64_array(const fwnode_handle *fwnode, const char *propname, u64 *val, size_t nval);
FFFFFFFF 00000000          int __cdecl fwnode_property_read_u8_array(const fwnode_handle *fwnode, const char *propname, u8 *val, size_t nval);
FFFFFFFF 00000000          void __cdecl fwnode_remove_software_node(fwnode_handle *fwnode);
FFFFFFFF 00000000          void __cdecl generate_random_uuid(unsigned __int8 uuid[16]);
FFFFFFFF 00000000          int __cdecl generic_access_phys(vm_area_struct *vma, unsigned __int64 addr, void *buf, int len, int write);
FFFFFFFF 00000000          void generic_bigsmp_probe(void);
FFFFFFFF 00000000          int __cdecl generic_block_fiemap(inode *inode, fiemap_extent_info *fieinfo, u64 start, u64 len, get_block_t *get_block);
FFFFFFFF 00000000          void generic_bug_clear_once(void);
FFFFFFFF 00000000          int __cdecl generic_check_addressable(unsigned int, u64);
FFFFFFFF 00000000          int __cdecl generic_copy_file_checks(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, size_t *count, unsigned int flags);
FFFFFFFF 00000000          ssize_t __cdecl generic_copy_file_range(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, size_t len, unsigned int flags);
FFFFFFFF 00000000          int __cdecl generic_delete_inode(inode *inode);
FFFFFFFF 00000000          void __cdecl generic_end_io_acct(request_queue *q, int op, hd_struct *part, unsigned __int64 start_time);
FFFFFFFF 00000000          int __cdecl generic_error_remove_page(address_space *mapping, page *page);
FFFFFFFF 00000000          int __cdecl generic_fadvise(file *file, loff_t offset, loff_t len, int advice);
FFFFFFFF 00000000          ssize_t __cdecl generic_file_direct_write(kiocb *, iov_iter *);
FFFFFFFF 00000000          int __cdecl generic_file_fsync(file *, loff_t, loff_t, int);
FFFFFFFF 00000000          loff_t __cdecl generic_file_llseek(file *file, loff_t offset, int whence);
FFFFFFFF 00000000          loff_t __cdecl generic_file_llseek_size(file *file, loff_t offset, int whence, loff_t maxsize, loff_t eof);
FFFFFFFF 00000000          int __cdecl generic_file_mmap(file *, vm_area_struct *);
FFFFFFFF 00000000          int __cdecl generic_file_open(inode *inode, file *filp);
FFFFFFFF 00000000          ssize_t __cdecl generic_file_read_iter(kiocb *, iov_iter *);
FFFFFFFF 00000000          int __cdecl generic_file_readonly_mmap(file *, vm_area_struct *);
FFFFFFFF 00000000          int __cdecl generic_file_rw_checks(file *file_in, file *file_out);
FFFFFFFF 00000000          ssize_t __cdecl generic_file_splice_read(file *, loff_t *, pipe_inode_info *, size_t, unsigned int);
FFFFFFFF 00000000          ssize_t __cdecl generic_file_write_iter(kiocb *, iov_iter *);
FFFFFFFF 00000000          void __cdecl generic_fillattr(inode *, kstat *);
FFFFFFFF 00000000          blk_qc_t __cdecl generic_make_request(bio *bio);
FFFFFFFF 00000000          ssize_t __cdecl generic_perform_write(file *, iov_iter *, loff_t);
FFFFFFFF 00000000          int __cdecl generic_permission(inode *, int);
FFFFFFFF 00000000          int __cdecl generic_processor_info(int apicid, int version);
FFFFFFFF 00000000          ssize_t __cdecl generic_read_dir(file *, char *, size_t, loff_t *);
FFFFFFFF 00000000          int __cdecl generic_remap_checks(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, loff_t *count, unsigned int remap_flags);
FFFFFFFF 00000000          int __cdecl generic_remap_file_range_prep(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, loff_t *count, unsigned int remap_flags);
00000110 00000000          const file_operations generic_ro_fops;
FFFFFFFF 00000000          int __cdecl generic_setlease(file *, __int64, file_lock **, void **priv);
FFFFFFFF 00000000          void __cdecl generic_shutdown_super(super_block *sb);
FFFFFFFF 00000000          void generic_smp_call_function_single_interrupt(void);
FFFFFFFF 00000000          ssize_t __cdecl generic_splice_sendpage(pipe_inode_info *pipe, file *out, loff_t *, size_t len, unsigned int flags);
FFFFFFFF 00000000          void __cdecl generic_start_io_acct(request_queue *q, int op, unsigned __int64 sectors, hd_struct *part);
FFFFFFFF 00000000          int __cdecl generic_update_time(inode *, timespec64 *, int);
FFFFFFFF 00000000          ssize_t __cdecl generic_write_checks(kiocb *, iov_iter *);
FFFFFFFF 00000000          super_block *__cdecl get_active_super(block_device *bdev);
FFFFFFFF 00000000          int __cdecl get_anon_bdev(dev_t *);
FFFFFFFF 00000000          bool __cdecl get_close_on_exec(unsigned int fd);
FFFFFFFF 00000000          int __cdecl get_cmdline(task_struct *task, char *buffer, int buflen);
FFFFFFFF 00000000          dev_pagemap *__cdecl get_dev_pagemap(unsigned __int64 pfn, dev_pagemap *pgmap);
FFFFFFFF 00000000          device *__cdecl get_device(device *dev);
FFFFFFFF 00000000          int __cdecl get_device_system_crosststamp(int (__cdecl *get_time_fn)(ktime_t *, system_counterval_t *, void *), void *ctx, system_time_snapshot *history, system_device_crosststamp *xtstamp);
FFFFFFFF 00000000          kobject *__cdecl get_disk_and_module(gendisk *disk);
FFFFFFFF 00000000          page *__cdecl get_dump_page(unsigned __int64 addr);
FFFFFFFF 00000000          file_system_type *__cdecl get_filesystem(file_system_type *fs);
FFFFFFFF 00000000          int __cdecl get_filesystem_list(char *buf);
FFFFFFFF 00000000          file_system_type *__cdecl get_fs_type(const char *name);
FFFFFFFF 00000000          vm_area_struct *__cdecl get_gate_vma(mm_struct *mm);
FFFFFFFF 00000000          gendisk *__cdecl get_gendisk(dev_t dev, int *partno);
FFFFFFFF 00000000          int __cdecl get_hwpoison_page(page *page);
FFFFFFFF 00000000          int __cdecl get_injectable_error_type(unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl get_itimerspec64(itimerspec64 *it, const __kernel_itimerspec *uit);
FFFFFFFF 00000000          int __cdecl get_kernel_page(unsigned __int64 start, int write, page **pages);
FFFFFFFF 00000000          int __cdecl get_kernel_pages(const kvec *iov, int nr_pages, int write, page **pages);
FFFFFFFF 00000000          unsigned __int64 get_max_files(void);
FFFFFFFF 00000000          file *__cdecl get_mm_exe_file(mm_struct *mm);
FFFFFFFF 00000000          unsigned __int64 __cdecl get_mmap_base(int is_legacy);
FFFFFFFF 00000000          unsigned int get_next_ino(void);
FFFFFFFF 00000000          int __cdecl get_old_itimerspec32(itimerspec64 *its, const old_itimerspec32 *uits);
FFFFFFFF 00000000          int __cdecl get_old_timespec32(timespec64 *, const void *);
FFFFFFFF 00000000          int __cdecl get_old_timex32(__kernel_timex *, const old_timex32 *);
FFFFFFFF 00000000          void get_online_mems(void);
FFFFFFFF 00000000          int __cdecl get_option(char **str, int *pint);
FFFFFFFF 00000000          char *__cdecl get_options(const char *str, int nints, int *ints);
FFFFFFFF 00000000          void __cdecl get_page_bootmem(unsigned __int64 ingo, page *page, unsigned __int64 type);
FFFFFFFF 00000000          void __cdecl get_pfn_range_for_nid(unsigned int nid, unsigned __int64 *start_pfn, unsigned __int64 *end_pfn);
FFFFFFFF 00000000          unsigned __int64 __cdecl get_pfnblock_flags_mask(page *page, unsigned __int64 pfn, unsigned __int64 end_bitidx, unsigned __int64 mask);
FFFFFFFF 00000000          int get_physical_broadcast(void);
FFFFFFFF 00000000          task_struct *__cdecl get_pid_task(pid *pid, pid_type);
FFFFFFFF 00000000          void __cdecl get_seccomp_filter(task_struct *tsk);
FFFFFFFF 00000000          unsigned __int64 get_state_synchronize_rcu(void);
FFFFFFFF 00000000          super_block *__cdecl get_super(block_device *);
FFFFFFFF 00000000          super_block *__cdecl get_super_exclusive_thawed(block_device *bdev);
FFFFFFFF 00000000          super_block *__cdecl get_super_thawed(block_device *);
FFFFFFFF 00000000          unsigned __int64 get_taint(void);
FFFFFFFF 00000000          const cred *__cdecl get_task_cred(task_struct *);
FFFFFFFF 00000000          file *__cdecl get_task_exe_file(task_struct *task);
FFFFFFFF 00000000          io_context *__cdecl get_task_io_context(task_struct *task, gfp_t gfp_flags, int node);
FFFFFFFF 00000000          pid *__cdecl get_task_pid(task_struct *task, pid_type type);
FFFFFFFF 00000000          int __cdecl get_timespec64(timespec64 *ts, const __kernel_timespec *uts);
FFFFFFFF 00000000          int __cdecl get_tsc_mode(unsigned __int64 adr);
FFFFFFFF 00000000          unsigned __int64 __cdecl get_unmapped_area(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
FFFFFFFF 00000000          int __cdecl get_unused_fd_flags(unsigned int flags);
FFFFFFFF 00000000          __int64 __cdecl get_user_pages(unsigned __int64 start, unsigned __int64 nr_pages, unsigned int gup_flags, page **pages, vm_area_struct **vmas);
FFFFFFFF 00000000          int __cdecl get_user_pages_fast(unsigned __int64 start, int nr_pages, unsigned int gup_flags, page **pages);
FFFFFFFF 00000000          __int64 __cdecl get_user_pages_locked(unsigned __int64 start, unsigned __int64 nr_pages, unsigned int gup_flags, page **pages, int *locked);
FFFFFFFF 00000000          __int64 __cdecl get_user_pages_remote(task_struct *tsk, mm_struct *mm, unsigned __int64 start, unsigned __int64 nr_pages, unsigned int gup_flags, page **pages, vm_area_struct **vmas, int *locked);
FFFFFFFF 00000000          __int64 __cdecl get_user_pages_unlocked(unsigned __int64 start, unsigned __int64 nr_pages, page **pages, unsigned int gup_flags);
FFFFFFFF 00000000          int __cdecl get_vaddr_frames(unsigned __int64 start, unsigned int nr_pfns, unsigned int gup_flags, frame_vector *vec);
FFFFFFFF 00000000          int __cdecl get_vfs_caps_from_disk(const dentry *dentry, cpu_vfs_cap_data *cpu_caps);
FFFFFFFF 00000000          vm_struct *__cdecl get_vm_area(unsigned __int64 size, unsigned __int64 flags);
FFFFFFFF 00000000          vm_struct *__cdecl get_vm_area_caller(unsigned __int64 size, unsigned __int64 flags, const void *caller);
FFFFFFFF 00000000          unsigned __int64 __cdecl get_wchan(task_struct *p);
FFFFFFFF 00000000          void *__cdecl get_xsave_addr(xregs_state *xsave, int xfeature_nr);
FFFFFFFF 00000000          const void *__cdecl get_xsave_field_ptr(int xfeature_nr);
FFFFFFFF 00000000          unsigned __int64 __cdecl get_zeroed_page(gfp_t gfp_mask);
FFFFFFFF 00000000          void __cdecl getboottime64(timespec64 *ts);
FFFFFFFF 00000000          filename *__cdecl getname(const char *);
FFFFFFFF 00000000          filename *__cdecl getname_flags(const char *, int, int *);
FFFFFFFF 00000000          filename *__cdecl getname_kernel(const char *);
FFFFFFFF 00000000          void __cdecl getrusage(task_struct *p, int who, rusage *ru);
00000004 00000000          gfp_t gfp_allowed_mask;
FFFFFFFF 00000000          bool __cdecl gfp_pfmemalloc_allowed(gfp_t gfp_mask);
FFFFFFFF 00000000          page *__cdecl grab_cache_page_write_begin(address_space *mapping, unsigned __int64 index, unsigned int flags);
FFFFFFFF 00000000          group_info *__cdecl groups_alloc(int);
FFFFFFFF 00000000          void __cdecl groups_free(group_info *);
FFFFFFFF 00000000          int __cdecl groups_search(const group_info *, kgid_t);
FFFFFFFF 00000000          void __cdecl groups_sort(group_info *);
00000004 00000000          u32 gsi_top;
FFFFFFFF 00000000          void __cdecl guid_gen(guid_t *u);
00000010 00000000          const u8 guid_index[16];
00000010 00000000          const guid_t guid_null;
FFFFFFFF 00000000          int __cdecl guid_parse(const char *uuid, guid_t *u);
FFFFFFFF 00000000          efi_status_t __cdecl handle_cmdline_files(efi_system_table_t *sys_table_arg, efi_loaded_image_t *image, char *cmd_line, char *option_string, unsigned __int64 max_addr, unsigned __int64 *load_addr, unsigned __int64 *load_size);
FFFFFFFF 00000000          void __cdecl handle_irq(irq_desc *desc, pt_regs *regs);
FFFFFFFF 00000000          vm_fault_t __cdecl handle_mm_fault(vm_area_struct *vma, unsigned __int64 address, unsigned int flags);
FFFFFFFF 00000000          int hard_smp_processor_id(void);
00000008 0000000000000000          irq_stack *hardirq_stack_ptr;
FFFFFFFF 00000000          void __cdecl hardpps(const timespec64 *, const timespec64 *);
FFFFFFFF 00000000          bool __cdecl has_capability(task_struct *t, int cap);
FFFFFFFF 00000000          bool __cdecl has_capability_noaudit(task_struct *t, int cap);
FFFFFFFF 00000000          bool has_managed_dma(void);
FFFFFFFF 00000000          bool __cdecl has_ns_capability(task_struct *t, user_namespace *ns, int cap);
FFFFFFFF 00000000          bool __cdecl has_ns_capability_noaudit(task_struct *t, user_namespace *ns, int cap);
FFFFFFFF 00000000          u64 __cdecl hashlen_string(const void *salt, const char *name);
FFFFFFFF 00000000          int __cdecl hex2bin(u8 *dst, const char *src, size_t count);
00000000 00000000          const char hex_asc[];
00000000 00000000          const char hex_asc_upper[];
FFFFFFFF 00000000          int __cdecl hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize, char *linebuf, size_t linebuflen, bool ascii);
FFFFFFFF 00000000          int __cdecl hex_to_bin(unsigned __int8 ch);
00000008 0000000000000000          void *high_memory;
FFFFFFFF 00000000          void hlt_play_dead(void);
FFFFFFFF 00000000          bool __cdecl hrtimer_active(const hrtimer *timer);
FFFFFFFF 00000000          int __cdecl hrtimer_cancel(hrtimer *timer);
FFFFFFFF 00000000          u64 __cdecl hrtimer_forward(hrtimer *timer, ktime_t now, ktime_t interval);
FFFFFFFF 00000000          u64 hrtimer_get_next_event(void);
FFFFFFFF 00000000          void __cdecl hrtimer_init(hrtimer *timer, clockid_t which_clock, hrtimer_mode mode);
FFFFFFFF 00000000          void __cdecl hrtimer_init_sleeper(hrtimer_sleeper *sl, clockid_t clock_id, hrtimer_mode mode);
FFFFFFFF 00000000          void __cdecl hrtimer_interrupt(clock_event_device *dev);
FFFFFFFF 00000000          __int64 __cdecl hrtimer_nanosleep(const timespec64 *rqtp, const hrtimer_mode mode, const clockid_t clockid);
FFFFFFFF 00000000          u64 __cdecl hrtimer_next_event_without(const hrtimer *exclude);
00000004 00000000          unsigned int hrtimer_resolution;
FFFFFFFF 00000000          void hrtimer_run_queues(void);
FFFFFFFF 00000000          void __cdecl hrtimer_sleeper_start_expires(hrtimer_sleeper *sl, hrtimer_mode mode);
FFFFFFFF 00000000          void __cdecl hrtimer_start_range_ns(hrtimer *timer, ktime_t tim, u64 range_ns, const hrtimer_mode mode);
FFFFFFFF 00000000          int __cdecl hrtimer_try_to_cancel(hrtimer *timer);
FFFFFFFF 00000000          int __cdecl hrtimers_dead_cpu(unsigned int cpu);
FFFFFFFF 00000000          void hrtimers_init(void);
FFFFFFFF 00000000          int __cdecl hrtimers_prepare_cpu(unsigned int cpu);
FFFFFFFF 00000000          void hrtimers_resume(void);
000000A8 00000000          const bpf_map_ops htab_lru_map_ops;
000000A8 00000000          const bpf_map_ops htab_lru_percpu_map_ops;
000000A8 00000000          const bpf_map_ops htab_map_ops;
000000A8 00000000          const bpf_map_ops htab_of_maps_map_ops;
000000A8 00000000          const bpf_map_ops htab_percpu_map_ops;
FFFFFFFF 00000000          void __cdecl huge_pmd_set_accessed(vm_fault *vmf, pmd_t orig_pmd);
FFFFFFFF 00000000          void __cdecl huge_pud_set_accessed(vm_fault *vmf, pud_t orig_pud);
00000008 0000000000000000          page *huge_zero_page;
00000008 0000000000000000          unsigned __int64 huge_zero_pfn;
FFFFFFFF 00000000          int __cdecl hugepage_madvise(vm_area_struct *vma, unsigned __int64 *vm_flags, int advice);
FFFFFFFF 00000000          unsigned __int64 __cdecl hugetlb_basepage_index(page *page);
00000008 0000000000000000          kobject *hypervisor_kobj;
FFFFFFFF 00000000          void __cdecl ia64_set_curr_task(int cpu, task_struct *p);
FFFFFFFF 00000000          int __cdecl ida_alloc_range(ida *, unsigned int min, unsigned int max, gfp_t);
FFFFFFFF 00000000          void __cdecl ida_destroy(ida *ida);
FFFFFFFF 00000000          void __cdecl ida_free(ida *, unsigned int id);
00000008 0000000000000000          const unsigned __int8 *const *ideal_nops;
FFFFFFFF 00000000          void identify_boot_cpu(void);
FFFFFFFF 00000000          void __cdecl identify_secondary_cpu(cpuinfo_x86 *);
FFFFFFFF 00000000          int __cdecl idle_cpu(int cpu);
FFFFFFFF 00000000          task_struct *__cdecl idle_task(int cpu);
FFFFFFFF 00000000          int __cdecl idr_alloc(idr *, void *ptr, int start, int end, gfp_t);
FFFFFFFF 00000000          int __cdecl idr_alloc_cyclic(idr *, void *ptr, int start, int end, gfp_t);
FFFFFFFF 00000000          int __cdecl idr_alloc_u32(idr *, void *ptr, u32 *id, unsigned __int64 max, gfp_t);
FFFFFFFF 00000000          void __cdecl idr_destroy(idr *);
FFFFFFFF 00000000          void *__cdecl idr_find(const idr *, unsigned __int64 id);
FFFFFFFF 00000000          int __cdecl idr_for_each(const idr *, int (__cdecl *fn)(int, void *, void *), void *data);
FFFFFFFF 00000000          void **__cdecl idr_get_free(xarray *root, radix_tree_iter *iter, gfp_t gfp, unsigned __int64 max);
FFFFFFFF 00000000          void *__cdecl idr_get_next(idr *, int *nextid);
FFFFFFFF 00000000          void *__cdecl idr_get_next_ul(idr *, unsigned __int64 *nextid);
FFFFFFFF 00000000          void __cdecl idr_preload(gfp_t gfp_mask);
FFFFFFFF 00000000          void *__cdecl idr_remove(idr *, unsigned __int64 id);
FFFFFFFF 00000000          void *__cdecl idr_replace(idr *, void *, unsigned __int64 id);
FFFFFFFF 00000000          inode *__cdecl iget5_locked(super_block *, unsigned __int64, int (__cdecl *test)(inode *, void *), int (__cdecl *set)(inode *, void *), void *);
FFFFFFFF 00000000          void __cdecl iget_failed(inode *);
FFFFFFFF 00000000          inode *__cdecl iget_locked(super_block *, unsigned __int64);
00000001 00000000          char ignore_fpu_irq;
FFFFFFFF 00000000          void ignore_sysret(void);
FFFFFFFF 00000000          inode *__cdecl igrab(inode *);
FFFFFFFF 00000000          void __cdecl ihold(inode *inode);
FFFFFFFF 00000000          inode *__cdecl ilookup(super_block *sb, unsigned __int64 ino);
FFFFFFFF 00000000          inode *__cdecl ilookup5(super_block *sb, unsigned __int64 hashval, int (__cdecl *test)(inode *, void *), void *data);
FFFFFFFF 00000000          inode *__cdecl ilookup5_nowait(super_block *sb, unsigned __int64 hashval, int (__cdecl *test)(inode *, void *), void *data);
FFFFFFFF 00000000          int __cdecl in_egroup_p(kgid_t);
FFFFFFFF 00000000          int __cdecl in_gate_area(mm_struct *mm, unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl in_gate_area_no_mm(unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl in_group_p(kgid_t);
FFFFFFFF 00000000          int __cdecl in_lock_functions(unsigned __int64 addr);
FFFFFFFF 00000000          void __cdecl inc_nlink(inode *inode);
FFFFFFFF 00000000          void __cdecl inc_node_page_state(page *, node_stat_item);
FFFFFFFF 00000000          void __cdecl inc_node_state(pglist_data *, node_stat_item);
FFFFFFFF 00000000          void __cdecl inc_zone_page_state(page *, zone_stat_item);
FFFFFFFF 00000000          void init_IRQ(void);
FFFFFFFF 00000000          void init_ISA_irqs(void);
FFFFFFFF 00000000          void init_apic_mappings(void);
FFFFFFFF 00000000          void init_bsp_APIC(void);
FFFFFFFF 00000000          void __cdecl init_cma_reserved_pageblock(page *page);
FFFFFFFF 00000000          void __cdecl init_cpu_online(const cpumask *src);
FFFFFFFF 00000000          void __cdecl init_cpu_possible(const cpumask *src);
FFFFFFFF 00000000          void __cdecl init_cpu_present(const cpumask *src);
FFFFFFFF 00000000          void init_cpu_to_node(void);
FFFFFFFF 00000000          void __cdecl init_currently_empty_zone(zone *zone, unsigned __int64 start_pfn, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl init_extra_mapping_uc(unsigned __int64 phys, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl init_extra_mapping_wb(unsigned __int64 phys, unsigned __int64 size);
00000008 0000000000000000          group_info init_groups;
FFFFFFFF 00000000          void init_irq_proc(void);
FFFFFFFF 00000000          int __cdecl init_kernel_text(unsigned __int64 addr);
FFFFFFFF 00000000          void init_mem_mapping(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl init_memory_mapping(unsigned __int64 start, unsigned __int64 end);
00000408 00000000          mm_struct init_mm;
FFFFFFFF 00000000          void init_mm_internals(void);
FFFFFFFF 00000000          int init_module(void);
00000010 00000000          static_key_true init_on_alloc;
00000010 00000000          static_key_false init_on_free;
00000030 00000000          fixed_percpu_data init_per_cpu__fixed_percpu_data;
FFFFFFFF 00000000          int init_per_zone_wmark_min(void);
FFFFFFFF 00000000          pid_namespace init_pid_ns;
00000004 00000000          u32 init_pkru_value;
FFFFFFFF 00000000          void init_rootfs(void);
FFFFFFFF 00000000          void __cdecl init_special_inode(inode *, umode_t, dev_t);
FFFFFFFF 00000000          int __cdecl init_srcu_struct(srcu_struct *ssp);
00004000 00000000          unsigned __int64 init_stack[2048];
00000060 00000000          pid init_struct_pid;
FFFFFFFF 00000000          void __cdecl init_timer_key(timer_list *timer, void (__cdecl *func)(timer_list *), unsigned int flags, const char *name, lock_class_key *key);
FFFFFFFF 00000000          void init_timers(void);
00000000 00000000          pgd_t init_top_pgt[];
FFFFFFFF 00000000          void init_trampoline(void);
FFFFFFFF 00000000          user_namespace init_user_ns;
FFFFFFFF 00000000          void __cdecl init_vdso_image(const vdso_image *image);
FFFFFFFF 00000000          void __cdecl init_wait_entry(wait_queue_entry *wq_entry, int flags);
FFFFFFFF 00000000          void __cdecl init_wait_var_entry(wait_bit_queue_entry *wbq_entry, void *var, int flags);
00000001 00000000          bool initcall_debug;
00000008 0000000000000000          unsigned __int64 initial_code;
00000008 0000000000000000          unsigned __int64 initial_gs;
00000008 0000000000000000          unsigned __int64 initial_stack;
FFFFFFFF 00000000          void initmem_init(void);
FFFFFFFF 00000000          void __cdecl inode_add_bytes(inode *inode, loff_t bytes);
FFFFFFFF 00000000          void __cdecl inode_dio_wait(inode *inode);
FFFFFFFF 00000000          loff_t __cdecl inode_get_bytes(inode *inode);
FFFFFFFF 00000000          void inode_init(void);
FFFFFFFF 00000000          int __cdecl inode_init_always(super_block *, inode *);
FFFFFFFF 00000000          void inode_init_early(void);
FFFFFFFF 00000000          void __cdecl inode_init_once(inode *);
FFFFFFFF 00000000          void __cdecl inode_init_owner(inode *inode, const inode *dir, umode_t mode);
FFFFFFFF 00000000          inode *__cdecl inode_insert5(inode *inode, unsigned __int64 hashval, int (__cdecl *test)(inode *, void *), int (__cdecl *set)(inode *, void *), void *data);
FFFFFFFF 00000000          int __cdecl inode_needs_sync(inode *inode);
FFFFFFFF 00000000          int __cdecl inode_newsize_ok(const inode *, loff_t offset);
FFFFFFFF 00000000          void __cdecl inode_nohighmem(inode *inode);
FFFFFFFF 00000000          bool __cdecl inode_owner_or_capable(const inode *inode);
FFFFFFFF 00000000          int __cdecl inode_permission(inode *, int);
FFFFFFFF 00000000          void __cdecl inode_sb_list_add(inode *inode);
FFFFFFFF 00000000          void __cdecl inode_set_bytes(inode *inode, loff_t bytes);
FFFFFFFF 00000000          void __cdecl inode_set_flags(inode *inode, unsigned int flags, unsigned int mask);
FFFFFFFF 00000000          void __cdecl inode_sub_bytes(inode *inode, loff_t bytes);
00000038 00000000          inodes_stat_t inodes_stat;
FFFFFFFF 00000000          int __cdecl insert_inode_locked(inode *);
FFFFFFFF 00000000          int __cdecl insert_inode_locked4(inode *, unsigned __int64, int (__cdecl *test)(inode *, void *), void *);
FFFFFFFF 00000000          int __cdecl insert_resource(resource *parent, resource *new);
FFFFFFFF 00000000          resource *__cdecl insert_resource_conflict(resource *parent, resource *new);
FFFFFFFF 00000000          void __cdecl insert_resource_expand_to_fit(resource *root, resource *new);
FFFFFFFF 00000000          int __cdecl insert_vm_struct(mm_struct *, vm_area_struct *);
FFFFFFFF 00000000          int __cdecl install_special_mapping(mm_struct *mm, unsigned __int64 addr, unsigned __int64 len, unsigned __int64 flags, page **pages);
FFFFFFFF 00000000          int __cdecl install_thread_keyring_to_cred(cred *cred);
FFFFFFFF 00000000          u64 __cdecl int_pow(u64 base, unsigned int exp);
FFFFFFFF 00000000          unsigned __int64 __cdecl int_sqrt(unsigned __int64);
FFFFFFFF 00000000          void __cdecl invalidate_bdev(block_device *);
FFFFFFFF 00000000          int __cdecl invalidate_inode_page(page *page);
FFFFFFFF 00000000          int __cdecl invalidate_inode_pages2(address_space *mapping);
FFFFFFFF 00000000          int __cdecl invalidate_inode_pages2_range(address_space *mapping, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          unsigned __int64 __cdecl invalidate_mapping_pages(address_space *mapping, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          int __cdecl invalidate_partition(gendisk *, int);
FFFFFFFF 00000000          int __cdecl invalidate_partitions(gendisk *disk, block_device *bdev);
FFFFFFFF 00000000          void io_apic_init_mappings(void);
00000008 0000000000000000          unsigned __int64 io_apic_irqs;
FFFFFFFF 00000000          void io_delay_init(void);
00000004 00000000          int io_delay_type;
FFFFFFFF 00000000          void io_schedule(void);
FFFFFFFF 00000000          void __cdecl io_schedule_finish(int token);
FFFFFFFF 00000000          int io_schedule_prepare(void);
FFFFFFFF 00000000          __int64 __cdecl io_schedule_timeout(__int64 timeout);
FFFFFFFF 00000000          sock *__cdecl io_uring_get_socket(file *file);
FFFFFFFF 00000000          void ioapic_insert_resources(void);
FFFFFFFF 00000000          void __cdecl ioapic_set_alloc_attr(irq_alloc_info *info, int node, int trigger, int polarity);
FFFFFFFF 00000000          void ioapic_zap_locks(void);
FFFFFFFF 00000000          int __cdecl ioctl_by_bdev(block_device *, unsigned int, unsigned __int64);
FFFFFFFF 00000000          int __cdecl ioctl_preallocate(file *filp, void *argp);
FFFFFFFF 00000000          bool __cdecl iomem_is_exclusive(u64 addr);
FFFFFFFF 00000000          int __cdecl iomem_map_sanity_check(resource_size_t addr, unsigned __int64 size);
00000040 00000000          resource iomem_resource;
FFFFFFFF 00000000          void *__cdecl ioport_map(unsigned __int64 port, unsigned int nr);
00000040 00000000          resource ioport_resource;
FFFFFFFF 00000000          void __cdecl ioport_unmap(void *p);
FFFFFFFF 00000000          int __cdecl ioprio_best(unsigned __int16 aprio, unsigned __int16 bprio);
FFFFFFFF 00000000          int __cdecl ioprio_check_cap(int ioprio);
FFFFFFFF 00000000          unsigned int __cdecl ioread16(void *);
FFFFFFFF 00000000          void __cdecl ioread16_rep(void *port, void *buf, unsigned __int64 count);
FFFFFFFF 00000000          unsigned int __cdecl ioread16be(void *);
FFFFFFFF 00000000          unsigned int __cdecl ioread32(void *);
FFFFFFFF 00000000          void __cdecl ioread32_rep(void *port, void *buf, unsigned __int64 count);
FFFFFFFF 00000000          unsigned int __cdecl ioread32be(void *);
FFFFFFFF 00000000          u64 __cdecl ioread64(void *);
FFFFFFFF 00000000          u64 __cdecl ioread64_hi_lo(void *addr);
FFFFFFFF 00000000          u64 __cdecl ioread64_lo_hi(void *addr);
FFFFFFFF 00000000          u64 __cdecl ioread64be(void *);
FFFFFFFF 00000000          u64 __cdecl ioread64be_hi_lo(void *addr);
FFFFFFFF 00000000          u64 __cdecl ioread64be_lo_hi(void *addr);
FFFFFFFF 00000000          unsigned int __cdecl ioread8(void *);
FFFFFFFF 00000000          void __cdecl ioread8_rep(void *port, void *buf, unsigned __int64 count);
FFFFFFFF 00000000          void *__cdecl ioremap_cache(resource_size_t offset, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl ioremap_change_attr(unsigned __int64 vaddr, unsigned __int64 size, page_cache_mode pcm);
FFFFFFFF 00000000          void *__cdecl ioremap_encrypted(resource_size_t phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          void ioremap_huge_init(void);
FFFFFFFF 00000000          void *__cdecl ioremap_nocache(resource_size_t offset, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl ioremap_page_range(unsigned __int64 addr, unsigned __int64 end, phys_addr_t phys_addr, pgprot_t prot);
FFFFFFFF 00000000          void *__cdecl ioremap_prot(resource_size_t offset, unsigned __int64 size, unsigned __int64 prot_val);
FFFFFFFF 00000000          void *__cdecl ioremap_uc(resource_size_t offset, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl ioremap_wc(resource_size_t offset, unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl ioremap_wt(resource_size_t offset, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl iounmap(void *addr);
FFFFFFFF 00000000          void __cdecl iowrite16(u16, void *);
FFFFFFFF 00000000          void __cdecl iowrite16_rep(void *port, const void *buf, unsigned __int64 count);
FFFFFFFF 00000000          void __cdecl iowrite16be(u16, void *);
FFFFFFFF 00000000          void __cdecl iowrite32(u32, void *);
FFFFFFFF 00000000          void __cdecl iowrite32_rep(void *port, const void *buf, unsigned __int64 count);
FFFFFFFF 00000000          void __cdecl iowrite32be(u32, void *);
FFFFFFFF 00000000          void __cdecl iowrite64(u64, void *);
FFFFFFFF 00000000          void __cdecl iowrite64_hi_lo(u64 val, void *addr);
FFFFFFFF 00000000          void __cdecl iowrite64_lo_hi(u64 val, void *addr);
FFFFFFFF 00000000          void __cdecl iowrite64be(u64, void *);
FFFFFFFF 00000000          void __cdecl iowrite64be_hi_lo(u64 val, void *addr);
FFFFFFFF 00000000          void __cdecl iowrite64be_lo_hi(u64 val, void *addr);
FFFFFFFF 00000000          void __cdecl iowrite8(u8, void *);
FFFFFFFF 00000000          void __cdecl iowrite8_rep(void *port, const void *buf, unsigned __int64 count);
FFFFFFFF 00000000          void __cdecl iput(inode *);
FFFFFFFF 00000000          unsigned int __cdecl irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec, const irq_affinity *affd);
FFFFFFFF 00000000          int __cdecl irq_can_set_affinity(unsigned int irq);
00000004 00000000          unsigned int irq_count;
FFFFFFFF 00000000          irq_affinity_desc *__cdecl irq_create_affinity_masks(unsigned int nvec, irq_affinity *affd);
FFFFFFFF 00000000          unsigned int __cdecl irq_create_direct_mapping(irq_domain *host);
FFFFFFFF 00000000          unsigned int __cdecl irq_create_fwspec_mapping(irq_fwspec *fwspec);
FFFFFFFF 00000000          unsigned int __cdecl irq_create_mapping_affinity(irq_domain *host, irq_hw_number_t hwirq, const irq_affinity_desc *affinity);
FFFFFFFF 00000000          int __cdecl irq_create_strict_mappings(irq_domain *domain, unsigned int irq_base, irq_hw_number_t hwirq_base, int count);
00000008 0000000000000000          cpumask_var_t irq_default_affinity;
FFFFFFFF 00000000          int __cdecl irq_destroy_ipi(unsigned int irq, const cpumask *dest);
FFFFFFFF 00000000          void __cdecl irq_dispose_mapping(unsigned int virq);
FFFFFFFF 00000000          int __cdecl irq_domain_activate_irq(irq_data *irq_data, bool early);
FFFFFFFF 00000000          irq_domain *__cdecl irq_domain_add_legacy(device_node *of_node, unsigned int size, unsigned int first_irq, irq_hw_number_t first_hwirq, const irq_domain_ops *ops, void *host_data);
FFFFFFFF 00000000          irq_domain *__cdecl irq_domain_add_simple(device_node *of_node, unsigned int size, unsigned int first_irq, const irq_domain_ops *ops, void *host_data);
FFFFFFFF 00000000          int __cdecl irq_domain_alloc_descs(int virq, unsigned int nr_irqs, irq_hw_number_t hwirq, int node, const irq_affinity_desc *affinity);
FFFFFFFF 00000000          int __cdecl irq_domain_alloc_irqs_hierarchy(irq_domain *domain, unsigned int irq_base, unsigned int nr_irqs, void *arg);
FFFFFFFF 00000000          int __cdecl irq_domain_alloc_irqs_parent(irq_domain *domain, unsigned int irq_base, unsigned int nr_irqs, void *arg);
FFFFFFFF 00000000          int __cdecl irq_domain_associate(irq_domain *domain, unsigned int irq, irq_hw_number_t hwirq);
FFFFFFFF 00000000          void __cdecl irq_domain_associate_many(irq_domain *domain, unsigned int irq_base, irq_hw_number_t hwirq_base, int count);
FFFFFFFF 00000000          bool irq_domain_check_msi_remap(void);
FFFFFFFF 00000000          irq_domain *__cdecl irq_domain_create_hierarchy(irq_domain *parent, unsigned int flags, unsigned int size, fwnode_handle *fwnode, const irq_domain_ops *ops, void *host_data);
FFFFFFFF 00000000          void __cdecl irq_domain_deactivate_irq(irq_data *irq_data);
FFFFFFFF 00000000          void __cdecl irq_domain_disassociate(irq_domain *domain, unsigned int irq);
FFFFFFFF 00000000          void __cdecl irq_domain_free_fwnode(fwnode_handle *fwnode);
FFFFFFFF 00000000          void __cdecl irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
FFFFFFFF 00000000          void __cdecl irq_domain_free_irqs_common(irq_domain *domain, unsigned int virq, unsigned int nr_irqs);
FFFFFFFF 00000000          void __cdecl irq_domain_free_irqs_parent(irq_domain *domain, unsigned int irq_base, unsigned int nr_irqs);
FFFFFFFF 00000000          void __cdecl irq_domain_free_irqs_top(irq_domain *domain, unsigned int virq, unsigned int nr_irqs);
FFFFFFFF 00000000          irq_data *__cdecl irq_domain_get_irq_data(irq_domain *domain, unsigned int virq);
FFFFFFFF 00000000          bool __cdecl irq_domain_hierarchical_is_msi_remap(irq_domain *domain);
FFFFFFFF 00000000          int __cdecl irq_domain_pop_irq(irq_domain *domain, int virq);
FFFFFFFF 00000000          int __cdecl irq_domain_push_irq(irq_domain *domain, int virq, void *arg);
FFFFFFFF 00000000          void __cdecl irq_domain_remove(irq_domain *host);
FFFFFFFF 00000000          void __cdecl irq_domain_reset_irq_data(irq_data *irq_data);
FFFFFFFF 00000000          int __cdecl irq_domain_set_hwirq_and_chip(irq_domain *domain, unsigned int virq, irq_hw_number_t hwirq, irq_chip *chip, void *chip_data);
FFFFFFFF 00000000          void __cdecl irq_domain_set_info(irq_domain *domain, unsigned int virq, irq_hw_number_t hwirq, irq_chip *chip, void *chip_data, irq_flow_handler_t handler, void *handler_data, const char *handler_name);
00000050 00000000          const irq_domain_ops irq_domain_simple_ops;
FFFFFFFF 00000000          int __cdecl irq_domain_translate_twocell(irq_domain *d, irq_fwspec *fwspec, unsigned __int64 *out_hwirq, unsigned int *out_type);
FFFFFFFF 00000000          void __cdecl irq_domain_update_bus_token(irq_domain *domain, irq_domain_bus_token bus_token);
FFFFFFFF 00000000          int __cdecl irq_domain_xlate_onecell(irq_domain *d, device_node *ctrlr, const u32 *intspec, unsigned int intsize, irq_hw_number_t *out_hwirq, unsigned int *out_type);
FFFFFFFF 00000000          int __cdecl irq_domain_xlate_onetwocell(irq_domain *d, device_node *ctrlr, const u32 *intspec, unsigned int intsize, irq_hw_number_t *out_hwirq, unsigned int *out_type);
FFFFFFFF 00000000          int __cdecl irq_domain_xlate_twocell(irq_domain *d, device_node *ctrlr, const u32 *intspec, unsigned int intsize, irq_hw_number_t *out_hwirq, unsigned int *out_type);
FFFFFFFF 00000000          void irq_enter(void);
FFFFFFFF 00000000          void irq_exit(void);
FFFFFFFF 00000000          unsigned int __cdecl irq_find_mapping(irq_domain *host, irq_hw_number_t hwirq);
FFFFFFFF 00000000          irq_domain *__cdecl irq_find_matching_fwspec(irq_fwspec *fwspec, irq_domain_bus_token bus_token);
FFFFFFFF 00000000          bool irq_fpu_usable(void);
00000050 00000000          irq_domain_ops irq_generic_chip_ops;
FFFFFFFF 00000000          irq_domain *irq_get_default_host(void);
FFFFFFFF 00000000          int __cdecl irq_get_irqchip_state(unsigned int irq, irqchip_irq_state which, bool *state);
FFFFFFFF 00000000          unsigned int __cdecl irq_get_next_irq(unsigned int offset);
FFFFFFFF 00000000          int __cdecl irq_init_percpu_irqstack(unsigned int cpu);
FFFFFFFF 00000000          bool __cdecl irq_percpu_is_enabled(unsigned int irq);
FFFFFFFF 00000000          int __cdecl irq_reserve_ipi(irq_domain *domain, const cpumask *dest);
FFFFFFFF 00000000          int __cdecl irq_select_affinity(unsigned int irq);
FFFFFFFF 00000000          int __cdecl irq_set_affinity_hint(unsigned int irq, const cpumask *m);
FFFFFFFF 00000000          int __cdecl irq_set_affinity_notifier(unsigned int irq, irq_affinity_notify *notify);
FFFFFFFF 00000000          void __cdecl irq_set_default_host(irq_domain *host);
FFFFFFFF 00000000          int __cdecl irq_set_irq_wake(unsigned int irq, unsigned int on);
FFFFFFFF 00000000          int __cdecl irq_set_irqchip_state(unsigned int irq, irqchip_irq_state which, bool state);
00000080 00000000          irq_cpustat_t irq_stat;
FFFFFFFF 00000000          irq_desc *__cdecl irq_to_desc(unsigned int irq);
FFFFFFFF 00000000          void __cdecl irq_wake_thread(unsigned int irq, void *dev_id);
00000078 00000000          const fwnode_operations irqchip_fwnode_ops;
FFFFFFFF 00000000          bool __cdecl is_acpi_data_node(const fwnode_handle *fwnode);
FFFFFFFF 00000000          bool __cdecl is_acpi_device_node(const fwnode_handle *fwnode);
FFFFFFFF 00000000          bool __cdecl is_bad_inode(inode *);
FFFFFFFF 00000000          int __cdecl is_dock_device(acpi_device *adev);
FFFFFFFF 00000000          bool __cdecl is_early_ioremap_ptep(pte_t *ptep);
FFFFFFFF 00000000          bool __cdecl is_empty_dir_inode(inode *inode);
FFFFFFFF 00000000          bool __cdecl is_file_shm_hugepages(file *file);
FFFFFFFF 00000000          bool __cdecl is_free_buddy_page(page *page);
FFFFFFFF 00000000          bool __cdecl is_kernel_percpu_address(unsigned __int64 addr);
FFFFFFFF 00000000          bool __cdecl is_mem_section_removable(unsigned __int64 pfn, unsigned __int64 nr_pages);
FFFFFFFF 00000000          bool __cdecl is_memblock_offlined(memory_block *mem);
FFFFFFFF 00000000          bool __cdecl is_module_address(unsigned __int64 addr);
FFFFFFFF 00000000          bool __cdecl is_module_percpu_address(unsigned __int64 addr);
FFFFFFFF 00000000          bool is_module_sig_enforced(void);
FFFFFFFF 00000000          bool __cdecl is_module_text_address(unsigned __int64 addr);
FFFFFFFF 00000000          bool __cdecl is_software_node(const fwnode_handle *fwnode);
FFFFFFFF 00000000          bool __cdecl is_subdir(dentry *, dentry *);
FFFFFFFF 00000000          bool __cdecl is_swbp_insn(uprobe_opcode_t *insn);
FFFFFFFF 00000000          bool __cdecl is_trap_insn(uprobe_opcode_t *insn);
FFFFFFFF 00000000          int __cdecl is_valid_bugaddr(unsigned __int64 addr);
FFFFFFFF 00000000          bool __cdecl is_vma_temporary_stack(vm_area_struct *vma);
FFFFFFFF 00000000          int __cdecl is_vmalloc_or_module_addr(const void *x);
00000010 00000000          ist_info ist_info;
FFFFFFFF 00000000          hrtimer_restart __cdecl it_real_fn(hrtimer *);
FFFFFFFF 00000000          u32 __cdecl iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);
FFFFFFFF 00000000          ssize_t __cdecl iter_file_splice_write(pipe_inode_info *, file *, loff_t *, size_t, unsigned int);
FFFFFFFF 00000000          void __cdecl iterate_bdevs(void (__cdecl *)(block_device *, void *), void *);
FFFFFFFF 00000000          int __cdecl iterate_dir(file *, dir_context *);
FFFFFFFF 00000000          int __cdecl iterate_mounts(int (__cdecl *)(vfsmount *, void *), void *, vfsmount *);
FFFFFFFF 00000000          void __cdecl iterate_supers(void (__cdecl *)(super_block *, void *), void *);
FFFFFFFF 00000000          void __cdecl iterate_supers_type(file_system_type *, void (__cdecl *)(super_block *, void *), void *);
FFFFFFFF 00000000          ino_t __cdecl iunique(super_block *, ino_t);
00000008 0000000000000000          unsigned __int64 jiffies;
FFFFFFFF 00000000          u64 __cdecl jiffies64_to_msecs(u64 j);
FFFFFFFF 00000000          u64 __cdecl jiffies64_to_nsecs(u64 j);
00000008 0000000000000000          u64 jiffies_64;
FFFFFFFF 00000000          u64 __cdecl jiffies_64_to_clock_t(u64 x);
FFFFFFFF 00000000          clock_t __cdecl jiffies_to_clock_t(unsigned __int64 x);
FFFFFFFF 00000000          unsigned int __cdecl jiffies_to_msecs(const unsigned __int64 j);
FFFFFFFF 00000000          void __cdecl jiffies_to_timespec64(const unsigned __int64 jiffies, timespec64 *value);
FFFFFFFF 00000000          void __cdecl jiffies_to_timeval(const unsigned __int64 jiffies, timeval *value);
FFFFFFFF 00000000          unsigned int __cdecl jiffies_to_usecs(const unsigned __int64 j);
FFFFFFFF 00000000          void __cdecl jump_label_apply_nops(module *mod);
FFFFFFFF 00000000          void jump_label_init(void);
FFFFFFFF 00000000          void jump_label_lock(void);
FFFFFFFF 00000000          int __cdecl jump_label_text_reserved(void *start, void *end);
FFFFFFFF 00000000          void jump_label_unlock(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl kaslr_get_random_long(const char *purpose);
FFFFFFFF 00000000          char *kasprintf(gfp_t gfp, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl kblockd_mod_delayed_work_on(int cpu, delayed_work *dwork, unsigned __int64 delay);
FFFFFFFF 00000000          int __cdecl kblockd_schedule_work(work_struct *work);
FFFFFFFF 00000000          int __cdecl kblockd_schedule_work_on(int cpu, work_struct *work);
FFFFFFFF 00000000          int __cdecl kern_addr_valid(unsigned __int64 addr);
FFFFFFFF 00000000          vfsmount *__cdecl kern_mount(file_system_type *);
FFFFFFFF 00000000          void __cdecl kern_unmount(vfsmount *mnt);
FFFFFFFF 00000000          void __cdecl kernel_fpu_begin_mask(unsigned int kfpu_mask);
FFFFFFFF 00000000          void kernel_fpu_end(void);
FFFFFFFF 00000000          void kernel_halt(void);
00000008 0000000000000000          kobject *kernel_kobj;
FFFFFFFF 00000000          int __cdecl kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned __int64 address, unsigned int numpages, unsigned __int64 page_flags);
FFFFFFFF 00000000          bool __cdecl kernel_page_present(page *page);
FFFFFFFF 00000000          void __cdecl kernel_param_lock(module *mod);
FFFFFFFF 00000000          void __cdecl kernel_param_unlock(module *mod);
FFFFFFFF 00000000          void __cdecl kernel_poison_pages(page *page, int numpages, int enable);
FFFFFFFF 00000000          void kernel_power_off(void);
FFFFFFFF 00000000          void kernel_randomize_memory(void);
FFFFFFFF 00000000          ssize_t __cdecl kernel_read(file *, void *, size_t, loff_t *);
FFFFFFFF 00000000          int __cdecl kernel_read_file(file *, void **, loff_t *, loff_t, kernel_read_file_id);
FFFFFFFF 00000000          int __cdecl kernel_read_file_from_fd(int, void **, loff_t *, loff_t, kernel_read_file_id);
FFFFFFFF 00000000          int __cdecl kernel_read_file_from_path(const char *, void **, loff_t *, loff_t, kernel_read_file_id);
FFFFFFFF 00000000          void __cdecl kernel_restart(char *cmd);
FFFFFFFF 00000000          void __cdecl kernel_restart_prepare(char *cmd);
FFFFFFFF 00000000          int __cdecl kernel_text_address(unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl kernel_unmap_pages_in_pgd(pgd_t *pgd, unsigned __int64 address, unsigned __int64 numpages);
FFFFFFFF 00000000          ssize_t __cdecl kernel_write(file *, const void *, size_t, loff_t *);
FFFFFFFF 00000000          void __cdecl kernfs_activate(kernfs_node *kn);
FFFFFFFF 00000000          void __cdecl kernfs_break_active_protection(kernfs_node *kn);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_create_dir_ns(kernfs_node *parent, const char *name, umode_t mode, kuid_t uid, kgid_t gid, void *priv, const void *ns);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_create_empty_dir(kernfs_node *parent, const char *name);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_create_link(kernfs_node *parent, const char *name, kernfs_node *target);
FFFFFFFF 00000000          kernfs_root *__cdecl kernfs_create_root(kernfs_syscall_ops *scops, unsigned int flags, void *priv);
FFFFFFFF 00000000          void __cdecl kernfs_destroy_root(kernfs_root *root);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_find_and_get_ns(kernfs_node *parent, const char *name, const void *ns);
FFFFFFFF 00000000          void __cdecl kernfs_free_fs_context(fs_context *fc);
FFFFFFFF 00000000          __poll_t __cdecl kernfs_generic_poll(kernfs_open_file *of, poll_table_struct *pt);
FFFFFFFF 00000000          void __cdecl kernfs_get(kernfs_node *kn);
FFFFFFFF 00000000          inode *__cdecl kernfs_get_inode(super_block *sb, kernfs_node *kn);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_get_node_by_id(kernfs_root *root, const kernfs_node_id *id);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_get_parent(kernfs_node *kn);
FFFFFFFF 00000000          int __cdecl kernfs_get_tree(fs_context *fc);
FFFFFFFF 00000000          void kernfs_init(void);
FFFFFFFF 00000000          void __cdecl kernfs_kill_sb(super_block *sb);
FFFFFFFF 00000000          int __cdecl kernfs_name(kernfs_node *kn, char *buf, size_t buflen);
FFFFFFFF 00000000          dentry *__cdecl kernfs_node_dentry(kernfs_node *kn, super_block *sb);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_node_from_dentry(dentry *dentry);
FFFFFFFF 00000000          void __cdecl kernfs_notify(kernfs_node *kn);
FFFFFFFF 00000000          int __cdecl kernfs_path_from_node(kernfs_node *root_kn, kernfs_node *kn, char *buf, size_t buflen);
FFFFFFFF 00000000          void __cdecl kernfs_put(kernfs_node *kn);
FFFFFFFF 00000000          void __cdecl kernfs_remove(kernfs_node *kn);
FFFFFFFF 00000000          int __cdecl kernfs_remove_by_name_ns(kernfs_node *parent, const char *name, const void *ns);
FFFFFFFF 00000000          bool __cdecl kernfs_remove_self(kernfs_node *kn);
FFFFFFFF 00000000          int __cdecl kernfs_rename_ns(kernfs_node *kn, kernfs_node *new_parent, const char *new_name, const void *new_ns);
FFFFFFFF 00000000          kernfs_root *__cdecl kernfs_root_from_sb(super_block *sb);
FFFFFFFF 00000000          int __cdecl kernfs_setattr(kernfs_node *kn, const iattr *iattr);
FFFFFFFF 00000000          const void *__cdecl kernfs_super_ns(super_block *sb);
FFFFFFFF 00000000          void __cdecl kernfs_unbreak_active_protection(kernfs_node *kn);
FFFFFFFF 00000000          kernfs_node *__cdecl kernfs_walk_and_get_ns(kernfs_node *parent, const char *path, const void *ns);
FFFFFFFF 00000000          int __cdecl kernfs_xattr_get(kernfs_node *kn, const char *name, void *value, size_t size);
FFFFFFFF 00000000          int __cdecl kernfs_xattr_set(kernfs_node *kn, const char *name, const void *value, size_t size, int flags);
FFFFFFFF 00000000          key *__cdecl key_alloc(key_type *type, const char *desc, kuid_t uid, kgid_t gid, const cred *cred, key_perm_t perm, unsigned __int64 flags, key_restriction *restrict_link);
FFFFFFFF 00000000          key_ref_t __cdecl key_create_or_update(key_ref_t keyring, const char *type, const char *description, const void *payload, size_t plen, key_perm_t perm, unsigned __int64 flags);
FFFFFFFF 00000000          void __cdecl key_free_user_ns(user_namespace *);
FFFFFFFF 00000000          void __cdecl key_fsgid_changed(cred *new_cred);
FFFFFFFF 00000000          void __cdecl key_fsuid_changed(cred *new_cred);
FFFFFFFF 00000000          void key_init(void);
FFFFFFFF 00000000          void __cdecl key_invalidate(key *key);
FFFFFFFF 00000000          int __cdecl key_link(key *keyring, key *key);
FFFFFFFF 00000000          key *__cdecl key_lookup(key_serial_t id);
FFFFFFFF 00000000          int __cdecl key_move(key *key, key *from_keyring, key *to_keyring, unsigned int flags);
FFFFFFFF 00000000          void __cdecl key_put(key *key);
FFFFFFFF 00000000          bool __cdecl key_put_tag(key_tag *tag);
FFFFFFFF 00000000          void __cdecl key_remove_domain(key_tag *domain_tag);
FFFFFFFF 00000000          void __cdecl key_revoke(key *key);
FFFFFFFF 00000000          void __cdecl key_set_timeout(key *, unsigned int);
00000000 00000000          ctl_table key_sysctls[];
FFFFFFFF 00000000          int __cdecl key_unlink(key *keyring, key *key);
FFFFFFFF 00000000          int __cdecl key_update(key_ref_t key, const void *payload, size_t plen);
FFFFFFFF 00000000          int __cdecl key_validate(const key *key);
FFFFFFFF 00000000          int __cdecl keyring_add_key(key *keyring, key *key);
FFFFFFFF 00000000          key *__cdecl keyring_alloc(const char *description, kuid_t uid, kgid_t gid, const cred *cred, key_perm_t perm, unsigned __int64 flags, key_restriction *restrict_link, key *dest);
FFFFFFFF 00000000          int __cdecl keyring_clear(key *keyring);
FFFFFFFF 00000000          int __cdecl keyring_restrict(key_ref_t keyring, const char *type, const char *restriction);
FFFFFFFF 00000000          key_ref_t __cdecl keyring_search(key_ref_t keyring, key_type *type, const char *description, bool recurse);
FFFFFFFF 00000000          void __cdecl kfree(const void *);
FFFFFFFF 00000000          void __cdecl kfree_call_rcu(callback_head *head, rcu_callback_t func);
FFFFFFFF 00000000          void __cdecl kfree_const(const void *x);
FFFFFFFF 00000000          void __cdecl kfree_link(void *);
FFFFFFFF 00000000          void kick_all_cpus_sync(void);
FFFFFFFF 00000000          void __cdecl kick_process(task_struct *tsk);
FFFFFFFF 00000000          void __cdecl kill_anon_super(super_block *sb);
FFFFFFFF 00000000          void __cdecl kill_bdev(block_device *);
FFFFFFFF 00000000          void __cdecl kill_block_super(super_block *sb);
FFFFFFFF 00000000          bool __cdecl kill_device(device *dev);
FFFFFFFF 00000000          void __cdecl kill_fasync(fasync_struct **, int, int);
FFFFFFFF 00000000          void __cdecl kill_litter_super(super_block *sb);
FFFFFFFF 00000000          void __cdecl klist_add_before(klist_node *n, klist_node *pos);
FFFFFFFF 00000000          void __cdecl klist_add_behind(klist_node *n, klist_node *pos);
FFFFFFFF 00000000          void __cdecl klist_add_head(klist_node *n, klist *k);
FFFFFFFF 00000000          void __cdecl klist_add_tail(klist_node *n, klist *k);
FFFFFFFF 00000000          void __cdecl klist_del(klist_node *n);
FFFFFFFF 00000000          void __cdecl klist_init(klist *k, void (__cdecl *get)(klist_node *), void (__cdecl *put)(klist_node *));
FFFFFFFF 00000000          void __cdecl klist_iter_exit(klist_iter *i);
FFFFFFFF 00000000          void __cdecl klist_iter_init(klist *k, klist_iter *i);
FFFFFFFF 00000000          void __cdecl klist_iter_init_node(klist *k, klist_iter *i, klist_node *n);
FFFFFFFF 00000000          klist_node *__cdecl klist_next(klist_iter *i);
FFFFFFFF 00000000          int __cdecl klist_node_attached(klist_node *n);
FFFFFFFF 00000000          klist_node *__cdecl klist_prev(klist_iter *i);
FFFFFFFF 00000000          void __cdecl klist_remove(klist_node *n);
00000150 00000000          kmem_cache *kmalloc_caches[3][14];
FFFFFFFF 00000000          void *__cdecl kmalloc_order(size_t size, gfp_t flags, unsigned int order);
FFFFFFFF 00000000          void *__cdecl kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order);
00000008 0000000000000000          pte_t *kmap_pte;
FFFFFFFF 00000000          void *__cdecl kmem_cache_alloc(kmem_cache *, gfp_t flags);
FFFFFFFF 00000000          int __cdecl kmem_cache_alloc_bulk(kmem_cache *, gfp_t, size_t, void **);
FFFFFFFF 00000000          void *__cdecl kmem_cache_alloc_node(kmem_cache *, gfp_t flags, int node);
FFFFFFFF 00000000          void *__cdecl kmem_cache_alloc_node_trace(kmem_cache *s, gfp_t gfpflags, int node, size_t size);
FFFFFFFF 00000000          void *__cdecl kmem_cache_alloc_trace(kmem_cache *, gfp_t, size_t);
FFFFFFFF 00000000          kmem_cache *__cdecl kmem_cache_create(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, void (__cdecl *ctor)(void *));
FFFFFFFF 00000000          kmem_cache *__cdecl kmem_cache_create_usercopy(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (__cdecl *ctor)(void *));
FFFFFFFF 00000000          void __cdecl kmem_cache_destroy(kmem_cache *);
FFFFFFFF 00000000          void __cdecl kmem_cache_free(kmem_cache *, void *);
FFFFFFFF 00000000          void __cdecl kmem_cache_free_bulk(kmem_cache *, size_t, void **);
FFFFFFFF 00000000          void kmem_cache_init(void);
FFFFFFFF 00000000          void kmem_cache_init_late(void);
FFFFFFFF 00000000          int __cdecl kmem_cache_shrink(kmem_cache *);
FFFFFFFF 00000000          unsigned int __cdecl kmem_cache_size(kmem_cache *s);
FFFFFFFF 00000000          void *__cdecl kmemdup(const void *p, size_t size, gfp_t gfp);
FFFFFFFF 00000000          char *__cdecl kmemdup_nul(const char *s, size_t len, gfp_t gfp);
FFFFFFFF 00000000          void __cdecl kmsg_dump(kmsg_dump_reason reason);
FFFFFFFF 00000000          bool __cdecl kmsg_dump_get_buffer(kmsg_dumper *dumper, bool syslog, char *buf, size_t size, size_t *len);
FFFFFFFF 00000000          bool __cdecl kmsg_dump_get_line(kmsg_dumper *dumper, bool syslog, char *line, size_t size, size_t *len);
FFFFFFFF 00000000          bool __cdecl kmsg_dump_get_line_nolock(kmsg_dumper *dumper, bool syslog, char *line, size_t size, size_t *len);
FFFFFFFF 00000000          int __cdecl kmsg_dump_register(kmsg_dumper *dumper);
FFFFFFFF 00000000          void __cdecl kmsg_dump_rewind(kmsg_dumper *dumper);
FFFFFFFF 00000000          void __cdecl kmsg_dump_rewind_nolock(kmsg_dumper *dumper);
FFFFFFFF 00000000          int __cdecl kmsg_dump_unregister(kmsg_dumper *dumper);
00000110 00000000          const file_operations kmsg_fops;
FFFFFFFF 00000000          const kobj_ns_type_operations *__cdecl kobj_child_ns_ops(kobject *parent);
FFFFFFFF 00000000          bool __cdecl kobj_ns_current_may_mount(kobj_ns_type type);
FFFFFFFF 00000000          void __cdecl kobj_ns_drop(kobj_ns_type type, void *ns);
FFFFFFFF 00000000          void *__cdecl kobj_ns_grab_current(kobj_ns_type type);
FFFFFFFF 00000000          const void *__cdecl kobj_ns_initial(kobj_ns_type type);
FFFFFFFF 00000000          const void *__cdecl kobj_ns_netlink(kobj_ns_type type, sock *sk);
FFFFFFFF 00000000          const kobj_ns_type_operations *__cdecl kobj_ns_ops(kobject *kobj);
FFFFFFFF 00000000          int __cdecl kobj_ns_type_register(const kobj_ns_type_operations *ops);
FFFFFFFF 00000000          int __cdecl kobj_ns_type_registered(kobj_ns_type type);
00000010 00000000          const sysfs_ops kobj_sysfs_ops;
FFFFFFFF 00000000          int kobject_add(kobject *kobj, kobject *parent, const char *fmt, ...);
FFFFFFFF 00000000          kobject *kobject_create(void);
FFFFFFFF 00000000          kobject *__cdecl kobject_create_and_add(const char *name, kobject *parent);
FFFFFFFF 00000000          void __cdecl kobject_del(kobject *kobj);
FFFFFFFF 00000000          kobject *__cdecl kobject_get(kobject *kobj);
FFFFFFFF 00000000          void __cdecl kobject_get_ownership(kobject *kobj, kuid_t *uid, kgid_t *gid);
FFFFFFFF 00000000          char *__cdecl kobject_get_path(kobject *kobj, gfp_t flag);
FFFFFFFF 00000000          kobject *__cdecl kobject_get_unless_zero(kobject *kobj);
FFFFFFFF 00000000          void __cdecl kobject_init(kobject *kobj, kobj_type *ktype);
FFFFFFFF 00000000          int kobject_init_and_add(kobject *kobj, kobj_type *ktype, kobject *parent, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl kobject_move(kobject *, kobject *);
FFFFFFFF 00000000          const void *__cdecl kobject_namespace(kobject *kobj);
FFFFFFFF 00000000          void __cdecl kobject_put(kobject *kobj);
FFFFFFFF 00000000          int __cdecl kobject_rename(kobject *, const char *new_name);
FFFFFFFF 00000000          int kobject_set_name(kobject *kobj, const char *name, ...);
FFFFFFFF 00000000          int __cdecl kobject_set_name_vargs(kobject *kobj, const char *fmt, va_list vargs);
FFFFFFFF 00000000          int __cdecl kobject_synth_uevent(kobject *kobj, const char *buf, size_t count);
FFFFFFFF 00000000          int __cdecl kobject_uevent(kobject *kobj, kobject_action action);
FFFFFFFF 00000000          int __cdecl kobject_uevent_env(kobject *kobj, kobject_action action, char *envp[]);
00000008 0000000000000000          const bpf_prog_ops kprobe_prog_ops;
00000028 00000000          const bpf_verifier_ops kprobe_verifier_ops;
00000004 00000000          int kptr_restrict;
FFFFFFFF 00000000          void *__cdecl krealloc(const void *, size_t, gfp_t);
FFFFFFFF 00000000          kset *__cdecl kset_create_and_add(const char *name, const kset_uevent_ops *u, kobject *parent_kobj);
FFFFFFFF 00000000          kobject *__cdecl kset_find_obj(kset *, const char *);
FFFFFFFF 00000000          void __cdecl kset_init(kset *kset);
FFFFFFFF 00000000          int __cdecl kset_register(kset *kset);
FFFFFFFF 00000000          void __cdecl kset_unregister(kset *kset);
FFFFFFFF 00000000          size_t __cdecl ksize(const void *);
00000008 0000000000000000          task_struct *ksoftirqd;
FFFFFFFF 00000000          char *__cdecl kstrdup(const char *s, gfp_t gfp);
FFFFFFFF 00000000          const char *__cdecl kstrdup_const(const char *s, gfp_t gfp);
FFFFFFFF 00000000          char *__cdecl kstrndup(const char *s, size_t len, gfp_t gfp);
FFFFFFFF 00000000          int __cdecl kstrtobool(const char *s, bool *res);
FFFFFFFF 00000000          int __cdecl kstrtobool_from_user(const char *s, size_t count, bool *res);
FFFFFFFF 00000000          int __cdecl kstrtoint(const char *s, unsigned int base, int *res);
FFFFFFFF 00000000          int __cdecl kstrtoint_from_user(const char *s, size_t count, unsigned int base, int *res);
FFFFFFFF 00000000          int __cdecl kstrtol_from_user(const char *s, size_t count, unsigned int base, __int64 *res);
FFFFFFFF 00000000          int __cdecl kstrtoll(const char *s, unsigned int base, __int64 *res);
FFFFFFFF 00000000          int __cdecl kstrtoll_from_user(const char *s, size_t count, unsigned int base, __int64 *res);
FFFFFFFF 00000000          int __cdecl kstrtos16(const char *s, unsigned int base, s16 *res);
FFFFFFFF 00000000          int __cdecl kstrtos16_from_user(const char *s, size_t count, unsigned int base, s16 *res);
FFFFFFFF 00000000          int __cdecl kstrtos8(const char *s, unsigned int base, s8 *res);
FFFFFFFF 00000000          int __cdecl kstrtos8_from_user(const char *s, size_t count, unsigned int base, s8 *res);
FFFFFFFF 00000000          int __cdecl kstrtou16(const char *s, unsigned int base, u16 *res);
FFFFFFFF 00000000          int __cdecl kstrtou16_from_user(const char *s, size_t count, unsigned int base, u16 *res);
FFFFFFFF 00000000          int __cdecl kstrtou8(const char *s, unsigned int base, u8 *res);
FFFFFFFF 00000000          int __cdecl kstrtou8_from_user(const char *s, size_t count, unsigned int base, u8 *res);
FFFFFFFF 00000000          int __cdecl kstrtouint(const char *s, unsigned int base, unsigned int *res);
FFFFFFFF 00000000          int __cdecl kstrtouint_from_user(const char *s, size_t count, unsigned int base, unsigned int *res);
FFFFFFFF 00000000          int __cdecl kstrtoul_from_user(const char *s, size_t count, unsigned int base, unsigned __int64 *res);
FFFFFFFF 00000000          int __cdecl kstrtoull(const char *s, unsigned int base, unsigned __int64 *res);
FFFFFFFF 00000000          int __cdecl kstrtoull_from_user(const char *s, size_t count, unsigned int base, unsigned __int64 *res);
FFFFFFFF 00000000          ktime_t __cdecl ktime_add_safe(const ktime_t lhs, const ktime_t rhs);
FFFFFFFF 00000000          ktime_t ktime_get(void);
FFFFFFFF 00000000          u64 ktime_get_boot_fast_ns(void);
FFFFFFFF 00000000          void __cdecl ktime_get_coarse_real_ts64(timespec64 *ts);
FFFFFFFF 00000000          void __cdecl ktime_get_coarse_ts64(timespec64 *ts);
FFFFFFFF 00000000          ktime_t __cdecl ktime_get_coarse_with_offset(tk_offsets offs);
FFFFFFFF 00000000          u64 ktime_get_mono_fast_ns(void);
FFFFFFFF 00000000          ktime_t ktime_get_raw(void);
FFFFFFFF 00000000          u64 ktime_get_raw_fast_ns(void);
FFFFFFFF 00000000          void __cdecl ktime_get_raw_ts64(timespec64 *ts);
FFFFFFFF 00000000          u64 ktime_get_real_fast_ns(void);
FFFFFFFF 00000000          time64_t ktime_get_real_seconds(void);
FFFFFFFF 00000000          void __cdecl ktime_get_real_ts64(timespec64 *tv);
FFFFFFFF 00000000          u32 ktime_get_resolution_ns(void);
FFFFFFFF 00000000          time64_t ktime_get_seconds(void);
FFFFFFFF 00000000          void __cdecl ktime_get_snapshot(system_time_snapshot *systime_snapshot);
FFFFFFFF 00000000          void __cdecl ktime_get_ts64(timespec64 *ts);
FFFFFFFF 00000000          ktime_t __cdecl ktime_get_with_offset(tk_offsets offs);
FFFFFFFF 00000000          ktime_t __cdecl ktime_mono_to_any(ktime_t tmono, tk_offsets offs);
FFFFFFFF 00000000          char *__cdecl kvasprintf(gfp_t gfp, const char *fmt, va_list args);
FFFFFFFF 00000000          const char *__cdecl kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);
FFFFFFFF 00000000          void __cdecl kvfree(const void *addr);
FFFFFFFF 00000000          void __cdecl kvfree_sensitive(const void *addr, size_t len);
FFFFFFFF 00000000          void __cdecl kvm_set_posted_intr_wakeup_handler(void (*handler)(void));
FFFFFFFF 00000000          void *__cdecl kvmalloc_node(size_t size, gfp_t flags, int node);
FFFFFFFF 00000000          void __cdecl kzfree(const void *);
00000004 00000000          l1tf_mitigations l1tf_mitigation;
FFFFFFFF 00000000          void __cdecl lapic_assign_legacy_vector(unsigned int isairq, bool replace);
FFFFFFFF 00000000          void lapic_assign_system_vectors(void);
FFFFFFFF 00000000          int lapic_can_unplug_cpu(void);
FFFFFFFF 00000000          int lapic_get_maxlvt(void);
FFFFFFFF 00000000          void lapic_offline(void);
FFFFFFFF 00000000          void lapic_online(void);
FFFFFFFF 00000000          void lapic_shutdown(void);
00000004 00000000          unsigned int lapic_timer_period;
FFFFFFFF 00000000          void lapic_update_legacy_vectors(void);
FFFFFFFF 00000000          void lapic_update_tsc_freq(void);
00000008 0000000000000000          void (*late_time_init)(void);
00000004 00000000          int lease_break_time;
FFFFFFFF 00000000          void __cdecl lease_get_mtime(inode *, timespec64 *time);
FFFFFFFF 00000000          int __cdecl lease_modify(file_lock *, int, list_head *);
FFFFFFFF 00000000          int __cdecl lease_register_notifier(notifier_block *);
FFFFFFFF 00000000          void __cdecl lease_unregister_notifier(notifier_block *);
00000004 00000000          int leases_enable;
FFFFFFFF 00000000          void __cdecl leave_mm(int cpu);
00002000 00000000          pte_t level1_fixmap_pgt[1024];
00001000 00000000          pmd_t level2_fixmap_pgt[512];
00001000 00000000          pmd_t level2_ident_pgt[512];
00001000 00000000          pmd_t level2_kernel_pgt[512];
00001000 00000000          pud_t level3_ident_pgt[512];
00001000 00000000          pud_t level3_kernel_pgt[512];
00001000 00000000          p4d_t level4_ident_pgt[512];
00001000 00000000          p4d_t level4_kernel_pgt[512];
FFFFFFFF 00000000          unsigned __int64 __cdecl linear_hugepage_index(vm_area_struct *vma, unsigned __int64 address);
00000000 00000000          const char linux_banner[];
00000000 00000000          const char linux_proc_banner[];
FFFFFFFF 00000000          bool __cdecl list_lru_add(list_lru *lru, list_head *item);
FFFFFFFF 00000000          unsigned __int64 __cdecl list_lru_count_node(list_lru *lru, int nid);
FFFFFFFF 00000000          unsigned __int64 __cdecl list_lru_count_one(list_lru *lru, int nid, mem_cgroup *memcg);
FFFFFFFF 00000000          bool __cdecl list_lru_del(list_lru *lru, list_head *item);
FFFFFFFF 00000000          void __cdecl list_lru_destroy(list_lru *lru);
FFFFFFFF 00000000          void __cdecl list_lru_isolate(list_lru_one *list, list_head *item);
FFFFFFFF 00000000          void __cdecl list_lru_isolate_move(list_lru_one *list, list_head *item, list_head *head);
FFFFFFFF 00000000          unsigned __int64 __cdecl list_lru_walk_node(list_lru *lru, int nid, list_lru_walk_cb isolate, void *cb_arg, unsigned __int64 *nr_to_walk);
FFFFFFFF 00000000          unsigned __int64 __cdecl list_lru_walk_one(list_lru *lru, int nid, mem_cgroup *memcg, list_lru_walk_cb isolate, void *cb_arg, unsigned __int64 *nr_to_walk);
FFFFFFFF 00000000          unsigned __int64 __cdecl list_lru_walk_one_irq(list_lru *lru, int nid, mem_cgroup *memcg, list_lru_walk_cb isolate, void *cb_arg, unsigned __int64 *nr_to_walk);
FFFFFFFF 00000000          bool __cdecl llist_add_batch(llist_node *new_first, llist_node *new_last, llist_head *head);
FFFFFFFF 00000000          llist_node *__cdecl llist_del_first(llist_head *head);
FFFFFFFF 00000000          llist_node *__cdecl llist_reverse_order(llist_node *head);
FFFFFFFF 00000000          void __cdecl load_direct_gdt(int);
FFFFFFFF 00000000          void __cdecl load_fixmap_gdt(int);
FFFFFFFF 00000000          void __cdecl load_percpu_segment(int);
FFFFFFFF 00000000          void load_trampoline_pgtable(void);
00000004 00000000          int local_apic_timer_c2_ok;
FFFFFFFF 00000000          void lock_device_hotplug(void);
FFFFFFFF 00000000          int lock_device_hotplug_sysfs(void);
00000004 00000000          int lock_stat;
FFFFFFFF 00000000          void __cdecl lock_two_nondirectories(inode *, inode *);
FFFFFFFF 00000000          void __cdecl lockref_get(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_get_not_dead(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_get_not_zero(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_get_or_lock(lockref *);
FFFFFFFF 00000000          void __cdecl lockref_mark_dead(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_put_not_zero(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_put_or_lock(lockref *);
FFFFFFFF 00000000          int __cdecl lockref_put_return(lockref *);
FFFFFFFF 00000000          file_lock *locks_alloc_lock(void);
FFFFFFFF 00000000          void __cdecl locks_copy_conflock(file_lock *, file_lock *);
FFFFFFFF 00000000          void __cdecl locks_copy_lock(file_lock *, file_lock *);
FFFFFFFF 00000000          int __cdecl locks_delete_block(file_lock *);
FFFFFFFF 00000000          void __cdecl locks_end_grace(lock_manager *);
FFFFFFFF 00000000          void __cdecl locks_free_lock(file_lock *fl);
FFFFFFFF 00000000          void __cdecl locks_free_lock_context(inode *inode);
FFFFFFFF 00000000          bool __cdecl locks_in_grace(net *);
FFFFFFFF 00000000          void __cdecl locks_init_lock(file_lock *);
FFFFFFFF 00000000          int __cdecl locks_lock_inode_wait(inode *inode, file_lock *fl);
FFFFFFFF 00000000          int __cdecl locks_mandatory_area(inode *, file *, loff_t, loff_t, unsigned __int8);
FFFFFFFF 00000000          int __cdecl locks_mandatory_locked(file *);
FFFFFFFF 00000000          void __cdecl locks_release_private(file_lock *);
FFFFFFFF 00000000          void __cdecl locks_remove_file(file *);
FFFFFFFF 00000000          void __cdecl locks_remove_posix(file *, fl_owner_t);
FFFFFFFF 00000000          void __cdecl locks_start_grace(net *, lock_manager *);
FFFFFFFF 00000000          char *log_buf_addr_get(void);
FFFFFFFF 00000000          u32 log_buf_len_get(void);
FFFFFFFF 00000000          void log_buf_vmcoreinfo_setup(void);
FFFFFFFF 00000000          int __cdecl logic_pio_register_range(logic_pio_hwaddr *newrange);
FFFFFFFF 00000000          resource_size_t __cdecl logic_pio_to_hwaddr(unsigned __int64 pio);
FFFFFFFF 00000000          unsigned __int64 __cdecl logic_pio_trans_cpuaddr(resource_size_t hw_addr);
FFFFFFFF 00000000          unsigned __int64 __cdecl logic_pio_trans_hwaddr(fwnode_handle *fwnode, resource_size_t hw_addr, resource_size_t size);
FFFFFFFF 00000000          void __cdecl logic_pio_unregister_range(logic_pio_hwaddr *range);
FFFFFFFF 00000000          pte_t *__cdecl lookup_address(unsigned __int64 address, unsigned int *level);
FFFFFFFF 00000000          pte_t *__cdecl lookup_address_in_pgd(pgd_t *pgd, unsigned __int64 address, unsigned int *level);
FFFFFFFF 00000000          block_device *__cdecl lookup_bdev(const char *);
FFFFFFFF 00000000          int __cdecl lookup_module_symbol_attrs(unsigned __int64 addr, unsigned __int64 *size, unsigned __int64 *offset, char *modname, char *name);
FFFFFFFF 00000000          int __cdecl lookup_module_symbol_name(unsigned __int64 addr, char *symname);
FFFFFFFF 00000000          pmd_t *__cdecl lookup_pmd_address(unsigned __int64 address);
FFFFFFFF 00000000          resource *__cdecl lookup_resource(resource *root, resource_size_t start);
FFFFFFFF 00000000          key_ref_t __cdecl lookup_user_key(key_serial_t id, unsigned __int64 flags, key_perm_t perm);
00000008 0000000000000000          unsigned __int64 loops_per_jiffy;
FFFFFFFF 00000000          int __cdecl lowmem_reserve_ratio_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl lpit_read_residency_count_address(u64 *address);
00000008 0000000000000000          unsigned __int64 lpj_fine;
FFFFFFFF 00000000          void __cdecl lruvec_init(lruvec *lruvec);
FFFFFFFF 00000000          unsigned __int64 __cdecl lruvec_lru_size(lruvec *lruvec, lru_list lru, int zone_idx);
00000008 0000000000000000          const bpf_prog_ops lwt_in_prog_ops;
00000028 00000000          const bpf_verifier_ops lwt_in_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops lwt_out_prog_ops;
00000028 00000000          const bpf_verifier_ops lwt_out_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops lwt_seg6local_prog_ops;
00000028 00000000          const bpf_verifier_ops lwt_seg6local_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops lwt_xmit_prog_ops;
00000028 00000000          const bpf_verifier_ops lwt_xmit_verifier_ops;
FFFFFFFF 00000000          bool __cdecl mac_pton(const char *s, u8 *mac);
FFFFFFFF 00000000          void __cdecl machine_crash_shutdown(pt_regs *);
FFFFFFFF 00000000          void machine_emergency_restart(void);
FFFFFFFF 00000000          void machine_halt(void);
FFFFFFFF 00000000          void machine_power_off(void);
FFFFFFFF 00000000          void __cdecl machine_restart(char *cmd);
FFFFFFFF 00000000          void machine_shutdown(void);
FFFFFFFF 00000000          bool __cdecl madvise_free_huge_pmd(mmu_gather *tlb, vm_area_struct *vma, pmd_t *pmd, unsigned __int64 addr, unsigned __int64 next);
FFFFFFFF 00000000          void __cdecl make_bad_inode(inode *);
FFFFFFFF 00000000          void __cdecl make_empty_dir_inode(inode *inode);
FFFFFFFF 00000000          kgid_t __cdecl make_kgid(user_namespace *from, gid_t gid);
FFFFFFFF 00000000          kprojid_t __cdecl make_kprojid(user_namespace *from, projid_t projid);
FFFFFFFF 00000000          kuid_t __cdecl make_kuid(user_namespace *from, uid_t uid);
FFFFFFFF 00000000          char *__cdecl mangle_path(char *s, const char *p, const char *esc);
FFFFFFFF 00000000          int __cdecl map_check_no_btf(const bpf_map *map, const btf *btf, const btf_type *key_type, const btf_type *value_type);
FFFFFFFF 00000000          int __cdecl map_kernel_range_noflush(unsigned __int64 start, unsigned __int64 size, pgprot_t prot, page **pages);
FFFFFFFF 00000000          int __cdecl map_vdso_once(const vdso_image *image, unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl map_vm_area(vm_struct *area, pgprot_t prot, page **pages);
FFFFFFFF 00000000          void __cdecl mark_info_dirty(super_block *sb, int type);
FFFFFFFF 00000000          void mark_rodata_ro(void);
FFFFFFFF 00000000          void __cdecl mark_tsc_async_resets(char *reason);
FFFFFFFF 00000000          void __cdecl mark_tsc_unstable(char *reason);
FFFFFFFF 00000000          void mask_ioapic_entries(void);
FFFFFFFF 00000000          int __cdecl match_string(const char *const *array, size_t n, const char *string);
00000008 0000000000000000          unsigned __int64 max_low_pfn_mapped;
00000008 0000000000000000          u64 max_mem_size;
00000008 0000000000000000          unsigned __int64 max_pfn;
00000008 0000000000000000          unsigned __int64 max_pfn_mapped;
FFFFFFFF 00000000          bool __cdecl may_expand_vm(mm_struct *, vm_flags_t, unsigned __int64 npages);
FFFFFFFF 00000000          bool __cdecl may_open_dev(const path *path);
FFFFFFFF 00000000          bool may_setgroups(void);
FFFFFFFF 00000000          int __cdecl may_umount(vfsmount *);
FFFFFFFF 00000000          int __cdecl may_umount_tree(vfsmount *);
FFFFFFFF 00000000          unsigned __int64 __cdecl mcsafe_handle_tail(char *to, char *from, unsigned int len);
00000010 00000000          static_key_false mcsafe_key;
00000010 00000000          static_key_false mds_idle_clear;
00000010 00000000          static_key_false mds_user_clear;
FFFFFFFF 00000000          void mem_encrypt_free_decrypted_mem(void);
FFFFFFFF 00000000          void mem_encrypt_init(void);
FFFFFFFF 00000000          void mem_hotplug_begin(void);
FFFFFFFF 00000000          void mem_hotplug_done(void);
FFFFFFFF 00000000          void mem_init(void);
FFFFFFFF 00000000          void __cdecl mem_init_print_info(const char *str);
00000008 0000000000000000          page *mem_map;
00000008 0000000000000000          mem_section **mem_section;
FFFFFFFF 00000000          size_t mem_section_usage_size(void);
FFFFFFFF 00000000          void memblock_find_dma_reserve(void);
FFFFFFFF 00000000          void memblocks_present(void);
FFFFFFFF 00000000          void __cdecl memcg_create_kmem_cache(mem_cgroup *, kmem_cache *);
FFFFFFFF 00000000          void __cdecl memcg_deactivate_kmem_caches(mem_cgroup *, mem_cgroup *);
FFFFFFFF 00000000          void __cdecl memcg_drain_all_list_lrus(int src_idx, mem_cgroup *dst_memcg);
FFFFFFFF 00000000          int __cdecl memcg_update_all_caches(int num_memcgs);
FFFFFFFF 00000000          int __cdecl memcg_update_all_list_lrus(int num_memcgs);
FFFFFFFF 00000000          void *__cdecl memchr(const void *p, int c, __kernel_size_t size);
FFFFFFFF 00000000          void *__cdecl memchr_inv(const void *p, int c, size_t size);
FFFFFFFF 00000000          int __cdecl memcmp(const void *p, const void *q, __kernel_size_t size);
FFFFFFFF 00000000          int __cdecl memcmp_pages(page *page1, page *page2);
FFFFFFFF 00000000          void *__cdecl memcpy(void *p, const void *q, __kernel_size_t size);
FFFFFFFF 00000000          void __cdecl memcpy_fromio(void *, const void *, size_t);
FFFFFFFF 00000000          void __cdecl memcpy_page_flushcache(char *to, page *page, size_t offset, size_t len);
FFFFFFFF 00000000          void __cdecl memcpy_toio(void *, const void *, size_t);
FFFFFFFF 00000000          void *__cdecl memdup_user(const void *, size_t);
FFFFFFFF 00000000          void *__cdecl memdup_user_nul(const void *, size_t);
00000001 00000000          bool memhp_auto_online;
FFFFFFFF 00000000          void __cdecl memmap_init_zone(unsigned __int64, int, unsigned __int64, unsigned __int64, meminit_context, vmem_altmap *);
FFFFFFFF 00000000          void __cdecl memmap_init_zone_device(zone *, unsigned __int64, unsigned __int64, dev_pagemap *);
FFFFFFFF 00000000          void *__cdecl memmove(void *p, const void *q, __kernel_size_t size);
FFFFFFFF 00000000          int __cdecl memory_add_physaddr_to_nid(u64 start);
FFFFFFFF 00000000          int __cdecl memory_failure(unsigned __int64 pfn, int flags);
FFFFFFFF 00000000          void __cdecl memory_failure_queue(unsigned __int64 pfn, int flags);
FFFFFFFF 00000000          void __cdecl memory_present(int nid, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          ssize_t __cdecl memory_read_from_buffer(void *to, size_t count, loff_t *ppos, const void *from, size_t available);
FFFFFFFF 00000000          ssize_t __cdecl memory_read_from_io_buffer(void *to, size_t count, loff_t *ppos, const void *from, size_t available);
FFFFFFFF 00000000          unsigned __int64 __cdecl memparse(const char *ptr, char **retptr);
FFFFFFFF 00000000          void *__cdecl mempool_alloc(mempool_t *pool, gfp_t gfp_mask);
FFFFFFFF 00000000          void *__cdecl mempool_alloc_pages(gfp_t gfp_mask, void *pool_data);
FFFFFFFF 00000000          void *__cdecl mempool_alloc_slab(gfp_t gfp_mask, void *pool_data);
FFFFFFFF 00000000          mempool_t *__cdecl mempool_create(int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data);
FFFFFFFF 00000000          mempool_t *__cdecl mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data, gfp_t gfp_mask, int nid);
FFFFFFFF 00000000          void __cdecl mempool_destroy(mempool_t *pool);
FFFFFFFF 00000000          void __cdecl mempool_exit(mempool_t *pool);
FFFFFFFF 00000000          void __cdecl mempool_free(void *element, mempool_t *pool);
FFFFFFFF 00000000          void __cdecl mempool_free_pages(void *element, void *pool_data);
FFFFFFFF 00000000          void __cdecl mempool_free_slab(void *element, void *pool_data);
FFFFFFFF 00000000          int __cdecl mempool_init(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data);
FFFFFFFF 00000000          int __cdecl mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data, gfp_t gfp_mask, int node_id);
FFFFFFFF 00000000          void __cdecl mempool_kfree(void *element, void *pool_data);
FFFFFFFF 00000000          void *__cdecl mempool_kmalloc(gfp_t gfp_mask, void *pool_data);
FFFFFFFF 00000000          int __cdecl mempool_resize(mempool_t *pool, int new_min_nr);
FFFFFFFF 00000000          void *__cdecl memremap(resource_size_t offset, size_t size, unsigned __int64 flags);
FFFFFFFF 00000000          void *__cdecl memremap_pages(dev_pagemap *pgmap, int nid);
FFFFFFFF 00000000          void *__cdecl memscan(void *p, int c, __kernel_size_t size);
FFFFFFFF 00000000          void *__cdecl memset(void *p, int c, __kernel_size_t size);
FFFFFFFF 00000000          void __cdecl memset_io(void *, int, size_t);
FFFFFFFF 00000000          void __cdecl memunmap(void *addr);
FFFFFFFF 00000000          void __cdecl memunmap_pages(dev_pagemap *pgmap);
FFFFFFFF 00000000          size_t __cdecl memweight(const void *ptr, size_t bytes);
FFFFFFFF 00000000          void microcode_check(void);
FFFFFFFF 00000000          void migrate_to_reboot_cpu(void);
00000030 00000000          const char *const migratetype_names[6];
00000004 00000000          int min_free_kbytes;
FFFFFFFF 00000000          int __cdecl min_free_kbytes_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl mincore_huge_pmd(vm_area_struct *vma, pmd_t *pmd, unsigned __int64 addr, unsigned __int64 end, unsigned __int8 *vec);
FFFFFFFF 00000000          time64_t __cdecl mktime64(const unsigned int year, const unsigned int mon, const unsigned int day, const unsigned int hour, const unsigned int min, const unsigned int sec);
FFFFFFFF 00000000          void __cdecl mm_drop_all_locks(mm_struct *mm);
FFFFFFFF 00000000          page *__cdecl mm_get_huge_zero_page(mm_struct *mm);
00000008 0000000000000000          kobject *mm_kobj;
FFFFFFFF 00000000          void __cdecl mm_put_huge_zero_page(mm_struct *mm);
FFFFFFFF 00000000          int __cdecl mm_take_all_locks(mm_struct *mm);
FFFFFFFF 00000000          bool __cdecl mmap_address_hint_valid(unsigned __int64 addr, unsigned __int64 len);
FFFFFFFF 00000000          void mmap_init(void);
00000008 0000000000000000          atomic_long_t mmap_pages_allocated;
FFFFFFFF 00000000          unsigned __int64 __cdecl mmap_region(file *file, unsigned __int64 addr, unsigned __int64 len, vm_flags_t vm_flags, unsigned __int64 pgoff, list_head *uf);
00000004 00000000          int mmap_rnd_bits;
00000004 00000000          const int mmap_rnd_bits_max;
00000004 00000000          const int mmap_rnd_bits_min;
00000004 00000000          int mmap_rnd_compat_bits;
00000004 00000000          const int mmap_rnd_compat_bits_max;
00000004 00000000          const int mmap_rnd_compat_bits_min;
00000010 00000000          static_key_false mmio_stale_data_clear;
FFFFFFFF 00000000          bool __cdecl mod_delayed_work_on(int cpu, workqueue_struct *wq, delayed_work *dwork, unsigned __int64 delay);
FFFFFFFF 00000000          void __cdecl mod_node_page_state(pglist_data *, node_stat_item, __int64);
FFFFFFFF 00000000          int __cdecl mod_timer(timer_list *timer, unsigned __int64 expires);
FFFFFFFF 00000000          int __cdecl mod_timer_pending(timer_list *timer, unsigned __int64 expires);
FFFFFFFF 00000000          void __cdecl mod_zone_page_state(zone *, zone_stat_item, __int64);
00000000 00000000          char modprobe_path[];
FFFFFFFF 00000000          const char *__cdecl module_address_lookup(unsigned __int64 addr, unsigned __int64 *symbolsize, unsigned __int64 *offset, char **modname, char *namebuf);
FFFFFFFF 00000000          void __cdecl module_bug_cleanup(module *);
FFFFFFFF 00000000          void __cdecl module_bug_finalize(const Elf64_Ehdr *, const Elf64_Shdr *, module *);
FFFFFFFF 00000000          void __cdecl module_disable_ro(const module *mod);
FFFFFFFF 00000000          void __cdecl module_enable_ro(const module *mod, bool after_init);
FFFFFFFF 00000000          int __cdecl module_get_kallsym(unsigned int symnum, unsigned __int64 *value, char *type, char *name, char *module_name, int *exported);
FFFFFFFF 00000000          unsigned __int64 __cdecl module_kallsyms_lookup_name(const char *name);
FFFFFFFF 00000000          int __cdecl module_kallsyms_on_each_symbol(int (__cdecl *fn)(void *, const char *, module *, unsigned __int64), void *data);
00000008 0000000000000000          kset *module_kset;
00000038 00000000          kobj_type module_ktype;
00000020 00000000          mutex module_mutex;
FFFFFFFF 00000000          void __cdecl module_param_sysfs_remove(module *mod);
FFFFFFFF 00000000          int __cdecl module_param_sysfs_setup(module *mod, const kernel_param *kparam, unsigned int num_params);
FFFFFFFF 00000000          void __cdecl module_put(module *module);
FFFFFFFF 00000000          int __cdecl module_refcount(module *mod);
00000004 00000000          int module_sysfs_initialized;
00000038 00000000          module_attribute module_uevent;
00000004 00000000          int modules_disabled;
FFFFFFFF 00000000          dentry *__cdecl mount_bdev(file_system_type *fs_type, int flags, const char *dev_name, void *data, int (__cdecl *fill_super)(super_block *, void *, int));
FFFFFFFF 00000000          dentry *__cdecl mount_nodev(file_system_type *fs_type, int flags, void *data, int (__cdecl *fill_super)(super_block *, void *, int));
FFFFFFFF 00000000          dentry *__cdecl mount_single(file_system_type *fs_type, int flags, void *data, int (__cdecl *fill_super)(super_block *, void *, int));
FFFFFFFF 00000000          dentry *__cdecl mount_subtree(vfsmount *mnt, const char *path);
00000001 00000000          bool movable_node_enabled;
00000004 00000000          int movable_zone;
FFFFFFFF 00000000          bool __cdecl move_huge_pmd(vm_area_struct *vma, unsigned __int64 old_addr, unsigned __int64 new_addr, unsigned __int64 old_end, pmd_t *old_pmd, pmd_t *new_pmd);
FFFFFFFF 00000000          unsigned __int64 __cdecl move_page_tables(vm_area_struct *vma, unsigned __int64 old_addr, vm_area_struct *new_vma, unsigned __int64 new_addr, unsigned __int64 len, bool need_rmap_locks);
FFFFFFFF 00000000          void __cdecl move_pfn_range_to_zone(zone *zone, unsigned __int64 start_pfn, unsigned __int64 nr_pages, vmem_altmap *altmap);
00000400 00000000          int mp_bus_id_to_type[256];
00000020 00000000          unsigned __int64 mp_bus_not_pci[4];
FFFFFFFF 00000000          int __cdecl mp_find_ioapic(u32 gsi);
FFFFFFFF 00000000          int __cdecl mp_find_ioapic_pin(int ioapic, u32 gsi);
FFFFFFFF 00000000          int __cdecl mp_ioapic_registered(u32 gsi_base);
00000004 00000000          int mp_irq_entries;
00002000 00000000          mpc_intsrc mp_irqs[1024];
00000008 0000000000000000          unsigned __int64 mp_lapic_addr;
FFFFFFFF 00000000          int __cdecl mp_map_gsi_to_irq(u32 gsi, unsigned int flags, irq_alloc_info *info);
FFFFFFFF 00000000          int __cdecl mp_register_ioapic(int id, u32 address, u32 gsi_base, ioapic_domain_cfg *cfg);
FFFFFFFF 00000000          void __cdecl mp_save_irq(mpc_intsrc *m);
FFFFFFFF 00000000          void __cdecl mp_unmap_irq(int irq);
FFFFFFFF 00000000          int __cdecl mp_unregister_ioapic(u32 gsi_base);
FFFFFFFF 00000000          unsigned int __cdecl mpc_ioapic_addr(int ioapic);
FFFFFFFF 00000000          int __cdecl mpc_ioapic_id(int ioapic);
FFFFFFFF 00000000          int __cdecl mprotect_fixup(vm_area_struct *vma, vm_area_struct **pprev, unsigned __int64 start, unsigned __int64 end, unsigned __int64 newflags);
FFFFFFFF 00000000          int mpx_disable_management(void);
FFFFFFFF 00000000          int mpx_enable_management(void);
FFFFFFFF 00000000          void __cdecl msleep(unsigned int msecs);
FFFFFFFF 00000000          unsigned __int64 __cdecl msleep_interruptible(unsigned int msecs);
FFFFFFFF 00000000          int __cdecl msr_clear_bit(u32 msr, u8 bit);
00000008 0000000000000000          unsigned __int64 msr_misc_features_shadow;
FFFFFFFF 00000000          int __cdecl msr_set_bit(u32 msr, u8 bit);
FFFFFFFF 00000000          msr *msrs_alloc(void);
FFFFFFFF 00000000          void __cdecl msrs_free(msr *msrs);
FFFFFFFF 00000000          bool __cdecl mutex_is_locked(mutex *lock);
FFFFFFFF 00000000          void __cdecl mutex_lock(mutex *lock);
FFFFFFFF 00000000          int __cdecl mutex_lock_interruptible(mutex *lock);
FFFFFFFF 00000000          void __cdecl mutex_lock_io(mutex *lock);
FFFFFFFF 00000000          int __cdecl mutex_lock_killable(mutex *lock);
FFFFFFFF 00000000          int __cdecl mutex_trylock(mutex *lock);
FFFFFFFF 00000000          mutex_trylock_recursive_enum __cdecl mutex_trylock_recursive(mutex *lock);
FFFFFFFF 00000000          void __cdecl mutex_unlock(mutex *lock);
00000008 0000000000000000          kmem_cache *names_cachep;
FFFFFFFF 00000000          int __cdecl nanosleep_copyout(restart_block *, timespec64 *);
FFFFFFFF 00000000          u64 native_apic_icr_read(void);
FFFFFFFF 00000000          void __cdecl native_apic_icr_write(u32 low, u32 id);
FFFFFFFF 00000000          void native_apic_wait_icr_idle(void);
FFFFFFFF 00000000          unsigned __int64 native_calibrate_cpu_early(void);
FFFFFFFF 00000000          unsigned __int64 native_calibrate_tsc(void);
FFFFFFFF 00000000          void __cdecl native_cpu_die(unsigned int cpu);
FFFFFFFF 00000000          int native_cpu_disable(void);
FFFFFFFF 00000000          int __cdecl native_cpu_up(unsigned int cpunum, task_struct *tidle);
FFFFFFFF 00000000          void native_init_IRQ(void);
FFFFFFFF 00000000          unsigned int __cdecl native_io_apic_read(unsigned int apic, unsigned int reg);
FFFFFFFF 00000000          void native_io_delay(void);
FFFFFFFF 00000000          void __cdecl native_load_gs_index(unsigned int);
FFFFFFFF 00000000          unsigned int __cdecl native_patch(u8 type, void *insn_buff, unsigned __int64 addr, unsigned int len);
FFFFFFFF 00000000          void native_play_dead(void);
FFFFFFFF 00000000          void native_pv_lock_init(void);
FFFFFFFF 00000000          void __cdecl native_queued_spin_lock_slowpath(qspinlock *lock, u32 val);
FFFFFFFF 00000000          void native_restore_boot_irq_mode(void);
FFFFFFFF 00000000          void __cdecl native_restore_fl(unsigned __int64 flags);
FFFFFFFF 00000000          u32 native_safe_apic_wait_icr_idle(void);
FFFFFFFF 00000000          unsigned __int64 native_save_fl(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl native_sched_clock_from_tsc(u64 tsc);
FFFFFFFF 00000000          void __cdecl native_send_call_func_ipi(const cpumask *mask);
FFFFFFFF 00000000          void __cdecl native_send_call_func_single_ipi(int cpu);
FFFFFFFF 00000000          void __cdecl native_set_fixmap(unsigned int idx, phys_addr_t phys, pgprot_t flags);
FFFFFFFF 00000000          void __cdecl native_smp_cpus_done(unsigned int max_cpus);
FFFFFFFF 00000000          void native_smp_prepare_boot_cpu(void);
FFFFFFFF 00000000          void __cdecl native_smp_prepare_cpus(unsigned int max_cpus);
FFFFFFFF 00000000          void __cdecl native_smp_send_reschedule(int cpu);
FFFFFFFF 00000000          void __cdecl native_write_cr0(unsigned __int64 val);
FFFFFFFF 00000000          void __cdecl native_write_cr4(unsigned __int64 val);
000000F0 00000000          cpuinfo_x86 new_cpu_data;
FFFFFFFF 00000000          inode *__cdecl new_inode(super_block *sb);
FFFFFFFF 00000000          inode *__cdecl new_inode_pseudo(super_block *sb);
FFFFFFFF 00000000          char *__cdecl next_arg(char *args, char **param, char **val);
FFFFFFFF 00000000          pglist_data *__cdecl next_online_pgdat(pglist_data *pgdat);
FFFFFFFF 00000000          zone *__cdecl next_zone(zone *zone);
FFFFFFFF 00000000          void __cdecl nmi_panic(pt_regs *regs, const char *msg);
FFFFFFFF 00000000          irqreturn_t __cdecl no_action(int cpl, void *dev_id);
FFFFFFFF 00000000          loff_t __cdecl no_llseek(file *file, loff_t offset, int whence);
FFFFFFFF 00000000          loff_t __cdecl no_seek_end_llseek(file *, loff_t, int);
FFFFFFFF 00000000          loff_t __cdecl no_seek_end_llseek_size(file *, loff_t, int, loff_t);
00000000 00000000          pglist_data *node_data[];
FFFFFFFF 00000000          unsigned __int64 node_map_pfn_alignment(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl node_page_state(pglist_data *pgdat, node_stat_item item);
FFFFFFFF 00000000          int __cdecl node_random(const nodemask_t *maskp);
00000004 00000000          int node_reclaim_distance;
00000280 00000000          nodemask_t node_states[5];
00002000 00000000          cpumask_var_t node_to_cpumask_map[1024];
FFFFFFFF 00000000          int __cdecl node_to_pxm(int);
00000004 00000000          int noioapicquirk;
00000004 00000000          int noioapicreroute;
FFFFFFFF 00000000          int __cdecl nommu_shrink_inode_mappings(inode *, size_t, size_t);
FFFFFFFF 00000000          int __cdecl nonseekable_open(inode *inode, file *filp);
FFFFFFFF 00000000          ssize_t __cdecl noop_direct_IO(kiocb *iocb, iov_iter *iter);
FFFFFFFF 00000000          int __cdecl noop_fsync(file *, loff_t, loff_t, int);
FFFFFFFF 00000000          void __cdecl noop_invalidatepage(page *page, unsigned int offset, unsigned int length);
FFFFFFFF 00000000          loff_t __cdecl noop_llseek(file *file, loff_t offset, int whence);
FFFFFFFF 00000000          int __cdecl noop_set_page_dirty(page *page);
FFFFFFFF 00000000          void normalize_rt_tasks(void);
FFFFFFFF 00000000          int __cdecl notify_change(dentry *, iattr *, inode **);
FFFFFFFF 00000000          int __cdecl notsc_setup(char *);
FFFFFFFF 00000000          __int64 nr_blockdev_pages(void);
00000004 00000000          unsigned int nr_cpu_ids;
00000004 00000000          int nr_ioapics;
00000004 00000000          int nr_irqs;
00000004 00000000          unsigned int nr_node_ids;
00000004 00000000          unsigned int nr_online_nodes;
00000004 00000000          int nr_pfn_mapped;
FFFFFFFF 00000000          bool __cdecl ns_capable(user_namespace *ns, int cap);
FFFFFFFF 00000000          bool __cdecl ns_capable_noaudit(user_namespace *ns, int cap);
FFFFFFFF 00000000          bool __cdecl ns_capable_setid(user_namespace *ns, int cap);
FFFFFFFF 00000000          __kernel_old_timeval __cdecl ns_to_kernel_old_timeval(s64 nsec);
FFFFFFFF 00000000          timespec __cdecl ns_to_timespec(const s64 nsec);
FFFFFFFF 00000000          timespec64 __cdecl ns_to_timespec64(const s64 nsec);
FFFFFFFF 00000000          timeval __cdecl ns_to_timeval(const s64 nsec);
FFFFFFFF 00000000          u64 __cdecl nsec_to_clock_t(u64 x);
FFFFFFFF 00000000          unsigned __int64 __cdecl nsecs_to_jiffies(u64 n);
FFFFFFFF 00000000          u64 __cdecl nsecs_to_jiffies64(u64 n);
FFFFFFFF 00000000          void ntp_notify_cmos_timer(void);
00000008 0000000000000000          atomic_long_t num_poisoned_pages;
00000004 00000000          unsigned int num_processors;
FFFFFFFF 00000000          int __cdecl num_to_str(char *buf, int size, unsigned __int64 num, unsigned int width);
FFFFFFFF 00000000          void __cdecl numa_add_cpu(int cpu);
FFFFFFFF 00000000          int __cdecl numa_add_memblk(int nodeid, u64 start, u64 end);
FFFFFFFF 00000000          void __cdecl numa_clear_node(int cpu);
FFFFFFFF 00000000          int __cdecl numa_cpu_node(int cpu);
00000004 00000000          int numa_node;
00000080 00000000          nodemask_t numa_nodes_parsed;
00000004 00000000          int numa_off;
FFFFFFFF 00000000          void __cdecl numa_remove_cpu(int cpu);
FFFFFFFF 00000000          void __cdecl numa_set_distance(int from, int to, int distance);
FFFFFFFF 00000000          void __cdecl numa_set_node(int cpu, int node);
00000000 00000000          char numa_zonelist_order[];
FFFFFFFF 00000000          int __cdecl numa_zonelist_order_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          void __cdecl nvmem_add_cell_table(nvmem_cell_table *table);
FFFFFFFF 00000000          void __cdecl nvmem_del_cell_table(nvmem_cell_table *table);
FFFFFFFF 00000000          nvmem_device *__cdecl nvmem_register(const nvmem_config *cfg);
FFFFFFFF 00000000          void __cdecl nvmem_unregister(nvmem_device *nvmem);
00000004 00000000          int nx_enabled;
00000008 0000000000000000          device_node *of_aliases;
00000008 0000000000000000          device_node *of_chosen;
00000078 00000000          const fwnode_operations of_fwnode_ops;
00000038 00000000          kobj_type of_node_ktype;
00000008 0000000000000000          device_node *of_root;
00000008 0000000000000000          device_node *of_stdout;
FFFFFFFF 00000000          void __cdecl offline_mem_sections(unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          int __cdecl offline_pages(unsigned __int64 start_pfn, unsigned __int64 nr_pages);
FFFFFFFF 00000000          void __cdecl on_each_cpu(smp_call_func_t func, void *info, int wait);
FFFFFFFF 00000000          void __cdecl on_each_cpu_cond(bool (__cdecl *cond_func)(int, void *), smp_call_func_t func, void *info, bool wait, gfp_t gfp_flags);
FFFFFFFF 00000000          void __cdecl on_each_cpu_cond_mask(bool (__cdecl *cond_func)(int, void *), smp_call_func_t func, void *info, bool wait, gfp_t gfp_flags, const cpumask *mask);
FFFFFFFF 00000000          void __cdecl on_each_cpu_mask(const cpumask *mask, smp_call_func_t func, void *info, bool wait);
FFFFFFFF 00000000          void __cdecl online_mem_sections(unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          int __cdecl online_pages(unsigned __int64, unsigned __int64, int);
FFFFFFFF 00000000          void oops_enter(void);
FFFFFFFF 00000000          void oops_exit(void);
00000004 00000000          int oops_in_progress;
FFFFFFFF 00000000          int oops_may_print(void);
FFFFFFFF 00000000          file *__cdecl open_exec(const char *);
FFFFFFFF 00000000          int __cdecl open_related_ns(ns_common *ns, ns_common *(__cdecl *get_ns)(ns_common *));
FFFFFFFF 00000000          void __cdecl open_softirq(int nr, void (__cdecl *action)(softirq_action *));
FFFFFFFF 00000000          file *__cdecl open_with_fake_path(const path *, int, inode *, const cred *);
FFFFFFFF 00000000          bool __cdecl opens_in_grace(net *);
FFFFFFFF 00000000          void __cdecl orderly_poweroff(bool force);
FFFFFFFF 00000000          void orderly_reboot(void);
00000001 00000000          bool osc_pc_lpi_support_confirmed;
00000001 00000000          bool osc_sb_apei_support_acked;
FFFFFFFF 00000000          bool __cdecl osq_lock(optimistic_spin_queue *lock);
FFFFFFFF 00000000          void __cdecl osq_unlock(optimistic_spin_queue *lock);
FFFFFFFF 00000000          bool __cdecl our_mnt(vfsmount *mnt);
FFFFFFFF 00000000          int __cdecl out_of_line_wait_on_bit(void *word, int, wait_bit_action_f *action, unsigned int mode);
FFFFFFFF 00000000          int __cdecl out_of_line_wait_on_bit_lock(void *word, int, wait_bit_action_f *action, unsigned int mode);
FFFFFFFF 00000000          int __cdecl out_of_line_wait_on_bit_timeout(void *word, int, wait_bit_action_f *action, unsigned int mode, unsigned __int64 timeout);
FFFFFFFF 00000000          int __cdecl overcommit_kbytes_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl overcommit_ratio_handler(ctl_table *, int, void *, size_t *, loff_t *);
00000004 00000000          int overflowgid;
00000004 00000000          int overflowuid;
FFFFFFFF 00000000          const cred *__cdecl override_creds(const cred *);
FFFFFFFF 00000000          void __cdecl override_function_with_return(pt_regs *regs);
FFFFFFFF 00000000          void __cdecl p4d_clear_bad(p4d_t *);
FFFFFFFF 00000000          int __cdecl p4d_free_pud_page(p4d_t *p4d, unsigned __int64 addr);
FFFFFFFF 00000000          void page_alloc_init(void);
FFFFFFFF 00000000          void page_alloc_init_late(void);
FFFFFFFF 00000000          anon_vma *__cdecl page_anon_vma(page *page);
FFFFFFFF 00000000          void __cdecl page_cache_async_readahead(address_space *mapping, file_ra_state *ra, file *filp, page *pg, unsigned __int64 offset, unsigned __int64 size);
FFFFFFFF 00000000          unsigned __int64 __cdecl page_cache_next_miss(address_space *mapping, unsigned __int64 index, unsigned __int64 max_scan);
FFFFFFFF 00000000          unsigned __int64 __cdecl page_cache_prev_miss(address_space *mapping, unsigned __int64 index, unsigned __int64 max_scan);
FFFFFFFF 00000000          void __cdecl page_cache_sync_readahead(address_space *mapping, file_ra_state *ra, file *filp, unsigned __int64 offset, unsigned __int64 size);
00000004 00000000          int page_cluster;
FFFFFFFF 00000000          int __cdecl page_cpupid_xchg_last(page *page, int cpupid);
FFFFFFFF 00000000          void __cdecl page_endio(page *page, bool is_write, int err);
FFFFFFFF 00000000          void *__cdecl page_frag_alloc(page_frag_cache *nc, unsigned int fragsz, gfp_t gfp_mask);
FFFFFFFF 00000000          void __cdecl page_frag_free(void *addr);
FFFFFFFF 00000000          const char *__cdecl page_get_link(dentry *, inode *, delayed_call *);
00000004 00000000          int page_group_by_mobility_disabled;
FFFFFFFF 00000000          bool __cdecl page_huge_active(page *page);
FFFFFFFF 00000000          int __cdecl page_is_ram(unsigned __int64 pfn);
FFFFFFFF 00000000          bool __cdecl page_mapped(page *page);
FFFFFFFF 00000000          address_space *__cdecl page_mapping(page *page);
FFFFFFFF 00000000          address_space *__cdecl page_mapping_file(page *page);
00000008 0000000000000000          unsigned __int64 page_offset_base;
FFFFFFFF 00000000          bool page_poisoning_enabled(void);
FFFFFFFF 00000000          void __cdecl page_put_link(void *);
FFFFFFFF 00000000          int __cdecl page_readlink(dentry *, char *, int);
FFFFFFFF 00000000          void *__cdecl page_rmapping(page *page);
FFFFFFFF 00000000          int __cdecl page_symlink(inode *inode, const char *symname, int len);
000000C0 00000000          const inode_operations page_symlink_inode_operations;
FFFFFFFF 00000000          int __cdecl page_trans_huge_mapcount(page *page, int *total_mapcount);
FFFFFFFF 00000000          page *__cdecl pagecache_get_page(address_space *mapping, unsigned __int64 offset, int fgp_flags, gfp_t cache_gfp_mask);
FFFFFFFF 00000000          void pagecache_init(void);
FFFFFFFF 00000000          void __cdecl pagecache_isize_extended(inode *inode, loff_t from, loff_t to);
FFFFFFFF 00000000          int __cdecl pagecache_write_begin(file *, address_space *mapping, loff_t pos, unsigned int len, unsigned int flags, page **pagep, void **fsdata);
FFFFFFFF 00000000          int __cdecl pagecache_write_end(file *, address_space *mapping, loff_t pos, unsigned int len, unsigned int copied, page *page, void *fsdata);
FFFFFFFF 00000000          void pagefault_out_of_memory(void);
FFFFFFFF 00000000          void paging_init(void);
FFFFFFFF 00000000          void __noreturn panic(const char *fmt, ...);
00000008 0000000000000000          __int64 (__cdecl *panic_blink)(int);
00000004 00000000          atomic_t panic_cpu;
00000010 00000000          atomic_notifier_head panic_notifier_list;
00000004 00000000          int panic_on_io_nmi;
00000004 00000000          int panic_on_oops;
00000004 00000000          int panic_on_unrecovered_nmi;
00000004 00000000          int panic_on_warn;
00000008 0000000000000000          unsigned __int64 panic_print;
00000004 00000000          reboot_mode panic_reboot_mode;
00000004 00000000          int panic_timeout;
00000020 00000000          const kernel_param_ops param_array_ops;
FFFFFFFF 00000000          void __cdecl param_free_charp(void *arg);
FFFFFFFF 00000000          int __cdecl param_get_bool(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_byte(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_charp(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_int(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_invbool(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_long(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_short(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_string(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_uint(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_ullong(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_ulong(char *buffer, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_get_ushort(char *buffer, const kernel_param *kp);
00000020 00000000          const kernel_param_ops param_ops_bint;
00000020 00000000          const kernel_param_ops param_ops_bool;
00000020 00000000          const kernel_param_ops param_ops_bool_enable_only;
00000020 00000000          const kernel_param_ops param_ops_byte;
00000020 00000000          const kernel_param_ops param_ops_charp;
00000020 00000000          const kernel_param_ops param_ops_int;
00000020 00000000          const kernel_param_ops param_ops_invbool;
00000020 00000000          const kernel_param_ops param_ops_long;
00000020 00000000          const kernel_param_ops param_ops_short;
00000020 00000000          const kernel_param_ops param_ops_string;
00000020 00000000          const kernel_param_ops param_ops_uint;
00000020 00000000          const kernel_param_ops param_ops_ullong;
00000020 00000000          const kernel_param_ops param_ops_ulong;
00000020 00000000          const kernel_param_ops param_ops_ushort;
FFFFFFFF 00000000          int __cdecl param_set_bint(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_bool(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_bool_enable_only(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_byte(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_charp(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_copystring(const char *val, const kernel_param *);
FFFFFFFF 00000000          int __cdecl param_set_int(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_invbool(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_long(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_short(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_uint(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_ullong(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_ulong(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          int __cdecl param_set_ushort(const char *val, const kernel_param *kp);
FFFFFFFF 00000000          bool __cdecl parameq(const char *name1, const char *name2);
FFFFFFFF 00000000          bool __cdecl parameqn(const char *name1, const char *name2, size_t n);
FFFFFFFF 00000000          int paravirt_disable_iospace(void);
FFFFFFFF 00000000          void __cdecl paravirt_end_context_switch(task_struct *next);
FFFFFFFF 00000000          void paravirt_enter_lazy_mmu(void);
FFFFFFFF 00000000          void paravirt_flush_lazy_mmu(void);
FFFFFFFF 00000000          paravirt_lazy_mode paravirt_get_lazy_mode(void);
FFFFFFFF 00000000          void paravirt_leave_lazy_mmu(void);
FFFFFFFF 00000000          unsigned int __cdecl paravirt_patch_default(u8 type, void *insn_buff, unsigned __int64 addr, unsigned int len);
FFFFFFFF 00000000          unsigned int __cdecl paravirt_patch_ident_64(void *insn_buff, unsigned int len);
FFFFFFFF 00000000          unsigned int __cdecl paravirt_patch_insns(void *insn_buff, unsigned int len, const char *start, const char *end);
FFFFFFFF 00000000          void __cdecl paravirt_start_context_switch(task_struct *prev);
00000010 00000000          static_key paravirt_steal_enabled;
00000010 00000000          static_key paravirt_steal_rq_enabled;
FFFFFFFF 00000000          char *__cdecl parse_args(const char *name, char *args, const kernel_param *params, unsigned int num, s16 level_min, s16 level_max, void *arg, int (__cdecl *unknown)(char *, char *, const char *, void *));
FFFFFFFF 00000000          void __cdecl parse_early_options(char *cmdline);
FFFFFFFF 00000000          void parse_early_param(void);
FFFFFFFF 00000000          int __cdecl parse_efi_signature_list(const char *source, const void *data, size_t size, efi_element_handler_t (__cdecl *get_handler_for_guid)(const efi_guid_t *));
FFFFFFFF 00000000          bool __cdecl parse_option_str(const char *str, const char *option);
FFFFFFFF 00000000          void __cdecl part_dec_in_flight(request_queue *q, hd_struct *part, int rw);
FFFFFFFF 00000000          unsigned int __cdecl part_in_flight(request_queue *q, hd_struct *part);
FFFFFFFF 00000000          void __cdecl part_in_flight_rw(request_queue *q, hd_struct *part, unsigned int inflight[2]);
FFFFFFFF 00000000          void __cdecl part_inc_in_flight(request_queue *q, hd_struct *part, int rw);
FFFFFFFF 00000000          ssize_t __cdecl part_inflight_show(device *dev, device_attribute *attr, char *buf);
FFFFFFFF 00000000          ssize_t __cdecl part_size_show(device *dev, device_attribute *attr, char *buf);
FFFFFFFF 00000000          ssize_t __cdecl part_stat_show(device *dev, device_attribute *attr, char *buf);
00000030 00000000          device_type part_type;
FFFFFFFF 00000000          void __cdecl path_get(const path *);
FFFFFFFF 00000000          int __cdecl path_has_submounts(const path *);
FFFFFFFF 00000000          bool __cdecl path_is_under(const path *, const path *);
FFFFFFFF 00000000          bool __cdecl path_noexec(const path *path);
FFFFFFFF 00000000          bool __cdecl path_nosuid(const path *path);
FFFFFFFF 00000000          void __cdecl path_put(const path *);
FFFFFFFF 00000000          void pci_acpi_crs_quirks(void);
FFFFFFFF 00000000          pci_bus *__cdecl pci_acpi_scan_root(acpi_pci_root *root);
FFFFFFFF 00000000          void *__cdecl pci_iomap(pci_dev *dev, int bar, unsigned __int64 max);
FFFFFFFF 00000000          void *__cdecl pci_iomap_range(pci_dev *dev, int bar, unsigned __int64 offset, unsigned __int64 maxlen);
FFFFFFFF 00000000          void *__cdecl pci_iomap_wc(pci_dev *dev, int bar, unsigned __int64 max);
FFFFFFFF 00000000          void *__cdecl pci_iomap_wc_range(pci_dev *dev, int bar, unsigned __int64 offset, unsigned __int64 maxlen);
FFFFFFFF 00000000          void __cdecl pci_iounmap(pci_dev *dev, void *);
FFFFFFFF 00000000          pcpu_alloc_info *__cdecl pcpu_alloc_alloc_info(int nr_groups, int nr_units);
00000008 0000000000000000          void *pcpu_base_addr;
00000004 00000000          pcpu_fc pcpu_chosen_fc;
FFFFFFFF 00000000          int __cdecl pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size, size_t atom_size, pcpu_fc_cpu_distance_fn_t cpu_distance_fn, pcpu_fc_alloc_fn_t alloc_fn, pcpu_fc_free_fn_t free_fn);
00000018 00000000          const char *const pcpu_fc_names[3];
FFFFFFFF 00000000          void __cdecl pcpu_free_alloc_info(pcpu_alloc_info *ai);
FFFFFFFF 00000000          void __cdecl pcpu_free_vm_areas(vm_struct **vms, int nr_vms);
FFFFFFFF 00000000          vm_struct **__cdecl pcpu_get_vm_areas(const unsigned __int64 *offsets, const size_t *sizes, int nr_vms, size_t align);
FFFFFFFF 00000000          unsigned __int64 pcpu_nr_pages(void);
FFFFFFFF 00000000          int __cdecl pcpu_page_first_chunk(size_t reserved_size, pcpu_fc_alloc_fn_t alloc_fn, pcpu_fc_free_fn_t free_fn, pcpu_fc_populate_pte_fn_t populate_pte_fn);
FFFFFFFF 00000000          void __cdecl pcpu_setup_first_chunk(const pcpu_alloc_info *ai, void *base_addr);
00000008 0000000000000000          const unsigned __int64 *pcpu_unit_offsets;
FFFFFFFF 00000000          phys_addr_t __cdecl per_cpu_ptr_to_phys(void *addr);
000000A8 00000000          const bpf_map_ops percpu_array_map_ops;
FFFFFFFF 00000000          void __cdecl percpu_counter_add_batch(percpu_counter *fbc, s64 amount, s32 batch);
00000004 00000000          int percpu_counter_batch;
FFFFFFFF 00000000          void __cdecl percpu_counter_destroy(percpu_counter *fbc);
FFFFFFFF 00000000          void __cdecl percpu_counter_set(percpu_counter *fbc, s64 amount);
FFFFFFFF 00000000          void __cdecl percpu_down_write(percpu_rw_semaphore *);
FFFFFFFF 00000000          void __cdecl percpu_free_rwsem(percpu_rw_semaphore *);
FFFFFFFF 00000000          int __cdecl percpu_pagelist_fraction_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          void __cdecl percpu_ref_exit(percpu_ref *ref);
FFFFFFFF 00000000          int __cdecl percpu_ref_init(percpu_ref *ref, percpu_ref_func_t *release, unsigned int flags, gfp_t gfp);
FFFFFFFF 00000000          void __cdecl percpu_ref_kill_and_confirm(percpu_ref *ref, percpu_ref_func_t *confirm_kill);
FFFFFFFF 00000000          void __cdecl percpu_ref_reinit(percpu_ref *ref);
FFFFFFFF 00000000          void __cdecl percpu_ref_resurrect(percpu_ref *ref);
FFFFFFFF 00000000          void __cdecl percpu_ref_switch_to_atomic(percpu_ref *ref, percpu_ref_func_t *confirm_switch);
FFFFFFFF 00000000          void __cdecl percpu_ref_switch_to_atomic_sync(percpu_ref *ref);
FFFFFFFF 00000000          void __cdecl percpu_ref_switch_to_percpu(percpu_ref *ref);
FFFFFFFF 00000000          void __cdecl percpu_up_write(percpu_rw_semaphore *);
000000A8 00000000          const bpf_map_ops perf_event_array_map_ops;
00000008 0000000000000000          const bpf_prog_ops perf_event_prog_ops;
00000028 00000000          const bpf_verifier_ops perf_event_verifier_ops;
00000004 00000000          int persistent_clock_is_local;
00000000 00000000          range pfn_mapped[];
FFFFFFFF 00000000          bool __cdecl pfn_modify_allowed(unsigned __int64 pfn, pgprot_t prot);
FFFFFFFF 00000000          bool __cdecl pfn_range_is_mapped(unsigned __int64 start_pfn, unsigned __int64 end_pfn);
FFFFFFFF 00000000          void __cdecl pgd_clear_bad(pgd_t *);
00000010 00000000          list_head pgd_list;
00000004 00000000          spinlock_t pgd_lock;
FFFFFFFF 00000000          mm_struct *__cdecl pgd_page_get_mm(page *page);
00000004 00000000          unsigned int pgdir_shift;
FFFFFFFF 00000000          pgprot_t __cdecl pgprot_writecombine(pgprot_t prot);
FFFFFFFF 00000000          pgprot_t __cdecl pgprot_writethrough(pgprot_t prot);
FFFFFFFF 00000000          void pgtable_cache_init(void);
FFFFFFFF 00000000          void __cdecl pgtable_trans_huge_deposit(mm_struct *mm, pmd_t *pmdp, pgtable_t pgtable);
FFFFFFFF 00000000          pgtable_t __cdecl pgtable_trans_huge_withdraw(mm_struct *mm, pmd_t *pmdp);
00000008 0000000000000000          unsigned __int64 phys_base;
00001000 00000000          physid_mask_t phys_cpu_present_map;
FFFFFFFF 00000000          bool __cdecl phys_mem_access_encrypted(unsigned __int64 phys_addr, unsigned __int64 size);
FFFFFFFF 00000000          pgprot_t __cdecl phys_mem_access_prot(file *file, unsigned __int64 pfn, unsigned __int64 size, pgprot_t vma_prot);
FFFFFFFF 00000000          int __cdecl phys_mem_access_prot_allowed(file *file, unsigned __int64 pfn, unsigned __int64 size, pgprot_t *vma_prot);
00000008 0000000000000000          phys_addr_t physical_mask;
00000004 00000000          int pic_mode;
FFFFFFFF 00000000          pid_t __cdecl pid_nr_ns(pid *pid, pid_namespace *ns);
FFFFFFFF 00000000          task_struct *__cdecl pid_task(pid *pid, pid_type);
FFFFFFFF 00000000          pid_t __cdecl pid_vnr(pid *pid);
00000110 00000000          const file_operations pidfd_fops;
FFFFFFFF 00000000          pid *__cdecl pidfd_pid(const file *file);
00000008 0000000000000000          pte_t *pkmap_page_table;
00000008 0000000000000000          int (__cdecl *platform_notify)(device *);
00000008 0000000000000000          int (__cdecl *platform_notify_remove)(device *);
FFFFFFFF 00000000          void play_dead_common(void);
FFFFFFFF 00000000          void __cdecl plist_add(plist_node *node, plist_head *head);
FFFFFFFF 00000000          void __cdecl plist_del(plist_node *node, plist_head *head);
FFFFFFFF 00000000          void __cdecl plist_requeue(plist_node *node, plist_head *head);
FFFFFFFF 00000000          void __cdecl pm_generic_complete(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_freeze(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_freeze_late(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_freeze_noirq(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_poweroff(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_poweroff_late(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_poweroff_noirq(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_prepare(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_restore(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_restore_early(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_restore_noirq(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_resume(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_resume_early(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_resume_noirq(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_runtime_resume(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_runtime_suspend(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_suspend(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_suspend_late(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_suspend_noirq(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_thaw(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_thaw_early(device *dev);
FFFFFFFF 00000000          int __cdecl pm_generic_thaw_noirq(device *dev);
00000008 0000000000000000          void (*pm_power_off)(void);
00000008 0000000000000000          void (*pm_power_off_prepare)(void);
FFFFFFFF 00000000          void __cdecl pm_relax(device *dev);
FFFFFFFF 00000000          void pm_restore_gfp_mask(void);
FFFFFFFF 00000000          void pm_restrict_gfp_mask(void);
FFFFFFFF 00000000          void __cdecl pm_runtime_allow(device *dev);
FFFFFFFF 00000000          u64 __cdecl pm_runtime_autosuspend_expiration(device *dev);
FFFFFFFF 00000000          int __cdecl pm_runtime_barrier(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_drop_link(device_link *link);
FFFFFFFF 00000000          void __cdecl pm_runtime_enable(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_forbid(device *dev);
FFFFFFFF 00000000          int __cdecl pm_runtime_force_resume(device *dev);
FFFFFFFF 00000000          int __cdecl pm_runtime_force_suspend(device *dev);
FFFFFFFF 00000000          int __cdecl pm_runtime_get_if_in_use(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_get_suppliers(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_irq_safe(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_new_link(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_no_callbacks(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_put_suppliers(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_set_autosuspend_delay(device *dev, int delay);
FFFFFFFF 00000000          void __cdecl pm_runtime_set_memalloc_noio(device *dev, bool enable);
FFFFFFFF 00000000          u64 __cdecl pm_runtime_suspended_time(device *dev);
FFFFFFFF 00000000          void __cdecl pm_runtime_update_max_time_suspended(device *dev, s64 delta_ns);
FFFFFFFF 00000000          int __cdecl pm_schedule_suspend(device *dev, unsigned int delay);
FFFFFFFF 00000000          void __cdecl pm_stay_awake(device *dev);
FFFFFFFF 00000000          bool pm_suspended_storage(void);
FFFFFFFF 00000000          void __cdecl pm_vt_switch_required(device *dev, bool required);
FFFFFFFF 00000000          void __cdecl pm_vt_switch_unregister(device *dev);
FFFFFFFF 00000000          void __cdecl pm_wakeup_dev_event(device *dev, unsigned int msec, bool hard);
FFFFFFFF 00000000          void __cdecl pm_wakeup_ws_event(wakeup_source *ws, unsigned int msec, bool hard);
00000008 0000000000000000          workqueue_struct *pm_wq;
FFFFFFFF 00000000          void __cdecl pmd_clear_bad(pmd_t *);
FFFFFFFF 00000000          int __cdecl pmd_clear_huge(pmd_t *pmd);
FFFFFFFF 00000000          int __cdecl pmd_free_pte_page(pmd_t *pmd, unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl pmd_set_huge(pmd_t *pmd, phys_addr_t addr, pgprot_t prot);
FFFFFFFF 00000000          int __cdecl pmdp_clear_flush_young(vm_area_struct *vma, unsigned __int64 address, pmd_t *pmdp);
FFFFFFFF 00000000          pmd_t __cdecl pmdp_collapse_flush(vm_area_struct *vma, unsigned __int64 address, pmd_t *pmdp);
FFFFFFFF 00000000          pmd_t __cdecl pmdp_huge_clear_flush(vm_area_struct *vma, unsigned __int64 address, pmd_t *pmdp);
FFFFFFFF 00000000          pmd_t __cdecl pmdp_invalidate(vm_area_struct *vma, unsigned __int64 address, pmd_t *pmdp);
FFFFFFFF 00000000          int __cdecl pmdp_set_access_flags(vm_area_struct *vma, unsigned __int64 address, pmd_t *pmdp, pmd_t entry, int dirty);
FFFFFFFF 00000000          int __cdecl pmdp_test_and_clear_young(vm_area_struct *vma, unsigned __int64 addr, pmd_t *pmdp);
00000004 00000000          int pnpacpi_disabled;
FFFFFFFF 00000000          void poking_init(void);
FFFFFFFF 00000000          void __cdecl poll_freewait(poll_wqueues *pwq);
FFFFFFFF 00000000          void __cdecl poll_initwait(poll_wqueues *pwq);
FFFFFFFF 00000000          int __cdecl poll_select_set_timeout(timespec64 *to, time64_t sec, __int64 nsec);
FFFFFFFF 00000000          pmd_t *__cdecl populate_extra_pmd(unsigned __int64 vaddr);
FFFFFFFF 00000000          pte_t *__cdecl populate_extra_pte(unsigned __int64 vaddr);
FFFFFFFF 00000000          void __cdecl posix_cpu_timers_exit(task_struct *task);
FFFFFFFF 00000000          void __cdecl posix_cpu_timers_exit_group(task_struct *task);
FFFFFFFF 00000000          void __cdecl posix_cputimers_group_init(posix_cputimers *pct, u64 cpu_limit);
FFFFFFFF 00000000          int __cdecl posix_lock_file(file *, file_lock *, file_lock *);
FFFFFFFF 00000000          void __cdecl posix_test_lock(file *, file_lock *);
FFFFFFFF 00000000          void __cdecl posixtimer_rearm(kernel_siginfo *info);
00000000 00000000          const char power_group_name[];
00000008 0000000000000000          kobject *power_kobj;
00000100 00000000          char poweroff_cmd[256];
FFFFFFFF 00000000          void __cdecl pr_cont_kernfs_name(kernfs_node *kn);
FFFFFFFF 00000000          void __cdecl pr_cont_kernfs_path(kernfs_node *kn);
FFFFFFFF 00000000          __int64 prctl_get_seccomp(void);
FFFFFFFF 00000000          __int64 __cdecl prctl_set_seccomp(unsigned __int64, void *);
FFFFFFFF 00000000          int __cdecl prealloc_shrinker(shrinker *shrinker);
FFFFFFFF 00000000          void preempt_notifier_dec(void);
FFFFFFFF 00000000          void preempt_notifier_inc(void);
FFFFFFFF 00000000          void __cdecl preempt_notifier_register(preempt_notifier *notifier);
FFFFFFFF 00000000          void __cdecl preempt_notifier_unregister(preempt_notifier *notifier);
FFFFFFFF 00000000          void preempt_schedule_irq(void);
FFFFFFFF 00000000          void __cdecl prep_transhuge_page(page *page);
FFFFFFFF 00000000          cred *prepare_creds(void);
FFFFFFFF 00000000          cred *prepare_exec_creds(void);
FFFFFFFF 00000000          cred *__cdecl prepare_kernel_cred(task_struct *);
FFFFFFFF 00000000          void prepare_namespace(void);
FFFFFFFF 00000000          int __cdecl prepare_percpu_nmi(unsigned int irq);
FFFFFFFF 00000000          void __cdecl prepare_to_wait(wait_queue_head *wq_head, wait_queue_entry *wq_entry, int state);
FFFFFFFF 00000000          __int64 __cdecl prepare_to_wait_event(wait_queue_head *wq_head, wait_queue_entry *wq_entry, int state);
FFFFFFFF 00000000          bool __cdecl prepare_to_wait_exclusive(wait_queue_head *wq_head, wait_queue_entry *wq_entry, int state);
00000008 0000000000000000          unsigned __int64 preset_lpj;
FFFFFFFF 00000000          void print_IO_APICs(void);
FFFFFFFF 00000000          void __cdecl print_cpu_info(cpuinfo_x86 *);
FFFFFFFF 00000000          void __cdecl print_cpu_msr(cpuinfo_x86 *);
FFFFFFFF 00000000          void __cdecl print_hex_dump(const char *level, const char *prefix_str, int prefix_type, int rowsize, int groupsize, const void *buf, size_t len, bool ascii);
FFFFFFFF 00000000          void print_modules(void);
FFFFFFFF 00000000          void print_oops_end_marker(void);
FFFFFFFF 00000000          const char *print_tainted(void);
FFFFFFFF 00000000          void __cdecl print_vma_addr(char *prefix, unsigned __int64 rip);
FFFFFFFF 00000000          void __cdecl print_worker_info(const char *log_lvl, task_struct *task);
FFFFFFFF 00000000          int printk(const char *fmt, ...);
FFFFFFFF 00000000          void printk_all_partitions(void);
FFFFFFFF 00000000          int printk_deferred(const char *fmt, ...);
00000004 00000000          int printk_delay_msec;
FFFFFFFF 00000000          void printk_nmi_direct_enter(void);
FFFFFFFF 00000000          void printk_nmi_direct_exit(void);
FFFFFFFF 00000000          void printk_nmi_enter(void);
FFFFFFFF 00000000          void printk_nmi_exit(void);
00000028 00000000          ratelimit_state printk_ratelimit_state;
FFFFFFFF 00000000          void printk_safe_flush(void);
FFFFFFFF 00000000          void printk_safe_flush_on_panic(void);
FFFFFFFF 00000000          bool __cdecl printk_timed_ratelimit(unsigned __int64 *caller_jiffies, unsigned int interval_msec);
FFFFFFFF 00000000          bool __cdecl privileged_wrt_inode_uidgid(user_namespace *ns, const inode *inode);
FFFFFFFF 00000000          unsigned int __cdecl probe_irq_mask(unsigned __int64);
FFFFFFFF 00000000          int __cdecl probe_irq_off(unsigned __int64);
FFFFFFFF 00000000          unsigned __int64 probe_irq_on(void);
FFFFFFFF 00000000          __int64 __cdecl probe_kernel_read(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl probe_kernel_write(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl probe_user_read(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          __int64 __cdecl probe_user_write(void *dst, const void *src, size_t size);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create(const char *name, umode_t mode, proc_dir_entry *parent, const file_operations *proc_fops);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_data(const char *, umode_t, proc_dir_entry *, const file_operations *, void *);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_mount_point(const char *name);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_net_data(const char *name, umode_t mode, proc_dir_entry *parent, const seq_operations *ops, unsigned int state_size, void *data);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_net_data_write(const char *name, umode_t mode, proc_dir_entry *parent, const seq_operations *ops, proc_write_t write, unsigned int state_size, void *data);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_net_single(const char *name, umode_t mode, proc_dir_entry *parent, int (__cdecl *show)(seq_file *, void *), void *data);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_net_single_write(const char *name, umode_t mode, proc_dir_entry *parent, int (__cdecl *show)(seq_file *, void *), proc_write_t write, void *data);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_seq_private(const char *name, umode_t mode, proc_dir_entry *parent, const seq_operations *ops, unsigned int state_size, void *data);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_create_single_data(const char *name, umode_t mode, proc_dir_entry *parent, int (__cdecl *show)(seq_file *, void *), void *data);
FFFFFFFF 00000000          int __cdecl proc_do_large_bitmap(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_do_static_key(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl proc_dointvec(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_dointvec_jiffies(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_dointvec_minmax(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_dointvec_ms_jiffies(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_dointvec_userhz_jiffies(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_dostring(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_douintvec(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_douintvec_minmax(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl proc_doulongvec_minmax(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          void __cdecl proc_flush_task(task_struct *);
FFFFFFFF 00000000          void *__cdecl proc_get_parent_data(const inode *);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_mkdir(const char *, proc_dir_entry *);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_mkdir_data(const char *, umode_t, proc_dir_entry *, void *);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_mkdir_mode(const char *, umode_t, proc_dir_entry *);
FFFFFFFF 00000000          int __cdecl proc_nr_dentry(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl proc_nr_files(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl proc_nr_inodes(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl proc_pid_arch_status(seq_file *m, pid_namespace *ns, pid *pid, task_struct *task);
FFFFFFFF 00000000          void __cdecl proc_remove(proc_dir_entry *);
FFFFFFFF 00000000          void proc_root_init(void);
FFFFFFFF 00000000          void __cdecl proc_set_size(proc_dir_entry *, loff_t);
FFFFFFFF 00000000          void __cdecl proc_set_user(proc_dir_entry *, kuid_t, kgid_t);
FFFFFFFF 00000000          proc_dir_entry *__cdecl proc_symlink(const char *, proc_dir_entry *, const char *);
FFFFFFFF 00000000          void __cdecl proc_sys_poll_notify(ctl_table_poll *poll);
FFFFFFFF 00000000          bool __cdecl process_shares_mm(task_struct *p, mm_struct *mm);
FFFFFFFF 00000000          unsigned __int64 __cdecl profile_pc(pt_regs *regs);
000000A8 00000000          const bpf_map_ops prog_array_map_ops;
FFFFFFFF 00000000          property_entry *__cdecl property_entries_dup(const property_entry *properties);
FFFFFFFF 00000000          void __cdecl property_entries_free(const property_entry *properties);
00000080 00000000          pgprot_t protection_map[16];
00000004 00000000          int prove_locking;
FFFFFFFF 00000000          pstore_type_id __cdecl pstore_name_to_type(const char *name);
FFFFFFFF 00000000          int __cdecl pstore_register(pstore_info *);
FFFFFFFF 00000000          const char *__cdecl pstore_type_to_name(pstore_type_id type);
FFFFFFFF 00000000          void __cdecl pstore_unregister(pstore_info *);
FFFFFFFF 00000000          void __cdecl ptdump_walk_pgd_level(seq_file *m, pgd_t *pgd);
FFFFFFFF 00000000          void ptdump_walk_pgd_level_checkwx(void);
FFFFFFFF 00000000          void __cdecl ptdump_walk_pgd_level_debugfs(seq_file *m, pgd_t *pgd, bool user);
FFFFFFFF 00000000          void ptdump_walk_user_pgd_level_checkwx(void);
FFFFFFFF 00000000          pte_t __cdecl ptep_clear_flush(vm_area_struct *vma, unsigned __int64 address, pte_t *ptep);
FFFFFFFF 00000000          int __cdecl ptep_clear_flush_young(vm_area_struct *vma, unsigned __int64 address, pte_t *ptep);
FFFFFFFF 00000000          int __cdecl ptep_set_access_flags(vm_area_struct *vma, unsigned __int64 address, pte_t *ptep, pte_t entry, int dirty);
FFFFFFFF 00000000          int __cdecl ptep_test_and_clear_young(vm_area_struct *vma, unsigned __int64 addr, pte_t *ptep);
FFFFFFFF 00000000          bool __cdecl ptracer_capable(task_struct *tsk, user_namespace *ns);
00000004 00000000          unsigned int ptrs_per_p4d;
FFFFFFFF 00000000          void __cdecl pud_clear_bad(pud_t *);
FFFFFFFF 00000000          int __cdecl pud_clear_huge(pud_t *pud);
FFFFFFFF 00000000          int __cdecl pud_free_pmd_page(pud_t *pud, unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl pud_set_huge(pud_t *pud, phys_addr_t addr, pgprot_t prot);
FFFFFFFF 00000000          pud_t __cdecl pudp_huge_clear_flush(vm_area_struct *vma, unsigned __int64 address, pud_t *pudp);
FFFFFFFF 00000000          int __cdecl pudp_set_access_flags(vm_area_struct *vma, unsigned __int64 address, pud_t *pudp, pud_t entry, int dirty);
FFFFFFFF 00000000          int __cdecl pudp_test_and_clear_young(vm_area_struct *vma, unsigned __int64 addr, pud_t *pudp);
FFFFFFFF 00000000          void __cdecl put_and_wait_on_page_locked(page *page);
FFFFFFFF 00000000          void __cdecl put_device(device *dev);
FFFFFFFF 00000000          void __cdecl put_disk(gendisk *disk);
FFFFFFFF 00000000          void __cdecl put_disk_and_module(gendisk *disk);
FFFFFFFF 00000000          void __cdecl put_filesystem(file_system_type *fs);
FFFFFFFF 00000000          void __cdecl put_io_context(io_context *ioc);
FFFFFFFF 00000000          void __cdecl put_io_context_active(io_context *ioc);
FFFFFFFF 00000000          int __cdecl put_itimerspec64(const itimerspec64 *it, __kernel_itimerspec *uit);
FFFFFFFF 00000000          int __cdecl put_old_itimerspec32(const itimerspec64 *its, old_itimerspec32 *uits);
FFFFFFFF 00000000          int __cdecl put_old_timespec32(const timespec64 *, void *);
FFFFFFFF 00000000          int __cdecl put_old_timex32(old_timex32 *, const __kernel_timex *);
FFFFFFFF 00000000          void put_online_mems(void);
FFFFFFFF 00000000          void __cdecl put_page_bootmem(page *page);
FFFFFFFF 00000000          void __cdecl put_pages_list(list_head *pages);
FFFFFFFF 00000000          void __cdecl put_pid(pid *pid);
FFFFFFFF 00000000          void __cdecl put_seccomp_filter(task_struct *tsk);
FFFFFFFF 00000000          int __cdecl put_timespec64(const timespec64 *ts, __kernel_timespec *uts);
FFFFFFFF 00000000          void __cdecl put_unused_fd(unsigned int fd);
FFFFFFFF 00000000          void __cdecl put_user_pages(page **pages, unsigned __int64 npages);
FFFFFFFF 00000000          void __cdecl put_user_pages_dirty_lock(page **pages, unsigned __int64 npages, bool make_dirty);
FFFFFFFF 00000000          void __cdecl put_vaddr_frames(frame_vector *vec);
FFFFFFFF 00000000          void __cdecl putname(filename *name);
00000018 00000000          pv_info pv_info;
FFFFFFFF 00000000          bool pv_is_native_spin_unlock(void);
FFFFFFFF 00000000          bool pv_is_native_vcpu_is_preempted(void);
000002B8 00000000          paravirt_patch_template pv_ops;
FFFFFFFF 00000000          int __cdecl pxm_to_node(int);
00000001 00000000          bool qdf2400_e44_present;
FFFFFFFF 00000000          bool __cdecl qid_eq(kqid left, kqid right);
FFFFFFFF 00000000          bool __cdecl qid_lt(kqid left, kqid right);
FFFFFFFF 00000000          bool __cdecl qid_valid(kqid qid);
FFFFFFFF 00000000          int __cdecl qtree_delete_dquot(qtree_mem_dqinfo *info, dquot *dquot);
FFFFFFFF 00000000          int __cdecl qtree_entry_unused(qtree_mem_dqinfo *info, char *disk);
FFFFFFFF 00000000          int __cdecl qtree_get_next_id(qtree_mem_dqinfo *info, kqid *qid);
FFFFFFFF 00000000          int __cdecl qtree_read_dquot(qtree_mem_dqinfo *info, dquot *dquot);
FFFFFFFF 00000000          int __cdecl qtree_release_dquot(qtree_mem_dqinfo *info, dquot *dquot);
FFFFFFFF 00000000          int __cdecl qtree_write_dquot(qtree_mem_dqinfo *info, dquot *dquot);
FFFFFFFF 00000000          bool __cdecl queue_delayed_work_on(int cpu, workqueue_struct *wq, delayed_work *work, unsigned __int64 delay);
000000A8 00000000          const bpf_map_ops queue_map_ops;
FFFFFFFF 00000000          bool __cdecl queue_rcu_work(workqueue_struct *wq, rcu_work *rwork);
FFFFFFFF 00000000          bool __cdecl queue_work_node(int node, workqueue_struct *wq, work_struct *work);
FFFFFFFF 00000000          bool __cdecl queue_work_on(int cpu, workqueue_struct *wq, work_struct *work);
FFFFFFFF 00000000          void __cdecl queued_read_lock_slowpath(qrwlock *lock);
FFFFFFFF 00000000          void __cdecl queued_write_lock_slowpath(qrwlock *lock);
FFFFFFFF 00000000          void quiet_vmstat(void);
FFFFFFFF 00000000          void __cdecl quota_send_warning(kqid qid, dev_t dev, const char warntype);
FFFFFFFF 00000000          void *__cdecl radix_tree_delete(xarray *, unsigned __int64);
FFFFFFFF 00000000          void *__cdecl radix_tree_delete_item(xarray *, unsigned __int64, void *);
FFFFFFFF 00000000          unsigned int __cdecl radix_tree_gang_lookup(const xarray *, void **results, unsigned __int64 first_index, unsigned int max_items);
FFFFFFFF 00000000          unsigned int __cdecl radix_tree_gang_lookup_tag(const xarray *, void **results, unsigned __int64 first_index, unsigned int max_items, unsigned int tag);
FFFFFFFF 00000000          unsigned int __cdecl radix_tree_gang_lookup_tag_slot(const xarray *, void ***results, unsigned __int64 first_index, unsigned int max_items, unsigned int tag);
FFFFFFFF 00000000          void radix_tree_init(void);
FFFFFFFF 00000000          int __cdecl radix_tree_insert(xarray *, unsigned __int64 index, void *);
FFFFFFFF 00000000          void __cdecl radix_tree_iter_delete(xarray *, radix_tree_iter *iter, void **slot);
FFFFFFFF 00000000          void __cdecl radix_tree_iter_replace(xarray *, const radix_tree_iter *, void **slot, void *entry);
FFFFFFFF 00000000          void **__cdecl radix_tree_iter_resume(void **slot, radix_tree_iter *iter);
FFFFFFFF 00000000          void __cdecl radix_tree_iter_tag_clear(xarray *, const radix_tree_iter *iter, unsigned int tag);
FFFFFFFF 00000000          void *__cdecl radix_tree_lookup(const xarray *, unsigned __int64);
FFFFFFFF 00000000          void **__cdecl radix_tree_lookup_slot(const xarray *, unsigned __int64 index);
FFFFFFFF 00000000          int __cdecl radix_tree_maybe_preload(gfp_t gfp_mask);
FFFFFFFF 00000000          void **__cdecl radix_tree_next_chunk(const xarray *, radix_tree_iter *iter, unsigned int flags);
FFFFFFFF 00000000          int __cdecl radix_tree_preload(gfp_t gfp_mask);
FFFFFFFF 00000000          void __cdecl radix_tree_replace_slot(xarray *, void **slot, void *entry);
FFFFFFFF 00000000          void *__cdecl radix_tree_tag_clear(xarray *, unsigned __int64 index, unsigned int tag);
FFFFFFFF 00000000          int __cdecl radix_tree_tag_get(const xarray *, unsigned __int64 index, unsigned int tag);
FFFFFFFF 00000000          void *__cdecl radix_tree_tag_set(xarray *, unsigned __int64 index, unsigned int tag);
FFFFFFFF 00000000          int __cdecl radix_tree_tagged(const xarray *, unsigned int tag);
FFFFFFFF 00000000          void __cdecl raise_softirq(unsigned int nr);
FFFFFFFF 00000000          void __cdecl raise_softirq_irqoff(unsigned int nr);
FFFFFFFF 00000000          void __cdecl rand_initialize_disk(gendisk *disk);
FFFFFFFF 00000000          unsigned __int64 random_get_entropy_fallback(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl randomize_page(unsigned __int64 start, unsigned __int64 range);
FFFFFFFF 00000000          unsigned __int64 __cdecl randomize_stack_top(unsigned __int64 stack_top);
00000004 00000000          int randomize_va_space;
FFFFFFFF 00000000          int __cdecl raw_notifier_call_chain(raw_notifier_head *nh, unsigned __int64 val, void *v);
FFFFFFFF 00000000          int __cdecl raw_notifier_chain_register(raw_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          int __cdecl raw_notifier_chain_unregister(raw_notifier_head *nh, notifier_block *nb);
00000008 0000000000000000          const bpf_prog_ops raw_tracepoint_prog_ops;
00000028 00000000          const bpf_verifier_ops raw_tracepoint_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops raw_tracepoint_writable_prog_ops;
00000028 00000000          const bpf_verifier_ops raw_tracepoint_writable_verifier_ops;
FFFFFFFF 00000000          void __cdecl rb_erase(rb_node *, rb_root *);
FFFFFFFF 00000000          rb_node *__cdecl rb_first(const rb_root *);
FFFFFFFF 00000000          rb_node *__cdecl rb_first_postorder(const rb_root *);
FFFFFFFF 00000000          void __cdecl rb_insert_color(rb_node *, rb_root *);
FFFFFFFF 00000000          rb_node *__cdecl rb_last(const rb_root *);
FFFFFFFF 00000000          rb_node *__cdecl rb_next(const rb_node *);
FFFFFFFF 00000000          rb_node *__cdecl rb_next_postorder(const rb_node *);
FFFFFFFF 00000000          rb_node *__cdecl rb_prev(const rb_node *);
FFFFFFFF 00000000          void __cdecl rb_replace_node(rb_node *victim, rb_node *new, rb_root *root);
FFFFFFFF 00000000          void __cdecl rb_replace_node_rcu(rb_node *victim, rb_node *new, rb_root *root);
00000008 0000000000000000          unsigned __int64 rci2_table_phys;
FFFFFFFF 00000000          void rcu_all_qs(void);
FFFFFFFF 00000000          void rcu_barrier(void);
FFFFFFFF 00000000          void rcu_barrier_tasks(void);
FFFFFFFF 00000000          void rcu_cpu_stall_reset(void);
FFFFFFFF 00000000          void __cdecl rcu_cpu_starting(unsigned int cpu);
FFFFFFFF 00000000          void rcu_end_inkernel_boot(void);
FFFFFFFF 00000000          bool __cdecl rcu_eqs_special_set(int cpu);
FFFFFFFF 00000000          void rcu_idle_enter(void);
FFFFFFFF 00000000          void rcu_idle_exit(void);
FFFFFFFF 00000000          void rcu_init(void);
FFFFFFFF 00000000          void rcu_irq_enter(void);
FFFFFFFF 00000000          void rcu_irq_enter_irqson(void);
FFFFFFFF 00000000          void rcu_irq_exit(void);
FFFFFFFF 00000000          void rcu_irq_exit_irqson(void);
FFFFFFFF 00000000          bool rcu_is_watching(void);
FFFFFFFF 00000000          int __cdecl rcu_needs_cpu(u64 basem, u64 *nextevt);
FFFFFFFF 00000000          void rcu_nmi_enter(void);
FFFFFFFF 00000000          void rcu_nmi_exit(void);
FFFFFFFF 00000000          void __cdecl rcu_note_context_switch(bool preempt);
FFFFFFFF 00000000          void __cdecl rcu_report_dead(unsigned int cpu);
FFFFFFFF 00000000          void __cdecl rcu_sched_clock_irq(int user);
00000004 00000000          int rcu_scheduler_active;
FFFFFFFF 00000000          void rcu_scheduler_starting(void);
FFFFFFFF 00000000          void rcu_softirq_qs(void);
FFFFFFFF 00000000          void __cdecl rcu_sync_dtor(rcu_sync *);
FFFFFFFF 00000000          void __cdecl rcu_sync_enter(rcu_sync *);
FFFFFFFF 00000000          void __cdecl rcu_sync_enter_start(rcu_sync *);
FFFFFFFF 00000000          void __cdecl rcu_sync_exit(rcu_sync *);
FFFFFFFF 00000000          void __cdecl rcu_sync_init(rcu_sync *);
FFFFFFFF 00000000          void rcu_sysrq_end(void);
FFFFFFFF 00000000          void rcu_sysrq_start(void);
FFFFFFFF 00000000          int __cdecl rcutree_dead_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl rcutree_dying_cpu(unsigned int cpu);
FFFFFFFF 00000000          void __cdecl rcutree_migrate_callbacks(int cpu);
FFFFFFFF 00000000          int __cdecl rcutree_offline_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl rcutree_online_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl rcutree_prepare_cpu(unsigned int cpu);
FFFFFFFF 00000000          void __cdecl rcuwait_wake_up(rcuwait *w);
FFFFFFFF 00000000          int __cdecl rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
FFFFFFFF 00000000          void __cdecl rdmsr_on_cpus(const cpumask *mask, u32 msr_no, msr *msrs);
FFFFFFFF 00000000          int __cdecl rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
FFFFFFFF 00000000          int __cdecl rdmsr_safe_regs(u32 regs[8]);
FFFFFFFF 00000000          int __cdecl rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);
FFFFFFFF 00000000          int __cdecl rdmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);
FFFFFFFF 00000000          int __cdecl rdmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);
FFFFFFFF 00000000          page *__cdecl read_cache_page(address_space *mapping, unsigned __int64 index, filler_t *filler, void *data);
FFFFFFFF 00000000          page *__cdecl read_cache_page_gfp(address_space *mapping, unsigned __int64 index, gfp_t gfp_mask);
FFFFFFFF 00000000          int __cdecl read_cache_pages(address_space *mapping, list_head *pages, filler_t *filler, void *data);
FFFFFFFF 00000000          int __cdecl read_current_timer(unsigned __int64 *timer_val);
FFFFFFFF 00000000          unsigned __int8 *__cdecl read_dev_sector(block_device *, sector_t, Sector *);
FFFFFFFF 00000000          void __cdecl read_persistent_clock64(timespec64 *ts);
FFFFFFFF 00000000          void __cdecl read_persistent_wall_and_boot_offset(timespec64 *wall_clock, timespec64 *boot_offset);
FFFFFFFF 00000000          int __cdecl readlink_copy(char *, int, const char *);
00000000 00000000          unsigned __int8 real_mode_blob[];
00000000 00000000          unsigned __int8 real_mode_blob_end[];
00000008 0000000000000000          real_mode_header *real_mode_header;
00000000 00000000          unsigned __int8 real_mode_relocs[];
FFFFFFFF 00000000          void __cdecl rearm_wake_irq(unsigned int irq);
00000004 00000000          int reboot_cpu;
00000004 00000000          int reboot_default;
00000004 00000000          int reboot_force;
00000004 00000000          reboot_mode reboot_mode;
00000030 00000000          blocking_notifier_head reboot_notifier_list;
00000004 00000000          reboot_type reboot_type;
FFFFFFFF 00000000          int __cdecl redirty_page_for_writepage(writeback_control *wbc, page *page);
FFFFFFFF 00000000          int __cdecl ref_module(module *a, module *b);
FFFFFFFF 00000000          bool __cdecl refcount_dec_and_lock(refcount_t *r, spinlock_t *lock);
FFFFFFFF 00000000          bool __cdecl refcount_dec_and_lock_irqsave(refcount_t *r, spinlock_t *lock, unsigned __int64 *flags);
FFFFFFFF 00000000          bool __cdecl refcount_dec_and_mutex_lock(refcount_t *r, mutex *lock);
FFFFFFFF 00000000          bool __cdecl refcount_dec_if_one(refcount_t *r);
FFFFFFFF 00000000          bool __cdecl refcount_dec_not_one(refcount_t *r);
FFFFFFFF 00000000          void __cdecl refcount_warn_saturate(refcount_t *r, refcount_saturation_type t);
FFFFFFFF 00000000          void refresh_zone_stat_thresholds(void);
FFFFFFFF 00000000          int __cdecl region_intersects(resource_size_t offset, size_t size, unsigned __int64 flags, unsigned __int64 desc);
FFFFFFFF 00000000          int __cdecl register_acpi_bus_type(acpi_bus_type *);
FFFFFFFF 00000000          int __cdecl register_acpi_notifier(notifier_block *);
FFFFFFFF 00000000          int __cdecl register_blkdev(unsigned int, const char *);
FFFFFFFF 00000000          int __cdecl register_chrdev_region(dev_t, unsigned int, const char *);
FFFFFFFF 00000000          int __cdecl register_filesystem(file_system_type *);
FFFFFFFF 00000000          void __cdecl register_lapic_address(unsigned __int64 address);
FFFFFFFF 00000000          int __cdecl register_module_notifier(notifier_block *nb);
FFFFFFFF 00000000          void __cdecl register_page_bootmem_info_node(pglist_data *pgdat);
FFFFFFFF 00000000          void __cdecl register_page_bootmem_memmap(unsigned __int64 section_nr, page *map, unsigned __int64 nr_pages);
FFFFFFFF 00000000          int __cdecl register_quota_format(quota_format_type *fmt);
FFFFFFFF 00000000          int __cdecl register_reboot_notifier(notifier_block *);
FFFFFFFF 00000000          int __cdecl register_refined_jiffies(__int64 clock_tick_rate);
FFFFFFFF 00000000          int __cdecl register_restart_handler(notifier_block *);
FFFFFFFF 00000000          int __cdecl register_shrinker(shrinker *shrinker);
FFFFFFFF 00000000          void __cdecl register_shrinker_prepared(shrinker *shrinker);
FFFFFFFF 00000000          ctl_table_header *__cdecl register_sysctl(const char *path, ctl_table *table);
FFFFFFFF 00000000          ctl_table_header *__cdecl register_sysctl_paths(const ctl_path *path, ctl_table *table);
FFFFFFFF 00000000          ctl_table_header *__cdecl register_sysctl_table(ctl_table *table);
FFFFFFFF 00000000          int __cdecl register_vmap_purge_notifier(notifier_block *nb);
FFFFFFFF 00000000          const char *__cdecl regs_query_register_name(unsigned int offset);
FFFFFFFF 00000000          int __cdecl regs_query_register_offset(const char *name);
FFFFFFFF 00000000          void __cdecl release_child_resources(resource *new);
FFFFFFFF 00000000          void __cdecl release_dentry_name_snapshot(name_snapshot *);
FFFFFFFF 00000000          int __cdecl release_mem_region_adjustable(resource *, resource_size_t, resource_size_t);
FFFFFFFF 00000000          void __cdecl release_pages(page **pages, int nr);
FFFFFFFF 00000000          int __cdecl release_resource(resource *new);
FFFFFFFF 00000000          void __cdecl release_thread(task_struct *);
FFFFFFFF 00000000          int __cdecl remap_pfn_range(vm_area_struct *, unsigned __int64 addr, unsigned __int64 pfn, unsigned __int64 size, pgprot_t);
FFFFFFFF 00000000          int __cdecl remap_vmalloc_range(vm_area_struct *vma, void *addr, unsigned __int64 pgoff);
FFFFFFFF 00000000          int __cdecl remap_vmalloc_range_partial(vm_area_struct *vma, unsigned __int64 uaddr, void *kaddr, unsigned __int64 pgoff, unsigned __int64 size);
FFFFFFFF 00000000          int __cdecl remove_memory(int nid, u64 start, u64 size);
FFFFFFFF 00000000          void __cdecl remove_pfn_range_from_zone(zone *zone, unsigned __int64 start_pfn, unsigned __int64 nr_pages);
FFFFFFFF 00000000          void __cdecl remove_proc_entry(const char *, proc_dir_entry *);
FFFFFFFF 00000000          int __cdecl remove_proc_subtree(const char *, proc_dir_entry *);
FFFFFFFF 00000000          int __cdecl remove_resource(resource *old);
FFFFFFFF 00000000          vm_struct *__cdecl remove_vm_area(const void *addr);
FFFFFFFF 00000000          void __cdecl remove_wait_queue(wait_queue_head *wq_head, wait_queue_entry *wq_entry);
00000008 0000000000000000          seqlock_t rename_lock;
FFFFFFFF 00000000          int __cdecl replace_fd(unsigned int fd, file *file, unsigned int flags);
FFFFFFFF 00000000          int __cdecl replace_page_cache_page(page *old, page *new, gfp_t gfp_mask);
FFFFFFFF 00000000          bug_trap_type __cdecl report_bug(unsigned __int64 bug_addr, pt_regs *regs);
FFFFFFFF 00000000          int __cdecl request_any_context_irq(unsigned int irq, irq_handler_t handler, unsigned __int64 flags, const char *name, void *dev_id);
FFFFFFFF 00000000          resource *__cdecl request_free_mem_region(resource *base, unsigned __int64 size, const char *name);
FFFFFFFF 00000000          key *__cdecl request_key_rcu(key_type *type, const char *description, key_tag *domain_tag);
FFFFFFFF 00000000          key *__cdecl request_key_tag(key_type *type, const char *description, key_tag *domain_tag, const char *callout_info);
FFFFFFFF 00000000          key *__cdecl request_key_with_auxdata(key_type *type, const char *description, key_tag *domain_tag, const void *callout_info, size_t callout_len, void *aux);
FFFFFFFF 00000000          int __cdecl request_nmi(unsigned int irq, irq_handler_t handler, unsigned __int64 flags, const char *name, void *dev);
FFFFFFFF 00000000          int __cdecl request_percpu_nmi(unsigned int irq, irq_handler_t handler, const char *devname, void *dev);
FFFFFFFF 00000000          int __cdecl request_resource(resource *root, resource *new);
FFFFFFFF 00000000          resource *__cdecl request_resource_conflict(resource *root, resource *new);
FFFFFFFF 00000000          int __cdecl request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned __int64 flags, const char *name, void *dev);
FFFFFFFF 00000000          int __cdecl rescan_partitions(gendisk *disk, block_device *bdev);
FFFFFFFF 00000000          void __cdecl reserve_bootmem_region(phys_addr_t start, phys_addr_t end);
FFFFFFFF 00000000          void reserve_real_mode(void);
FFFFFFFF 00000000          void __cdecl reserve_region_with_split(resource *root, resource_size_t start, resource_size_t end, const char *name);
FFFFFFFF 00000000          void __cdecl reserve_top_address(unsigned __int64 reserve);
00000004 00000000          unsigned int reset_devices;
FFFFFFFF 00000000          resource_size_t __cdecl resource_alignment(resource *res);
FFFFFFFF 00000000          resource_entry *__cdecl resource_list_create_entry(resource *res, size_t extra_size);
FFFFFFFF 00000000          void __cdecl resource_list_free(list_head *head);
FFFFFFFF 00000000          void restore_boot_irq_mode(void);
FFFFFFFF 00000000          int restore_ioapic_entries(void);
FFFFFFFF 00000000          int __cdecl restore_online_page_callback(online_page_callback_t callback);
FFFFFFFF 00000000          int __cdecl restrict_link_reject(key *keyring, const key_type *type, const key_payload *payload, key *restriction_key);
FFFFFFFF 00000000          void resume_device_irqs(void);
FFFFFFFF 00000000          void __cdecl retire_sysctl_set(ctl_table_set *set);
FFFFFFFF 00000000          bool __cdecl retpoline_module_ok(bool has_retpoline);
000000A8 00000000          const bpf_map_ops reuseport_array_ops;
FFFFFFFF 00000000          int __cdecl revalidate_disk(gendisk *);
FFFFFFFF 00000000          void __cdecl revert_creds(const cred *);
FFFFFFFF 00000000          int __cdecl rhashtable_init(rhashtable *ht, const rhashtable_params *params);
FFFFFFFF 00000000          int __cdecl rhltable_init(rhltable *hlt, const rhashtable_params *params);
00000001 00000000          bool rodata_enabled;
FFFFFFFF 00000000          void __cdecl root_device_unregister(device *root);
00000004 00000000          int root_mountflags;
00000080 00000000          user_struct root_user;
00000048 00000000          file_system_type rootfs_fs_type;
FFFFFFFF 00000000          unsigned __int64 __cdecl round_jiffies(unsigned __int64 j);
FFFFFFFF 00000000          unsigned __int64 __cdecl round_jiffies_relative(unsigned __int64 j);
FFFFFFFF 00000000          unsigned __int64 __cdecl round_jiffies_up(unsigned __int64 j);
FFFFFFFF 00000000          unsigned __int64 __cdecl round_jiffies_up_relative(unsigned __int64 j);
FFFFFFFF 00000000          void __cdecl rt_mutex_adjust_pi(task_struct *p);
FFFFFFFF 00000000          void __cdecl rt_mutex_setprio(task_struct *p, task_struct *pi_task);
FFFFFFFF 00000000          int __cdecl rtc_add_group(rtc_device *rtc, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl rtc_add_groups(rtc_device *rtc, const attribute_group **grps);
FFFFFFFF 00000000          void __cdecl rtc_aie_update_irq(rtc_device *rtc);
FFFFFFFF 00000000          int __cdecl rtc_alarm_irq_enable(rtc_device *rtc, unsigned int enabled);
00000008 0000000000000000          class *rtc_class;
FFFFFFFF 00000000          void __cdecl rtc_class_close(rtc_device *rtc);
FFFFFFFF 00000000          rtc_device *__cdecl rtc_class_open(const char *name);
FFFFFFFF 00000000          int __cdecl rtc_dev_update_irq_enable_emul(rtc_device *rtc, unsigned int enabled);
FFFFFFFF 00000000          void __cdecl rtc_handle_legacy_irq(rtc_device *rtc, int num, int mode);
00000004 00000000          int rtc_hctosys_ret;
FFFFFFFF 00000000          int __cdecl rtc_initialize_alarm(rtc_device *rtc, rtc_wkalrm *alrm);
FFFFFFFF 00000000          int __cdecl rtc_irq_set_freq(rtc_device *rtc, int freq);
FFFFFFFF 00000000          int __cdecl rtc_irq_set_state(rtc_device *rtc, int enabled);
FFFFFFFF 00000000          rtc_time __cdecl rtc_ktime_to_tm(ktime_t kt);
FFFFFFFF 00000000          int __cdecl rtc_month_days(unsigned int month, unsigned int year);
FFFFFFFF 00000000          int __cdecl rtc_nvmem_register(rtc_device *rtc, nvmem_config *nvmem_config);
FFFFFFFF 00000000          void __cdecl rtc_nvmem_unregister(rtc_device *rtc);
FFFFFFFF 00000000          hrtimer_restart __cdecl rtc_pie_update_irq(hrtimer *timer);
FFFFFFFF 00000000          int __cdecl rtc_read_alarm(rtc_device *rtc, rtc_wkalrm *alrm);
FFFFFFFF 00000000          int __cdecl rtc_read_offset(rtc_device *rtc, __int64 *offset);
FFFFFFFF 00000000          int __cdecl rtc_read_time(rtc_device *rtc, rtc_time *tm);
FFFFFFFF 00000000          int __cdecl rtc_set_alarm(rtc_device *rtc, rtc_wkalrm *alrm);
FFFFFFFF 00000000          int __cdecl rtc_set_ntp_time(timespec64 now, unsigned __int64 *target_nsec);
FFFFFFFF 00000000          int __cdecl rtc_set_offset(rtc_device *rtc, __int64 offset);
FFFFFFFF 00000000          int __cdecl rtc_set_time(rtc_device *rtc, rtc_time *tm);
FFFFFFFF 00000000          void __cdecl rtc_time64_to_tm(time64_t time, rtc_time *tm);
FFFFFFFF 00000000          void __cdecl rtc_timer_cancel(rtc_device *rtc, rtc_timer *timer);
FFFFFFFF 00000000          void __cdecl rtc_timer_do_work(work_struct *work);
FFFFFFFF 00000000          void __cdecl rtc_timer_init(rtc_timer *timer, void (__cdecl *f)(rtc_device *), rtc_device *rtc);
FFFFFFFF 00000000          int __cdecl rtc_timer_start(rtc_device *rtc, rtc_timer *timer, ktime_t expires, ktime_t period);
FFFFFFFF 00000000          ktime_t __cdecl rtc_tm_to_ktime(rtc_time tm);
FFFFFFFF 00000000          time64_t __cdecl rtc_tm_to_time64(rtc_time *tm);
FFFFFFFF 00000000          void __cdecl rtc_uie_update_irq(rtc_device *rtc);
FFFFFFFF 00000000          void __cdecl rtc_update_irq(rtc_device *rtc, unsigned __int64 num, unsigned __int64 events);
FFFFFFFF 00000000          int __cdecl rtc_update_irq_enable(rtc_device *rtc, unsigned int enabled);
FFFFFFFF 00000000          int __cdecl rtc_valid_tm(rtc_time *tm);
FFFFFFFF 00000000          int __cdecl rtc_year_days(unsigned int day, unsigned int month, unsigned int year);
FFFFFFFF 00000000          void run_local_timers(void);
FFFFFFFF 00000000          void run_posix_cpu_timers(void);
FFFFFFFF 00000000          u64 running_clock(void);
FFFFFFFF 00000000          ssize_t __cdecl rw_copy_check_uvector(int type, const iovec *uvector, unsigned __int64 nr_segs, unsigned __int64 fast_segs, iovec *fast_pointer, iovec **ret_pointer);
FFFFFFFF 00000000          void save_fsgs_for_kvm(void);
FFFFFFFF 00000000          int save_ioapic_entries(void);
00000008 0000000000000000          char *saved_command_line;
FFFFFFFF 00000000          int __cdecl sb_min_blocksize(super_block *, int);
FFFFFFFF 00000000          int __cdecl sb_set_blocksize(super_block *, int);
00000004 00000000          int sbf_port;
FFFFFFFF 00000000          void sched_clear_itmt_support(void);
FFFFFFFF 00000000          unsigned __int64 sched_clock(void);
FFFFFFFF 00000000          u64 __cdecl sched_clock_cpu(int cpu);
FFFFFFFF 00000000          void sched_clock_idle_sleep_event(void);
FFFFFFFF 00000000          void sched_clock_idle_wakeup_event(void);
FFFFFFFF 00000000          void sched_clock_init(void);
FFFFFFFF 00000000          int sched_clock_stable(void);
FFFFFFFF 00000000          void sched_clock_tick(void);
FFFFFFFF 00000000          void sched_clock_tick_stable(void);
00000004 00000000          int sched_core_priority;
00000020 00000000          mutex sched_domains_mutex;
FFFFFFFF 00000000          __int64 __cdecl sched_getaffinity(pid_t pid, cpumask *mask);
FFFFFFFF 00000000          void __cdecl sched_set_itmt_core_prio(int prio, int core_cpu);
FFFFFFFF 00000000          int sched_set_itmt_support(void);
FFFFFFFF 00000000          __int64 __cdecl sched_setaffinity(pid_t pid, const cpumask *new_mask);
FFFFFFFF 00000000          int __cdecl sched_setattr(task_struct *, const sched_attr *);
FFFFFFFF 00000000          int __cdecl sched_setattr_nocheck(task_struct *, const sched_attr *);
FFFFFFFF 00000000          int __cdecl sched_setscheduler(task_struct *, int, const sched_param *);
FFFFFFFF 00000000          int __cdecl sched_setscheduler_nocheck(task_struct *, int, const sched_param *);
FFFFFFFF 00000000          const sched_avg *__cdecl sched_trace_cfs_rq_avg(cfs_rq *cfs_rq);
FFFFFFFF 00000000          int __cdecl sched_trace_cfs_rq_cpu(cfs_rq *cfs_rq);
FFFFFFFF 00000000          char *__cdecl sched_trace_cfs_rq_path(cfs_rq *cfs_rq, char *str, int len);
FFFFFFFF 00000000          const cpumask *__cdecl sched_trace_rd_span(root_domain *rd);
FFFFFFFF 00000000          const sched_avg *__cdecl sched_trace_rq_avg_dl(rq *rq);
FFFFFFFF 00000000          const sched_avg *__cdecl sched_trace_rq_avg_irq(rq *rq);
FFFFFFFF 00000000          const sched_avg *__cdecl sched_trace_rq_avg_rt(rq *rq);
FFFFFFFF 00000000          int __cdecl sched_trace_rq_cpu(rq *rq);
FFFFFFFF 00000000          void schedule(void);
FFFFFFFF 00000000          int __cdecl schedule_hrtimeout(ktime_t *expires, const hrtimer_mode mode);
FFFFFFFF 00000000          int __cdecl schedule_hrtimeout_range(ktime_t *expires, u64 delta, const hrtimer_mode mode);
FFFFFFFF 00000000          int __cdecl schedule_hrtimeout_range_clock(ktime_t *expires, u64 delta, const hrtimer_mode mode, clockid_t clock_id);
FFFFFFFF 00000000          int __cdecl schedule_on_each_cpu(work_func_t func);
FFFFFFFF 00000000          void schedule_preempt_disabled(void);
FFFFFFFF 00000000          __int64 __cdecl schedule_timeout(__int64 timeout);
FFFFFFFF 00000000          __int64 __cdecl schedule_timeout_idle(__int64 timeout);
FFFFFFFF 00000000          __int64 __cdecl schedule_timeout_interruptible(__int64 timeout);
FFFFFFFF 00000000          __int64 __cdecl schedule_timeout_killable(__int64 timeout);
FFFFFFFF 00000000          __int64 __cdecl schedule_timeout_uninterruptible(__int64 timeout);
FFFFFFFF 00000000          void scheduler_ipi(void);
FFFFFFFF 00000000          void scheduler_tick(void);
FFFFFFFF 00000000          int scnprintf(char *buf, size_t size, const char *fmt, ...);
00000040 00000000          screen_info screen_info;
FFFFFFFF 00000000          int __cdecl scsi_cmd_blk_ioctl(block_device *, fmode_t, unsigned int, void *);
FFFFFFFF 00000000          int __cdecl scsi_cmd_ioctl(request_queue *, gendisk *, fmode_t, unsigned int, void *);
FFFFFFFF 00000000          int __cdecl scsi_verify_blk_ioctl(block_device *, unsigned int);
FFFFFFFF 00000000          __int64 __cdecl seccomp_get_filter(task_struct *task, unsigned __int64 filter_off, void *data);
FFFFFFFF 00000000          __int64 __cdecl seccomp_get_metadata(task_struct *task, unsigned __int64 filter_off, void *data);
00000000 00000000          unsigned __int8 secondary_startup_64[];
FFFFFFFF 00000000          u64 __cdecl select_estimate_accuracy(timespec64 *tv);
FFFFFFFF 00000000          void __cdecl select_idle_routine(const cpuinfo_x86 *c);
FFFFFFFF 00000000          void __cdecl send_sigio(fown_struct *fown, int fd, int band);
FFFFFFFF 00000000          void __cdecl send_sigtrap(pt_regs *regs, int error_code, int si_code);
FFFFFFFF 00000000          int __cdecl send_sigurg(fown_struct *fown);
FFFFFFFF 00000000          int __cdecl seq_dentry(seq_file *, dentry *, const char *);
FFFFFFFF 00000000          void __cdecl seq_escape(seq_file *m, const char *s, const char *esc);
FFFFFFFF 00000000          void __cdecl seq_escape_mem_ascii(seq_file *m, const char *src, size_t isz);
FFFFFFFF 00000000          void seq_file_init(void);
FFFFFFFF 00000000          int __cdecl seq_file_path(seq_file *, file *, const char *);
FFFFFFFF 00000000          void __cdecl seq_hex_dump(seq_file *m, const char *prefix_str, int prefix_type, int rowsize, int groupsize, const void *buf, size_t len, bool ascii);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_next(void *v, hlist_head *head, loff_t *ppos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_next_percpu(void *v, hlist_head *head, int *cpu, loff_t *pos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_next_rcu(void *v, hlist_head *head, loff_t *ppos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_start(hlist_head *head, loff_t pos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_start_head(hlist_head *head, loff_t pos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_start_head_rcu(hlist_head *head, loff_t pos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_start_percpu(hlist_head *head, int *cpu, loff_t pos);
FFFFFFFF 00000000          hlist_node *__cdecl seq_hlist_start_rcu(hlist_head *head, loff_t pos);
FFFFFFFF 00000000          list_head *__cdecl seq_list_next(void *v, list_head *head, loff_t *ppos);
FFFFFFFF 00000000          list_head *__cdecl seq_list_start(list_head *head, loff_t pos);
FFFFFFFF 00000000          list_head *__cdecl seq_list_start_head(list_head *head, loff_t pos);
FFFFFFFF 00000000          loff_t __cdecl seq_lseek(file *, loff_t, int);
FFFFFFFF 00000000          int __cdecl seq_open(file *, const seq_operations *);
FFFFFFFF 00000000          int __cdecl seq_open_private(file *, const seq_operations *, int);
FFFFFFFF 00000000          void __cdecl seq_pad(seq_file *m, char c);
FFFFFFFF 00000000          int __cdecl seq_path(seq_file *, const path *, const char *);
FFFFFFFF 00000000          int __cdecl seq_path_root(seq_file *m, const path *path, const path *root, const char *esc);
FFFFFFFF 00000000          void seq_printf(seq_file *m, const char *fmt, ...);
FFFFFFFF 00000000          void __cdecl seq_put_decimal_ll(seq_file *m, const char *delimiter, __int64 num);
FFFFFFFF 00000000          void __cdecl seq_put_decimal_ull(seq_file *m, const char *delimiter, unsigned __int64 num);
FFFFFFFF 00000000          void __cdecl seq_put_decimal_ull_width(seq_file *m, const char *delimiter, unsigned __int64 num, unsigned int width);
FFFFFFFF 00000000          void __cdecl seq_put_hex_ll(seq_file *m, const char *delimiter, unsigned __int64 v, unsigned int width);
FFFFFFFF 00000000          void __cdecl seq_putc(seq_file *m, char c);
FFFFFFFF 00000000          void __cdecl seq_puts(seq_file *m, const char *s);
FFFFFFFF 00000000          ssize_t __cdecl seq_read(file *, char *, size_t, loff_t *);
FFFFFFFF 00000000          int __cdecl seq_release(inode *, file *);
FFFFFFFF 00000000          int __cdecl seq_release_private(inode *, file *);
FFFFFFFF 00000000          void __cdecl seq_vprintf(seq_file *m, const char *fmt, va_list args);
FFFFFFFF 00000000          int __cdecl seq_write(seq_file *seq, const void *data, size_t len);
FFFFFFFF 00000000          void set_all_modules_text_ro(void);
FFFFFFFF 00000000          void set_all_modules_text_rw(void);
FFFFFFFF 00000000          int __cdecl set_anon_super(super_block *s, void *data);
FFFFFFFF 00000000          int __cdecl set_anon_super_fc(super_block *s, fs_context *fc);
FFFFFFFF 00000000          int __cdecl set_blocksize(block_device *, int);
FFFFFFFF 00000000          void __cdecl set_close_on_exec(unsigned int fd, int flag);
FFFFFFFF 00000000          void __cdecl set_cpu_online(unsigned int cpu, bool online);
FFFFFFFF 00000000          void __cdecl set_cpu_sibling_map(int cpu);
FFFFFFFF 00000000          int __cdecl set_cpus_allowed_ptr(task_struct *p, const cpumask *new_mask);
FFFFFFFF 00000000          int __cdecl set_create_files_as(cred *, inode *);
FFFFFFFF 00000000          int __cdecl set_current_groups(group_info *);
FFFFFFFF 00000000          void __cdecl set_default_mem_hotplug_zone(zone_type zone);
FFFFFFFF 00000000          void __cdecl set_device_ro(block_device *bdev, int flag);
FFFFFFFF 00000000          void __cdecl set_disk_ro(gendisk *disk, int flag);
FFFFFFFF 00000000          void __cdecl set_dma_reserve(unsigned __int64 new_dma_reserve);
FFFFFFFF 00000000          void __cdecl set_dumpable(mm_struct *mm, int value);
FFFFFFFF 00000000          void __cdecl set_groups(cred *, group_info *);
FFFFFFFF 00000000          bool __cdecl set_hwpoison_free_buddy_page(page *page);
FFFFFFFF 00000000          void set_iounmap_nonlazy(void);
FFFFFFFF 00000000          void __cdecl set_mm_exe_file(mm_struct *mm, file *new_exe_file);
FFFFFFFF 00000000          void set_module_sig_enforced(void);
FFFFFFFF 00000000          void __cdecl set_nlink(inode *inode, unsigned int nlink);
FFFFFFFF 00000000          void __cdecl set_normalized_timespec64(timespec64 *ts, time64_t sec, s64 nsec);
FFFFFFFF 00000000          void set_nx(void);
FFFFFFFF 00000000          int __cdecl set_online_page_callback(online_page_callback_t callback);
FFFFFFFF 00000000          int __cdecl set_orig_insn(arch_uprobe *aup, mm_struct *mm, unsigned __int64 vaddr);
FFFFFFFF 00000000          int __cdecl set_page_dirty(page *page);
FFFFFFFF 00000000          int __cdecl set_page_dirty_lock(page *page);
FFFFFFFF 00000000          void set_personality_64bit(void);
FFFFFFFF 00000000          void __cdecl set_personality_ia32(bool);
FFFFFFFF 00000000          void __cdecl set_pfnblock_flags_mask(page *page, unsigned __int64 flags, unsigned __int64 pfn, unsigned __int64 end_bitidx, unsigned __int64 mask);
FFFFFFFF 00000000          void __cdecl set_pgdat_percpu_threshold(pg_data_t *pgdat, int (__cdecl *calculate_pressure)(zone *));
FFFFFFFF 00000000          void __cdecl set_primary_fwnode(device *dev, fwnode_handle *fwnode);
FFFFFFFF 00000000          void __cdecl set_process_cpu_timer(task_struct *task, unsigned int clock_idx, u64 *newval, u64 *oldval);
FFFFFFFF 00000000          void __cdecl set_pte_vaddr(unsigned __int64 vaddr, pte_t pte);
FFFFFFFF 00000000          void __cdecl set_pte_vaddr_p4d(p4d_t *p4d_page, unsigned __int64 vaddr, pte_t new_pte);
FFFFFFFF 00000000          void __cdecl set_pte_vaddr_pud(pud_t *pud_page, unsigned __int64 vaddr, pte_t new_pte);
FFFFFFFF 00000000          void __cdecl set_secondary_fwnode(device *dev, fwnode_handle *fwnode);
FFFFFFFF 00000000          int __cdecl set_security_override(cred *, u32);
FFFFFFFF 00000000          int __cdecl set_security_override_from_ctx(cred *, const char *);
FFFFFFFF 00000000          int __cdecl set_swbp(arch_uprobe *aup, mm_struct *mm, unsigned __int64 vaddr);
FFFFFFFF 00000000          void __cdecl set_task_blockstep(task_struct *task, bool on);
FFFFFFFF 00000000          void __cdecl set_task_cpu(task_struct *p, unsigned int cpu);
FFFFFFFF 00000000          int __cdecl set_task_ioprio(task_struct *task, int ioprio);
FFFFFFFF 00000000          int __cdecl set_tsc_mode(unsigned int val);
FFFFFFFF 00000000          void __cdecl set_user_nice(task_struct *p, __int64 nice);
FFFFFFFF 00000000          void __cdecl set_wb_congested(bdi_writeback_congested *congested, int sync);
FFFFFFFF 00000000          void set_worker_desc(const char *fmt, ...);
FFFFFFFF 00000000          void __cdecl set_zone_contiguous(zone *zone);
FFFFFFFF 00000000          void __cdecl setattr_copy(inode *inode, const iattr *attr);
FFFFFFFF 00000000          int __cdecl setattr_prepare(dentry *, iattr *);
FFFFFFFF 00000000          int __cdecl setfl(int fd, file *filp, unsigned __int64 arg);
FFFFFFFF 00000000          int __cdecl setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
FFFFFFFF 00000000          void setup_IO_APIC(void);
FFFFFFFF 00000000          void __cdecl setup_arch(char **);
FFFFFFFF 00000000          void setup_boot_APIC_clock(void);
FFFFFFFF 00000000          void __cdecl setup_clear_cpu_cap(unsigned int bit);
FFFFFFFF 00000000          void setup_cpu_local_masks(void);
FFFFFFFF 00000000          void setup_ioapic_ids_from_mpc(void);
FFFFFFFF 00000000          void setup_ioapic_ids_from_mpc_nocheck(void);
FFFFFFFF 00000000          void __cdecl setup_log_buf(int early);
00000004 00000000          unsigned int setup_max_cpus;
FFFFFFFF 00000000          void setup_node_to_cpumask_map(void);
FFFFFFFF 00000000          void setup_nr_cpu_ids(void);
FFFFFFFF 00000000          void setup_nr_node_ids(void);
FFFFFFFF 00000000          void setup_per_cpu_areas(void);
FFFFFFFF 00000000          void setup_per_cpu_pageset(void);
FFFFFFFF 00000000          void setup_per_zone_wmarks(void);
FFFFFFFF 00000000          int __cdecl setup_profiling_timer(unsigned int);
FFFFFFFF 00000000          void setup_secondary_APIC_clock(void);
FFFFFFFF 00000000          void __cdecl setup_sysctl_set(ctl_table_set *p, ctl_table_root *root, int (__cdecl *is_seen)(ctl_table_set *));
FFFFFFFF 00000000          bool sev_active(void);
00000010 00000000          static_key_false sev_enable_key;
00000001 00000000          bool sev_enabled;
FFFFFFFF 00000000          int __cdecl sg_alloc_table(sg_table *, unsigned int, gfp_t);
FFFFFFFF 00000000          int __cdecl sg_alloc_table_chained(sg_table *table, int nents, scatterlist *first_chunk, unsigned int nents_first_chunk);
FFFFFFFF 00000000          int __cdecl sg_alloc_table_from_pages(sg_table *sgt, page **pages, unsigned int n_pages, unsigned int offset, unsigned __int64 size, gfp_t gfp_mask);
FFFFFFFF 00000000          size_t __cdecl sg_copy_buffer(scatterlist *sgl, unsigned int nents, void *buf, size_t buflen, off_t skip, bool to_buffer);
FFFFFFFF 00000000          size_t __cdecl sg_copy_from_buffer(scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen);
FFFFFFFF 00000000          size_t __cdecl sg_copy_to_buffer(scatterlist *sgl, unsigned int nents, void *buf, size_t buflen);
FFFFFFFF 00000000          void __cdecl sg_free_table(sg_table *);
FFFFFFFF 00000000          void __cdecl sg_free_table_chained(sg_table *table, unsigned int nents_first_chunk);
FFFFFFFF 00000000          void __cdecl sg_init_one(scatterlist *, const void *, unsigned int);
FFFFFFFF 00000000          void __cdecl sg_init_table(scatterlist *, unsigned int);
FFFFFFFF 00000000          scatterlist *__cdecl sg_last(scatterlist *s, unsigned int);
FFFFFFFF 00000000          bool __cdecl sg_miter_next(sg_mapping_iter *miter);
FFFFFFFF 00000000          bool __cdecl sg_miter_skip(sg_mapping_iter *miter, off_t offset);
FFFFFFFF 00000000          void __cdecl sg_miter_start(sg_mapping_iter *miter, scatterlist *sgl, unsigned int nents, unsigned int flags);
FFFFFFFF 00000000          void __cdecl sg_miter_stop(sg_mapping_iter *miter);
FFFFFFFF 00000000          int __cdecl sg_nents(scatterlist *sg);
FFFFFFFF 00000000          int __cdecl sg_nents_for_len(scatterlist *sg, u64 len);
FFFFFFFF 00000000          scatterlist *__cdecl sg_next(scatterlist *);
FFFFFFFF 00000000          size_t __cdecl sg_pcopy_from_buffer(scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen, off_t skip);
FFFFFFFF 00000000          size_t __cdecl sg_pcopy_to_buffer(scatterlist *sgl, unsigned int nents, void *buf, size_t buflen, off_t skip);
FFFFFFFF 00000000          int __cdecl sg_scsi_ioctl(request_queue *, gendisk *, fmode_t, scsi_ioctl_command *);
FFFFFFFF 00000000          int __cdecl sg_split(scatterlist *in, const int in_mapped_nents, const off_t skip, const int nb_splits, const size_t *split_sizes, scatterlist **out, int *out_mapped_nents, gfp_t gfp_mask);
FFFFFFFF 00000000          size_t __cdecl sg_zero_buffer(scatterlist *sgl, unsigned int nents, size_t buflen, off_t skip);
FFFFFFFF 00000000          super_block *__cdecl sget(file_system_type *type, int (__cdecl *test)(super_block *, void *), int (__cdecl *set)(super_block *, void *), int flags, void *data);
FFFFFFFF 00000000          super_block *__cdecl sget_fc(fs_context *fc, int (__cdecl *test)(super_block *, fs_context *), int (__cdecl *set)(super_block *, fs_context *));
FFFFFFFF 00000000          scatterlist *__cdecl sgl_alloc(unsigned __int64 length, gfp_t gfp, unsigned int *nent_p);
FFFFFFFF 00000000          scatterlist *__cdecl sgl_alloc_order(unsigned __int64 length, unsigned int order, bool chainable, gfp_t gfp, unsigned int *nent_p);
FFFFFFFF 00000000          void __cdecl sgl_free(scatterlist *sgl);
FFFFFFFF 00000000          void __cdecl sgl_free_n_order(scatterlist *sgl, int nents, int order);
FFFFFFFF 00000000          void __cdecl sgl_free_order(scatterlist *sgl, int order);
FFFFFFFF 00000000          void __cdecl shake_page(page *p, int access);
00000020 00000000          kobj_attribute shmem_enabled_attr;
FFFFFFFF 00000000          int __cdecl should_remove_suid(dentry *);
FFFFFFFF 00000000          ssize_t __cdecl show_class_attr_string(class *class, class_attribute *attr, char *buf);
FFFFFFFF 00000000          void __cdecl show_fd_locks(seq_file *f, file *filp, files_struct *files);
FFFFFFFF 00000000          void __cdecl show_free_areas(unsigned int flags, nodemask_t *nodemask);
FFFFFFFF 00000000          int __cdecl show_interrupts(seq_file *p, void *v);
FFFFFFFF 00000000          void __cdecl show_mem(unsigned int flags, nodemask_t *nodemask);
FFFFFFFF 00000000          void __cdecl show_regs_print_info(const char *log_lvl);
FFFFFFFF 00000000          void show_workqueue_state(void);
FFFFFFFF 00000000          void __cdecl shrink_dcache_for_umount(super_block *);
FFFFFFFF 00000000          void __cdecl shrink_dcache_parent(dentry *);
FFFFFFFF 00000000          void __cdecl shrink_dcache_sb(super_block *);
FFFFFFFF 00000000          __int64 si_mem_available(void);
FFFFFFFF 00000000          void __cdecl si_meminfo(sysinfo *val);
FFFFFFFF 00000000          void __cdecl si_meminfo_node(sysinfo *val, int nid);
FFFFFFFF 00000000          int __cdecl simple_attr_open(inode *inode, file *file, int (__cdecl *get)(void *, u64 *), int (__cdecl *set)(void *, u64), const char *fmt);
FFFFFFFF 00000000          ssize_t __cdecl simple_attr_read(file *file, char *buf, size_t len, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl simple_attr_release(inode *inode, file *file);
FFFFFFFF 00000000          ssize_t __cdecl simple_attr_write(file *file, const char *buf, size_t len, loff_t *ppos);
FFFFFFFF 00000000          ssize_t __cdecl simple_attr_write_signed(file *file, const char *buf, size_t len, loff_t *ppos);
00000080 00000000          const dentry_operations simple_dentry_operations;
000000C0 00000000          const inode_operations simple_dir_inode_operations;
00000110 00000000          const file_operations simple_dir_operations;
FFFFFFFF 00000000          int __cdecl simple_empty(dentry *);
FFFFFFFF 00000000          int __cdecl simple_fill_super(super_block *, unsigned __int64, const tree_descr *);
FFFFFFFF 00000000          const char *__cdecl simple_get_link(dentry *, inode *, delayed_call *);
FFFFFFFF 00000000          int __cdecl simple_getattr(const path *, kstat *, u32, unsigned int);
FFFFFFFF 00000000          int __cdecl simple_link(dentry *, inode *, dentry *);
FFFFFFFF 00000000          dentry *__cdecl simple_lookup(inode *, dentry *, unsigned int flags);
FFFFFFFF 00000000          int __cdecl simple_nosetlease(file *, __int64, file_lock **, void **);
FFFFFFFF 00000000          int __cdecl simple_open(inode *inode, file *file);
FFFFFFFF 00000000          int __cdecl simple_pin_fs(file_system_type *, vfsmount **mount, int *count);
FFFFFFFF 00000000          ssize_t __cdecl simple_read_from_buffer(void *to, size_t count, loff_t *ppos, const void *from, size_t available);
FFFFFFFF 00000000          int __cdecl simple_readpage(file *file, page *page);
FFFFFFFF 00000000          void __cdecl simple_release_fs(vfsmount **mount, int *count);
FFFFFFFF 00000000          int __cdecl simple_rename(inode *, dentry *, inode *, dentry *, unsigned int);
FFFFFFFF 00000000          int __cdecl simple_rmdir(inode *, dentry *);
FFFFFFFF 00000000          int __cdecl simple_setattr(dentry *, iattr *);
FFFFFFFF 00000000          int __cdecl simple_statfs(dentry *, kstatfs *);
FFFFFFFF 00000000          __int64 __cdecl simple_strtol(const char *, char **, unsigned int);
FFFFFFFF 00000000          __int64 __cdecl simple_strtoll(const char *, char **, unsigned int);
FFFFFFFF 00000000          unsigned __int64 __cdecl simple_strtoul(const char *, char **, unsigned int);
FFFFFFFF 00000000          unsigned __int64 __cdecl simple_strtoull(const char *, char **, unsigned int);
000000C0 00000000          const inode_operations simple_symlink_inode_operations;
FFFFFFFF 00000000          char *__cdecl simple_transaction_get(file *file, const char *buf, size_t size);
FFFFFFFF 00000000          ssize_t __cdecl simple_transaction_read(file *file, char *buf, size_t size, loff_t *pos);
FFFFFFFF 00000000          int __cdecl simple_transaction_release(inode *inode, file *file);
FFFFFFFF 00000000          void __cdecl simple_transaction_set(file *file, size_t n);
FFFFFFFF 00000000          int __cdecl simple_unlink(inode *, dentry *);
FFFFFFFF 00000000          int __cdecl simple_write_begin(file *file, address_space *mapping, loff_t pos, unsigned int len, unsigned int flags, page **pagep, void **fsdata);
FFFFFFFF 00000000          int __cdecl simple_write_end(file *file, address_space *mapping, loff_t pos, unsigned int len, unsigned int copied, page *page, void *fsdata);
FFFFFFFF 00000000          ssize_t __cdecl simple_write_to_buffer(void *to, size_t available, loff_t *ppos, const void *from, size_t count);
FFFFFFFF 00000000          ssize_t __cdecl single_hugepage_flag_show(kobject *kobj, kobj_attribute *attr, char *buf, transparent_hugepage_flag flag);
FFFFFFFF 00000000          ssize_t __cdecl single_hugepage_flag_store(kobject *kobj, kobj_attribute *attr, const char *buf, size_t count, transparent_hugepage_flag flag);
FFFFFFFF 00000000          int __cdecl single_open(file *, int (__cdecl *)(seq_file *, void *), void *);
FFFFFFFF 00000000          int __cdecl single_open_size(file *, int (__cdecl *)(seq_file *, void *), void *, size_t);
FFFFFFFF 00000000          int __cdecl single_release(inode *, file *);
00000008 0000000000000000          const bpf_prog_ops sk_filter_prog_ops;
00000028 00000000          const bpf_verifier_ops sk_filter_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops sk_msg_prog_ops;
00000028 00000000          const bpf_verifier_ops sk_msg_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops sk_reuseport_prog_ops;
00000028 00000000          const bpf_verifier_ops sk_reuseport_verifier_ops;
00000008 0000000000000000          const bpf_prog_ops sk_skb_prog_ops;
00000028 00000000          const bpf_verifier_ops sk_skb_verifier_ops;
000000A8 00000000          const bpf_map_ops sk_storage_map_ops;
00000004 00000000          int skip_ioapic_setup;
00000001 00000000          bool skip_smp_alternatives;
FFFFFFFF 00000000          char *__cdecl skip_spaces(const char *);
FFFFFFFF 00000000          bool slab_is_available(void);
00000010 00000000          const qstr slash_name;
FFFFFFFF 00000000          phys_addr_t __cdecl slow_virt_to_phys(void *__address);
FFFFFFFF 00000000          bool sme_active(void);
FFFFFFFF 00000000          void __cdecl sme_early_decrypt(resource_size_t paddr, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl sme_early_encrypt(resource_size_t paddr, unsigned __int64 size);
FFFFFFFF 00000000          void sme_early_init(void);
FFFFFFFF 00000000          void __cdecl sme_enable(boot_params *bp);
FFFFFFFF 00000000          void __cdecl sme_encrypt_execute(unsigned __int64 encrypted_kernel_vaddr, unsigned __int64 decrypted_kernel_vaddr, unsigned __int64 kernel_len, unsigned __int64 encryption_wa, unsigned __int64 encryption_pgd);
FFFFFFFF 00000000          void __cdecl sme_encrypt_kernel(boot_params *bp);
FFFFFFFF 00000000          void __cdecl sme_map_bootdata(char *real_mode_data);
00000008 0000000000000000          u64 sme_me_mask;
FFFFFFFF 00000000          void __cdecl sme_unmap_bootdata(char *real_mode_data);
FFFFFFFF 00000000          void __cdecl smp_call_function(smp_call_func_t func, void *info, int wait);
FFFFFFFF 00000000          int __cdecl smp_call_function_any(const cpumask *mask, smp_call_func_t func, void *info, int wait);
FFFFFFFF 00000000          void __cdecl smp_call_function_interrupt(pt_regs *regs);
FFFFFFFF 00000000          void __cdecl smp_call_function_many(const cpumask *mask, smp_call_func_t func, void *info, bool wait);
FFFFFFFF 00000000          int __cdecl smp_call_function_single(int cpuid, smp_call_func_t func, void *info, int wait);
FFFFFFFF 00000000          int __cdecl smp_call_function_single_async(int cpu, __call_single_data *csd);
FFFFFFFF 00000000          void __cdecl smp_call_function_single_interrupt(pt_regs *r);
FFFFFFFF 00000000          int __cdecl smp_call_on_cpu(unsigned int cpu, int (__cdecl *func)(void *), void *par, bool phys);
00000004 00000000          int smp_found_config;
FFFFFFFF 00000000          void smp_init(void);
FFFFFFFF 00000000          void __cdecl smp_kvm_posted_intr_ipi(pt_regs *regs);
FFFFFFFF 00000000          void __cdecl smp_kvm_posted_intr_nested_ipi(pt_regs *regs);
FFFFFFFF 00000000          void __cdecl smp_kvm_posted_intr_wakeup_ipi(pt_regs *regs);
00000004 00000000          int smp_num_siblings;
00000060 00000000          smp_ops smp_ops;
FFFFFFFF 00000000          void smp_reboot_interrupt(void);
FFFFFFFF 00000000          void __cdecl smp_reschedule_interrupt(pt_regs *regs);
FFFFFFFF 00000000          void smp_setup_processor_id(void);
FFFFFFFF 00000000          void smp_store_boot_cpu_info(void);
FFFFFFFF 00000000          void __cdecl smp_store_cpu_info(int id);
FFFFFFFF 00000000          void __cdecl smp_x86_platform_ipi(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl smpcfd_dead_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl smpcfd_dying_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl smpcfd_prepare_cpu(unsigned int cpu);
FFFFFFFF 00000000          int snprintf(char *buf, size_t size, const char *fmt, ...);
000000A8 00000000          const bpf_map_ops sock_hash_ops;
FFFFFFFF 00000000          int __cdecl sock_map_get_from_fd(const bpf_attr *attr, bpf_prog *prog);
000000A8 00000000          const bpf_map_ops sock_map_ops;
FFFFFFFF 00000000          int __cdecl sock_map_prog_detach(const bpf_attr *attr, bpf_prog_type ptype);
FFFFFFFF 00000000          int __cdecl sock_map_prog_update(bpf_map *map, bpf_prog *prog, bpf_prog *old, u32 which);
00000008 0000000000000000          const bpf_prog_ops sock_ops_prog_ops;
00000028 00000000          const bpf_verifier_ops sock_ops_verifier_ops;
FFFFFFFF 00000000          int __cdecl soft_offline_page(page *page, int flags);
FFFFFFFF 00000000          void softirq_init(void);
00000050 00000000          const char *const softirq_to_name[10];
FFFFFFFF 00000000          const software_node *__cdecl software_node_find_by_name(const software_node *parent, const char *name);
FFFFFFFF 00000000          fwnode_handle *__cdecl software_node_fwnode(const software_node *node);
FFFFFFFF 00000000          int __cdecl software_node_notify(device *dev, unsigned __int64 action);
FFFFFFFF 00000000          int __cdecl software_node_register(const software_node *node);
FFFFFFFF 00000000          int __cdecl software_node_register_nodes(const software_node *nodes);
FFFFFFFF 00000000          void __cdecl software_node_unregister_nodes(const software_node *nodes);
FFFFFFFF 00000000          void __cdecl sort_range(range *range, int nr_range);
FFFFFFFF 00000000          int __cdecl sparse_add_section(int nid, unsigned __int64 pfn, unsigned __int64 nr_pages, vmem_altmap *altmap);
FFFFFFFF 00000000          void *__cdecl sparse_buffer_alloc(unsigned __int64 size);
FFFFFFFF 00000000          page *__cdecl sparse_decode_mem_map(unsigned __int64 coded_mem_map, unsigned __int64 pnum);
FFFFFFFF 00000000          void sparse_init(void);
FFFFFFFF 00000000          void __cdecl sparse_memory_present_with_active_regions(int nid);
FFFFFFFF 00000000          void __cdecl sparse_remove_section(mem_section *ms, unsigned __int64 pfn, unsigned __int64 nr_pages, unsigned __int64 map_offset, vmem_altmap *altmap);
FFFFFFFF 00000000          u64 spec_ctrl_current(void);
FFFFFFFF 00000000          int __cdecl split_huge_page_to_list(page *page, list_head *list);
FFFFFFFF 00000000          void __cdecl split_huge_pmd_address(vm_area_struct *vma, unsigned __int64 address, bool freeze, page *page);
FFFFFFFF 00000000          void __cdecl split_page(page *page, unsigned int order);
FFFFFFFF 00000000          int __cdecl split_vma(mm_struct *, vm_area_struct *, unsigned __int64 addr, int new_below);
FFFFFFFF 00000000          int sprintf(char *buf, const char *fmt, ...);
FFFFFFFF 00000000          int srat_disabled(void);
FFFFFFFF 00000000          void __cdecl srcu_barrier(srcu_struct *ssp);
FFFFFFFF 00000000          void __cdecl srcu_init_notifier_head(srcu_notifier_head *nh);
FFFFFFFF 00000000          int __cdecl srcu_notifier_call_chain(srcu_notifier_head *nh, unsigned __int64 val, void *v);
FFFFFFFF 00000000          int __cdecl srcu_notifier_chain_register(srcu_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          int __cdecl srcu_notifier_chain_unregister(srcu_notifier_head *nh, notifier_block *nb);
FFFFFFFF 00000000          void __cdecl srcu_torture_stats_print(srcu_struct *ssp, char *tt, char *tf);
FFFFFFFF 00000000          int sscanf(const char *, const char *, ...);
FFFFFFFF 00000000          u64 __cdecl stable_page_flags(page *page);
FFFFFFFF 00000000          unsigned int __cdecl stack_depot_fetch(depot_stack_handle_t handle, unsigned __int64 **entries);
FFFFFFFF 00000000          depot_stack_handle_t __cdecl stack_depot_save(unsigned __int64 *entries, unsigned int nr_entries, gfp_t gfp_flags);
00000008 0000000000000000          unsigned __int64 stack_guard_gap;
000000A8 00000000          const bpf_map_ops stack_map_ops;
000000A8 00000000          const bpf_map_ops stack_trace_map_ops;
FFFFFFFF 00000000          void __cdecl stack_trace_print(const unsigned __int64 *trace, unsigned int nr_entries, int spaces);
FFFFFFFF 00000000          unsigned int __cdecl stack_trace_save(unsigned __int64 *store, unsigned int size, unsigned int skipnr);
FFFFFFFF 00000000          unsigned int __cdecl stack_trace_save_regs(pt_regs *regs, unsigned __int64 *store, unsigned int size, unsigned int skipnr);
FFFFFFFF 00000000          unsigned int __cdecl stack_trace_save_tsk(task_struct *task, unsigned __int64 *store, unsigned int size, unsigned int skipnr);
FFFFFFFF 00000000          int __cdecl stack_trace_save_tsk_reliable(task_struct *tsk, unsigned __int64 *store, unsigned int size);
FFFFFFFF 00000000          unsigned int __cdecl stack_trace_save_user(unsigned __int64 *store, unsigned int size);
FFFFFFFF 00000000          int __cdecl stack_trace_snprint(char *buf, size_t size, const unsigned __int64 *entries, unsigned int nr_entries, int spaces);
FFFFFFFF 00000000          void __cdecl start_thread(pt_regs *regs, unsigned __int64 new_ip, unsigned __int64 new_sp);
FFFFFFFF 00000000          int __cdecl static_key_count(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_disable(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_disable_cpuslocked(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_enable(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_enable_cpuslocked(static_key *key);
00000001 00000000          bool static_key_initialized;
FFFFFFFF 00000000          void __cdecl static_key_slow_dec(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_slow_dec_cpuslocked(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_slow_inc(static_key *key);
FFFFFFFF 00000000          void __cdecl static_key_slow_inc_cpuslocked(static_key *key);
FFFFFFFF 00000000          void __cdecl stop_this_cpu(void *dummy);
FFFFFFFF 00000000          int __cdecl strcasecmp(const char *s1, const char *s2);
FFFFFFFF 00000000          char *__cdecl strcat(char *p, const char *q);
FFFFFFFF 00000000          char *__cdecl strchr(const char *, int);
FFFFFFFF 00000000          char *__cdecl strchrnul(const char *, int);
FFFFFFFF 00000000          int __cdecl strcmp(const char *, const char *);
FFFFFFFF 00000000          char *__cdecl strcpy(char *p, const char *q);
FFFFFFFF 00000000          unsigned __int64 __cdecl strcspn(const char *, const char *);
FFFFFFFF 00000000          int __cdecl stream_open(inode *inode, file *filp);
FFFFFFFF 00000000          char *__cdecl strim(char *);
FFFFFFFF 00000000          unsigned __int64 __cdecl strlcat(char *, const char *, __kernel_size_t);
FFFFFFFF 00000000          unsigned __int64 __cdecl strlcpy(char *p, const char *q, size_t size);
FFFFFFFF 00000000          unsigned __int64 __cdecl strlen(const char *p);
FFFFFFFF 00000000          int __cdecl strncasecmp(const char *s1, const char *s2, size_t n);
FFFFFFFF 00000000          char *__cdecl strncat(char *p, const char *q, __kernel_size_t count);
FFFFFFFF 00000000          char *__cdecl strnchr(const char *, size_t, int);
FFFFFFFF 00000000          int __cdecl strncmp(const char *, const char *, __kernel_size_t);
FFFFFFFF 00000000          char *__cdecl strncpy(char *p, const char *q, __kernel_size_t size);
FFFFFFFF 00000000          __int64 __cdecl strncpy_from_unsafe(char *dst, const void *unsafe_addr, __int64 count);
FFFFFFFF 00000000          __int64 __cdecl strncpy_from_unsafe_user(char *dst, const void *unsafe_addr, __int64 count);
FFFFFFFF 00000000          __int64 __cdecl strncpy_from_user(char *dst, const char *src, __int64 count);
FFFFFFFF 00000000          char *__cdecl strndup_user(const char *, __int64);
FFFFFFFF 00000000          __kernel_size_t __cdecl strnlen(const char *p, __kernel_size_t maxlen);
FFFFFFFF 00000000          __int64 __cdecl strnlen_unsafe_user(const void *unsafe_addr, __int64 count);
FFFFFFFF 00000000          __int64 __cdecl strnlen_user(const char *str, __int64 n);
FFFFFFFF 00000000          char *__cdecl strnstr(const char *, const char *, size_t);
FFFFFFFF 00000000          char *__cdecl strpbrk(const char *, const char *);
FFFFFFFF 00000000          char *__cdecl strrchr(const char *, int);
FFFFFFFF 00000000          char *__cdecl strreplace(char *s, char old, char new);
FFFFFFFF 00000000          ssize_t __cdecl strscpy(char *, const char *, size_t);
FFFFFFFF 00000000          ssize_t __cdecl strscpy_pad(char *dest, const char *src, size_t count);
FFFFFFFF 00000000          char *__cdecl strsep(char **, const char *);
FFFFFFFF 00000000          unsigned __int64 __cdecl strspn(const char *, const char *);
FFFFFFFF 00000000          char *__cdecl strstr(const char *, const char *);
FFFFFFFF 00000000          blk_qc_t __cdecl submit_bio(bio *);
FFFFFFFF 00000000          int __cdecl submit_bio_wait(bio *bio);
FFFFFFFF 00000000          void __cdecl subsection_map_init(unsigned __int64 pfn, unsigned __int64 nr_pages);
FFFFFFFF 00000000          void __cdecl subsys_dev_iter_exit(subsys_dev_iter *iter);
FFFFFFFF 00000000          void __cdecl subsys_dev_iter_init(subsys_dev_iter *iter, bus_type *subsys, device *start, const device_type *type);
FFFFFFFF 00000000          device *__cdecl subsys_dev_iter_next(subsys_dev_iter *iter);
FFFFFFFF 00000000          device *__cdecl subsys_find_device_by_id(bus_type *bus, unsigned int id, device *hint);
FFFFFFFF 00000000          int __cdecl subsys_interface_register(subsys_interface *sif);
FFFFFFFF 00000000          void __cdecl subsys_interface_unregister(subsys_interface *sif);
FFFFFFFF 00000000          int __cdecl subsys_system_register(bus_type *subsys, const attribute_group **groups);
FFFFFFFF 00000000          int __cdecl subsys_virtual_register(bus_type *subsys, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl subtract_range(range *range, int az, u64 start, u64 end);
FFFFFFFF 00000000          unsigned __int64 __cdecl sum_zone_node_page_state(int node, zone_stat_item item);
FFFFFFFF 00000000          unsigned __int64 __cdecl sum_zone_numa_state(int node, numa_stat_item item);
FFFFFFFF 00000000          int __cdecl super_setup_bdi(super_block *sb);
FFFFFFFF 00000000          int super_setup_bdi_name(super_block *sb, char *fmt, ...);
00000004 00000000          int suppress_printk;
FFFFFFFF 00000000          void suspend_device_irqs(void);
FFFFFFFF 00000000          void switch_fpu_return(void);
00000010 00000000          static_key_false switch_mm_always_ibpb;
00000010 00000000          static_key_false switch_mm_cond_ibpb;
00000010 00000000          static_key_false switch_to_cond_stibp;
FFFFFFFF 00000000          void __cdecl switch_to_new_gdt(int);
FFFFFFFF 00000000          void __cdecl symbol_put_addr(void *addr);
FFFFFFFF 00000000          void sync_Arb_IDs(void);
FFFFFFFF 00000000          int __cdecl sync_blockdev(block_device *bdev);
FFFFFFFF 00000000          int __cdecl sync_file_range(file *file, loff_t offset, loff_t nbytes, unsigned int flags);
FFFFFFFF 00000000          int __cdecl sync_filesystem(super_block *);
FFFFFFFF 00000000          void __cdecl sync_global_pgds(unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          int __cdecl sync_inode(inode *inode, writeback_control *wbc);
FFFFFFFF 00000000          int __cdecl sync_inode_metadata(inode *inode, int wait);
FFFFFFFF 00000000          void __cdecl sync_mm_rss(mm_struct *mm);
FFFFFFFF 00000000          bool __cdecl synchronize_hardirq(unsigned int irq);
FFFFFFFF 00000000          void __cdecl synchronize_irq(unsigned int irq);
FFFFFFFF 00000000          void synchronize_rcu(void);
FFFFFFFF 00000000          void synchronize_rcu_expedited(void);
FFFFFFFF 00000000          void synchronize_rcu_tasks(void);
FFFFFFFF 00000000          void __cdecl synchronize_srcu(srcu_struct *ssp);
FFFFFFFF 00000000          void __cdecl synchronize_srcu_expedited(srcu_struct *ssp);
00000008 0000000000000000          timezone sys_tz;
00000008 0000000000000000          unsigned __int64 sysctl_admin_reserve_kbytes;
00000004 00000000          int sysctl_drop_caches;
FFFFFFFF 00000000          int sysctl_init(void);
00000004 00000000          int sysctl_legacy_va_layout;
00000014 00000000          int sysctl_lowmem_reserve_ratio[5];
00000004 00000000          int sysctl_max_map_count;
FFFFFFFF 00000000          int __cdecl sysctl_max_threads(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
00000004 00000000          int sysctl_memory_failure_early_kill;
00000004 00000000          int sysctl_memory_failure_recovery;
FFFFFFFF 00000000          int __cdecl sysctl_min_slab_ratio_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int __cdecl sysctl_min_unmapped_ratio_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
00000000 00000000          ctl_table sysctl_mount_point[];
00000004 00000000          unsigned int sysctl_nr_open;
00000008 0000000000000000          unsigned __int64 sysctl_overcommit_kbytes;
00000004 00000000          int sysctl_overcommit_memory;
00000004 00000000          int sysctl_overcommit_ratio;
00000004 00000000          int sysctl_panic_on_rcu_stall;
00000004 00000000          int sysctl_panic_on_stackoverflow;
00000004 00000000          int sysctl_protected_fifos;
00000004 00000000          int sysctl_protected_hardlinks;
00000004 00000000          int sysctl_protected_regular;
00000004 00000000          int sysctl_protected_symlinks;
00000004 00000000          unsigned int sysctl_sched_itmt_enabled;
00000004 00000000          int sysctl_stat_interval;
00000004 00000000          unsigned int sysctl_timer_migration;
00000004 00000000          int sysctl_unprivileged_bpf_disabled;
00000008 0000000000000000          unsigned __int64 sysctl_user_reserve_kbytes;
00000000 00000000          const int sysctl_vals[];
00000004 00000000          int sysctl_vfs_cache_pressure;
00000004 00000000          int sysctl_vm_numa_stat;
FFFFFFFF 00000000          int __cdecl sysctl_vm_numa_stat_handler(ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos);
00000004 00000000          unsigned int sysctl_vsyscall32;
FFFFFFFF 00000000          int sysenter_setup(void);
FFFFFFFF 00000000          int __cdecl sysfs_add_file_to_group(kobject *kobj, const attribute *attr, const char *group);
FFFFFFFF 00000000          int __cdecl sysfs_add_link_to_group(kobject *kobj, const char *group_name, kobject *target, const char *link_name);
FFFFFFFF 00000000          kernfs_node *__cdecl sysfs_break_active_protection(kobject *kobj, const attribute *attr);
FFFFFFFF 00000000          int __cdecl sysfs_change_owner(kobject *kobj, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          int __cdecl sysfs_chmod_file(kobject *kobj, const attribute *attr, umode_t mode);
FFFFFFFF 00000000          int __cdecl sysfs_create_bin_file(kobject *kobj, const bin_attribute *attr);
FFFFFFFF 00000000          int __cdecl sysfs_create_dir_ns(kobject *kobj, const void *ns);
FFFFFFFF 00000000          int __cdecl sysfs_create_file_ns(kobject *kobj, const attribute *attr, const void *ns);
FFFFFFFF 00000000          int __cdecl sysfs_create_files(kobject *kobj, const attribute *const *attr);
FFFFFFFF 00000000          int __cdecl sysfs_create_group(kobject *kobj, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl sysfs_create_groups(kobject *kobj, const attribute_group **groups);
FFFFFFFF 00000000          int __cdecl sysfs_create_link(kobject *kobj, kobject *target, const char *name);
FFFFFFFF 00000000          int __cdecl sysfs_create_link_nowarn(kobject *kobj, kobject *target, const char *name);
FFFFFFFF 00000000          int __cdecl sysfs_create_mount_point(kobject *parent_kobj, const char *name);
FFFFFFFF 00000000          void __cdecl sysfs_delete_link(kobject *dir, kobject *targ, const char *name);
00000008 0000000000000000          kobject *sysfs_dev_block_kobj;
00000008 0000000000000000          kobject *sysfs_dev_char_kobj;
FFFFFFFF 00000000          int sysfs_emit(char *buf, const char *fmt, ...);
FFFFFFFF 00000000          int sysfs_emit_at(char *buf, int at, const char *fmt, ...);
FFFFFFFF 00000000          int __cdecl sysfs_file_change_owner(kobject *kobj, const char *name, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          int __cdecl sysfs_group_change_owner(kobject *kobj, const attribute_group *groups, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          int __cdecl sysfs_groups_change_owner(kobject *kobj, const attribute_group **groups, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          int sysfs_init(void);
FFFFFFFF 00000000          int __cdecl sysfs_link_change_owner(kobject *kobj, kobject *targ, const char *name, kuid_t kuid, kgid_t kgid);
FFFFFFFF 00000000          int __cdecl sysfs_merge_group(kobject *kobj, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl sysfs_move_dir_ns(kobject *kobj, kobject *new_parent_kobj, const void *new_ns);
FFFFFFFF 00000000          void __cdecl sysfs_notify(kobject *kobj, const char *dir, const char *attr);
FFFFFFFF 00000000          void __cdecl sysfs_remove_bin_file(kobject *kobj, const bin_attribute *attr);
FFFFFFFF 00000000          void __cdecl sysfs_remove_dir(kobject *kobj);
FFFFFFFF 00000000          void __cdecl sysfs_remove_file_from_group(kobject *kobj, const attribute *attr, const char *group);
FFFFFFFF 00000000          void __cdecl sysfs_remove_file_ns(kobject *kobj, const attribute *attr, const void *ns);
FFFFFFFF 00000000          bool __cdecl sysfs_remove_file_self(kobject *kobj, const attribute *attr);
FFFFFFFF 00000000          void __cdecl sysfs_remove_files(kobject *kobj, const attribute *const *attr);
FFFFFFFF 00000000          void __cdecl sysfs_remove_group(kobject *kobj, const attribute_group *grp);
FFFFFFFF 00000000          void __cdecl sysfs_remove_groups(kobject *kobj, const attribute_group **groups);
FFFFFFFF 00000000          void __cdecl sysfs_remove_link(kobject *kobj, const char *name);
FFFFFFFF 00000000          void __cdecl sysfs_remove_link_from_group(kobject *kobj, const char *group_name, const char *link_name);
FFFFFFFF 00000000          void __cdecl sysfs_remove_mount_point(kobject *parent_kobj, const char *name);
FFFFFFFF 00000000          int __cdecl sysfs_rename_dir_ns(kobject *kobj, const char *new_name, const void *new_ns);
FFFFFFFF 00000000          int __cdecl sysfs_rename_link_ns(kobject *kobj, kobject *target, const char *old_name, const char *new_name, const void *new_ns);
FFFFFFFF 00000000          bool __cdecl sysfs_streq(const char *s1, const char *s2);
FFFFFFFF 00000000          void __cdecl sysfs_unbreak_active_protection(kernfs_node *kn);
FFFFFFFF 00000000          void __cdecl sysfs_unmerge_group(kobject *kobj, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl sysfs_update_group(kobject *kobj, const attribute_group *grp);
FFFFFFFF 00000000          int __cdecl sysfs_update_groups(kobject *kobj, const attribute_group **groups);
FFFFFFFF 00000000          void sysrq_timer_list_show(void);
00000008 0000000000000000          workqueue_struct *system_freezable_power_efficient_wq;
00000008 0000000000000000          workqueue_struct *system_freezable_wq;
00000008 0000000000000000          workqueue_struct *system_highpri_wq;
00000008 0000000000000000          workqueue_struct *system_long_wq;
00000008 0000000000000000          workqueue_struct *system_power_efficient_wq;
00000004 00000000          system_states system_state;
00000008 0000000000000000          workqueue_struct *system_unbound_wq;
00000008 0000000000000000          workqueue_struct *system_wq;
00000036 00000000          const taint_flag taint_flags[18];
FFFFFFFF 00000000          void __cdecl take_dentry_name_snapshot(name_snapshot *, dentry *);
FFFFFFFF 00000000          int __cdecl task_can_attach(task_struct *p, const cpumask *cs_cpus_allowed);
FFFFFFFF 00000000          int __cdecl task_curr(const task_struct *p);
FFFFFFFF 00000000          void __cdecl task_dirty_inc(task_struct *tsk);
FFFFFFFF 00000000          int __cdecl task_prio(const task_struct *p);
FFFFFFFF 00000000          unsigned __int64 task_size_32bit(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl task_size_64bit(int full_addr_space);
FFFFFFFF 00000000          void __cdecl tasklet_init(tasklet_struct *t, void (__cdecl *func)(unsigned __int64), unsigned __int64 data);
FFFFFFFF 00000000          void __cdecl tasklet_kill(tasklet_struct *t);
FFFFFFFF 00000000          void __cdecl tasklet_kill_immediate(tasklet_struct *t, unsigned int cpu);
00000028 00000000          const bpf_verifier_ops tc_cls_act_analyzer_ops;
00000008 0000000000000000          const bpf_prog_ops tc_cls_act_prog_ops;
00000028 00000000          const bpf_verifier_ops tc_cls_act_verifier_ops;
FFFFFFFF 00000000          void __cdecl teardown_percpu_nmi(unsigned int irq);
FFFFFFFF 00000000          int __cdecl test_clear_page_writeback(page *page);
FFFFFFFF 00000000          int __cdecl test_pages_in_a_zone(unsigned __int64 start_pfn, unsigned __int64 end_pfn, unsigned __int64 *valid_start, unsigned __int64 *valid_end);
FFFFFFFF 00000000          int __cdecl test_taint(unsigned int flag);
FFFFFFFF 00000000          pid *__cdecl tgid_pidfd_to_pid(const file *file);
FFFFFFFF 00000000          int __cdecl thaw_bdev(block_device *bdev, super_block *sb);
FFFFFFFF 00000000          int __cdecl thaw_super(super_block *super);
FFFFFFFF 00000000          void thaw_workqueues(void);
00000008 0000000000000000          unsigned __int64 this_cpu_off;
FFFFFFFF 00000000          unsigned __int64 __cdecl thp_get_unmapped_area(file *filp, unsigned __int64 addr, unsigned __int64 len, unsigned __int64 pgoff, unsigned __int64 flags);
FFFFFFFF 00000000          tick_device tick_cpu_device;
00000008 0000000000000000          unsigned __int64 tick_nsec;
00000008 0000000000000000          unsigned __int64 tick_usec;
FFFFFFFF 00000000          void __cdecl time64_to_tm(time64_t totalsecs, int offset, tm *result);
FFFFFFFF 00000000          void timekeeping_init(void);
FFFFFFFF 00000000          void __cdecl timekeeping_inject_sleeptime64(const timespec64 *delta);
FFFFFFFF 00000000          bool timekeeping_rtc_skipresume(void);
FFFFFFFF 00000000          bool timekeeping_rtc_skipsuspend(void);
00000004 00000000          int timekeeping_suspended;
FFFFFFFF 00000000          int __cdecl timer_migration_handler(ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos);
FFFFFFFF 00000000          int __cdecl timer_reduce(timer_list *timer, unsigned __int64 expires);
FFFFFFFF 00000000          void timerfd_clock_was_set(void);
FFFFFFFF 00000000          bool __cdecl timerqueue_add(timerqueue_head *head, timerqueue_node *node);
FFFFFFFF 00000000          bool __cdecl timerqueue_del(timerqueue_head *head, timerqueue_node *node);
FFFFFFFF 00000000          timerqueue_node *__cdecl timerqueue_iterate_next(timerqueue_node *node);
FFFFFFFF 00000000          int __cdecl timers_dead_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl timers_prepare_cpu(unsigned int cpu);
FFFFFFFF 00000000          timespec64 __cdecl timespec64_add_safe(const timespec64 lhs, const timespec64 rhs);
FFFFFFFF 00000000          unsigned __int64 __cdecl timespec64_to_jiffies(const timespec64 *value);
FFFFFFFF 00000000          timespec64 __cdecl timespec64_trunc(timespec64 t, unsigned int gran);
FFFFFFFF 00000000          timespec64 __cdecl timestamp_truncate(timespec64 t, inode *inode);
FFFFFFFF 00000000          unsigned __int64 __cdecl timeval_to_jiffies(const timeval *value);
FFFFFFFF 00000000          void __cdecl tlb_finish_mmu(mmu_gather *tlb, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          void __cdecl tlb_gather_mmu(mmu_gather *tlb, mm_struct *mm, unsigned __int64 start, unsigned __int64 end);
00000002 00000000          u16 tlb_lld_1g[1];
00000002 00000000          u16 tlb_lld_2m[1];
00000002 00000000          u16 tlb_lld_4k[1];
00000002 00000000          u16 tlb_lld_4m[1];
00000002 00000000          u16 tlb_lli_2m[1];
00000002 00000000          u16 tlb_lli_4k[1];
00000002 00000000          u16 tlb_lli_4m[1];
FFFFFFFF 00000000          const software_node *__cdecl to_software_node(fwnode_handle *fwnode);
FFFFFFFF 00000000          bool __cdecl topology_is_primary_thread(unsigned int cpu);
FFFFFFFF 00000000          void topology_normalize_cpu_scale(void);
FFFFFFFF 00000000          bool __cdecl topology_parse_cpu_capacity(device_node *cpu_node, int cpu);
FFFFFFFF 00000000          int __cdecl topology_phys_to_logical_die(unsigned int die, unsigned int cpu);
FFFFFFFF 00000000          int __cdecl topology_phys_to_logical_pkg(unsigned int pkg);
FFFFFFFF 00000000          void __cdecl topology_set_cpu_scale(unsigned int cpu, unsigned __int64 capacity);
FFFFFFFF 00000000          bool topology_smt_supported(void);
FFFFFFFF 00000000          int topology_update_cpu_topology(void);
FFFFFFFF 00000000          int __cdecl topology_update_die_map(unsigned int dieid, unsigned int cpu);
FFFFFFFF 00000000          int __cdecl topology_update_package_map(unsigned int apicid, unsigned int cpu);
00000004 00000000          unsigned int total_cpus;
FFFFFFFF 00000000          int __cdecl total_mapcount(page *page);
FFFFFFFF 00000000          void __cdecl touch_atime(const path *);
FFFFFFFF 00000000          void __cdecl trace_dump_stack(int skip);
FFFFFFFF 00000000          void __cdecl trace_hwlat_callback(bool enter);
00000001 00000000          bool trace_hwlat_callback_enabled;
00000008 0000000000000000          const bpf_prog_ops tracepoint_prog_ops;
00000028 00000000          const bpf_verifier_ops tracepoint_verifier_ops;
FFFFFFFF 00000000          int tracing_is_on(void);
FFFFFFFF 00000000          void tracing_off(void);
FFFFFFFF 00000000          void tracing_on(void);
FFFFFFFF 00000000          void tracing_snapshot(void);
FFFFFFFF 00000000          void tracing_snapshot_alloc(void);
FFFFFFFF 00000000          void tracing_start(void);
FFFFFFFF 00000000          void tracing_stop(void);
FFFFFFFF 00000000          int __cdecl track_pfn_copy(vm_area_struct *vma);
FFFFFFFF 00000000          void __cdecl track_pfn_insert(vm_area_struct *vma, pgprot_t *prot, pfn_t pfn);
FFFFFFFF 00000000          int __cdecl track_pfn_remap(vm_area_struct *vma, pgprot_t *prot, unsigned __int64 pfn, unsigned __int64 addr, unsigned __int64 size);
00000008 0000000000000000          pgd_t trampoline_pgd_entry;
FFFFFFFF 00000000          void __cdecl transfer_pid(task_struct *old, task_struct *new, pid_type);
FFFFFFFF 00000000          bool __cdecl transparent_hugepage_enabled(vm_area_struct *vma);
00000008 0000000000000000          unsigned __int64 transparent_hugepage_flags;
000000A8 00000000          const bpf_map_ops trie_map_ops;
FFFFFFFF 00000000          int __cdecl truncate_inode_page(address_space *mapping, page *page);
FFFFFFFF 00000000          void __cdecl truncate_inode_pages(address_space *, loff_t);
FFFFFFFF 00000000          void __cdecl truncate_inode_pages_final(address_space *);
FFFFFFFF 00000000          void __cdecl truncate_inode_pages_range(address_space *, loff_t lstart, loff_t lend);
FFFFFFFF 00000000          void __cdecl truncate_pagecache(inode *inode, loff_t new);
FFFFFFFF 00000000          void __cdecl truncate_pagecache_range(inode *inode, loff_t offset, loff_t end);
FFFFFFFF 00000000          void __cdecl truncate_setsize(inode *inode, loff_t newsize);
FFFFFFFF 00000000          bool __cdecl try_module_get(module *module);
FFFFFFFF 00000000          void __cdecl try_offline_node(int nid);
FFFFFFFF 00000000          int __cdecl try_online_node(int nid);
FFFFFFFF 00000000          int __cdecl try_to_del_timer_sync(timer_list *timer);
FFFFFFFF 00000000          int __cdecl try_to_release_page(page *page, gfp_t gfp_mask);
FFFFFFFF 00000000          bool __cdecl try_wait_for_completion(completion *x);
00000001 00000000          bool tsc_async_resets;
00000004 00000000          int tsc_clocksource_reliable;
FFFFFFFF 00000000          void tsc_early_init(void);
FFFFFFFF 00000000          void tsc_init(void);
00000004 00000000          unsigned int tsc_khz;
FFFFFFFF 00000000          void tsc_restore_sched_clock_state(void);
FFFFFFFF 00000000          void tsc_save_sched_clock_state(void);
FFFFFFFF 00000000          bool __cdecl tsc_store_and_check_tsc_adjust(bool bootcpu);
FFFFFFFF 00000000          void __cdecl tsc_verify_tsc_adjust(bool resume);
00000000 00000000          char uevent_helper[];
00000008 0000000000000000          u64 uevent_seqnum;
FFFFFFFF 00000000          int uids_sysfs_init(void);
FFFFFFFF 00000000          void __cdecl unlink_file_vma(vm_area_struct *);
FFFFFFFF 00000000          void unlock_device_hotplug(void);
FFFFFFFF 00000000          void __cdecl unlock_new_inode(inode *);
FFFFFFFF 00000000          void __cdecl unlock_page(page *page);
FFFFFFFF 00000000          void __cdecl unlock_two_nondirectories(inode *, inode *);
FFFFFFFF 00000000          void __cdecl unmap_kernel_range(unsigned __int64 addr, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl unmap_kernel_range_noflush(unsigned __int64 addr, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl unmap_mapping_page(page *page);
FFFFFFFF 00000000          void __cdecl unmap_mapping_pages(address_space *mapping, unsigned __int64 start, unsigned __int64 nr, bool even_cows);
FFFFFFFF 00000000          void __cdecl unmap_mapping_range(address_space *mapping, const loff_t holebegin, const loff_t holelen, int even_cows);
FFFFFFFF 00000000          void __cdecl unmap_vmas(mmu_gather *tlb, vm_area_struct *start_vma, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          unsigned __int64 __cdecl unmapped_area(vm_unmapped_area_info *info);
FFFFFFFF 00000000          unsigned __int64 __cdecl unmapped_area_topdown(vm_unmapped_area_info *info);
FFFFFFFF 00000000          int __cdecl unpoison_memory(unsigned __int64 pfn);
FFFFFFFF 00000000          void __cdecl unpriv_ebpf_notify(int new_state);
FFFFFFFF 00000000          int __cdecl unregister_acpi_bus_type(acpi_bus_type *);
FFFFFFFF 00000000          int __cdecl unregister_acpi_notifier(notifier_block *);
FFFFFFFF 00000000          void __cdecl unregister_blkdev(unsigned int, const char *);
FFFFFFFF 00000000          void __cdecl unregister_chrdev_region(dev_t, unsigned int);
FFFFFFFF 00000000          int __cdecl unregister_filesystem(file_system_type *);
FFFFFFFF 00000000          int __cdecl unregister_module_notifier(notifier_block *nb);
FFFFFFFF 00000000          void __cdecl unregister_quota_format(quota_format_type *fmt);
FFFFFFFF 00000000          int __cdecl unregister_reboot_notifier(notifier_block *);
FFFFFFFF 00000000          int __cdecl unregister_restart_handler(notifier_block *);
FFFFFFFF 00000000          void __cdecl unregister_shrinker(shrinker *shrinker);
FFFFFFFF 00000000          void __cdecl unregister_sysctl_table(ctl_table_header *table);
FFFFFFFF 00000000          int __cdecl unregister_vmap_purge_notifier(notifier_block *nb);
FFFFFFFF 00000000          int unsynchronized_tsc(void);
FFFFFFFF 00000000          void __cdecl untrack_pfn(vm_area_struct *vma, unsigned __int64 pfn, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl untrack_pfn_moved(vm_area_struct *vma);
FFFFFFFF 00000000          void __cdecl unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
FFFFFFFF 00000000          void __cdecl up(semaphore *sem);
FFFFFFFF 00000000          void __cdecl up_read(rw_semaphore *sem);
FFFFFFFF 00000000          void __cdecl up_write(rw_semaphore *sem);
FFFFFFFF 00000000          void __cdecl update_io_ticks(hd_struct *part, unsigned __int64 now, bool end);
FFFFFFFF 00000000          void __cdecl update_page_count(int level, unsigned __int64 pages);
FFFFFFFF 00000000          int __cdecl update_persistent_clock64(timespec64 now);
FFFFFFFF 00000000          void __cdecl update_process_times(int user);
FFFFFFFF 00000000          void __cdecl update_regset_xstate_info(unsigned int size, u64 xstate_mask);
FFFFFFFF 00000000          void __cdecl update_rlimit_cpu(task_struct *task, unsigned __int64 rlim_new);
FFFFFFFF 00000000          void __cdecl update_spec_ctrl_cond(u64 val);
FFFFFFFF 00000000          int __cdecl update_time(inode *, timespec64 *, int);
FFFFFFFF 00000000          int __cdecl uprobe_apply(inode *inode, loff_t offset, uprobe_consumer *uc, bool);
FFFFFFFF 00000000          void __cdecl uprobe_clear_state(mm_struct *mm);
FFFFFFFF 00000000          void __cdecl uprobe_copy_process(task_struct *t, unsigned __int64 flags);
FFFFFFFF 00000000          bool uprobe_deny_signal(void);
FFFFFFFF 00000000          void __cdecl uprobe_dup_mmap(mm_struct *oldmm, mm_struct *newmm);
FFFFFFFF 00000000          void uprobe_end_dup_mmap(void);
FFFFFFFF 00000000          void __cdecl uprobe_free_utask(task_struct *t);
FFFFFFFF 00000000          unsigned __int64 __cdecl uprobe_get_swbp_addr(pt_regs *regs);
FFFFFFFF 00000000          unsigned __int64 __cdecl uprobe_get_trap_addr(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl uprobe_mmap(vm_area_struct *vma);
FFFFFFFF 00000000          void __cdecl uprobe_munmap(vm_area_struct *vma, unsigned __int64 start, unsigned __int64 end);
FFFFFFFF 00000000          void __cdecl uprobe_notify_resume(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl uprobe_post_sstep_notifier(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl uprobe_pre_sstep_notifier(pt_regs *regs);
FFFFFFFF 00000000          int __cdecl uprobe_register(inode *inode, loff_t offset, uprobe_consumer *uc);
FFFFFFFF 00000000          int __cdecl uprobe_register_refctr(inode *inode, loff_t offset, loff_t ref_ctr_offset, uprobe_consumer *uc);
FFFFFFFF 00000000          void uprobe_start_dup_mmap(void);
FFFFFFFF 00000000          void __cdecl uprobe_unregister(inode *inode, loff_t offset, uprobe_consumer *uc);
FFFFFFFF 00000000          int __cdecl uprobe_write_opcode(arch_uprobe *auprobe, mm_struct *mm, unsigned __int64 vaddr, uprobe_opcode_t);
FFFFFFFF 00000000          void uprobes_init(void);
FFFFFFFF 00000000          int __cdecl usb_acpi_port_lpm_incapable(usb_device *hdev, int index);
FFFFFFFF 00000000          bool __cdecl usb_acpi_power_manageable(usb_device *hdev, int index);
FFFFFFFF 00000000          int __cdecl usb_acpi_set_power_state(usb_device *hdev, int index, bool enable);
FFFFFFFF 00000000          void *__cdecl usb_alloc_coherent(usb_device *dev, size_t size, gfp_t mem_flags, dma_addr_t *dma);
FFFFFFFF 00000000          int __cdecl usb_alloc_streams(usb_interface *interface, usb_host_endpoint **eps, unsigned int num_eps, unsigned int num_streams, gfp_t mem_flags);
FFFFFFFF 00000000          urb *__cdecl usb_alloc_urb(int iso_packets, gfp_t mem_flags);
FFFFFFFF 00000000          usb_host_interface *__cdecl usb_altnum_to_altsetting(const usb_interface *intf, unsigned int altnum);
FFFFFFFF 00000000          int __cdecl usb_anchor_empty(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_anchor_resume_wakeups(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_anchor_suspend_wakeups(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_anchor_urb(urb *urb, usb_anchor *anchor);
FFFFFFFF 00000000          int __cdecl usb_autopm_get_interface(usb_interface *intf);
FFFFFFFF 00000000          int __cdecl usb_autopm_get_interface_async(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_autopm_get_interface_no_resume(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_autopm_put_interface(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_autopm_put_interface_async(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_autopm_put_interface_no_suspend(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_block_urb(urb *urb);
FFFFFFFF 00000000          int __cdecl usb_buffer_map_sg(const usb_device *dev, int is_in, scatterlist *sg, int nents);
FFFFFFFF 00000000          void __cdecl usb_buffer_unmap_sg(const usb_device *dev, int is_in, scatterlist *sg, int n_hw_ents);
FFFFFFFF 00000000          int __cdecl usb_bulk_msg(usb_device *usb_dev, unsigned int pipe, void *data, int len, int *actual_length, int timeout);
000000A8 00000000          bus_type usb_bus_type;
FFFFFFFF 00000000          int __cdecl usb_choose_configuration(usb_device *udev);
FFFFFFFF 00000000          int __cdecl usb_clear_halt(usb_device *dev, int pipe);
FFFFFFFF 00000000          int __cdecl usb_control_msg(usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout);
FFFFFFFF 00000000          int __cdecl usb_control_msg_recv(usb_device *dev, __u8 endpoint, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout, gfp_t memflags);
FFFFFFFF 00000000          int __cdecl usb_control_msg_send(usb_device *dev, __u8 endpoint, __u8 request, __u8 requesttype, __u16 value, __u16 index, const void *data, __u16 size, int timeout, gfp_t memflags);
00000008 0000000000000000          dentry *usb_debug_root;
FFFFFFFF 00000000          const char *__cdecl usb_decode_ctrl(char *str, size_t size, __u8 bRequestType, __u8 bRequest, __u16 wValue, __u16 wIndex, __u16 wLength);
FFFFFFFF 00000000          void __cdecl usb_deregister(usb_driver *);
FFFFFFFF 00000000          void __cdecl usb_deregister_dev(usb_interface *intf, usb_class_driver *class_driver);
FFFFFFFF 00000000          void __cdecl usb_deregister_device_driver(usb_device_driver *);
FFFFFFFF 00000000          void __cdecl usb_disable_autosuspend(usb_device *udev);
FFFFFFFF 00000000          int __cdecl usb_disable_lpm(usb_device *udev);
FFFFFFFF 00000000          int __cdecl usb_disable_ltm(usb_device *udev);
FFFFFFFF 00000000          int usb_disabled(void);
FFFFFFFF 00000000          int __cdecl usb_driver_claim_interface(usb_driver *driver, usb_interface *iface, void *priv);
FFFFFFFF 00000000          void __cdecl usb_driver_release_interface(usb_driver *driver, usb_interface *iface);
FFFFFFFF 00000000          int __cdecl usb_driver_set_configuration(usb_device *udev, int config);
FFFFFFFF 00000000          void __cdecl usb_enable_autosuspend(usb_device *udev);
FFFFFFFF 00000000          void __cdecl usb_enable_lpm(usb_device *udev);
FFFFFFFF 00000000          void __cdecl usb_enable_ltm(usb_device *udev);
FFFFFFFF 00000000          const char *__cdecl usb_ep_type_string(int ep_type);
FFFFFFFF 00000000          usb_host_interface *__cdecl usb_find_alt_setting(usb_host_config *config, unsigned int iface_num, unsigned int alt_num);
FFFFFFFF 00000000          int __cdecl usb_find_common_endpoints(usb_host_interface *alt, usb_endpoint_descriptor **bulk_in, usb_endpoint_descriptor **bulk_out, usb_endpoint_descriptor **int_in, usb_endpoint_descriptor **int_out);
FFFFFFFF 00000000          int __cdecl usb_find_common_endpoints_reverse(usb_host_interface *alt, usb_endpoint_descriptor **bulk_in, usb_endpoint_descriptor **bulk_out, usb_endpoint_descriptor **int_in, usb_endpoint_descriptor **int_out);
FFFFFFFF 00000000          usb_interface *__cdecl usb_find_interface(usb_driver *drv, int minor);
FFFFFFFF 00000000          int __cdecl usb_for_each_dev(void *data, int (__cdecl *fn)(usb_device *, void *));
FFFFFFFF 00000000          void __cdecl usb_free_coherent(usb_device *dev, size_t size, void *addr, dma_addr_t dma);
FFFFFFFF 00000000          int __cdecl usb_free_streams(usb_interface *interface, usb_host_endpoint **eps, unsigned int num_eps, gfp_t mem_flags);
FFFFFFFF 00000000          void __cdecl usb_free_urb(urb *urb);
FFFFFFFF 00000000          int __cdecl usb_get_current_frame_number(usb_device *usb_dev);
FFFFFFFF 00000000          int __cdecl usb_get_descriptor(usb_device *dev, unsigned __int8 desctype, unsigned __int8 descindex, void *buf, int size);
FFFFFFFF 00000000          usb_device *__cdecl usb_get_dev(usb_device *dev);
FFFFFFFF 00000000          urb *__cdecl usb_get_from_anchor(usb_anchor *anchor);
FFFFFFFF 00000000          usb_interface *__cdecl usb_get_intf(usb_interface *intf);
FFFFFFFF 00000000          usb_device_speed __cdecl usb_get_maximum_speed(device *dev);
FFFFFFFF 00000000          int __cdecl usb_get_status(usb_device *dev, int recip, int type, int target, void *data);
FFFFFFFF 00000000          urb *__cdecl usb_get_urb(urb *urb);
FFFFFFFF 00000000          int __cdecl usb_hub_claim_port(usb_device *hdev, unsigned int port1, usb_dev_state *owner);
FFFFFFFF 00000000          usb_device *__cdecl usb_hub_find_child(usb_device *hdev, int port1);
FFFFFFFF 00000000          int __cdecl usb_hub_release_port(usb_device *hdev, unsigned int port1, usb_dev_state *owner);
FFFFFFFF 00000000          usb_interface *__cdecl usb_ifnum_to_if(const usb_device *dev, unsigned int ifnum);
FFFFFFFF 00000000          void __cdecl usb_init_urb(urb *urb);
FFFFFFFF 00000000          int __cdecl usb_interrupt_msg(usb_device *usb_dev, unsigned int pipe, void *data, int len, int *actual_length, int timeout);
FFFFFFFF 00000000          void __cdecl usb_kill_anchored_urbs(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_kill_urb(urb *urb);
FFFFFFFF 00000000          void __cdecl usb_led_activity(usb_led_event ev);
FFFFFFFF 00000000          int __cdecl usb_lock_device_for_reset(usb_device *udev, const usb_interface *iface);
FFFFFFFF 00000000          const usb_device_id *__cdecl usb_match_id(usb_interface *interface, const usb_device_id *id);
FFFFFFFF 00000000          int __cdecl usb_match_one_id(usb_interface *interface, const usb_device_id *id);
FFFFFFFF 00000000          int __cdecl usb_pipe_type_check(usb_device *dev, unsigned int pipe);
FFFFFFFF 00000000          void __cdecl usb_poison_anchored_urbs(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_poison_urb(urb *urb);
FFFFFFFF 00000000          void __cdecl usb_put_dev(usb_device *dev);
FFFFFFFF 00000000          void __cdecl usb_put_intf(usb_interface *intf);
FFFFFFFF 00000000          void __cdecl usb_queue_reset_device(usb_interface *dev);
FFFFFFFF 00000000          int __cdecl usb_register_dev(usb_interface *intf, usb_class_driver *class_driver);
FFFFFFFF 00000000          int __cdecl usb_register_device_driver(usb_device_driver *, module *);
FFFFFFFF 00000000          int __cdecl usb_register_driver(usb_driver *, module *, const char *);
FFFFFFFF 00000000          void __cdecl usb_register_notify(notifier_block *nb);
FFFFFFFF 00000000          int __cdecl usb_reset_configuration(usb_device *dev);
FFFFFFFF 00000000          int __cdecl usb_reset_device(usb_device *dev);
FFFFFFFF 00000000          void __cdecl usb_reset_endpoint(usb_device *dev, unsigned int epaddr);
FFFFFFFF 00000000          void __cdecl usb_scuttle_anchored_urbs(usb_anchor *anchor);
FFFFFFFF 00000000          int __cdecl usb_set_configuration(usb_device *dev, int configuration);
FFFFFFFF 00000000          int __cdecl usb_set_interface(usb_device *dev, int ifnum, int alternate);
FFFFFFFF 00000000          void __cdecl usb_sg_cancel(usb_sg_request *io);
FFFFFFFF 00000000          int __cdecl usb_sg_init(usb_sg_request *io, usb_device *dev, unsigned int pipe, unsigned int period, scatterlist *sg, int nents, size_t length, gfp_t mem_flags);
FFFFFFFF 00000000          void __cdecl usb_sg_wait(usb_sg_request *io);
FFFFFFFF 00000000          ssize_t __cdecl usb_show_dynids(usb_dynids *dynids, char *buf);
FFFFFFFF 00000000          const char *__cdecl usb_speed_string(usb_device_speed speed);
FFFFFFFF 00000000          const char *__cdecl usb_state_string(usb_device_state state);
FFFFFFFF 00000000          ssize_t __cdecl usb_store_new_id(usb_dynids *dynids, const usb_device_id *id_table, device_driver *driver, const char *buf, size_t count);
FFFFFFFF 00000000          int __cdecl usb_string(usb_device *dev, int index, char *buf, size_t size);
FFFFFFFF 00000000          int __cdecl usb_submit_urb(urb *urb, gfp_t mem_flags);
FFFFFFFF 00000000          void __cdecl usb_unanchor_urb(urb *urb);
FFFFFFFF 00000000          void __cdecl usb_unlink_anchored_urbs(usb_anchor *anchor);
FFFFFFFF 00000000          int __cdecl usb_unlink_urb(urb *urb);
FFFFFFFF 00000000          int __cdecl usb_unlocked_disable_lpm(usb_device *udev);
FFFFFFFF 00000000          void __cdecl usb_unlocked_enable_lpm(usb_device *udev);
FFFFFFFF 00000000          void __cdecl usb_unpoison_anchored_urbs(usb_anchor *anchor);
FFFFFFFF 00000000          void __cdecl usb_unpoison_urb(urb *urb);
FFFFFFFF 00000000          void __cdecl usb_unregister_notify(notifier_block *nb);
FFFFFFFF 00000000          int __cdecl usb_urb_ep_type_check(const urb *urb);
FFFFFFFF 00000000          int __cdecl usb_wait_anchor_empty_timeout(usb_anchor *anchor, unsigned int timeout);
FFFFFFFF 00000000          void use_mwaitx_delay(void);
FFFFFFFF 00000000          void use_tsc_delay(void);
FFFFFFFF 00000000          int __cdecl user_shm_lock(size_t, user_struct *);
FFFFFFFF 00000000          void __cdecl user_shm_unlock(size_t, user_struct *);
FFFFFFFF 00000000          int __cdecl user_statfs(const char *, kstatfs *);
FFFFFFFF 00000000          void __cdecl __noreturn usercopy_abort(const char *name, const char *detail, bool to_user, unsigned __int64 offset, unsigned __int64 len);
00000001 00000000          bool usercopy_fallback;
FFFFFFFF 00000000          void __cdecl usercopy_warn(const char *name, const char *detail, bool to_user, unsigned __int64 offset, unsigned __int64 len);
FFFFFFFF 00000000          __int64 __cdecl usermodehelper_read_lock_wait(__int64 timeout);
FFFFFFFF 00000000          int usermodehelper_read_trylock(void);
FFFFFFFF 00000000          void usermodehelper_read_unlock(void);
00000000 00000000          ctl_table usermodehelper_table[];
FFFFFFFF 00000000          int using_compacted_format(void);
FFFFFFFF 00000000          void __cdecl usleep_range(unsigned __int64 min, unsigned __int64 max);
FFFFFFFF 00000000          void __cdecl uuid_gen(uuid_t *u);
00000010 00000000          const u8 uuid_index[16];
FFFFFFFF 00000000          bool __cdecl uuid_is_valid(const char *uuid);
00000010 00000000          const uuid_t uuid_null;
FFFFFFFF 00000000          int __cdecl uuid_parse(const char *uuid, uuid_t *u);
00000040 00000000          va_alignment va_align;
FFFFFFFF 00000000          int __cdecl valid_mmap_phys_addr_range(unsigned __int64 pfn, size_t size);
FFFFFFFF 00000000          int __cdecl valid_phys_addr_range(phys_addr_t addr, size_t size);
FFFFFFFF 00000000          int __cdecl validate_xstate_header(const xstate_header *hdr);
FFFFFFFF 00000000          int __cdecl vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
00000004 00000000          unsigned int vdso32_enabled;
00000004 00000000          unsigned int vdso64_enabled;
00000068 00000000          const vdso_image vdso_image_32;
00000068 00000000          const vdso_image vdso_image_64;
00000068 00000000          const vdso_image vdso_image_x32;
FFFFFFFF 00000000          void __cdecl vfree(const void *addr);
FFFFFFFF 00000000          void __cdecl vfree_atomic(const void *addr);
FFFFFFFF 00000000          void vfs_caches_init(void);
FFFFFFFF 00000000          void vfs_caches_init_early(void);
FFFFFFFF 00000000          int __cdecl vfs_cancel_lock(file *filp, file_lock *fl);
FFFFFFFF 00000000          loff_t __cdecl vfs_clone_file_range(file *file_in, loff_t pos_in, file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags);
FFFFFFFF 00000000          ssize_t __cdecl vfs_copy_file_range(file *, loff_t, file *, loff_t, size_t, unsigned int);
FFFFFFFF 00000000          int __cdecl vfs_create(inode *, dentry *, umode_t, bool);
FFFFFFFF 00000000          int __cdecl vfs_dedupe_file_range(file *file, file_dedupe_range *same);
FFFFFFFF 00000000          loff_t __cdecl vfs_dedupe_file_range_one(file *src_file, loff_t src_pos, file *dst_file, loff_t dst_pos, loff_t len, unsigned int remap_flags);
FFFFFFFF 00000000          int __cdecl vfs_fadvise(file *file, loff_t offset, loff_t len, int advice);
FFFFFFFF 00000000          int __cdecl vfs_fallocate(file *file, int mode, loff_t offset, loff_t len);
FFFFFFFF 00000000          int __cdecl vfs_fsync(file *file, int datasync);
FFFFFFFF 00000000          int __cdecl vfs_fsync_range(file *file, loff_t start, loff_t end, int datasync);
FFFFFFFF 00000000          const char *__cdecl vfs_get_link(dentry *, delayed_call *);
FFFFFFFF 00000000          int __cdecl vfs_getattr(const path *, kstat *, u32, unsigned int);
FFFFFFFF 00000000          int __cdecl vfs_getattr_nosec(const path *, kstat *, u32, unsigned int);
FFFFFFFF 00000000          int __cdecl vfs_ioc_fssetxattr_check(inode *inode, const fsxattr *old_fa, fsxattr *fa);
FFFFFFFF 00000000          int __cdecl vfs_ioc_setflags_prepare(inode *inode, unsigned int oldflags, unsigned int flags);
FFFFFFFF 00000000          __int64 __cdecl vfs_ioctl(file *file, unsigned int cmd, unsigned __int64 arg);
FFFFFFFF 00000000          ssize_t __cdecl vfs_iter_read(file *file, iov_iter *iter, loff_t *ppos, rwf_t flags);
FFFFFFFF 00000000          ssize_t __cdecl vfs_iter_write(file *file, iov_iter *iter, loff_t *ppos, rwf_t flags);
FFFFFFFF 00000000          int __cdecl vfs_link(dentry *, inode *, dentry *, inode **);
FFFFFFFF 00000000          loff_t __cdecl vfs_llseek(file *file, loff_t offset, int whence);
FFFFFFFF 00000000          int __cdecl vfs_lock_file(file *, unsigned int, file_lock *, file_lock *);
FFFFFFFF 00000000          int __cdecl vfs_mkdir(inode *, dentry *, umode_t);
FFFFFFFF 00000000          int __cdecl vfs_mknod(inode *, dentry *, umode_t, dev_t);
FFFFFFFF 00000000          int __cdecl vfs_mkobj(dentry *, umode_t, int (__cdecl *f)(dentry *, umode_t, void *), void *);
FFFFFFFF 00000000          ssize_t __cdecl vfs_read(file *, char *, size_t, loff_t *);
FFFFFFFF 00000000          vfs_readf_t __cdecl vfs_readf(file *file);
FFFFFFFF 00000000          int __cdecl vfs_readlink(dentry *, char *, int);
FFFFFFFF 00000000          ssize_t __cdecl vfs_readv(file *, const iovec *, unsigned __int64, loff_t *, rwf_t);
FFFFFFFF 00000000          int __cdecl vfs_rename(inode *, dentry *, inode *, dentry *, inode **, unsigned int);
FFFFFFFF 00000000          int __cdecl vfs_rmdir(inode *, dentry *);
FFFFFFFF 00000000          int __cdecl vfs_setlease(file *, __int64, file_lock **, void **);
FFFFFFFF 00000000          loff_t __cdecl vfs_setpos(file *file, loff_t offset, loff_t maxsize);
FFFFFFFF 00000000          int __cdecl vfs_statfs(const path *, kstatfs *);
FFFFFFFF 00000000          int __cdecl vfs_statx(int, const char *, int, kstat *, u32);
FFFFFFFF 00000000          int __cdecl vfs_statx_fd(unsigned int, kstat *, u32, unsigned int);
FFFFFFFF 00000000          int __cdecl vfs_symlink(inode *, dentry *, const char *);
FFFFFFFF 00000000          int __cdecl vfs_test_lock(file *, file_lock *);
FFFFFFFF 00000000          dentry *__cdecl vfs_tmpfile(dentry *dentry, umode_t mode, int open_flag);
FFFFFFFF 00000000          __int64 __cdecl vfs_truncate(const path *, loff_t);
FFFFFFFF 00000000          int __cdecl vfs_unlink(inode *, dentry *, inode **);
FFFFFFFF 00000000          int __cdecl vfs_whiteout(inode *, dentry *);
FFFFFFFF 00000000          ssize_t __cdecl vfs_write(file *, const char *, size_t, loff_t *);
FFFFFFFF 00000000          vfs_writef_t __cdecl vfs_writef(file *file);
00000010 00000000          static_key_true virt_spin_lock_key;
FFFFFFFF 00000000          void __cdecl vm_area_add_early(vm_struct *vm);
FFFFFFFF 00000000          vm_area_struct *__cdecl vm_area_alloc(mm_struct *);
FFFFFFFF 00000000          vm_area_struct *__cdecl vm_area_dup(vm_area_struct *);
FFFFFFFF 00000000          void __cdecl vm_area_free(vm_area_struct *);
FFFFFFFF 00000000          void __cdecl vm_area_register_early(vm_struct *vm, size_t align);
FFFFFFFF 00000000          int __cdecl vm_brk(unsigned __int64, unsigned __int64);
FFFFFFFF 00000000          int __cdecl vm_brk_flags(unsigned __int64, unsigned __int64, unsigned __int64);
000002A8 00000000          vm_event_state vm_event_states;
FFFFFFFF 00000000          void __cdecl vm_events_fold_cpu(int cpu);
FFFFFFFF 00000000          pgprot_t __cdecl vm_get_page_prot(unsigned __int64 vm_flags);
FFFFFFFF 00000000          int __cdecl vm_insert_page(vm_area_struct *, unsigned __int64 addr, page *);
FFFFFFFF 00000000          int __cdecl vm_iomap_memory(vm_area_struct *vma, phys_addr_t start, unsigned __int64 len);
FFFFFFFF 00000000          int __cdecl vm_map_pages(vm_area_struct *vma, page **pages, unsigned __int64 num);
FFFFFFFF 00000000          int __cdecl vm_map_pages_zero(vm_area_struct *vma, page **pages, unsigned __int64 num);
FFFFFFFF 00000000          void *__cdecl vm_map_ram(page **pages, unsigned int count, int node, pgprot_t prot);
FFFFFFFF 00000000          unsigned __int64 __cdecl vm_mmap(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
FFFFFFFF 00000000          int __cdecl vm_munmap(unsigned __int64, size_t);
00000100 00000000          atomic_long_t vm_node_stat[32];
FFFFFFFF 00000000          page *__cdecl vm_normal_page(vm_area_struct *vma, unsigned __int64 addr, pte_t pte);
FFFFFFFF 00000000          page *__cdecl vm_normal_page_pmd(vm_area_struct *vma, unsigned __int64 addr, pmd_t pmd);
00000030 00000000          atomic_long_t vm_numa_stat[6];
00000010 00000000          static_key_true vm_numa_stat_key;
FFFFFFFF 00000000          void __cdecl vm_stat_account(mm_struct *, vm_flags_t, __int64 npages);
FFFFFFFF 00000000          void vm_unmap_aliases(void);
FFFFFFFF 00000000          void __cdecl vm_unmap_ram(const void *mem, unsigned int count);
00000068 00000000          atomic_long_t vm_zone_stat[13];
FFFFFFFF 00000000          void __cdecl vma_adjust_trans_huge(vm_area_struct *vma, unsigned __int64 start, unsigned __int64 end, __int64 adjust_next);
FFFFFFFF 00000000          void __cdecl vma_do_file_update_time(vm_area_struct *, const char[], int);
FFFFFFFF 00000000          void __cdecl vma_do_fput(vm_area_struct *, const char[], int);
FFFFFFFF 00000000          void __cdecl vma_do_get_file(vm_area_struct *, const char[], int);
FFFFFFFF 00000000          file *__cdecl vma_do_pr_or_file(vm_area_struct *, const char[], int);
FFFFFFFF 00000000          void __cdecl vma_interval_tree_insert(vm_area_struct *node, rb_root_cached *root);
FFFFFFFF 00000000          void __cdecl vma_interval_tree_insert_after(vm_area_struct *node, vm_area_struct *prev, rb_root_cached *root);
FFFFFFFF 00000000          vm_area_struct *__cdecl vma_interval_tree_iter_first(rb_root_cached *root, unsigned __int64 start, unsigned __int64 last);
FFFFFFFF 00000000          vm_area_struct *__cdecl vma_interval_tree_iter_next(vm_area_struct *node, unsigned __int64 start, unsigned __int64 last);
FFFFFFFF 00000000          void __cdecl vma_interval_tree_remove(vm_area_struct *node, rb_root_cached *root);
FFFFFFFF 00000000          bool __cdecl vma_is_shmem(vm_area_struct *vma);
FFFFFFFF 00000000          bool __cdecl vma_is_special_mapping(const vm_area_struct *vma, const vm_special_mapping *sm);
FFFFFFFF 00000000          int __cdecl vma_is_stack_for_current(vm_area_struct *vma);
FFFFFFFF 00000000          vm_area_struct *__cdecl vma_merge(mm_struct *, vm_area_struct *prev, unsigned __int64 addr, unsigned __int64 end, unsigned __int64 vm_flags, anon_vma *, file *, unsigned __int64, mempolicy *, vm_userfaultfd_ctx);
FFFFFFFF 00000000          void __cdecl vma_set_page_prot(vm_area_struct *vma);
FFFFFFFF 00000000          int __cdecl vma_wants_writenotify(vm_area_struct *vma, pgprot_t vm_page_prot);
FFFFFFFF 00000000          void *__cdecl vmalloc(unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl vmalloc_32(unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl vmalloc_32_user(unsigned __int64 size);
00000008 0000000000000000          unsigned __int64 vmalloc_base;
FFFFFFFF 00000000          void *__cdecl vmalloc_exec(unsigned __int64 size);
FFFFFFFF 00000000          void vmalloc_init(void);
FFFFFFFF 00000000          void *__cdecl vmalloc_node(unsigned __int64 size, int node);
FFFFFFFF 00000000          unsigned __int64 vmalloc_nr_pages(void);
FFFFFFFF 00000000          void vmalloc_sync_mappings(void);
FFFFFFFF 00000000          void vmalloc_sync_unmappings(void);
FFFFFFFF 00000000          page *__cdecl vmalloc_to_page(const void *addr);
FFFFFFFF 00000000          unsigned __int64 __cdecl vmalloc_to_pfn(const void *addr);
FFFFFFFF 00000000          void *__cdecl vmalloc_user(unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl vmap(page **pages, unsigned int count, unsigned __int64 flags, pgprot_t prot);
00000010 00000000          list_head vmap_area_list;
FFFFFFFF 00000000          void __cdecl vmem_altmap_free(vmem_altmap *altmap, unsigned __int64 nr_pfns);
FFFFFFFF 00000000          unsigned __int64 __cdecl vmem_altmap_offset(vmem_altmap *altmap);
FFFFFFFF 00000000          void *__cdecl vmemdup_user(const void *, size_t);
FFFFFFFF 00000000          void *__cdecl vmemmap_alloc_block(unsigned __int64 size, int node);
FFFFFFFF 00000000          void *__cdecl vmemmap_alloc_block_buf(unsigned __int64 size, int node);
00000008 0000000000000000          unsigned __int64 vmemmap_base;
FFFFFFFF 00000000          void __cdecl vmemmap_free(unsigned __int64 start, unsigned __int64 end, vmem_altmap *altmap);
FFFFFFFF 00000000          p4d_t *__cdecl vmemmap_p4d_populate(pgd_t *pgd, unsigned __int64 addr, int node);
FFFFFFFF 00000000          pgd_t *__cdecl vmemmap_pgd_populate(unsigned __int64 addr, int node);
FFFFFFFF 00000000          pmd_t *__cdecl vmemmap_pmd_populate(pud_t *pud, unsigned __int64 addr, int node);
FFFFFFFF 00000000          int __cdecl vmemmap_populate(unsigned __int64 start, unsigned __int64 end, int node, vmem_altmap *altmap);
FFFFFFFF 00000000          int __cdecl vmemmap_populate_basepages(unsigned __int64 start, unsigned __int64 end, int node);
FFFFFFFF 00000000          void vmemmap_populate_print_last(void);
FFFFFFFF 00000000          pte_t *__cdecl vmemmap_pte_populate(pmd_t *pmd, unsigned __int64 addr, int node);
FFFFFFFF 00000000          pud_t *__cdecl vmemmap_pud_populate(p4d_t *p4d, unsigned __int64 addr, int node);
FFFFFFFF 00000000          void __cdecl vmemmap_verify(pte_t *, int, unsigned __int64, unsigned __int64);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_mixed(vm_area_struct *vma, unsigned __int64 addr, pfn_t pfn);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_mixed_mkwrite(vm_area_struct *vma, unsigned __int64 addr, pfn_t pfn);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_pfn(vm_area_struct *vma, unsigned __int64 addr, unsigned __int64 pfn);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_pfn_pmd(vm_fault *vmf, pfn_t pfn, bool write);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_pfn_prot(vm_area_struct *vma, unsigned __int64 addr, unsigned __int64 pfn, pgprot_t pgprot);
FFFFFFFF 00000000          vm_fault_t __cdecl vmf_insert_pfn_pud(vm_fault *vmf, pfn_t pfn, bool write);
FFFFFFFF 00000000          int __cdecl vmstat_refresh(ctl_table *, int write, void *buffer, size_t *lenp, loff_t *ppos);
00000000 00000000          const char *const vmstat_text[];
FFFFFFFF 00000000          int __cdecl vprintk(const char *fmt, va_list args);
FFFFFFFF 00000000          int __cdecl vprintk_emit(int facility, int level, const char *dict, size_t dictlen, const char *fmt, va_list args);
FFFFFFFF 00000000          __int64 __cdecl vread(char *buf, char *addr, unsigned __int64 count);
FFFFFFFF 00000000          int __cdecl vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
FFFFFFFF 00000000          int __cdecl vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
FFFFFFFF 00000000          int __cdecl vsprintf(char *buf, const char *, va_list);
FFFFFFFF 00000000          int __cdecl vsscanf(const char *, const char *, va_list);
FFFFFFFF 00000000          void __cdecl vunmap(const void *addr);
FFFFFFFF 00000000          __int64 __cdecl vwrite(char *buf, char *addr, unsigned __int64 count);
FFFFFFFF 00000000          void *__cdecl vzalloc(unsigned __int64 size);
FFFFFFFF 00000000          void *__cdecl vzalloc_node(unsigned __int64 size, int node);
FFFFFFFF 00000000          void wait_bit_init(void);
FFFFFFFF 00000000          void __cdecl wait_for_completion(completion *);
FFFFFFFF 00000000          int __cdecl wait_for_completion_interruptible(completion *x);
FFFFFFFF 00000000          __int64 __cdecl wait_for_completion_interruptible_timeout(completion *x, unsigned __int64 timeout);
FFFFFFFF 00000000          void __cdecl wait_for_completion_io(completion *);
FFFFFFFF 00000000          unsigned __int64 __cdecl wait_for_completion_io_timeout(completion *x, unsigned __int64 timeout);
FFFFFFFF 00000000          int __cdecl wait_for_completion_killable(completion *x);
FFFFFFFF 00000000          __int64 __cdecl wait_for_completion_killable_timeout(completion *x, unsigned __int64 timeout);
FFFFFFFF 00000000          unsigned __int64 __cdecl wait_for_completion_timeout(completion *x, unsigned __int64 timeout);
FFFFFFFF 00000000          void wait_for_device_probe(void);
FFFFFFFF 00000000          int __cdecl wait_for_key_construction(key *key, bool intr);
FFFFFFFF 00000000          void __cdecl wait_for_stable_page(page *page);
FFFFFFFF 00000000          void __cdecl wait_on_page_bit(page *page, int bit_nr);
FFFFFFFF 00000000          int __cdecl wait_on_page_bit_killable(page *page, int bit_nr);
FFFFFFFF 00000000          void __cdecl wait_on_page_writeback(page *page);
FFFFFFFF 00000000          unsigned __int64 __cdecl wait_task_inactive(task_struct *, __int64 match_state);
FFFFFFFF 00000000          __int64 __cdecl wait_woken(wait_queue_entry *wq_entry, unsigned int mode, __int64 timeout);
FFFFFFFF 00000000          int __cdecl wake_bit_function(wait_queue_entry *wq_entry, unsigned int mode, int sync, void *key);
FFFFFFFF 00000000          void wake_up_all_idle_cpus(void);
FFFFFFFF 00000000          void __cdecl wake_up_bit(void *word, int bit);
FFFFFFFF 00000000          void wake_up_klogd(void);
FFFFFFFF 00000000          void __cdecl wake_up_new_task(task_struct *tsk);
FFFFFFFF 00000000          int __cdecl wake_up_process(task_struct *tsk);
FFFFFFFF 00000000          int __cdecl wake_up_state(task_struct *tsk, unsigned int state);
FFFFFFFF 00000000          void __cdecl wake_up_var(void *var);
FFFFFFFF 00000000          void __cdecl wakeup_kswapd(zone *zone, gfp_t gfp_mask, int order, zone_type classzone_idx);
FFFFFFFF 00000000          int __cdecl wakeup_secondary_cpu_via_nmi(int apicid, unsigned __int64 start_eip);
FFFFFFFF 00000000          void __cdecl wakeup_source_add(wakeup_source *ws);
FFFFFFFF 00000000          wakeup_source *__cdecl wakeup_source_create(const char *name);
FFFFFFFF 00000000          void __cdecl wakeup_source_destroy(wakeup_source *ws);
FFFFFFFF 00000000          wakeup_source *__cdecl wakeup_source_register(device *dev, const char *name);
FFFFFFFF 00000000          void __cdecl wakeup_source_remove(wakeup_source *ws);
FFFFFFFF 00000000          void __cdecl wakeup_source_unregister(wakeup_source *ws);
FFFFFFFF 00000000          int __cdecl walk_iomem_res_desc(unsigned __int64 desc, unsigned __int64 flags, u64 start, u64 end, void *arg, int (__cdecl *func)(resource *, void *));
FFFFFFFF 00000000          int __cdecl walk_mem_res(u64 start, u64 end, void *arg, int (__cdecl *func)(resource *, void *));
FFFFFFFF 00000000          int __cdecl walk_system_ram_range(unsigned __int64 start_pfn, unsigned __int64 nr_pages, void *arg, int (__cdecl *func)(unsigned __int64, unsigned __int64, void *));
FFFFFFFF 00000000          int __cdecl walk_system_ram_res(u64 start, u64 end, void *arg, int (__cdecl *func)(resource *, void *));
FFFFFFFF 00000000          void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...);
00000004 00000000          int watermark_boost_factor;
FFFFFFFF 00000000          int __cdecl watermark_boost_factor_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
00000004 00000000          int watermark_scale_factor;
FFFFFFFF 00000000          int __cdecl watermark_scale_factor_sysctl_handler(ctl_table *, int, void *, size_t *, loff_t *);
FFFFFFFF 00000000          int wbinvd_on_all_cpus(void);
FFFFFFFF 00000000          void __cdecl wbinvd_on_cpu(int cpu);
FFFFFFFF 00000000          bool __cdecl within_error_injection_list(unsigned __int64 addr);
FFFFFFFF 00000000          acpi_status __cdecl wmi_evaluate_method(const char *guid, u8 instance, u32 method_id, const acpi_buffer *in, acpi_buffer *out);
FFFFFFFF 00000000          char *__cdecl wmi_get_acpi_device_uid(const char *guid);
FFFFFFFF 00000000          acpi_status __cdecl wmi_get_event_data(u32 event, acpi_buffer *out);
FFFFFFFF 00000000          bool __cdecl wmi_has_guid(const char *guid);
FFFFFFFF 00000000          acpi_status __cdecl wmi_install_notify_handler(const char *guid, wmi_notify_handler handler, void *data);
FFFFFFFF 00000000          acpi_status __cdecl wmi_query_block(const char *guid, u8 instance, acpi_buffer *out);
FFFFFFFF 00000000          acpi_status __cdecl wmi_remove_notify_handler(const char *guid);
FFFFFFFF 00000000          acpi_status __cdecl wmi_set_block(const char *guid, u8 instance, const acpi_buffer *in);
FFFFFFFF 00000000          int __cdecl woken_wake_function(wait_queue_entry *wq_entry, unsigned int mode, int sync, void *key);
FFFFFFFF 00000000          unsigned int __cdecl work_busy(work_struct *work);
FFFFFFFF 00000000          __int64 __cdecl work_on_cpu(int cpu, __int64 (__cdecl *fn)(void *), void *arg);
FFFFFFFF 00000000          __int64 __cdecl work_on_cpu_safe(int cpu, __int64 (__cdecl *fn)(void *), void *arg);
FFFFFFFF 00000000          bool __cdecl workqueue_congested(int cpu, workqueue_struct *wq);
FFFFFFFF 00000000          int workqueue_init(void);
FFFFFFFF 00000000          int workqueue_init_early(void);
FFFFFFFF 00000000          int __cdecl workqueue_offline_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl workqueue_online_cpu(unsigned int cpu);
FFFFFFFF 00000000          int __cdecl workqueue_prepare_cpu(unsigned int cpu);
FFFFFFFF 00000000          void __cdecl workqueue_set_max_active(workqueue_struct *wq, int max_active);
FFFFFFFF 00000000          int __cdecl workqueue_set_unbound_cpumask(cpumask_var_t cpumask);
FFFFFFFF 00000000          int __cdecl workqueue_sysfs_register(workqueue_struct *wq);
FFFFFFFF 00000000          void __cdecl wq_worker_comm(char *buf, size_t size, task_struct *task);
FFFFFFFF 00000000          int __cdecl write_inode_now(inode *, int);
FFFFFFFF 00000000          int __cdecl write_one_page(page *page);
FFFFFFFF 00000000          int __cdecl wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
FFFFFFFF 00000000          void __cdecl wrmsr_on_cpus(const cpumask *mask, u32 msr_no, msr *msrs);
FFFFFFFF 00000000          int __cdecl wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
FFFFFFFF 00000000          int __cdecl wrmsr_safe_regs(u32 regs[8]);
FFFFFFFF 00000000          int __cdecl wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);
FFFFFFFF 00000000          int __cdecl wrmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 q);
FFFFFFFF 00000000          int __cdecl wrmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 q);
00000004 00000000          int x2apic_mode;
00000004 00000000          int x2apic_phys;
FFFFFFFF 00000000          void __cdecl x2apic_set_max_apicid(u32 apicid);
FFFFFFFF 00000000          void x2apic_setup(void);
FFFFFFFF 00000000          int x86_acpi_numa_init(void);
00000010 00000000          x86_apic_ops x86_apic_ops;
00000002 00000000          unsigned __int16 x86_bios_cpu_apicid;
00000000 00000000          unsigned __int16 x86_bios_cpu_apicid_early_map[];
00000008 0000000000000000          unsigned __int16 *x86_bios_cpu_apicid_early_ptr;
00000100 00000000          const char *const x86_bug_flags[32];
00001300 00000000          const char *const x86_cap_flags[608];
00000004 00000000          unsigned int x86_cpu_to_acpiid;
00000000 00000000          unsigned int x86_cpu_to_acpiid_early_map[];
00000008 0000000000000000          unsigned int *x86_cpu_to_acpiid_early_ptr;
00000002 00000000          unsigned __int16 x86_cpu_to_apicid;
00000000 00000000          unsigned __int16 x86_cpu_to_apicid_early_map[];
00000008 0000000000000000          unsigned __int16 *x86_cpu_to_apicid_early_ptr;
00000004 00000000          int x86_cpu_to_node_map;
00000000 00000000          int x86_cpu_to_node_map_early_map[];
00000008 0000000000000000          int *x86_cpu_to_node_map_early_ptr;
00000018 00000000          x86_cpuinit_ops x86_cpuinit;
FFFFFFFF 00000000          u64 x86_default_get_root_pointer(void);
FFFFFFFF 00000000          void __cdecl x86_default_set_root_pointer(u64 addr);
FFFFFFFF 00000000          void x86_early_init_platform_quirks(void);
FFFFFFFF 00000000          unsigned __int64 __cdecl x86_fsbase_read_task(task_struct *task);
FFFFFFFF 00000000          void __cdecl x86_fsbase_write_task(task_struct *task, unsigned __int64 fsbase);
FFFFFFFF 00000000          unsigned __int64 __cdecl x86_gsbase_read_task(task_struct *task);
FFFFFFFF 00000000          void __cdecl x86_gsbase_write_task(task_struct *task, unsigned __int64 gsbase);
FFFFFFFF 00000000          void __cdecl x86_idle_thread_init(unsigned int cpu, task_struct *idle);
00000118 00000000          x86_init_ops x86_init;
FFFFFFFF 00000000          void x86_init_noop(void);
FFFFFFFF 00000000          void __cdecl x86_init_uint_noop(unsigned int unused);
00000020 00000000          x86_msi_ops x86_msi;
FFFFFFFF 00000000          void __cdecl x86_op_int_noop(int cpu);
FFFFFFFF 00000000          int __cdecl x86_pci_root_bus_node(int bus);
FFFFFFFF 00000000          void __cdecl x86_pci_root_bus_resources(int bus, list_head *resources);
00000080 00000000          x86_platform_ops x86_platform;
00000008 0000000000000000          void (*x86_platform_ipi_callback)(void);
FFFFFFFF 00000000          bool x86_pnpbios_disabled(void);
00000100 00000000          const char *const x86_power_flags[32];
00000008 0000000000000000          u64 x86_spec_ctrl_base;
00000008 0000000000000000          unsigned __int64 x86_spec_ctrl_current;
00000001 00000000          bool x86_topology_update;
FFFFFFFF 00000000          void __cdecl xa_clear_mark(xarray *, unsigned __int64 index, xa_mark_t);
FFFFFFFF 00000000          void __cdecl xa_destroy(xarray *);
FFFFFFFF 00000000          void __cdecl xa_dump(const xarray *);
FFFFFFFF 00000000          void __cdecl xa_dump_node(const xa_node *);
FFFFFFFF 00000000          void *__cdecl xa_erase(xarray *, unsigned __int64 index);
FFFFFFFF 00000000          unsigned int __cdecl xa_extract(xarray *, void **dst, unsigned __int64 start, unsigned __int64 max, unsigned int n, xa_mark_t);
FFFFFFFF 00000000          void *__cdecl xa_find(xarray *xa, unsigned __int64 *index, unsigned __int64 max, xa_mark_t);
FFFFFFFF 00000000          void *__cdecl xa_find_after(xarray *xa, unsigned __int64 *index, unsigned __int64 max, xa_mark_t);
FFFFFFFF 00000000          bool __cdecl xa_get_mark(xarray *, unsigned __int64 index, xa_mark_t);
FFFFFFFF 00000000          int __cdecl xa_get_order(xarray *, unsigned __int64 index);
FFFFFFFF 00000000          void *__cdecl xa_load(xarray *, unsigned __int64 index);
FFFFFFFF 00000000          void __cdecl xa_set_mark(xarray *, unsigned __int64 index, xa_mark_t);
FFFFFFFF 00000000          void *__cdecl xa_store(xarray *, unsigned __int64 index, void *entry, gfp_t);
FFFFFFFF 00000000          void *__cdecl xa_store_range(xarray *, unsigned __int64 first, unsigned __int64 last, void *entry, gfp_t);
FFFFFFFF 00000000          void __cdecl xas_clear_mark(const xa_state *, xa_mark_t);
FFFFFFFF 00000000          void __cdecl xas_create_range(xa_state *);
FFFFFFFF 00000000          void *__cdecl xas_find(xa_state *, unsigned __int64 max);
FFFFFFFF 00000000          void *__cdecl xas_find_conflict(xa_state *);
FFFFFFFF 00000000          void *__cdecl xas_find_marked(xa_state *, unsigned __int64 max, xa_mark_t);
FFFFFFFF 00000000          bool __cdecl xas_get_mark(const xa_state *, xa_mark_t);
FFFFFFFF 00000000          void __cdecl xas_init_marks(const xa_state *);
FFFFFFFF 00000000          void *__cdecl xas_load(xa_state *);
FFFFFFFF 00000000          bool __cdecl xas_nomem(xa_state *, gfp_t);
FFFFFFFF 00000000          void __cdecl xas_pause(xa_state *);
FFFFFFFF 00000000          void __cdecl xas_set_mark(const xa_state *, xa_mark_t);
FFFFFFFF 00000000          void __cdecl xas_split(xa_state *, void *entry, unsigned int order);
FFFFFFFF 00000000          void __cdecl xas_split_alloc(xa_state *, void *entry, unsigned int order, gfp_t);
FFFFFFFF 00000000          void *__cdecl xas_store(xa_state *, void *entry);
00000028 00000000          const bpf_verifier_ops xdp_analyzer_ops;
00000008 0000000000000000          const bpf_prog_ops xdp_prog_ops;
00000028 00000000          const bpf_verifier_ops xdp_verifier_ops;
00000100 00000000          const char xen_early_idt_handler_array[32][8];
FFFFFFFF 00000000          bool xen_set_default_idle(void);
00000008 0000000000000000          u64 xfeatures_mask;
FFFFFFFF 00000000          void *__cdecl xlate_dev_mem_ptr(phys_addr_t phys);
000000A8 00000000          const bpf_map_ops xsk_map_ops;
00000030 00000000          u64 xstate_fx_sw_bytes[6];
FFFFFFFF 00000000          void __cdecl xtime_update(unsigned __int64 ticks);
FFFFFFFF 00000000          void yield(void);
FFFFFFFF 00000000          int __cdecl yield_to(task_struct *p, bool preempt);
FFFFFFFF 00000000          bool __cdecl zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
FFFFFFFF 00000000          bool __cdecl zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
FFFFFFFF 00000000          int __cdecl zap_huge_pmd(mmu_gather *tlb, vm_area_struct *vma, pmd_t *pmd, unsigned __int64 addr);
FFFFFFFF 00000000          int __cdecl zap_huge_pud(mmu_gather *tlb, vm_area_struct *vma, pud_t *pud, unsigned __int64 addr);
FFFFFFFF 00000000          void __cdecl zap_page_range(vm_area_struct *vma, unsigned __int64 address, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl zap_vma_ptes(vm_area_struct *vma, unsigned __int64 address, unsigned __int64 size);
FFFFFFFF 00000000          void __cdecl zero_fill_bio_iter(bio *bio, bvec_iter iter);
FFFFFFFF 00000000          void zero_resv_unavail(void);
FFFFFFFF 00000000          zone *__cdecl zone_for_pfn_range(int online_type, int nid, unsigned __int64 start_pfn, unsigned __int64 nr_pages);
FFFFFFFF 00000000          int __cdecl zone_grow_free_lists(zone *zone, unsigned __int64 new_nr_pages);
FFFFFFFF 00000000          int __cdecl zone_grow_waitqueues(zone *zone, unsigned __int64 nr_pages);
FFFFFFFF 00000000          void __cdecl zone_pcp_reset(zone *zone);
FFFFFFFF 00000000          void __cdecl zone_pcp_update(zone *zone);
FFFFFFFF 00000000          bool __cdecl zone_watermark_ok(zone *z, unsigned int order, unsigned __int64 mark, int classzone_idx, unsigned int alloc_flags);
FFFFFFFF 00000000          bool __cdecl zone_watermark_ok_safe(zone *z, unsigned int order, unsigned __int64 mark, int classzone_idx);
00000004 00000000          acpi_predicate all_versions;
00000004 00000007          ioapic_irq_destination_types dest_ExtINT;
00000004 00000000          ioapic_irq_destination_types dest_Fixed;
00000004 00000005          ioapic_irq_destination_types dest_INIT;
00000004 00000001          ioapic_irq_destination_types dest_LowestPrio;
00000004 00000004          ioapic_irq_destination_types dest_NMI;
00000004 00000002          ioapic_irq_destination_types dest_SMI;
00000004 00000003          ioapic_irq_destination_types dest__reserved_1;
00000004 00000006          ioapic_irq_destination_types dest__reserved_2;
00000004 00000002          efi_secureboot_mode efi_secureboot_mode_disabled;
00000004 00000003          efi_secureboot_mode efi_secureboot_mode_enabled;
00000004 00000001          efi_secureboot_mode efi_secureboot_mode_unknown;
00000004 00000000          efi_secureboot_mode efi_secureboot_mode_unset;
00000004 00000002          acpi_predicate equal;
00000004 00000000          $86BD942A5D2993CC42377410B601BBDB false;
00000004 00000003          acpi_predicate greater_than_or_equal;
00000004 00000004          hwparam_type hwparam_dma;
00000004 00000005          hwparam_type hwparam_dma_addr;
00000004 00000001          hwparam_type hwparam_iomem;
00000004 00000000          hwparam_type hwparam_ioport;
00000004 00000002          hwparam_type hwparam_ioport_or_iomem;
00000004 00000003          hwparam_type hwparam_irq;
00000004 00000006          hwparam_type hwparam_other;
00000004 00000001          acpi_predicate less_than_or_equal;
00000004 00000003          mp_irq_source_types mp_ExtINT;
00000004 00000000          mp_irq_source_types mp_INT;
00000004 00000001          mp_irq_source_types mp_NMI;
00000004 00000002          mp_irq_source_types mp_SMI;
00000004 00000000          perf_event_task_context perf_hw_context;
00000004 FFFFFFFF          perf_event_task_context perf_invalid_context;
00000004 00000002          perf_event_task_context perf_nr_task_contexts;
00000004 00000001          perf_event_task_context perf_sw_context;
00000004 00000001          $86BD942A5D2993CC42377410B601BBDB true;

TYPES
00000004 enum $0057655D8FF5A403A412A059E838C320 : unsigned __int32
{
  BPF_FIB_LKUP_RET_SUCCESS = 0x0,
  BPF_FIB_LKUP_RET_BLACKHOLE = 0x1,
  BPF_FIB_LKUP_RET_UNREACHABLE = 0x2,
  BPF_FIB_LKUP_RET_PROHIBIT = 0x3,
  BPF_FIB_LKUP_RET_NOT_FWDED = 0x4,
  BPF_FIB_LKUP_RET_FWD_DISABLED = 0x5,
  BPF_FIB_LKUP_RET_UNSUPP_LWT = 0x6,
  BPF_FIB_LKUP_RET_NO_NEIGH = 0x7,
  BPF_FIB_LKUP_RET_FRAG_NEEDED = 0x8,
};
00000004 enum $00998310628785E0AEA1159A66AFA631 : unsigned __int32
{
  BIO_NO_PAGE_REF = 0x0,
  BIO_CLONED = 0x1,
  BIO_BOUNCED = 0x2,
  BIO_USER_MAPPED = 0x3,
  BIO_NULL_MAPPED = 0x4,
  BIO_WORKINGSET = 0x5,
  BIO_QUIET = 0x6,
  BIO_CHAIN = 0x7,
  BIO_REFFED = 0x8,
  BIO_THROTTLED = 0x9,
  BIO_TRACE_COMPLETION = 0xA,
  BIO_QUEUE_ENTERED = 0xB,
  BIO_TRACKED = 0xC,
  BIO_FLAG_LAST = 0xD,
};
00000010 struct $01BDD16C1AA177C5585F7FD1924C3EAA
{
  u64 rip;
  u64 rdp;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $01BDD16C1AA177C5585F7FD1924C3EAA.rip u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $01BDD16C1AA177C5585F7FD1924C3EAA.rdp u64;
//          0010 effalign(8) sda=0 bits=0000 $01BDD16C1AA177C5585F7FD1924C3EAA struct packalign=0

00000008 union $0256C37A800425CA166D3F6F142F680B
{
  __attribute__((aligned(8))) __u64 value;
  __attribute__((aligned(8))) __u64 next_key;
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 $0256C37A800425CA166D3F6F142F680B.value __u64;
//  1. 0000 0008 effalign(8) fda=4 bits=0000 $0256C37A800425CA166D3F6F142F680B.next_key __u64;
//          0008 effalign(8) sda=0 bits=0000 $0256C37A800425CA166D3F6F142F680B union packalign=0

00000004 enum $038368816E7FF15918B7FC1B8961DCB5 : unsigned __int32
{
  QIF_BLIMITS_B = 0x0,
  QIF_SPACE_B = 0x1,
  QIF_ILIMITS_B = 0x2,
  QIF_INODES_B = 0x3,
  QIF_BTIME_B = 0x4,
  QIF_ITIME_B = 0x5,
};
00000004 enum $05CF1DF5F3AA29F92A37408928E5EB3B : unsigned __int32
{
  DQF_ROOT_SQUASH_B = 0x0,
  DQF_SYS_FILE_B = 0x10,
  DQF_PRIVATE = 0x11,
};
00000004 enum $05DFF05EFD664B2206B6A34A0C6E8EB7 : unsigned __int32
{
  __PERCPU_REF_ATOMIC = 0x1,
  __PERCPU_REF_DEAD = 0x2,
  __PERCPU_REF_ATOMIC_DEAD = 0x3,
  __PERCPU_REF_FLAG_BITS = 0x2,
};
00000002 struct $0A3F26CD0DA2348788F16A085A72286B
{
  u8 reg_offset;
  u8 ilen;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $0A3F26CD0DA2348788F16A085A72286B.reg_offset u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $0A3F26CD0DA2348788F16A085A72286B.ilen u8;
//          0002 effalign(1) sda=0 bits=0000 $0A3F26CD0DA2348788F16A085A72286B struct packalign=0

00000004 union $0AB7F792334A5D00E72DC46855D66EE8
{
  unsigned __int32 __reserved_1 : 24;
  unsigned __int32 phys_dest : 4;
  unsigned __int32 __reserved_2 : 4;
  unsigned __int32 __reserved_3 : 24;
  unsigned __int32 logical_dest : 8;
};
//  0. 0000. 0 24 effalign(4) fda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8.__reserved_1 bi.nbytes=4 U
//  1. 0000. 0 4 effalign(1) fda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8.phys_dest bi.nbytes=4 U
//  2. 0000. 0 4 effalign(1) fda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8.__reserved_2 bi.nbytes=4 U
//  3. 0000. 0 24 effalign(4) fda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8.__reserved_3 bi.nbytes=4 U
//  4. 0000. 0 8 effalign(1) fda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8.logical_dest bi.nbytes=4 U
//          0003 unpadded_size
//          0004 effalign(4) sda=0 bits=0000 $0AB7F792334A5D00E72DC46855D66EE8 union packalign=0

00000008 struct $0C00FA23BDE0A874E23F9019515AD89A
{
  u32 l;
  u32 h;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $0C00FA23BDE0A874E23F9019515AD89A.l u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $0C00FA23BDE0A874E23F9019515AD89A.h u32;
//          0008 effalign(4) sda=0 bits=0000 $0C00FA23BDE0A874E23F9019515AD89A struct packalign=0

00000004 enum $0E63971FF611EFBC58C5ACB3C2E507C8 : unsigned __int32
{
  NET_X25_RESTART_REQUEST_TIMEOUT = 0x1,
  NET_X25_CALL_REQUEST_TIMEOUT = 0x2,
  NET_X25_RESET_REQUEST_TIMEOUT = 0x3,
  NET_X25_CLEAR_REQUEST_TIMEOUT = 0x4,
  NET_X25_ACK_HOLD_BACK_TIMEOUT = 0x5,
  NET_X25_FORWARD = 0x6,
};
00000004 enum $14BC4732EFAB4DB3C424C5B74F9B2FA1 : unsigned __int32
{
  NET_ATALK_AARP_EXPIRY_TIME = 0x1,
  NET_ATALK_AARP_TICK_TIME = 0x2,
  NET_ATALK_AARP_RETRANSMIT_LIMIT = 0x3,
  NET_ATALK_AARP_RESOLVE_TIME = 0x4,
};
00000004 enum $187884F4088CD9BBE07DDAE7E9FCE777 : unsigned __int32
{
  NET_IPV6_FORWARDING = 0x1,
  NET_IPV6_HOP_LIMIT = 0x2,
  NET_IPV6_MTU = 0x3,
  NET_IPV6_ACCEPT_RA = 0x4,
  NET_IPV6_ACCEPT_REDIRECTS = 0x5,
  NET_IPV6_AUTOCONF = 0x6,
  NET_IPV6_DAD_TRANSMITS = 0x7,
  NET_IPV6_RTR_SOLICITS = 0x8,
  NET_IPV6_RTR_SOLICIT_INTERVAL = 0x9,
  NET_IPV6_RTR_SOLICIT_DELAY = 0xA,
  NET_IPV6_USE_TEMPADDR = 0xB,
  NET_IPV6_TEMP_VALID_LFT = 0xC,
  NET_IPV6_TEMP_PREFERED_LFT = 0xD,
  NET_IPV6_REGEN_MAX_RETRY = 0xE,
  NET_IPV6_MAX_DESYNC_FACTOR = 0xF,
  NET_IPV6_MAX_ADDRESSES = 0x10,
  NET_IPV6_FORCE_MLD_VERSION = 0x11,
  NET_IPV6_ACCEPT_RA_DEFRTR = 0x12,
  NET_IPV6_ACCEPT_RA_PINFO = 0x13,
  NET_IPV6_ACCEPT_RA_RTR_PREF = 0x14,
  NET_IPV6_RTR_PROBE_INTERVAL = 0x15,
  NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 0x16,
  NET_IPV6_PROXY_NDP = 0x17,
  NET_IPV6_ACCEPT_SOURCE_ROUTE = 0x19,
  NET_IPV6_ACCEPT_RA_FROM_LOCAL = 0x1A,
  NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN = 0x1B,
  __NET_IPV6_MAX = 0x1C,
};
00000008 struct $19297B8565531AC76857E0FF223BC140
{
  u32 hash;
  u32 len;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $19297B8565531AC76857E0FF223BC140.hash u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $19297B8565531AC76857E0FF223BC140.len u32;
//          0008 effalign(4) sda=0 bits=0000 $19297B8565531AC76857E0FF223BC140 struct packalign=0

00000004 enum $1BD4E6AB35C1BC0E966A06B79AEB29B4 : unsigned __int32
{
  DEV_PARPORT_DEVICE_TIMESLICE = 0x1,
};
00000004 enum $1D7DC671811FCBECC9CA03AA95A665D0 : unsigned __int32
{
  NET_LLC2_ACK_TIMEOUT = 0x1,
  NET_LLC2_P_TIMEOUT = 0x2,
  NET_LLC2_REJ_TIMEOUT = 0x3,
  NET_LLC2_BUSY_TIMEOUT = 0x4,
};
00000004 enum $21512D32A1F68B3E2EE322B1CFB51275 : unsigned __int32
{
  NET_DECNET_CONF_DEV_PRIORITY = 0x1,
  NET_DECNET_CONF_DEV_T1 = 0x2,
  NET_DECNET_CONF_DEV_T2 = 0x3,
  NET_DECNET_CONF_DEV_T3 = 0x4,
  NET_DECNET_CONF_DEV_FORWARDING = 0x5,
  NET_DECNET_CONF_DEV_BLKSIZE = 0x6,
  NET_DECNET_CONF_DEV_STATE = 0x7,
};
00000004 enum $24C4792CDD1F41699BBC435C70A94D72 : unsigned __int32
{
  DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 0x1,
  DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 0x2,
  DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 0x3,
  DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 0x4,
  DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 0x5,
  DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 0x6,
};
00000004 struct $274F6A0FE63D1E8E4D8A716FC38C5A7D
{
  u8 wlocked;
  u8 __lstate[3];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $274F6A0FE63D1E8E4D8A716FC38C5A7D.wlocked u8;
//  1. 0001 0003 effalign(1) fda=0 bits=0000 $274F6A0FE63D1E8E4D8A716FC38C5A7D.__lstate u8[3];
//          0004 effalign(1) sda=0 bits=0000 $274F6A0FE63D1E8E4D8A716FC38C5A7D struct packalign=0

00000010 struct $28099A4E4B70B6D11EF5DB4F925A6FFF
{
  page *next;
  int pages;
  int pobjects;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $28099A4E4B70B6D11EF5DB4F925A6FFF.next page *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 $28099A4E4B70B6D11EF5DB4F925A6FFF.pages int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 $28099A4E4B70B6D11EF5DB4F925A6FFF.pobjects int;
//          0010 effalign(8) sda=0 bits=0000 $28099A4E4B70B6D11EF5DB4F925A6FFF struct packalign=0

00000002 struct $28773E666A9823AEB9EC03C7A199C944
{
  u8 fixups;
  u8 ilen;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $28773E666A9823AEB9EC03C7A199C944.fixups u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $28773E666A9823AEB9EC03C7A199C944.ilen u8;
//          0002 effalign(1) sda=0 bits=0000 $28773E666A9823AEB9EC03C7A199C944 struct packalign=0

00000008 struct __attribute__((packed)) $29D3DFB965F453A09EC040260BDA44B8
{
  __u64 reserved;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $29D3DFB965F453A09EC040260BDA44B8.reserved __u64;
//          0008 effalign(1) sda=0 bits=0040 $29D3DFB965F453A09EC040260BDA44B8 struct packalign=0

00000018 union $2B0C88ED88ED3BB73D04C51F76AE706D
{
  __int16 _addr_lsb;
  $F5C1C9C04BCDB0ADA1B147BEDD0D212C _addr_bnd;
  $AE7699F1C0F08D928DAB88E00BBC947C _addr_pkey;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 $2B0C88ED88ED3BB73D04C51F76AE706D._addr_lsb __int16;
//  1. 0000 0018 effalign(8) fda=0 bits=0000 $2B0C88ED88ED3BB73D04C51F76AE706D._addr_bnd $F5C1C9C04BCDB0ADA1B147BEDD0D212C;
//  2. 0000 000C effalign(4) fda=0 bits=0000 $2B0C88ED88ED3BB73D04C51F76AE706D._addr_pkey $AE7699F1C0F08D928DAB88E00BBC947C;
//          0018 effalign(8) sda=0 bits=0000 $2B0C88ED88ED3BB73D04C51F76AE706D union packalign=0

00000004 enum $2E9D172CAA035E0370957B5AF4415823 : unsigned __int32
{
  ZONELIST_FALLBACK = 0x0,
  ZONELIST_NOFALLBACK = 0x1,
  MAX_ZONELISTS = 0x2,
};
00000018 struct $2F8F0B40204E9F9467F489FB07BFF473
{
  callback_head dup_xol_work;
  unsigned __int64 dup_xol_addr;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $2F8F0B40204E9F9467F489FB07BFF473.dup_xol_work callback_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 $2F8F0B40204E9F9467F489FB07BFF473.dup_xol_addr unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 $2F8F0B40204E9F9467F489FB07BFF473 struct packalign=0

00000004 enum $2FD438E2A2F08791E408C294C231390D : unsigned __int32
{
  MM_FILEPAGES = 0x0,
  MM_ANONPAGES = 0x1,
  MM_SWAPENTS = 0x2,
  MM_SHMEMPAGES = 0x3,
  NR_MM_COUNTERS = 0x4,
};
00000004 enum $33C2810983D6D097EBD64454FBBEAA1D : unsigned __int32
{
  BPF_REG_0 = 0x0,
  BPF_REG_1 = 0x1,
  BPF_REG_2 = 0x2,
  BPF_REG_3 = 0x3,
  BPF_REG_4 = 0x4,
  BPF_REG_5 = 0x5,
  BPF_REG_6 = 0x6,
  BPF_REG_7 = 0x7,
  BPF_REG_8 = 0x8,
  BPF_REG_9 = 0x9,
  BPF_REG_10 = 0xA,
  __MAX_BPF_REG = 0xB,
};
00000004 struct $34157686918C88ADDB14C11D63ECF3D3
{
  unsigned __int32 inuse : 16;
  unsigned __int32 objects : 15;
  unsigned __int32 frozen : 1;
};
//  0. 0000. 0 16 effalign(2) fda=0 bits=0000 $34157686918C88ADDB14C11D63ECF3D3.inuse bi.nbytes=4 U
//  1. 0000.16 15 effalign(2) fda=0 bits=0000 $34157686918C88ADDB14C11D63ECF3D3.objects bi.nbytes=4 U
//  2. 0000.31 1 effalign(2) fda=0 bits=0000 $34157686918C88ADDB14C11D63ECF3D3.frozen bi.nbytes=4 U
//          0004 effalign(4) sda=0 bits=0000 $34157686918C88ADDB14C11D63ECF3D3 struct packalign=0

00000028 struct $34672576DAEADB9A5B053A678A7DD49F
{
  list_head lru;
  address_space *mapping;
  unsigned __int64 index;
  unsigned __int64 private;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $34672576DAEADB9A5B053A678A7DD49F.lru list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 $34672576DAEADB9A5B053A678A7DD49F.mapping address_space *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 $34672576DAEADB9A5B053A678A7DD49F.index unsigned __int64;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 $34672576DAEADB9A5B053A678A7DD49F.private unsigned __int64;
//          0028 effalign(8) sda=0 bits=0000 $34672576DAEADB9A5B053A678A7DD49F struct packalign=0

00000004 enum $351E6E9B07F7A2F5C3B6E85CED34CA17 : unsigned __int32
{
  DIO_LOCKING = 0x1,
  DIO_SKIP_HOLES = 0x2,
};
00000002 struct $3846E5716A6A61A346C1663F85F1EE2B
{
  u8 locked;
  u8 pending;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $3846E5716A6A61A346C1663F85F1EE2B.locked u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $3846E5716A6A61A346C1663F85F1EE2B.pending u8;
//          0002 effalign(1) sda=0 bits=0000 $3846E5716A6A61A346C1663F85F1EE2B struct packalign=0

00000004 enum $3C897483CD60E997325FAB081547E2CD : unsigned __int32
{
  FS_NRINODE = 0x1,
  FS_STATINODE = 0x2,
  FS_MAXINODE = 0x3,
  FS_NRDQUOT = 0x4,
  FS_MAXDQUOT = 0x5,
  FS_NRFILE = 0x6,
  FS_MAXFILE = 0x7,
  FS_DENTRY = 0x8,
  FS_NRSUPER = 0x9,
  FS_MAXSUPER = 0xA,
  FS_OVERFLOWUID = 0xB,
  FS_OVERFLOWGID = 0xC,
  FS_LEASES = 0xD,
  FS_DIR_NOTIFY = 0xE,
  FS_LEASE_TIME = 0xF,
  FS_DQSTATS = 0x10,
  FS_XFS = 0x11,
  FS_AIO_NR = 0x12,
  FS_AIO_MAX_NR = 0x13,
  FS_INOTIFY = 0x14,
  FS_OCFS2 = 0x3DC,
};
00000008 union $3EB18370503AAC13F34FCFCFFC2152CC
{
  const u8 *u8_data;
  const u16 *u16_data;
  const u32 *u32_data;
  const u64 *u64_data;
  const char *const *str;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC.u8_data const u8 *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC.u16_data const u16 *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC.u32_data const u32 *;
//  3. 0000 0008 effalign(8) fda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC.u64_data const u64 *;
//  4. 0000 0008 effalign(8) fda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC.str const char *const *;
//          0008 effalign(8) sda=0 bits=0000 $3EB18370503AAC13F34FCFCFFC2152CC union packalign=0

00000004 enum $411DA2B6574699F7D8C6ACF66163E448 : unsigned __int32
{
  DEV_SCSI_LOGGING_LEVEL = 0x1,
};
00000004 enum $42AA7968567CB5517F8D3321B22BA7FC : unsigned __int32
{
  KCOV_TRACE_PC = 0x0,
  KCOV_TRACE_CMP = 0x1,
};
00000010 struct __attribute__((packed)) $42D5F5B662BD61DA5FC8E511DFAF9EBF
{
  __u64 serial_number;
  __u64 reserved;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $42D5F5B662BD61DA5FC8E511DFAF9EBF.serial_number __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 $42D5F5B662BD61DA5FC8E511DFAF9EBF.reserved __u64;
//          0010 effalign(1) sda=0 bits=0040 $42D5F5B662BD61DA5FC8E511DFAF9EBF struct packalign=0

00000004 enum $4428FE6B781B78B25B204D3D56A4B251 : unsigned __int32
{
  DEV_IPMI_POWEROFF_POWERCYCLE = 0x1,
};
00000004 enum $45D62DEFE14D4A5E97434CC7550C7E75 : unsigned __int32
{
  SB_UNFROZEN = 0x0,
  SB_FREEZE_WRITE = 0x1,
  SB_FREEZE_PAGEFAULT = 0x2,
  SB_FREEZE_FS = 0x3,
  SB_FREEZE_COMPLETE = 0x4,
};
00000004 enum $473A456D5B42351FDD7DD7C07E42ECDE : unsigned __int32
{
  RANDOM_POOLSIZE = 0x1,
  RANDOM_ENTROPY_COUNT = 0x2,
  RANDOM_READ_THRESH = 0x3,
  RANDOM_WRITE_THRESH = 0x4,
  RANDOM_BOOT_ID = 0x5,
  RANDOM_UUID = 0x6,
};
00000004 enum $49CB0BD6DF0B9506CA50BC4081F89D9F : unsigned __int32
{
  VM_UNUSED1 = 0x1,
  VM_UNUSED2 = 0x2,
  VM_UNUSED3 = 0x3,
  VM_UNUSED4 = 0x4,
  VM_OVERCOMMIT_MEMORY = 0x5,
  VM_UNUSED5 = 0x6,
  VM_UNUSED7 = 0x7,
  VM_UNUSED8 = 0x8,
  VM_UNUSED9 = 0x9,
  VM_PAGE_CLUSTER = 0xA,
  VM_DIRTY_BACKGROUND = 0xB,
  VM_DIRTY_RATIO = 0xC,
  VM_DIRTY_WB_CS = 0xD,
  VM_DIRTY_EXPIRE_CS = 0xE,
  VM_NR_PDFLUSH_THREADS = 0xF,
  VM_OVERCOMMIT_RATIO = 0x10,
  VM_PAGEBUF = 0x11,
  VM_HUGETLB_PAGES = 0x12,
  VM_SWAPPINESS = 0x13,
  VM_LOWMEM_RESERVE_RATIO = 0x14,
  VM_MIN_FREE_KBYTES = 0x15,
  VM_MAX_MAP_COUNT = 0x16,
  VM_LAPTOP_MODE = 0x17,
  VM_BLOCK_DUMP = 0x18,
  VM_HUGETLB_GROUP = 0x19,
  VM_VFS_CACHE_PRESSURE = 0x1A,
  VM_LEGACY_VA_LAYOUT = 0x1B,
  VM_SWAP_TOKEN_TIMEOUT = 0x1C,
  VM_DROP_PAGECACHE = 0x1D,
  VM_PERCPU_PAGELIST_FRACTION = 0x1E,
  VM_ZONE_RECLAIM_MODE = 0x1F,
  VM_MIN_UNMAPPED = 0x20,
  VM_PANIC_ON_OOM = 0x21,
  VM_VDSO_ENABLED = 0x22,
  VM_MIN_SLAB = 0x23,
};
00000004 union $4A79DFF647024094CE87A60332B16610
{
  __u32 start_id;
  __u32 prog_id;
  __u32 map_id;
  __u32 btf_id;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $4A79DFF647024094CE87A60332B16610.start_id __u32;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 $4A79DFF647024094CE87A60332B16610.prog_id __u32;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 $4A79DFF647024094CE87A60332B16610.map_id __u32;
//  3. 0000 0004 effalign(4) fda=0 bits=0000 $4A79DFF647024094CE87A60332B16610.btf_id __u32;
//          0004 effalign(4) sda=0 bits=0000 $4A79DFF647024094CE87A60332B16610 union packalign=0

00000004 enum $4B65E9CAA671A29AB236B2850E23C880 : unsigned __int32
{
  DEV_PARPORT_SPINTIME = 0x1,
  DEV_PARPORT_BASE_ADDR = 0x2,
  DEV_PARPORT_IRQ = 0x3,
  DEV_PARPORT_DMA = 0x4,
  DEV_PARPORT_MODES = 0x5,
  DEV_PARPORT_DEVICES = 0x6,
  DEV_PARPORT_AUTOPROBE = 0x10,
};
00000004 struct $4CE1142269C6BA11D3A4D858343DA2F7
{
  u16 locked_pending;
  u16 tail;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 $4CE1142269C6BA11D3A4D858343DA2F7.locked_pending u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 $4CE1142269C6BA11D3A4D858343DA2F7.tail u16;
//          0004 effalign(2) sda=0 bits=0000 $4CE1142269C6BA11D3A4D858343DA2F7 struct packalign=0

00000004 enum $4D591E22FE8A11A6C092068C1DE474D5 : unsigned __int32
{
  WQ_UNBOUND = 0x2,
  WQ_FREEZABLE = 0x4,
  WQ_MEM_RECLAIM = 0x8,
  WQ_HIGHPRI = 0x10,
  WQ_CPU_INTENSIVE = 0x20,
  WQ_SYSFS = 0x40,
  WQ_POWER_EFFICIENT = 0x80,
  __WQ_DRAINING = 0x10000,
  __WQ_ORDERED = 0x20000,
  __WQ_LEGACY = 0x40000,
  __WQ_ORDERED_EXPLICIT = 0x80000,
  WQ_MAX_ACTIVE = 0x200,
  WQ_MAX_UNBOUND_PER_CPU = 0x4,
  WQ_DFL_ACTIVE = 0x100,
};
00000004 enum $512660047B55412B2BAF31B0BB49255B : unsigned __int32
{
  BUS_ISA_MEM_BASE = 0x1,
  BUS_ISA_PORT_BASE = 0x2,
  BUS_ISA_PORT_SHIFT = 0x3,
};
00000028 struct $51362CFB81AC1A39C0D7F8CCE9E59377
{
  union
  {
    list_head slab_list;
    struct
    {
      page *next;
      int pages;
      int pobjects;
    };
  };
  kmem_cache *slab_cache;
  void *freelist;
  union
  {
    void *s_mem;
    unsigned __int64 counters;
    struct
    {
      unsigned __int32 inuse : 16;
      unsigned __int32 objects : 15;
      unsigned __int32 frozen : 1;
    };
  };
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $51362CFB81AC1A39C0D7F8CCE9E59377.$6930C4213C896AF8325D59FEE2871F03 $6930C4213C896AF8325D59FEE2871F03;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 $51362CFB81AC1A39C0D7F8CCE9E59377.slab_cache kmem_cache *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 $51362CFB81AC1A39C0D7F8CCE9E59377.freelist void *;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 $51362CFB81AC1A39C0D7F8CCE9E59377.$6E8202FA793B648AB1D21B30705B6617 $6E8202FA793B648AB1D21B30705B6617;
//          0028 effalign(8) sda=0 bits=0000 $51362CFB81AC1A39C0D7F8CCE9E59377 struct packalign=0

00000010 struct __attribute__((packed)) $5211084EA13AFCE1BC8B790544A28F9F
{
  __u64 reserved1;
  __u64 reserved2;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $5211084EA13AFCE1BC8B790544A28F9F.reserved1 __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 $5211084EA13AFCE1BC8B790544A28F9F.reserved2 __u64;
//          0010 effalign(1) sda=0 bits=0040 $5211084EA13AFCE1BC8B790544A28F9F struct packalign=0

00000004 enum $52593586F30D64AE5B28AA59437E3640 : unsigned __int32
{
  DISK_EVENT_MEDIA_CHANGE = 0x1,
  DISK_EVENT_EJECT_REQUEST = 0x2,
};
00000010 struct $52EB9FD98AFFF636B8D8273C5836D4A5
{
  void (__cdecl *_function)(sigval_t);
  void *_attribute;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $52EB9FD98AFFF636B8D8273C5836D4A5._function void (__cdecl *)(sigval_t);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $52EB9FD98AFFF636B8D8273C5836D4A5._attribute void *;
//          0010 effalign(8) sda=0 bits=0000 $52EB9FD98AFFF636B8D8273C5836D4A5 struct packalign=0

00000004 enum $534583194F03A437CB05609CF180A532 : unsigned __int32
{
  NET_IPV6_CONF = 0x10,
  NET_IPV6_NEIGH = 0x11,
  NET_IPV6_ROUTE = 0x12,
  NET_IPV6_ICMP = 0x13,
  NET_IPV6_BINDV6ONLY = 0x14,
  NET_IPV6_IP6FRAG_HIGH_THRESH = 0x15,
  NET_IPV6_IP6FRAG_LOW_THRESH = 0x16,
  NET_IPV6_IP6FRAG_TIME = 0x17,
  NET_IPV6_IP6FRAG_SECRET_INTERVAL = 0x18,
  NET_IPV6_MLD_MAX_MSF = 0x19,
};
00000004 enum $5360083879AC87D5226F57A4A0F46C43 : unsigned __int32
{
  EI_ETYPE_NONE = 0x0,
  EI_ETYPE_NULL = 0x1,
  EI_ETYPE_ERRNO = 0x2,
  EI_ETYPE_ERRNO_NULL = 0x3,
  EI_ETYPE_TRUE = 0x4,
};
00000004 enum $550AAD0D06A2C47FA73759B6530AED52 : unsigned __int32
{
  NET_NEIGH_MCAST_SOLICIT = 0x1,
  NET_NEIGH_UCAST_SOLICIT = 0x2,
  NET_NEIGH_APP_SOLICIT = 0x3,
  NET_NEIGH_RETRANS_TIME = 0x4,
  NET_NEIGH_REACHABLE_TIME = 0x5,
  NET_NEIGH_DELAY_PROBE_TIME = 0x6,
  NET_NEIGH_GC_STALE_TIME = 0x7,
  NET_NEIGH_UNRES_QLEN = 0x8,
  NET_NEIGH_PROXY_QLEN = 0x9,
  NET_NEIGH_ANYCAST_DELAY = 0xA,
  NET_NEIGH_PROXY_DELAY = 0xB,
  NET_NEIGH_LOCKTIME = 0xC,
  NET_NEIGH_GC_INTERVAL = 0xD,
  NET_NEIGH_GC_THRESH1 = 0xE,
  NET_NEIGH_GC_THRESH2 = 0xF,
  NET_NEIGH_GC_THRESH3 = 0x10,
  NET_NEIGH_RETRANS_TIME_MS = 0x11,
  NET_NEIGH_REACHABLE_TIME_MS = 0x12,
};
00000004 enum $56043FBF751FA02B184DBBEB9F9EC0C4 : unsigned __int32
{
  FS_DQ_LOOKUPS = 0x1,
  FS_DQ_DROPS = 0x2,
  FS_DQ_READS = 0x3,
  FS_DQ_WRITES = 0x4,
  FS_DQ_CACHE_HITS = 0x5,
  FS_DQ_ALLOCATED = 0x6,
  FS_DQ_FREE = 0x7,
  FS_DQ_SYNCS = 0x8,
  FS_DQ_WARNINGS = 0x9,
};
00000004 enum $564FE539A1D0653776DB6B6580CFEE4D : unsigned __int32
{
  NET_IPV4_CONF_FORWARDING = 0x1,
  NET_IPV4_CONF_MC_FORWARDING = 0x2,
  NET_IPV4_CONF_PROXY_ARP = 0x3,
  NET_IPV4_CONF_ACCEPT_REDIRECTS = 0x4,
  NET_IPV4_CONF_SECURE_REDIRECTS = 0x5,
  NET_IPV4_CONF_SEND_REDIRECTS = 0x6,
  NET_IPV4_CONF_SHARED_MEDIA = 0x7,
  NET_IPV4_CONF_RP_FILTER = 0x8,
  NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 0x9,
  NET_IPV4_CONF_BOOTP_RELAY = 0xA,
  NET_IPV4_CONF_LOG_MARTIANS = 0xB,
  NET_IPV4_CONF_TAG = 0xC,
  NET_IPV4_CONF_ARPFILTER = 0xD,
  NET_IPV4_CONF_MEDIUM_ID = 0xE,
  NET_IPV4_CONF_NOXFRM = 0xF,
  NET_IPV4_CONF_NOPOLICY = 0x10,
  NET_IPV4_CONF_FORCE_IGMP_VERSION = 0x11,
  NET_IPV4_CONF_ARP_ANNOUNCE = 0x12,
  NET_IPV4_CONF_ARP_IGNORE = 0x13,
  NET_IPV4_CONF_PROMOTE_SECONDARIES = 0x14,
  NET_IPV4_CONF_ARP_ACCEPT = 0x15,
  NET_IPV4_CONF_ARP_NOTIFY = 0x16,
};
00000004 enum $596FAD39ADBF5BB4571CF5330A90C7F8 : unsigned __int32
{
  NET_LLC2 = 0x1,
  NET_LLC_STATION = 0x2,
};
00000004 enum $5999AE35E101408E5D03CC2611A2D199 : unsigned __int32
{
  NET_LLC_STATION_ACK_TIMEOUT = 0x1,
};
00000018 struct $599CAA50DA31E34ACF419229BA5AB7AB
{
  clockid_t clockid;
  timespec_type type;
  union
  {
    __kernel_timespec *rmtp;
    old_timespec32 *compat_rmtp;
  };
  u64 expires;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $599CAA50DA31E34ACF419229BA5AB7AB.clockid clockid_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $599CAA50DA31E34ACF419229BA5AB7AB.type timespec_type;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 $599CAA50DA31E34ACF419229BA5AB7AB.$652664C735688D98B493330420B0A39D $652664C735688D98B493330420B0A39D;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 $599CAA50DA31E34ACF419229BA5AB7AB.expires u64;
//          0018 effalign(8) sda=0 bits=0000 $599CAA50DA31E34ACF419229BA5AB7AB struct packalign=0

00000004 enum $59BCDDE0051E086138E1DDF7B528786B : unsigned __int32
{
  IOPRIO_WHO_PROCESS = 0x1,
  IOPRIO_WHO_PGRP = 0x2,
  IOPRIO_WHO_USER = 0x3,
};
00000018 struct $5D35329CDE05C1838A937F7339567B02
{
  arch_uprobe_task autask;
  unsigned __int64 vaddr;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $5D35329CDE05C1838A937F7339567B02.autask arch_uprobe_task;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 $5D35329CDE05C1838A937F7339567B02.vaddr unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 $5D35329CDE05C1838A937F7339567B02 struct packalign=0

00000010 struct $5D69F5B72CCA61C8CE3CD8BAA8412A47
{
  unsigned __int64 miss;
  unsigned __int64 hit;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $5D69F5B72CCA61C8CE3CD8BAA8412A47.miss unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $5D69F5B72CCA61C8CE3CD8BAA8412A47.hit unsigned __int64;
//          0010 effalign(8) sda=0 bits=0000 $5D69F5B72CCA61C8CE3CD8BAA8412A47 struct packalign=0

00000010 struct __attribute__((packed)) $5E18C62100CCF68E4E5E71C179E6A3BF
{
  __u16 id;
  __u64 lun;
  __u16 reserved1;
  __u32 reserved2;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 $5E18C62100CCF68E4E5E71C179E6A3BF.id __u16;
//  1. 0002 0008 effalign(1) fda=0 bits=0000 $5E18C62100CCF68E4E5E71C179E6A3BF.lun __u64;
//  2. 000A 0002 effalign(1) fda=0 bits=0000 $5E18C62100CCF68E4E5E71C179E6A3BF.reserved1 __u16;
//  3. 000C 0004 effalign(1) fda=0 bits=0000 $5E18C62100CCF68E4E5E71C179E6A3BF.reserved2 __u32;
//          0010 effalign(1) sda=0 bits=0040 $5E18C62100CCF68E4E5E71C179E6A3BF struct packalign=0

00000004 enum $60A10810DFA7A3DBF77266120B2AFEDE : unsigned __int32
{
  NET_IPV4_NF_CONNTRACK_MAX = 0x1,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 0x2,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 0x3,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 0x4,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 0x5,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 0x6,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 0x7,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 0x8,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 0x9,
  NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 0xA,
  NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 0xB,
  NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 0xC,
  NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 0xD,
  NET_IPV4_NF_CONNTRACK_BUCKETS = 0xE,
  NET_IPV4_NF_CONNTRACK_LOG_INVALID = 0xF,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 0x10,
  NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 0x11,
  NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 0x12,
  NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 0x13,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 0x14,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 0x15,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 0x16,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 0x17,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 0x18,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 0x19,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 0x1A,
  NET_IPV4_NF_CONNTRACK_COUNT = 0x1B,
  NET_IPV4_NF_CONNTRACK_CHECKSUM = 0x1C,
};
00000004 enum $60B62F48899D961D20EBC59F7F1840D8 : unsigned __int32
{
  DEV_CDROM = 0x1,
  DEV_HWMON = 0x2,
  DEV_PARPORT = 0x3,
  DEV_RAID = 0x4,
  DEV_MAC_HID = 0x5,
  DEV_SCSI = 0x6,
  DEV_IPMI = 0x7,
};
00000004 enum $61095D04A8B2D7F56ABAF771B351C10B : unsigned __int32
{
  IRQC_IS_HARDIRQ = 0x0,
  IRQC_IS_NESTED = 0x1,
};
00000004 enum $616F435F032F8A816FE9E5F141D3010F : unsigned __int32
{
  DEV_RAID_SPEED_LIMIT_MIN = 0x1,
  DEV_RAID_SPEED_LIMIT_MAX = 0x2,
};
00000010 struct __attribute__((packed)) $6333D439F89A1B26526669C96B2EE017
{
  __u8 device;
  __u8 lun;
  __u8 reserved1;
  __u8 reserved2;
  __u32 reserved3;
  __u64 reserved4;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.device __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.lun __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.reserved1 __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.reserved2 __u8;
//  4. 0004 0004 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.reserved3 __u32;
//  5. 0008 0008 effalign(1) fda=0 bits=0000 $6333D439F89A1B26526669C96B2EE017.reserved4 __u64;
//          0010 effalign(1) sda=0 bits=0040 $6333D439F89A1B26526669C96B2EE017 struct packalign=0

00000008 union $652664C735688D98B493330420B0A39D
{
  __kernel_timespec *rmtp;
  old_timespec32 *compat_rmtp;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $652664C735688D98B493330420B0A39D.rmtp __kernel_timespec *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 $652664C735688D98B493330420B0A39D.compat_rmtp old_timespec32 *;
//          0008 effalign(8) sda=0 bits=0000 $652664C735688D98B493330420B0A39D union packalign=0

00000004 enum $680DC75DD138978FA3CB363B51D0585B : unsigned __int32
{
  PTY_MAX = 0x1,
  PTY_NR = 0x2,
};
00000010 union $6930C4213C896AF8325D59FEE2871F03
{
  list_head slab_list;
  struct
  {
    page *next;
    int pages;
    int pobjects;
  };
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $6930C4213C896AF8325D59FEE2871F03.slab_list list_head;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 $6930C4213C896AF8325D59FEE2871F03.$28099A4E4B70B6D11EF5DB4F925A6FFF $28099A4E4B70B6D11EF5DB4F925A6FFF;
//          0010 effalign(8) sda=0 bits=0000 $6930C4213C896AF8325D59FEE2871F03 union packalign=0

00000018 struct $69569C1B850793C50E7B56EB6E59F135
{
  ctl_table *ctl_table;
  int used;
  int count;
  int nreg;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $69569C1B850793C50E7B56EB6E59F135.ctl_table ctl_table *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 $69569C1B850793C50E7B56EB6E59F135.used int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 $69569C1B850793C50E7B56EB6E59F135.count int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 $69569C1B850793C50E7B56EB6E59F135.nreg int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 $69569C1B850793C50E7B56EB6E59F135 struct packalign=0

00000004 enum $6D848B1F08A515B4F2CE8369AFAA7D22 : unsigned __int32
{
  CTL_BUS_ISA = 0x1,
};
00000008 union $6E8202FA793B648AB1D21B30705B6617
{
  void *s_mem;
  unsigned __int64 counters;
  struct
  {
    unsigned __int32 inuse : 16;
    unsigned __int32 objects : 15;
    unsigned __int32 frozen : 1;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $6E8202FA793B648AB1D21B30705B6617.s_mem void *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 $6E8202FA793B648AB1D21B30705B6617.counters unsigned __int64;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 $6E8202FA793B648AB1D21B30705B6617.$34157686918C88ADDB14C11D63ECF3D3 $34157686918C88ADDB14C11D63ECF3D3;
//          0008 effalign(8) sda=0 bits=0000 $6E8202FA793B648AB1D21B30705B6617 union packalign=0

00000010 struct $6F3630504A23BCE969F37C5A473E0AD7
{
  unsigned __int64 dma_addr[2];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $6F3630504A23BCE969F37C5A473E0AD7.dma_addr unsigned __int64[2];
//          0010 effalign(8) sda=0 bits=0000 $6F3630504A23BCE969F37C5A473E0AD7 struct packalign=0

00000004 enum $703B5ABC350937E66EAF60AD5B95930B : unsigned __int32
{
  ICQ_EXITED = 0x4,
  ICQ_DESTROYED = 0x8,
};
00000004 enum $709DF5F3F56DB7DD3E16F05CC6E604B3 : unsigned __int32
{
  NET_DECNET_NODE_TYPE = 0x1,
  NET_DECNET_NODE_ADDRESS = 0x2,
  NET_DECNET_NODE_NAME = 0x3,
  NET_DECNET_DEFAULT_DEVICE = 0x4,
  NET_DECNET_TIME_WAIT = 0x5,
  NET_DECNET_DN_COUNT = 0x6,
  NET_DECNET_DI_COUNT = 0x7,
  NET_DECNET_DR_COUNT = 0x8,
  NET_DECNET_DST_GC_INTERVAL = 0x9,
  NET_DECNET_CONF = 0xA,
  NET_DECNET_NO_FC_MAX_CWND = 0xB,
  NET_DECNET_MEM = 0xC,
  NET_DECNET_RMEM = 0xD,
  NET_DECNET_WMEM = 0xE,
  NET_DECNET_DEBUG_LEVEL = 0xFF,
};
00000004 enum $73F457F405A5D51C3FDDF95473AB392E : unsigned __int32
{
  NET_CORE_WMEM_MAX = 0x1,
  NET_CORE_RMEM_MAX = 0x2,
  NET_CORE_WMEM_DEFAULT = 0x3,
  NET_CORE_RMEM_DEFAULT = 0x4,
  NET_CORE_MAX_BACKLOG = 0x6,
  NET_CORE_FASTROUTE = 0x7,
  NET_CORE_MSG_COST = 0x8,
  NET_CORE_MSG_BURST = 0x9,
  NET_CORE_OPTMEM_MAX = 0xA,
  NET_CORE_HOT_LIST_LENGTH = 0xB,
  NET_CORE_DIVERT_VERSION = 0xC,
  NET_CORE_NO_CONG_THRESH = 0xD,
  NET_CORE_NO_CONG = 0xE,
  NET_CORE_LO_CONG = 0xF,
  NET_CORE_MOD_CONG = 0x10,
  NET_CORE_DEV_WEIGHT = 0x11,
  NET_CORE_SOMAXCONN = 0x12,
  NET_CORE_BUDGET = 0x13,
  NET_CORE_AEVENT_ETIME = 0x14,
  NET_CORE_AEVENT_RSEQTH = 0x15,
  NET_CORE_WARNINGS = 0x16,
};
00000004 enum $76602C1D950947A0A79A611E6C37E6C0 : unsigned __int32
{
  UNAME26 = 0x20000,
  ADDR_NO_RANDOMIZE = 0x40000,
  FDPIC_FUNCPTRS = 0x80000,
  MMAP_PAGE_ZERO = 0x100000,
  ADDR_COMPAT_LAYOUT = 0x200000,
  READ_IMPLIES_EXEC = 0x400000,
  ADDR_LIMIT_32BIT = 0x800000,
  SHORT_INODE = 0x1000000,
  WHOLE_SECONDS = 0x2000000,
  STICKY_TIMEOUTS = 0x4000000,
  ADDR_LIMIT_3GB = 0x8000000,
};
00000004 enum $77F19FD6E96F4DCDF889CD607B5C3F5D : unsigned __int32
{
  KERNEL_PARAM_OPS_FL_NOARG = 0x1,
};
00000008 struct $792D8DB77BFDC553877F8E79F73D09AC
{
  u32 hid;
  u32 uid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $792D8DB77BFDC553877F8E79F73D09AC.hid u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $792D8DB77BFDC553877F8E79F73D09AC.uid u32;
//          0008 effalign(4) sda=0 bits=0000 $792D8DB77BFDC553877F8E79F73D09AC struct packalign=0

00000010 struct $7A2D00F1EDED085A322EED81EE9DDD1F
{
  unsigned __int64 correct;
  unsigned __int64 incorrect;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $7A2D00F1EDED085A322EED81EE9DDD1F.correct unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $7A2D00F1EDED085A322EED81EE9DDD1F.incorrect unsigned __int64;
//          0010 effalign(8) sda=0 bits=0000 $7A2D00F1EDED085A322EED81EE9DDD1F struct packalign=0

00000004 enum $7A4A42E21375D24B0EC7301047402AA2 : unsigned __int32
{
  KERN_OSTYPE = 0x1,
  KERN_OSRELEASE = 0x2,
  KERN_OSREV = 0x3,
  KERN_VERSION = 0x4,
  KERN_SECUREMASK = 0x5,
  KERN_PROF = 0x6,
  KERN_NODENAME = 0x7,
  KERN_DOMAINNAME = 0x8,
  KERN_PANIC = 0xF,
  KERN_REALROOTDEV = 0x10,
  KERN_SPARC_REBOOT = 0x15,
  KERN_CTLALTDEL = 0x16,
  KERN_PRINTK = 0x17,
  KERN_NAMETRANS = 0x18,
  KERN_PPC_HTABRECLAIM = 0x19,
  KERN_PPC_ZEROPAGED = 0x1A,
  KERN_PPC_POWERSAVE_NAP = 0x1B,
  KERN_MODPROBE = 0x1C,
  KERN_SG_BIG_BUFF = 0x1D,
  KERN_ACCT = 0x1E,
  KERN_PPC_L2CR = 0x1F,
  KERN_RTSIGNR = 0x20,
  KERN_RTSIGMAX = 0x21,
  KERN_SHMMAX = 0x22,
  KERN_MSGMAX = 0x23,
  KERN_MSGMNB = 0x24,
  KERN_MSGPOOL = 0x25,
  KERN_SYSRQ = 0x26,
  KERN_MAX_THREADS = 0x27,
  KERN_RANDOM = 0x28,
  KERN_SHMALL = 0x29,
  KERN_MSGMNI = 0x2A,
  KERN_SEM = 0x2B,
  KERN_SPARC_STOP_A = 0x2C,
  KERN_SHMMNI = 0x2D,
  KERN_OVERFLOWUID = 0x2E,
  KERN_OVERFLOWGID = 0x2F,
  KERN_SHMPATH = 0x30,
  KERN_HOTPLUG = 0x31,
  KERN_IEEE_EMULATION_WARNINGS = 0x32,
  KERN_S390_USER_DEBUG_LOGGING = 0x33,
  KERN_CORE_USES_PID = 0x34,
  KERN_TAINTED = 0x35,
  KERN_CADPID = 0x36,
  KERN_PIDMAX = 0x37,
  KERN_CORE_PATTERN = 0x38,
  KERN_PANIC_ON_OOPS = 0x39,
  KERN_HPPA_PWRSW = 0x3A,
  KERN_HPPA_UNALIGNED = 0x3B,
  KERN_PRINTK_RATELIMIT = 0x3C,
  KERN_PRINTK_RATELIMIT_BURST = 0x3D,
  KERN_PTY = 0x3E,
  KERN_NGROUPS_MAX = 0x3F,
  KERN_SPARC_SCONS_PWROFF = 0x40,
  KERN_HZ_TIMER = 0x41,
  KERN_UNKNOWN_NMI_PANIC = 0x42,
  KERN_BOOTLOADER_TYPE = 0x43,
  KERN_RANDOMIZE = 0x44,
  KERN_SETUID_DUMPABLE = 0x45,
  KERN_SPIN_RETRY = 0x46,
  KERN_ACPI_VIDEO_FLAGS = 0x47,
  KERN_IA64_UNALIGNED = 0x48,
  KERN_COMPAT_LOG = 0x49,
  KERN_MAX_LOCK_DEPTH = 0x4A,
  KERN_NMI_WATCHDOG = 0x4B,
  KERN_PANIC_ON_NMI = 0x4C,
  KERN_PANIC_ON_WARN = 0x4D,
  KERN_PANIC_PRINT = 0x4E,
};
00000004 enum $7CE2251B09B7020AF5AF21F04A24179B : unsigned __int32
{
  NET_IPV4_FORWARD = 0x8,
  NET_IPV4_DYNADDR = 0x9,
  NET_IPV4_CONF = 0x10,
  NET_IPV4_NEIGH = 0x11,
  NET_IPV4_ROUTE = 0x12,
  NET_IPV4_FIB_HASH = 0x13,
  NET_IPV4_NETFILTER = 0x14,
  NET_IPV4_TCP_TIMESTAMPS = 0x21,
  NET_IPV4_TCP_WINDOW_SCALING = 0x22,
  NET_IPV4_TCP_SACK = 0x23,
  NET_IPV4_TCP_RETRANS_COLLAPSE = 0x24,
  NET_IPV4_DEFAULT_TTL = 0x25,
  NET_IPV4_AUTOCONFIG = 0x26,
  NET_IPV4_NO_PMTU_DISC = 0x27,
  NET_IPV4_TCP_SYN_RETRIES = 0x28,
  NET_IPV4_IPFRAG_HIGH_THRESH = 0x29,
  NET_IPV4_IPFRAG_LOW_THRESH = 0x2A,
  NET_IPV4_IPFRAG_TIME = 0x2B,
  NET_IPV4_TCP_MAX_KA_PROBES = 0x2C,
  NET_IPV4_TCP_KEEPALIVE_TIME = 0x2D,
  NET_IPV4_TCP_KEEPALIVE_PROBES = 0x2E,
  NET_IPV4_TCP_RETRIES1 = 0x2F,
  NET_IPV4_TCP_RETRIES2 = 0x30,
  NET_IPV4_TCP_FIN_TIMEOUT = 0x31,
  NET_IPV4_IP_MASQ_DEBUG = 0x32,
  NET_TCP_SYNCOOKIES = 0x33,
  NET_TCP_STDURG = 0x34,
  NET_TCP_RFC1337 = 0x35,
  NET_TCP_SYN_TAILDROP = 0x36,
  NET_TCP_MAX_SYN_BACKLOG = 0x37,
  NET_IPV4_LOCAL_PORT_RANGE = 0x38,
  NET_IPV4_ICMP_ECHO_IGNORE_ALL = 0x39,
  NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 0x3A,
  NET_IPV4_ICMP_SOURCEQUENCH_RATE = 0x3B,
  NET_IPV4_ICMP_DESTUNREACH_RATE = 0x3C,
  NET_IPV4_ICMP_TIMEEXCEED_RATE = 0x3D,
  NET_IPV4_ICMP_PARAMPROB_RATE = 0x3E,
  NET_IPV4_ICMP_ECHOREPLY_RATE = 0x3F,
  NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 0x40,
  NET_IPV4_IGMP_MAX_MEMBERSHIPS = 0x41,
  NET_TCP_TW_RECYCLE = 0x42,
  NET_IPV4_ALWAYS_DEFRAG = 0x43,
  NET_IPV4_TCP_KEEPALIVE_INTVL = 0x44,
  NET_IPV4_INET_PEER_THRESHOLD = 0x45,
  NET_IPV4_INET_PEER_MINTTL = 0x46,
  NET_IPV4_INET_PEER_MAXTTL = 0x47,
  NET_IPV4_INET_PEER_GC_MINTIME = 0x48,
  NET_IPV4_INET_PEER_GC_MAXTIME = 0x49,
  NET_TCP_ORPHAN_RETRIES = 0x4A,
  NET_TCP_ABORT_ON_OVERFLOW = 0x4B,
  NET_TCP_SYNACK_RETRIES = 0x4C,
  NET_TCP_MAX_ORPHANS = 0x4D,
  NET_TCP_MAX_TW_BUCKETS = 0x4E,
  NET_TCP_FACK = 0x4F,
  NET_TCP_REORDERING = 0x50,
  NET_TCP_ECN = 0x51,
  NET_TCP_DSACK = 0x52,
  NET_TCP_MEM = 0x53,
  NET_TCP_WMEM = 0x54,
  NET_TCP_RMEM = 0x55,
  NET_TCP_APP_WIN = 0x56,
  NET_TCP_ADV_WIN_SCALE = 0x57,
  NET_IPV4_NONLOCAL_BIND = 0x58,
  NET_IPV4_ICMP_RATELIMIT = 0x59,
  NET_IPV4_ICMP_RATEMASK = 0x5A,
  NET_TCP_TW_REUSE = 0x5B,
  NET_TCP_FRTO = 0x5C,
  NET_TCP_LOW_LATENCY = 0x5D,
  NET_IPV4_IPFRAG_SECRET_INTERVAL = 0x5E,
  NET_IPV4_IGMP_MAX_MSF = 0x60,
  NET_TCP_NO_METRICS_SAVE = 0x61,
  NET_TCP_DEFAULT_WIN_SCALE = 0x69,
  NET_TCP_MODERATE_RCVBUF = 0x6A,
  NET_TCP_TSO_WIN_DIVISOR = 0x6B,
  NET_TCP_BIC_BETA = 0x6C,
  NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 0x6D,
  NET_TCP_CONG_CONTROL = 0x6E,
  NET_TCP_ABC = 0x6F,
  NET_IPV4_IPFRAG_MAX_DIST = 0x70,
  NET_TCP_MTU_PROBING = 0x71,
  NET_TCP_BASE_MSS = 0x72,
  NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 0x73,
  NET_TCP_DMA_COPYBREAK = 0x74,
  NET_TCP_SLOW_START_AFTER_IDLE = 0x75,
  NET_CIPSOV4_CACHE_ENABLE = 0x76,
  NET_CIPSOV4_CACHE_BUCKET_SIZE = 0x77,
  NET_CIPSOV4_RBM_OPTFMT = 0x78,
  NET_CIPSOV4_RBM_STRICTVALID = 0x79,
  NET_TCP_AVAIL_CONG_CONTROL = 0x7A,
  NET_TCP_ALLOWED_CONG_CONTROL = 0x7B,
  NET_TCP_MAX_SSTHRESH = 0x7C,
  NET_TCP_FRTO_RESPONSE = 0x7D,
};
00000004 enum $7CE73F2334FEBC06325C41F1D4EDE363 : __int32
{
  NET_DECNET_CONF_LOOPBACK = 0xFFFFFFFE,
  NET_DECNET_CONF_DDCMP = 0xFFFFFFFD,
  NET_DECNET_CONF_PPP = 0xFFFFFFFC,
  NET_DECNET_CONF_X25 = 0xFFFFFFFB,
  NET_DECNET_CONF_GRE = 0xFFFFFFFA,
  NET_DECNET_CONF_ETHER = 0xFFFFFFF9,
};
00000008 union $817ABCB5B9F3F86FCBFB06C6B3A4AA5A
{
  mm_struct *pt_mm;
  atomic_t pt_frag_refcount;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $817ABCB5B9F3F86FCBFB06C6B3A4AA5A.pt_mm mm_struct *;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 $817ABCB5B9F3F86FCBFB06C6B3A4AA5A.pt_frag_refcount atomic_t;
//          0008 effalign(8) sda=0 bits=0000 $817ABCB5B9F3F86FCBFB06C6B3A4AA5A union packalign=0

00000024 struct $82BA7F6B6A9107A3E90C483C03471D56
{
  __be32 saddr[4];
  __be32 daddr[4];
  __be16 sport;
  __be16 dport;
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 $82BA7F6B6A9107A3E90C483C03471D56.saddr __be32[4];
//  1. 0010 0010 effalign(4) fda=0 bits=0000 $82BA7F6B6A9107A3E90C483C03471D56.daddr __be32[4];
//  2. 0020 0002 effalign(2) fda=0 bits=0000 $82BA7F6B6A9107A3E90C483C03471D56.sport __be16;
//  3. 0022 0002 effalign(2) fda=0 bits=0000 $82BA7F6B6A9107A3E90C483C03471D56.dport __be16;
//          0024 effalign(4) sda=0 bits=0000 $82BA7F6B6A9107A3E90C483C03471D56 struct packalign=0

00000008 struct $84C44666FD2523EEB7381B988A0293BE
{
  __be32 ipv4_src;
  __be32 ipv4_dst;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $84C44666FD2523EEB7381B988A0293BE.ipv4_src __be32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $84C44666FD2523EEB7381B988A0293BE.ipv4_dst __be32;
//          0008 effalign(4) sda=0 bits=0000 $84C44666FD2523EEB7381B988A0293BE struct packalign=0

00000004 enum $84DD7F43B858C66E6EC7FD290C403DAF : unsigned __int32
{
  DISK_EVENT_FLAG_POLL = 0x1,
  DISK_EVENT_FLAG_UEVENT = 0x2,
};
00000004 enum $853ECE93C1DB30EE0E7CFCC8AED03E2B : unsigned __int32
{
  PER_LINUX = 0x0,
  PER_LINUX_32BIT = 0x800000,
  PER_LINUX_FDPIC = 0x80000,
  PER_SVR4 = 0x4100001,
  PER_SVR3 = 0x5000002,
  PER_SCOSVR3 = 0x7000003,
  PER_OSR5 = 0x6000003,
  PER_WYSEV386 = 0x5000004,
  PER_ISCR4 = 0x4000005,
  PER_BSD = 0x6,
  PER_SUNOS = 0x4000006,
  PER_XENIX = 0x5000007,
  PER_LINUX32 = 0x8,
  PER_LINUX32_3GB = 0x8000008,
  PER_IRIX32 = 0x4000009,
  PER_IRIXN32 = 0x400000A,
  PER_IRIX64 = 0x400000B,
  PER_RISCOS = 0xC,
  PER_SOLARIS = 0x400000D,
  PER_UW7 = 0x410000E,
  PER_OSF4 = 0xF,
  PER_HPUX = 0x10,
  PER_MASK = 0xFF,
};
00000004 enum $85AB55CAC5A6CED4E63ABAA78F522968 : unsigned __int32
{
  QUOTA_NL_C_UNSPEC = 0x0,
  QUOTA_NL_C_WARNING = 0x1,
  __QUOTA_NL_C_MAX = 0x2,
};
00000004 enum $86BD942A5D2993CC42377410B601BBDB : unsigned __int32
{
  false = 0x0,
  true = 0x1,
};
00000008 struct $86C47FF540A4A51F0C907547963D9CB9
{
  s32 offs;
  u8 ilen;
  u8 opc1;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $86C47FF540A4A51F0C907547963D9CB9.offs s32;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 $86C47FF540A4A51F0C907547963D9CB9.ilen u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 $86C47FF540A4A51F0C907547963D9CB9.opc1 u8;
//          0006 unpadded_size
//          0008 effalign(4) sda=0 bits=0000 $86C47FF540A4A51F0C907547963D9CB9 struct packalign=0

00000004 enum $86D0ABDFA99038684D0DD91396445982 : unsigned __int32
{
  KERNEL_PARAM_FL_UNSAFE = 0x1,
  KERNEL_PARAM_FL_HWPARAM = 0x2,
};
00000004 enum $8A312B2D78DB719AC82A393A5A941300 : unsigned __int32
{
  IRQCHIP_FWNODE_REAL = 0x0,
  IRQCHIP_FWNODE_NAMED = 0x1,
  IRQCHIP_FWNODE_NAMED_ID = 0x2,
};
00000004 enum $8ABAFD08B9948368318FB033F2287D90 : unsigned __int32
{
  XA_CHECK_SCHED = 0x1000,
};
00000004 enum $8AC3DD55B09FDA3ECC26ED8839BEC97F : unsigned __int32
{
  BPF_SOCK_OPS_VOID = 0x0,
  BPF_SOCK_OPS_TIMEOUT_INIT = 0x1,
  BPF_SOCK_OPS_RWND_INIT = 0x2,
  BPF_SOCK_OPS_TCP_CONNECT_CB = 0x3,
  BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 0x4,
  BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 0x5,
  BPF_SOCK_OPS_NEEDS_ECN = 0x6,
  BPF_SOCK_OPS_BASE_RTT = 0x7,
  BPF_SOCK_OPS_RTO_CB = 0x8,
  BPF_SOCK_OPS_RETRANS_CB = 0x9,
  BPF_SOCK_OPS_STATE_CB = 0xA,
  BPF_SOCK_OPS_TCP_LISTEN_CB = 0xB,
  BPF_SOCK_OPS_RTT_CB = 0xC,
};
00000004 enum $8D68C32ED054832757E63F0A732EEA24 : unsigned __int32
{
  ABI_DEFHANDLER_COFF = 0x1,
  ABI_DEFHANDLER_ELF = 0x2,
  ABI_DEFHANDLER_LCALL7 = 0x3,
  ABI_DEFHANDLER_LIBCSO = 0x4,
  ABI_TRACE = 0x5,
  ABI_FAKE_UTSNAME = 0x6,
};
00000004 enum $8EE75ACFE4C7E25E8006D062E16DEF3C : unsigned __int32
{
  MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 0xC,
  SECTION_INFO = 0xC,
  MIX_SECTION_INFO = 0xD,
  NODE_INFO = 0xE,
  MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = 0xE,
};
00000004 enum $8F79D9D84589DB364612B4CE8A4916F1 : unsigned __int32
{
  DOS_EXTENDED_PARTITION = 0x5,
  LINUX_EXTENDED_PARTITION = 0x85,
  WIN98_EXTENDED_PARTITION = 0xF,
  SUN_WHOLE_DISK = 0x5,
  LINUX_SWAP_PARTITION = 0x82,
  LINUX_DATA_PARTITION = 0x83,
  LINUX_LVM_PARTITION = 0x8E,
  LINUX_RAID_PARTITION = 0xFD,
  SOLARIS_X86_PARTITION = 0x82,
  NEW_SOLARIS_X86_PARTITION = 0xBF,
  DM6_AUX1PARTITION = 0x51,
  DM6_AUX3PARTITION = 0x53,
  DM6_PARTITION = 0x54,
  EZD_PARTITION = 0x55,
  FREEBSD_PARTITION = 0xA5,
  OPENBSD_PARTITION = 0xA6,
  NETBSD_PARTITION = 0xA9,
  BSDI_PARTITION = 0xB7,
  MINIX_PARTITION = 0x81,
  UNIXWARE_PARTITION = 0x63,
};
00000078 struct $90254D87D549C40300494CBC395EE945
{
  alarm alarmtimer;
};
//  0. 0000 0078 effalign(8) fda=0 bits=0000 $90254D87D549C40300494CBC395EE945.alarmtimer alarm;
//          0078 effalign(8) sda=0 bits=0000 $90254D87D549C40300494CBC395EE945 struct packalign=0

00000008 struct __attribute__((packed)) $917BCA6048F928E1199E2CDF8EF12D5D
{
  __u8 bus;
  __u8 slot;
  __u8 function;
  __u8 channel;
  __u32 reserved;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $917BCA6048F928E1199E2CDF8EF12D5D.bus __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $917BCA6048F928E1199E2CDF8EF12D5D.slot __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 $917BCA6048F928E1199E2CDF8EF12D5D.function __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 $917BCA6048F928E1199E2CDF8EF12D5D.channel __u8;
//  4. 0004 0004 effalign(1) fda=0 bits=0000 $917BCA6048F928E1199E2CDF8EF12D5D.reserved __u32;
//          0008 effalign(1) sda=0 bits=0040 $917BCA6048F928E1199E2CDF8EF12D5D struct packalign=0

00000004 enum $920EC0BBA3FEB6A91852241075E3F405 : unsigned __int32
{
  IORES_MAP_SYSTEM_RAM = 0x1,
  IORES_MAP_ENCRYPTED = 0x2,
};
00000004 enum $92BBB68DB384BCA758C7B6186973B9DA : unsigned __int32
{
  NET_NF_CONNTRACK_MAX = 0x1,
  NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 0x2,
  NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 0x3,
  NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 0x4,
  NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 0x5,
  NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 0x6,
  NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 0x7,
  NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 0x8,
  NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 0x9,
  NET_NF_CONNTRACK_UDP_TIMEOUT = 0xA,
  NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 0xB,
  NET_NF_CONNTRACK_ICMP_TIMEOUT = 0xC,
  NET_NF_CONNTRACK_GENERIC_TIMEOUT = 0xD,
  NET_NF_CONNTRACK_BUCKETS = 0xE,
  NET_NF_CONNTRACK_LOG_INVALID = 0xF,
  NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 0x10,
  NET_NF_CONNTRACK_TCP_LOOSE = 0x11,
  NET_NF_CONNTRACK_TCP_BE_LIBERAL = 0x12,
  NET_NF_CONNTRACK_TCP_MAX_RETRANS = 0x13,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 0x14,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 0x15,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 0x16,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 0x17,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 0x18,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 0x19,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 0x1A,
  NET_NF_CONNTRACK_COUNT = 0x1B,
  NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 0x1C,
  NET_NF_CONNTRACK_FRAG6_TIMEOUT = 0x1D,
  NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 0x1E,
  NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 0x1F,
  NET_NF_CONNTRACK_CHECKSUM = 0x20,
};
00000004 enum $9378181ED114762C16D6A0CA075A1AED : unsigned __int32
{
  DEV_PARPORT_DEFAULT_TIMESLICE = 0x1,
  DEV_PARPORT_DEFAULT_SPINTIME = 0x2,
};
00000010 struct __attribute__((packed)) $93C956B6D490774D97BADC09ACD6CEA4
{
  __u8 device;
  __u8 reserved1;
  __u16 reserved2;
  __u32 reserved3;
  __u64 reserved4;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $93C956B6D490774D97BADC09ACD6CEA4.device __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $93C956B6D490774D97BADC09ACD6CEA4.reserved1 __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 $93C956B6D490774D97BADC09ACD6CEA4.reserved2 __u16;
//  3. 0004 0004 effalign(1) fda=0 bits=0000 $93C956B6D490774D97BADC09ACD6CEA4.reserved3 __u32;
//  4. 0008 0008 effalign(1) fda=0 bits=0000 $93C956B6D490774D97BADC09ACD6CEA4.reserved4 __u64;
//          0010 effalign(1) sda=0 bits=0040 $93C956B6D490774D97BADC09ACD6CEA4 struct packalign=0

00000004 enum $996A157442774DB15D331DAB676978AB : __int32
{
  BAD_STACK = 0xFFFFFFFF,
  NOT_STACK = 0x0,
  GOOD_FRAME = 0x1,
  GOOD_STACK = 0x2,
};
00000008 struct $99E1C31D7C026F6F12847AB310A0B651
{
  u16 desc_len;
  char desc[6];
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 $99E1C31D7C026F6F12847AB310A0B651.desc_len u16;
//  1. 0002 0006 effalign(1) fda=0 bits=0000 $99E1C31D7C026F6F12847AB310A0B651.desc char[6];
//          0008 effalign(2) sda=0 bits=0000 $99E1C31D7C026F6F12847AB310A0B651 struct packalign=0

00000004 enum $9B7665AE312985EE65D541D8F377D77E : unsigned __int32
{
  IRQ_DOMAIN_FLAG_HIERARCHY = 0x1,
  IRQ_DOMAIN_NAME_ALLOCATED = 0x2,
  IRQ_DOMAIN_FLAG_IPI_PER_CPU = 0x4,
  IRQ_DOMAIN_FLAG_IPI_SINGLE = 0x8,
  IRQ_DOMAIN_FLAG_MSI = 0x10,
  IRQ_DOMAIN_FLAG_MSI_REMAP = 0x20,
  IRQ_DOMAIN_MSI_NOMASK_QUIRK = 0x40,
  IRQ_DOMAIN_FLAG_NONCORE = 0x10000,
};
00000004 enum $9CD6C74639A446D0BEB3AAB7E9A0E7A0 : unsigned __int32
{
  NET_IPX_PPROP_BROADCASTING = 0x1,
  NET_IPX_FORWARDING = 0x2,
};
00000004 enum $9DA96C2F69A1683D205BD20C634B5163 : unsigned __int32
{
  NET_DCCP_DEFAULT = 0x1,
};
00000004 enum $9F1C343F19E43E2C791976B81DDFE73F : unsigned __int32
{
  CTL_KERN = 0x1,
  CTL_VM = 0x2,
  CTL_NET = 0x3,
  CTL_PROC = 0x4,
  CTL_FS = 0x5,
  CTL_DEBUG = 0x6,
  CTL_DEV = 0x7,
  CTL_BUS = 0x8,
  CTL_ABI = 0x9,
  CTL_CPU = 0xA,
  CTL_ARLAN = 0xFE,
  CTL_S390DBF = 0x162D,
  CTL_SUNRPC = 0x1C51,
  CTL_PM = 0x26AB,
  CTL_FRV = 0x26AA,
};
00000028 struct $9F8590F102EB2841150ECC2E0574E358
{
  u32 *uaddr;
  u32 val;
  u32 flags;
  u32 bitset;
  u64 time;
  u32 *uaddr2;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.uaddr u32 *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.val u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.flags u32;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.bitset u32;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.time u64;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358.uaddr2 u32 *;
//          0028 effalign(8) sda=0 bits=0000 $9F8590F102EB2841150ECC2E0574E358 struct packalign=0

00000004 enum $A053D32692F1695D6D7D85526762485A : __int32
{
  DEV_PARPORT_DEVICES_ACTIVE = 0xFFFFFFFD,
};
00000010 struct __attribute__((packed)) $A325BF819B520A657BED1A4CCDD95F0C
{
  __u64 wwid;
  __u64 lun;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $A325BF819B520A657BED1A4CCDD95F0C.wwid __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 $A325BF819B520A657BED1A4CCDD95F0C.lun __u64;
//          0010 effalign(1) sda=0 bits=0040 $A325BF819B520A657BED1A4CCDD95F0C struct packalign=0

00000008 struct __attribute__((packed)) $A816B002F72288AE3D8ED110908EFED4
{
  __u16 base_address;
  __u16 reserved1;
  __u32 reserved2;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 $A816B002F72288AE3D8ED110908EFED4.base_address __u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 $A816B002F72288AE3D8ED110908EFED4.reserved1 __u16;
//  2. 0004 0004 effalign(1) fda=0 bits=0000 $A816B002F72288AE3D8ED110908EFED4.reserved2 __u32;
//          0008 effalign(1) sda=0 bits=0040 $A816B002F72288AE3D8ED110908EFED4 struct packalign=0

00000020 struct $A871915AF794C75F2AAD498C00BC3826
{
  unsigned __int64 _compound_pad_1;
  unsigned __int64 _compound_pad_2;
  list_head deferred_list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $A871915AF794C75F2AAD498C00BC3826._compound_pad_1 unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $A871915AF794C75F2AAD498C00BC3826._compound_pad_2 unsigned __int64;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 $A871915AF794C75F2AAD498C00BC3826.deferred_list list_head;
//          0020 effalign(8) sda=0 bits=0000 $A871915AF794C75F2AAD498C00BC3826 struct packalign=0

0000000C struct $A9F29324AF96E616719CBC495F44E56E
{
  __be32 saddr;
  __be32 daddr;
  __be16 sport;
  __be16 dport;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $A9F29324AF96E616719CBC495F44E56E.saddr __be32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $A9F29324AF96E616719CBC495F44E56E.daddr __be32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 $A9F29324AF96E616719CBC495F44E56E.sport __be16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 $A9F29324AF96E616719CBC495F44E56E.dport __be16;
//          000C effalign(4) sda=0 bits=0000 $A9F29324AF96E616719CBC495F44E56E struct packalign=0

00000018 struct $AB2BA2D8FED8EF3F1B006727337A4822
{
  io_cq *icq;
  void *priv[2];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $AB2BA2D8FED8EF3F1B006727337A4822.icq io_cq *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 $AB2BA2D8FED8EF3F1B006727337A4822.priv void *[2];
//          0018 effalign(8) sda=0 bits=0000 $AB2BA2D8FED8EF3F1B006727337A4822 struct packalign=0

00000004 enum $AD3103F308C2081BDF7D3C1527B29EEA : unsigned __int32
{
  BPF_TCP_ESTABLISHED = 0x1,
  BPF_TCP_SYN_SENT = 0x2,
  BPF_TCP_SYN_RECV = 0x3,
  BPF_TCP_FIN_WAIT1 = 0x4,
  BPF_TCP_FIN_WAIT2 = 0x5,
  BPF_TCP_TIME_WAIT = 0x6,
  BPF_TCP_CLOSE = 0x7,
  BPF_TCP_CLOSE_WAIT = 0x8,
  BPF_TCP_LAST_ACK = 0x9,
  BPF_TCP_LISTEN = 0xA,
  BPF_TCP_CLOSING = 0xB,
  BPF_TCP_NEW_SYN_RECV = 0xC,
  BPF_TCP_MAX_STATES = 0xD,
};
0000000C struct $AE7699F1C0F08D928DAB88E00BBC947C
{
  char _dummy_pkey[8];
  __u32 _pkey;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $AE7699F1C0F08D928DAB88E00BBC947C._dummy_pkey char[8];
//  1. 0008 0004 effalign(4) fda=0 bits=0000 $AE7699F1C0F08D928DAB88E00BBC947C._pkey __u32;
//          000C effalign(4) sda=0 bits=0000 $AE7699F1C0F08D928DAB88E00BBC947C struct packalign=0

00000040 struct $AE78027FB145D3BF34A38FAC5A6C0061
{
  hrtimer timer;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 $AE78027FB145D3BF34A38FAC5A6C0061.timer hrtimer;
//          003C unpadded_size
//          0040 effalign(8) sda=0 bits=0000 $AE78027FB145D3BF34A38FAC5A6C0061 struct packalign=0

00000008 struct $AEEEF0908C303B51493A2C30B2CD252A
{
  spinlock_t lock;
  int count;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $AEEEF0908C303B51493A2C30B2CD252A.lock spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $AEEEF0908C303B51493A2C30B2CD252A.count int;
//          0008 effalign(4) sda=0 bits=0000 $AEEEF0908C303B51493A2C30B2CD252A struct packalign=0

00000004 enum $AF0F795171410374A86F54C119508627 : unsigned __int32
{
  PERCPU_REF_INIT_ATOMIC = 0x1,
  PERCPU_REF_INIT_DEAD = 0x2,
  PERCPU_REF_ALLOW_REINIT = 0x4,
};
00000010 struct $B0040E8A9BB1B2883A6D5C53D1E7371A
{
  unsigned int errors;
  unsigned int __reserved_3[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $B0040E8A9BB1B2883A6D5C53D1E7371A.errors unsigned int;
//  1. 0004 000C effalign(4) fda=0 bits=0000 $B0040E8A9BB1B2883A6D5C53D1E7371A.__reserved_3 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 $B0040E8A9BB1B2883A6D5C53D1E7371A struct packalign=0

00000004 enum $B125586D9729EEE128612194FB4E81EB : __int32
{
  MMOP_OFFLINE = 0xFFFFFFFF,
  MMOP_ONLINE_KEEP = 0x0,
  MMOP_ONLINE_KERNEL = 0x1,
  MMOP_ONLINE_MOVABLE = 0x2,
};
00000004 enum $B2BE5ADE84BE27CF87124FAAFF70590C : unsigned __int32
{
  NET_SCTP_RTO_INITIAL = 0x1,
  NET_SCTP_RTO_MIN = 0x2,
  NET_SCTP_RTO_MAX = 0x3,
  NET_SCTP_RTO_ALPHA = 0x4,
  NET_SCTP_RTO_BETA = 0x5,
  NET_SCTP_VALID_COOKIE_LIFE = 0x6,
  NET_SCTP_ASSOCIATION_MAX_RETRANS = 0x7,
  NET_SCTP_PATH_MAX_RETRANS = 0x8,
  NET_SCTP_MAX_INIT_RETRANSMITS = 0x9,
  NET_SCTP_HB_INTERVAL = 0xA,
  NET_SCTP_PRESERVE_ENABLE = 0xB,
  NET_SCTP_MAX_BURST = 0xC,
  NET_SCTP_ADDIP_ENABLE = 0xD,
  NET_SCTP_PRSCTP_ENABLE = 0xE,
  NET_SCTP_SNDBUF_POLICY = 0xF,
  NET_SCTP_SACK_TIMEOUT = 0x10,
  NET_SCTP_RCVBUF_POLICY = 0x11,
};
00000004 enum $B67EA7470D2A6AF09336569BE8951073 : unsigned __int32
{
  GATE_INTERRUPT = 0xE,
  GATE_TRAP = 0xF,
  GATE_CALL = 0xC,
  GATE_TASK = 0x5,
};
00000028 struct $B909293F6C414207B8940B35813701F8
{
  unsigned __int64 _pt_pad_1;
  pgtable_t pmd_huge_pte;
  unsigned __int64 _pt_pad_2;
  union
  {
    mm_struct *pt_mm;
    atomic_t pt_frag_refcount;
  };
  spinlock_t ptl;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $B909293F6C414207B8940B35813701F8._pt_pad_1 unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $B909293F6C414207B8940B35813701F8.pmd_huge_pte pgtable_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 $B909293F6C414207B8940B35813701F8._pt_pad_2 unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 $B909293F6C414207B8940B35813701F8.$817ABCB5B9F3F86FCBFB06C6B3A4AA5A $817ABCB5B9F3F86FCBFB06C6B3A4AA5A;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 $B909293F6C414207B8940B35813701F8.ptl spinlock_t;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 $B909293F6C414207B8940B35813701F8 struct packalign=0

00000008 enum $BADEFA5A81D7C4BA7479B07AE508D21D : __int64
{
  WORK_STRUCT_PENDING_BIT = 0x0,
  WORK_STRUCT_DELAYED_BIT = 0x1,
  WORK_STRUCT_PWQ_BIT = 0x2,
  WORK_STRUCT_LINKED_BIT = 0x3,
  WORK_STRUCT_COLOR_SHIFT = 0x4,
  WORK_STRUCT_COLOR_BITS = 0x4,
  WORK_STRUCT_PENDING = 0x1,
  WORK_STRUCT_DELAYED = 0x2,
  WORK_STRUCT_PWQ = 0x4,
  WORK_STRUCT_LINKED = 0x8,
  WORK_STRUCT_STATIC = 0x0,
  WORK_NR_COLORS = 0xF,
  WORK_NO_COLOR = 0xF,
  WORK_CPU_UNBOUND = 0x2000,
  WORK_STRUCT_FLAG_BITS = 0x8,
  WORK_OFFQ_FLAG_BASE = 0x4,
  __WORK_OFFQ_CANCELING = 0x4,
  WORK_OFFQ_CANCELING = 0x10,
  WORK_OFFQ_FLAG_BITS = 0x1,
  WORK_OFFQ_POOL_SHIFT = 0x5,
  WORK_OFFQ_LEFT = 0x3B,
  WORK_OFFQ_POOL_BITS = 0x1F,
  WORK_OFFQ_POOL_NONE = 0x7FFFFFFF,
  WORK_STRUCT_FLAG_MASK = 0xFF,
  WORK_STRUCT_WQ_DATA_MASK = 0xFFFFFFFFFFFFFF00,
  WORK_STRUCT_NO_POOL = 0xFFFFFFFE0,
  WORK_BUSY_PENDING = 0x1,
  WORK_BUSY_RUNNING = 0x2,
  WORKER_DESC_LEN = 0x18,
};
00000004 enum $BC115D47C9DDFB8CD40A21C6FB547B3A : unsigned __int32
{
  NET_AX25_IP_DEFAULT_MODE = 0x1,
  NET_AX25_DEFAULT_MODE = 0x2,
  NET_AX25_BACKOFF_TYPE = 0x3,
  NET_AX25_CONNECT_MODE = 0x4,
  NET_AX25_STANDARD_WINDOW = 0x5,
  NET_AX25_EXTENDED_WINDOW = 0x6,
  NET_AX25_T1_TIMEOUT = 0x7,
  NET_AX25_T2_TIMEOUT = 0x8,
  NET_AX25_T3_TIMEOUT = 0x9,
  NET_AX25_IDLE_TIMEOUT = 0xA,
  NET_AX25_N2 = 0xB,
  NET_AX25_PACLEN = 0xC,
  NET_AX25_PROTOCOL = 0xD,
  NET_AX25_DAMA_SLAVE_TIMEOUT = 0xE,
};
00000010 struct __attribute__((packed)) $C230E8656B59790AE365036A1B215898
{
  __u32 array_number;
  __u32 reserved1;
  __u64 reserved2;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 $C230E8656B59790AE365036A1B215898.array_number __u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 $C230E8656B59790AE365036A1B215898.reserved1 __u32;
//  2. 0008 0008 effalign(1) fda=0 bits=0000 $C230E8656B59790AE365036A1B215898.reserved2 __u64;
//          0010 effalign(1) sda=0 bits=0040 $C230E8656B59790AE365036A1B215898 struct packalign=0

00000010 struct $C27BEB34D2E5F24B2A42044AEB0EB8C3
{
  u32 fip;
  u32 fcs;
  u32 foo;
  u32 fos;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $C27BEB34D2E5F24B2A42044AEB0EB8C3.fip u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $C27BEB34D2E5F24B2A42044AEB0EB8C3.fcs u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 $C27BEB34D2E5F24B2A42044AEB0EB8C3.foo u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 $C27BEB34D2E5F24B2A42044AEB0EB8C3.fos u32;
//          0010 effalign(4) sda=0 bits=0000 $C27BEB34D2E5F24B2A42044AEB0EB8C3 struct packalign=0

00000004 enum $C3253497E792F022ED6F36DA19188F48 : unsigned __int32
{
  MEMREMAP_WB = 0x1,
  MEMREMAP_WT = 0x2,
  MEMREMAP_WC = 0x4,
  MEMREMAP_ENC = 0x8,
  MEMREMAP_DEC = 0x10,
};
00000004 enum $C596A7A4E478CF6BC6D2869770D6CD05 : unsigned __int32
{
  BLK_RW_ASYNC = 0x0,
  BLK_RW_SYNC = 0x1,
};
00000004 enum $C613B9654F5A6887C90E6A27E8AC39F0 : unsigned __int32
{
  NET_UNIX_DESTROY_DELAY = 0x1,
  NET_UNIX_DELETE_DELAY = 0x2,
  NET_UNIX_MAX_DGRAM_QLEN = 0x3,
};
00000004 enum $C79E0A93E66CA749659366F31D952A37 : unsigned __int32
{
  NET_BRIDGE_NF_CALL_ARPTABLES = 0x1,
  NET_BRIDGE_NF_CALL_IPTABLES = 0x2,
  NET_BRIDGE_NF_CALL_IP6TABLES = 0x3,
  NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 0x4,
  NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 0x5,
};
00000004 enum $C8133BF94EE3AFC5F16AA8508ABCA0FF : unsigned __int32
{
  DQST_LOOKUPS = 0x0,
  DQST_DROPS = 0x1,
  DQST_READS = 0x2,
  DQST_WRITES = 0x3,
  DQST_CACHE_HITS = 0x4,
  DQST_ALLOC_DQUOTS = 0x5,
  DQST_FREE_DQUOTS = 0x6,
  DQST_SYNCS = 0x7,
  _DQST_DQSTAT_LAST = 0x8,
};
00000010 struct __attribute__((packed)) $CA92296E8AC6642454C9882B6FE5C971
{
  __u64 identity_tag;
  __u64 reserved;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $CA92296E8AC6642454C9882B6FE5C971.identity_tag __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 $CA92296E8AC6642454C9882B6FE5C971.reserved __u64;
//          0010 effalign(1) sda=0 bits=0040 $CA92296E8AC6642454C9882B6FE5C971 struct packalign=0

00000010 struct __attribute__((packed)) $CBD268B33DAA25A6FCA5CAD6B8CD0A90
{
  __u64 eui;
  __u64 reserved;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $CBD268B33DAA25A6FCA5CAD6B8CD0A90.eui __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 $CBD268B33DAA25A6FCA5CAD6B8CD0A90.reserved __u64;
//          0010 effalign(1) sda=0 bits=0040 $CBD268B33DAA25A6FCA5CAD6B8CD0A90 struct packalign=0

00000004 enum $CC4A454E8208181B52210202C2CBA085 : unsigned __int32
{
  IORES_DESC_NONE = 0x0,
  IORES_DESC_CRASH_KERNEL = 0x1,
  IORES_DESC_ACPI_TABLES = 0x2,
  IORES_DESC_ACPI_NV_STORAGE = 0x3,
  IORES_DESC_PERSISTENT_MEMORY = 0x4,
  IORES_DESC_PERSISTENT_MEMORY_LEGACY = 0x5,
  IORES_DESC_DEVICE_PRIVATE_MEMORY = 0x6,
  IORES_DESC_RESERVED = 0x7,
};
00000004 enum $CE0796B31961C3FB6E01C0482FE4D62D : unsigned __int32
{
  REGION_INTERSECTS = 0x0,
  REGION_DISJOINT = 0x1,
  REGION_MIXED = 0x2,
};
00000008 union $D0E43D72358DA8AA2A573F3F4043ED1C
{
  u8 u8_data;
  u16 u16_data;
  u32 u32_data;
  u64 u64_data;
  const char *str;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C.u8_data u8;
//  1. 0000 0002 effalign(2) fda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C.u16_data u16;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C.u32_data u32;
//  3. 0000 0008 effalign(8) fda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C.u64_data u64;
//  4. 0000 0008 effalign(8) fda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C.str const char *;
//          0008 effalign(8) sda=0 bits=0000 $D0E43D72358DA8AA2A573F3F4043ED1C union packalign=0

00000020 struct $D0E7BB60637F8A57EBC3B64012540D98
{
  __u32 ipv6_src[4];
  __u32 ipv6_dst[4];
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 $D0E7BB60637F8A57EBC3B64012540D98.ipv6_src __u32[4];
//  1. 0010 0010 effalign(4) fda=0 bits=0000 $D0E7BB60637F8A57EBC3B64012540D98.ipv6_dst __u32[4];
//          0020 effalign(4) sda=0 bits=0000 $D0E7BB60637F8A57EBC3B64012540D98 struct packalign=0

00000010 struct $D137D31AB4BF200B069527E143652062
{
  unsigned __int64 compound_head;
  unsigned __int8 compound_dtor;
  unsigned __int8 compound_order;
  atomic_t compound_mapcount;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $D137D31AB4BF200B069527E143652062.compound_head unsigned __int64;
//  1. 0008 0001 effalign(1) fda=0 bits=0000 $D137D31AB4BF200B069527E143652062.compound_dtor unsigned __int8;
//  2. 0009 0001 effalign(1) fda=0 bits=0000 $D137D31AB4BF200B069527E143652062.compound_order unsigned __int8;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 $D137D31AB4BF200B069527E143652062.compound_mapcount atomic_t;
//          0010 effalign(8) sda=0 bits=0000 $D137D31AB4BF200B069527E143652062 struct packalign=0

00000004 enum $D1C6CDD7D7C74B624F76AE5A57ABAF86 : unsigned __int32
{
  NET_IPV4_ROUTE_FLUSH = 0x1,
  NET_IPV4_ROUTE_MIN_DELAY = 0x2,
  NET_IPV4_ROUTE_MAX_DELAY = 0x3,
  NET_IPV4_ROUTE_GC_THRESH = 0x4,
  NET_IPV4_ROUTE_MAX_SIZE = 0x5,
  NET_IPV4_ROUTE_GC_MIN_INTERVAL = 0x6,
  NET_IPV4_ROUTE_GC_TIMEOUT = 0x7,
  NET_IPV4_ROUTE_GC_INTERVAL = 0x8,
  NET_IPV4_ROUTE_REDIRECT_LOAD = 0x9,
  NET_IPV4_ROUTE_REDIRECT_NUMBER = 0xA,
  NET_IPV4_ROUTE_REDIRECT_SILENCE = 0xB,
  NET_IPV4_ROUTE_ERROR_COST = 0xC,
  NET_IPV4_ROUTE_ERROR_BURST = 0xD,
  NET_IPV4_ROUTE_GC_ELASTICITY = 0xE,
  NET_IPV4_ROUTE_MTU_EXPIRES = 0xF,
  NET_IPV4_ROUTE_MIN_PMTU = 0x10,
  NET_IPV4_ROUTE_MIN_ADVMSS = 0x11,
  NET_IPV4_ROUTE_SECRET_INTERVAL = 0x12,
  NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 0x13,
};
00000010 struct $D2A5E924C2C4CF1CF51E8DE55C3CCAA5
{
  dev_pagemap *pgmap;
  void *zone_device_data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $D2A5E924C2C4CF1CF51E8DE55C3CCAA5.pgmap dev_pagemap *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $D2A5E924C2C4CF1CF51E8DE55C3CCAA5.zone_device_data void *;
//          0010 effalign(8) sda=0 bits=0000 $D2A5E924C2C4CF1CF51E8DE55C3CCAA5 struct packalign=0

00000004 enum $D34C68FE13AAA27A261CD86BDC983917 : unsigned __int32
{
  DQF_INFO_DIRTY_B = 0x11,
};
00000004 enum $D5C7B8FBA1EBE00DBA64C02267B194F4 : unsigned __int32
{
  QUOTA_NL_A_UNSPEC = 0x0,
  QUOTA_NL_A_QTYPE = 0x1,
  QUOTA_NL_A_EXCESS_ID = 0x2,
  QUOTA_NL_A_WARNING = 0x3,
  QUOTA_NL_A_DEV_MAJOR = 0x4,
  QUOTA_NL_A_DEV_MINOR = 0x5,
  QUOTA_NL_A_CAUSED_ID = 0x6,
  QUOTA_NL_A_PAD = 0x7,
  __QUOTA_NL_A_MAX = 0x8,
};
00000004 enum $D747ABAD008AE6BC12062CA0C168DA56 : unsigned __int32
{
  TASKLET_STATE_SCHED = 0x0,
  TASKLET_STATE_RUN = 0x1,
};
00000002 struct $DA3C97E7A5F978318679C7D516AF6688
{
  u8 fn;
  u8 dev;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 $DA3C97E7A5F978318679C7D516AF6688.fn u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 $DA3C97E7A5F978318679C7D516AF6688.dev u8;
//          0002 effalign(1) sda=0 bits=0000 $DA3C97E7A5F978318679C7D516AF6688 struct packalign=0

00000004 enum $DD2FCB3BD885EF085C64DD38A6B8659D : unsigned __int32
{
  HI_SOFTIRQ = 0x0,
  TIMER_SOFTIRQ = 0x1,
  NET_TX_SOFTIRQ = 0x2,
  NET_RX_SOFTIRQ = 0x3,
  BLOCK_SOFTIRQ = 0x4,
  IRQ_POLL_SOFTIRQ = 0x5,
  TASKLET_SOFTIRQ = 0x6,
  SCHED_SOFTIRQ = 0x7,
  HRTIMER_SOFTIRQ = 0x8,
  RCU_SOFTIRQ = 0x9,
  NR_SOFTIRQS = 0xA,
};
00000004 enum $DD660EA5423A614ACA40036D6D43F5E5 : unsigned __int32
{
  DEV_CDROM_INFO = 0x1,
  DEV_CDROM_AUTOCLOSE = 0x2,
  DEV_CDROM_AUTOEJECT = 0x3,
  DEV_CDROM_DEBUG = 0x4,
  DEV_CDROM_LOCK = 0x5,
  DEV_CDROM_CHECK_MEDIA = 0x6,
};
00000004 enum $E078C9ACDA5326FB81275127CAE2B29F : unsigned __int32
{
  IOPRIO_CLASS_NONE = 0x0,
  IOPRIO_CLASS_RT = 0x1,
  IOPRIO_CLASS_BE = 0x2,
  IOPRIO_CLASS_IDLE = 0x3,
};
00000004 enum $E18CBD23AF204134F6C348F22E1A9F58 : unsigned __int32
{
  NET_IPV6_ICMP_RATELIMIT = 0x1,
  NET_IPV6_ICMP_ECHO_IGNORE_ALL = 0x2,
};
00000004 enum $E1E110DEFD816DF1B74D124C6ED67C44 : unsigned __int32
{
  NET_NETROM_DEFAULT_PATH_QUALITY = 0x1,
  NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 0x2,
  NET_NETROM_NETWORK_TTL_INITIALISER = 0x3,
  NET_NETROM_TRANSPORT_TIMEOUT = 0x4,
  NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 0x5,
  NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 0x6,
  NET_NETROM_TRANSPORT_BUSY_DELAY = 0x7,
  NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 0x8,
  NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 0x9,
  NET_NETROM_ROUTING_CONTROL = 0xA,
  NET_NETROM_LINK_FAILS_COUNT = 0xB,
  NET_NETROM_RESET = 0xC,
};
00000004 enum $E2802EBDA04C37773D722411B2859A54 : __int32
{
  DEV_PARPORT_DEFAULT = 0xFFFFFFFD,
};
00000028 struct $E3857CE99C57F8B5022B9A513C27E905
{
  unsigned __int64 hash;
  unsigned __int64 len_desc;
  key_type *type;
  key_tag *domain_tag;
  char *description;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905.hash unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905.len_desc unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905.type key_type *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905.domain_tag key_tag *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905.description char *;
//          0028 effalign(8) sda=0 bits=0000 $E3857CE99C57F8B5022B9A513C27E905 struct packalign=0

00000004 enum $E48FB40A2EEEB6009AB0899CAD55E209 : unsigned __int32
{
  NET_IPV6_ROUTE_FLUSH = 0x1,
  NET_IPV6_ROUTE_GC_THRESH = 0x2,
  NET_IPV6_ROUTE_MAX_SIZE = 0x3,
  NET_IPV6_ROUTE_GC_MIN_INTERVAL = 0x4,
  NET_IPV6_ROUTE_GC_TIMEOUT = 0x5,
  NET_IPV6_ROUTE_GC_INTERVAL = 0x6,
  NET_IPV6_ROUTE_GC_ELASTICITY = 0x7,
  NET_IPV6_ROUTE_MTU_EXPIRES = 0x8,
  NET_IPV6_ROUTE_MIN_ADVMSS = 0x9,
  NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 0xA,
};
00000004 enum $E6D6BE9659EDA578D1F3A457560E33EB : __int32
{
  NET_PROTO_CONF_ALL = 0xFFFFFFFE,
  NET_PROTO_CONF_DEFAULT = 0xFFFFFFFD,
};
00000020 struct $EA376F78C5A06A542D2A89563F183819
{
  unsigned int seq;
  list_head list;
  rq_end_io_fn *saved_end_io;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $EA376F78C5A06A542D2A89563F183819.seq unsigned int;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 $EA376F78C5A06A542D2A89563F183819.list list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 $EA376F78C5A06A542D2A89563F183819.saved_end_io rq_end_io_fn *;
//          0020 effalign(8) sda=0 bits=0000 $EA376F78C5A06A542D2A89563F183819 struct packalign=0

00000018 struct $EB3075E152535FBC682ED73518D5C19B
{
  list_head link;
  int state;
  unsigned int debug_id;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $EB3075E152535FBC682ED73518D5C19B.link list_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 $EB3075E152535FBC682ED73518D5C19B.state int;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 $EB3075E152535FBC682ED73518D5C19B.debug_id unsigned int;
//          0018 effalign(8) sda=0 bits=0000 $EB3075E152535FBC682ED73518D5C19B struct packalign=0

00000004 enum $ECC0383DEEDD781B0BE9116A0E842892 : unsigned __int32
{
  BIOSET_NEED_BVECS = 0x1,
  BIOSET_NEED_RESCUER = 0x2,
};
00000004 enum $EE5B2A57A5EB045B93276320FF073840 : unsigned __int32
{
  _DQUOT_USAGE_ENABLED = 0x0,
  _DQUOT_LIMITS_ENABLED = 0x1,
  _DQUOT_SUSPENDED = 0x2,
  _DQUOT_STATE_FLAGS = 0x3,
};
00000004 enum $EE881B30B7542CFB3C32B33271ABE56C : unsigned __int32
{
  NET_CORE = 0x1,
  NET_ETHER = 0x2,
  NET_802 = 0x3,
  NET_UNIX = 0x4,
  NET_IPV4 = 0x5,
  NET_IPX = 0x6,
  NET_ATALK = 0x7,
  NET_NETROM = 0x8,
  NET_AX25 = 0x9,
  NET_BRIDGE = 0xA,
  NET_ROSE = 0xB,
  NET_IPV6 = 0xC,
  NET_X25 = 0xD,
  NET_TR = 0xE,
  NET_DECNET = 0xF,
  NET_ECONET = 0x10,
  NET_SCTP = 0x11,
  NET_LLC = 0x12,
  NET_NETFILTER = 0x13,
  NET_DCCP = 0x14,
  NET_IRDA = 0x19C,
};
00000030 struct $EEA86D27551D0E98B064575E41986325
{
  int si_signo;
  int si_errno;
  int si_code;
  __sifields _sifields;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 $EEA86D27551D0E98B064575E41986325.si_signo int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 $EEA86D27551D0E98B064575E41986325.si_errno int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 $EEA86D27551D0E98B064575E41986325.si_code int;
//  3. 0010 0020 effalign(8) fda=0 bits=0000 $EEA86D27551D0E98B064575E41986325._sifields __sifields;
//          0030 effalign(8) sda=0 bits=0000 $EEA86D27551D0E98B064575E41986325 struct packalign=0

00000004 enum $F2B463A3EF31DCCBF93B3492CC8C662A : unsigned __int32
{
  RADIX_TREE_ITER_TAG_MASK = 0xF,
  RADIX_TREE_ITER_TAGGED = 0x10,
  RADIX_TREE_ITER_CONTIG = 0x20,
};
00000004 enum $F343D6E3F3FA4C251E7C37669AE684EF : unsigned __int32
{
  NET_ROSE_RESTART_REQUEST_TIMEOUT = 0x1,
  NET_ROSE_CALL_REQUEST_TIMEOUT = 0x2,
  NET_ROSE_RESET_REQUEST_TIMEOUT = 0x3,
  NET_ROSE_CLEAR_REQUEST_TIMEOUT = 0x4,
  NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 0x5,
  NET_ROSE_ROUTING_CONTROL = 0x6,
  NET_ROSE_LINK_FAIL_TIMEOUT = 0x7,
  NET_ROSE_MAX_VCS = 0x8,
  NET_ROSE_WINDOW_SIZE = 0x9,
  NET_ROSE_NO_ACTIVITY_TIMEOUT = 0xA,
};
00000020 struct $F3CAA52711B0FBBABA04D84B2645ECC4
{
  pollfd *ufds;
  int nfds;
  int has_timeout;
  unsigned __int64 tv_sec;
  unsigned __int64 tv_nsec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4.ufds pollfd *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4.nfds int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4.has_timeout int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4.tv_sec unsigned __int64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4.tv_nsec unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 $F3CAA52711B0FBBABA04D84B2645ECC4 struct packalign=0

00000018 struct $F5C1C9C04BCDB0ADA1B147BEDD0D212C
{
  char _dummy_bnd[8];
  void *_lower;
  void *_upper;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 $F5C1C9C04BCDB0ADA1B147BEDD0D212C._dummy_bnd char[8];
//  1. 0008 0008 effalign(8) fda=0 bits=0000 $F5C1C9C04BCDB0ADA1B147BEDD0D212C._lower void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 $F5C1C9C04BCDB0ADA1B147BEDD0D212C._upper void *;
//          0018 effalign(8) sda=0 bits=0000 $F5C1C9C04BCDB0ADA1B147BEDD0D212C struct packalign=0

00000004 enum $F95B50F6F94511BD921427ED12628368 : unsigned __int32
{
  INOTIFY_MAX_USER_INSTANCES = 0x1,
  INOTIFY_MAX_USER_WATCHES = 0x2,
  INOTIFY_MAX_QUEUED_EVENTS = 0x3,
};
00000020 struct $FA1F96C4209A82444F7F77101C731C3B
{
  list_head name_link;
  assoc_array keys;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 $FA1F96C4209A82444F7F77101C731C3B.name_link list_head;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 $FA1F96C4209A82444F7F77101C731C3B.keys assoc_array;
//          0020 effalign(8) sda=0 bits=0000 $FA1F96C4209A82444F7F77101C731C3B struct packalign=0

00000004 enum $FA4B264BC8EEF9F64DD8398F93A5E41E : unsigned __int32
{
  LOGIC_PIO_INDIRECT = 0x0,
  LOGIC_PIO_CPU_MMIO = 0x1,
};
00000004 enum $FB90A9B33AACD20852F8AD06D332219C : unsigned __int32
{
  NET_LLC2_TIMEOUT = 0x1,
};
00000004 enum $FD885BF279F4D68832B2662A17689723 : unsigned __int32
{
  DUMP_PREFIX_NONE = 0x0,
  DUMP_PREFIX_ADDRESS = 0x1,
  DUMP_PREFIX_OFFSET = 0x2,
};
00000010 struct $FE522FAF5CB4CC13731D513BC018CDE7
{
  unsigned __int32 send_cs_error : 1;
  unsigned __int32 receive_cs_error : 1;
  unsigned __int32 send_accept_error : 1;
  unsigned __int32 receive_accept_error : 1;
  unsigned __int32 __reserved_1 : 1;
  unsigned __int32 send_illegal_vector : 1;
  unsigned __int32 receive_illegal_vector : 1;
  unsigned __int32 illegal_register_address : 1;
  unsigned __int32 __reserved_2 : 24;
  unsigned int __reserved_3[3];
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.send_cs_error bi.nbytes=4 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.receive_cs_error bi.nbytes=4 U
//  2. 0000. 2 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.send_accept_error bi.nbytes=4 U
//  3. 0000. 3 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.receive_accept_error bi.nbytes=4 U
//  4. 0000. 4 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.__reserved_1 bi.nbytes=4 U
//  5. 0000. 5 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.send_illegal_vector bi.nbytes=4 U
//  6. 0000. 6 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.receive_illegal_vector bi.nbytes=4 U
//  7. 0000. 7 1 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.illegal_register_address bi.nbytes=4 U
//  8. 0000. 8 24 effalign(1) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.__reserved_2 bi.nbytes=4 U
//  9. 0004 000C effalign(4) fda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7.__reserved_3 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 $FE522FAF5CB4CC13731D513BC018CDE7 struct packalign=0

00000004 enum $FE78702B5580ECC83A56568737032F29 : unsigned __int32
{
  DESC_TSS = 0x9,
  DESC_LDT = 0x2,
  DESCTYPE_S = 0x10,
};
00000004 enum $FED5731118ACCAE6FA3F89894F713DB9 : unsigned __int32
{
  NET_TR_RIF_TIMEOUT = 0x1,
};
00000004 enum EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION : unsigned __int32
{
  EfiPciIoAttributeOperationGet = 0x0,
  EfiPciIoAttributeOperationSet = 0x1,
  EfiPciIoAttributeOperationEnable = 0x2,
  EfiPciIoAttributeOperationDisable = 0x3,
  EfiPciIoAttributeOperationSupported = 0x4,
  EfiPciIoAttributeOperationMaximum = 0x5,
};
00000004 enum EFI_PCI_IO_PROTOCOL_WIDTH : unsigned __int32
{
  EfiPciIoWidthUint8 = 0x0,
  EfiPciIoWidthUint16 = 0x1,
  EfiPciIoWidthUint32 = 0x2,
  EfiPciIoWidthUint64 = 0x3,
  EfiPciIoWidthFifoUint8 = 0x4,
  EfiPciIoWidthFifoUint16 = 0x5,
  EfiPciIoWidthFifoUint32 = 0x6,
  EfiPciIoWidthFifoUint64 = 0x7,
  EfiPciIoWidthFillUint8 = 0x8,
  EfiPciIoWidthFillUint16 = 0x9,
  EfiPciIoWidthFillUint32 = 0xA,
  EfiPciIoWidthFillUint64 = 0xB,
  EfiPciIoWidthMaximum = 0xC,
};
00000004 typedef __u32 Elf32_Addr;
00000008 typedef dynamic Elf32_Dyn;
00000034 typedef elf32_hdr Elf32_Ehdr;
00000002 typedef __u16 Elf32_Half;
0000000C typedef elf32_note Elf32_Nhdr;
00000004 typedef __u32 Elf32_Off;
00000020 typedef elf32_phdr Elf32_Phdr;
00000008 typedef elf32_rel Elf32_Rel;
0000000C typedef elf32_rela Elf32_Rela;
00000028 typedef elf32_shdr Elf32_Shdr;
00000004 typedef __s32 Elf32_Sword;
00000010 typedef elf32_sym Elf32_Sym;
00000004 typedef __u32 Elf32_Word;
00000008 typedef __u64 Elf64_Addr;
00000010 struct Elf64_Dyn
{
  Elf64_Sxword d_tag;
  Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F d_un;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 Elf64_Dyn.d_tag Elf64_Sxword;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 Elf64_Dyn.d_un Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F;
//          0010 effalign(8) sda=0 bits=0000 Elf64_Dyn struct packalign=0

00000008 union Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F
{
  Elf64_Xword d_val;
  Elf64_Addr d_ptr;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F.d_val Elf64_Xword;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F.d_ptr Elf64_Addr;
//          0008 effalign(8) sda=0 bits=0000 Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F union packalign=0

00000040 typedef elf64_hdr Elf64_Ehdr;
00000002 typedef __u16 Elf64_Half;
0000000C typedef elf64_note Elf64_Nhdr;
00000008 typedef __u64 Elf64_Off;
00000038 typedef elf64_phdr Elf64_Phdr;
00000010 typedef elf64_rel Elf64_Rel;
00000018 typedef elf64_rela Elf64_Rela;
00000002 typedef __s16 Elf64_SHalf;
00000040 typedef elf64_shdr Elf64_Shdr;
00000004 typedef __s32 Elf64_Sword;
00000008 typedef __s64 Elf64_Sxword;
00000018 typedef elf64_sym Elf64_Sym;
00000004 typedef __u32 Elf64_Word;
00000008 typedef __u64 Elf64_Xword;
00000004 union IO_APIC_reg_00
{
  u32 raw;
  IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B bits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 IO_APIC_reg_00.raw u32;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 IO_APIC_reg_00.bits IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B;
//          0004 effalign(4) sda=0 bits=0000 IO_APIC_reg_00 union packalign=0

00000004 struct __attribute__((packed)) IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B
{
  unsigned __int32 __reserved_2 : 14;
  unsigned __int32 LTS : 1;
  unsigned __int32 delivery_type : 1;
  unsigned __int32 __reserved_1 : 8;
  unsigned __int32 ID : 8;
};
//  0. 0000. 0 14 effalign(2) fda=0 bits=0000 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B.__reserved_2 bi.nbytes=4 U
//  1. 0000.14 1 effalign(2) fda=0 bits=0000 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B.LTS bi.nbytes=4 U
//  2. 0000.15 1 effalign(2) fda=0 bits=0000 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B.delivery_type bi.nbytes=4 U
//  3. 0000.16 8 effalign(2) fda=0 bits=0000 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B.__reserved_1 bi.nbytes=4 U
//  4. 0000.24 8 effalign(2) fda=0 bits=0000 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B.ID bi.nbytes=4 U
//          0004 effalign(1) sda=0 bits=0040 IO_APIC_reg_00::$5841DA45821EED1860E08F07C9DDAB5B struct packalign=0

00000004 union IO_APIC_reg_01
{
  u32 raw;
  IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF bits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 IO_APIC_reg_01.raw u32;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 IO_APIC_reg_01.bits IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF;
//          0004 effalign(4) sda=0 bits=0000 IO_APIC_reg_01 union packalign=0

00000004 struct __attribute__((packed)) IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF
{
  unsigned __int32 version : 8;
  unsigned __int32 __reserved_2 : 7;
  unsigned __int32 PRQ : 1;
  unsigned __int32 entries : 8;
  unsigned __int32 __reserved_1 : 8;
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF.version bi.nbytes=4 U
//  1. 0000. 8 7 effalign(1) fda=0 bits=0000 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF.__reserved_2 bi.nbytes=4 U
//  2. 0000.15 1 effalign(1) fda=0 bits=0000 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF.PRQ bi.nbytes=4 U
//  3. 0000.16 8 effalign(1) fda=0 bits=0000 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF.entries bi.nbytes=4 U
//  4. 0000.24 8 effalign(1) fda=0 bits=0000 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF.__reserved_1 bi.nbytes=4 U
//          0004 effalign(1) sda=0 bits=0040 IO_APIC_reg_01::$546DCF88102F9428D7FCC220FEC61FEF struct packalign=0

00000004 union IO_APIC_reg_02
{
  u32 raw;
  IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C bits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 IO_APIC_reg_02.raw u32;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 IO_APIC_reg_02.bits IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C;
//          0004 effalign(4) sda=0 bits=0000 IO_APIC_reg_02 union packalign=0

00000004 struct __attribute__((packed)) IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C
{
  unsigned __int32 __reserved_2 : 24;
  unsigned __int32 arbitration : 4;
  unsigned __int32 __reserved_1 : 4;
};
//  0. 0000. 0 24 effalign(4) fda=0 bits=0000 IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C.__reserved_2 bi.nbytes=4 U
//  1. 0000.24 4 effalign(4) fda=0 bits=0000 IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C.arbitration bi.nbytes=4 U
//  2. 0000.28 4 effalign(4) fda=0 bits=0000 IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C.__reserved_1 bi.nbytes=4 U
//          0004 effalign(1) sda=0 bits=0040 IO_APIC_reg_02::$8E3ADB25796A6D8B7FCD5CFDDF26014C struct packalign=0

00000004 union IO_APIC_reg_03
{
  u32 raw;
  IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4 bits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 IO_APIC_reg_03.raw u32;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 IO_APIC_reg_03.bits IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4;
//          0004 effalign(4) sda=0 bits=0000 IO_APIC_reg_03 union packalign=0

00000004 struct __attribute__((packed)) IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4
{
  unsigned __int32 boot_DT : 1;
  unsigned __int32 __reserved_1 : 31;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4.boot_DT bi.nbytes=4 U
//  1. 0000. 1 31 effalign(1) fda=0 bits=0000 IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4.__reserved_1 bi.nbytes=4 U
//          0004 effalign(1) sda=0 bits=0040 IO_APIC_reg_03::$42379F63D30F0C6CB7FFE313AC8FC2B4 struct packalign=0

00000008 struct __attribute__((packed)) IO_APIC_route_entry
{
  unsigned __int32 vector : 8;
  unsigned __int32 delivery_mode : 3;
  unsigned __int32 dest_mode : 1;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 polarity : 1;
  unsigned __int32 irr : 1;
  unsigned __int32 trigger : 1;
  unsigned __int32 mask : 1;
  unsigned __int32 __reserved_2 : 15;
  unsigned __int32 __reserved_3 : 24;
  unsigned __int32 dest : 8;
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.vector bi.nbytes=4 U
//  1. 0000. 8 3 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.delivery_mode bi.nbytes=4 U
//  2. 0000.11 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.dest_mode bi.nbytes=4 U
//  3. 0000.12 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.delivery_status bi.nbytes=4 U
//  4. 0000.13 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.polarity bi.nbytes=4 U
//  5. 0000.14 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.irr bi.nbytes=4 U
//  6. 0000.15 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.trigger bi.nbytes=4 U
//  7. 0000.16 1 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.mask bi.nbytes=4 U
//  8. 0000.17 15 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.__reserved_2 bi.nbytes=4 U
//  9. 0004. 0 24 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.__reserved_3 bi.nbytes=4 U
// 10. 0004.24 8 effalign(1) fda=0 bits=0000 IO_APIC_route_entry.dest bi.nbytes=4 U
//          0008 effalign(1) sda=0 bits=0040 IO_APIC_route_entry struct packalign=0

00000008 struct __attribute__((packed)) IR_IO_APIC_route_entry
{
  unsigned __int64 vector : 8;
  unsigned __int64 zero : 3;
  unsigned __int64 index2 : 1;
  unsigned __int64 delivery_status : 1;
  unsigned __int64 polarity : 1;
  unsigned __int64 irr : 1;
  unsigned __int64 trigger : 1;
  unsigned __int64 mask : 1;
  unsigned __int64 reserved : 31;
  unsigned __int64 format : 1;
  unsigned __int64 index : 15;
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.vector bi.nbytes=8 U
//  1. 0000. 8 3 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.zero bi.nbytes=8 U
//  2. 0000.11 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.index2 bi.nbytes=8 U
//  3. 0000.12 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.delivery_status bi.nbytes=8 U
//  4. 0000.13 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.polarity bi.nbytes=8 U
//  5. 0000.14 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.irr bi.nbytes=8 U
//  6. 0000.15 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.trigger bi.nbytes=8 U
//  7. 0000.16 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.mask bi.nbytes=8 U
//  8. 0000.17 31 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.reserved bi.nbytes=8 U
//  9. 0000.48 1 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.format bi.nbytes=8 U
// 10. 0000.49 15 effalign(1) fda=0 bits=0000 IR_IO_APIC_route_entry.index bi.nbytes=8 U
//          0008 effalign(1) sda=0 bits=0040 IR_IO_APIC_route_entry struct packalign=0

00000008 struct Sector
{
  page *v;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 Sector.v page *;
//          0008 effalign(8) sda=0 bits=0000 Sector struct packalign=0

00000002 typedef __u16 __be16;
00000004 typedef __u32 __be32;
00000008 typedef __u64 __be64;
00000018 typedef __va_list_tag __builtin_va_list[1];
00000020 struct __call_single_data
{
  llist_node llist;
  smp_call_func_t func;
  void *info;
  unsigned int flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __call_single_data.llist llist_node;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 __call_single_data.func smp_call_func_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 __call_single_data.info void *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 __call_single_data.flags unsigned int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 __call_single_data struct packalign=0

00000018 typedef __builtin_va_list __gnuc_va_list;
00000008 typedef char *__kernel_caddr_t;
00000008 typedef __kernel_long_t __kernel_clock_t;
00000004 typedef int __kernel_clockid_t;
00000004 typedef int __kernel_daddr_t;
00000004 typedef u32 __kernel_dev_t;
00000080 struct __kernel_fd_set
{
  unsigned __int64 fds_bits[16];
};
//  0. 0000 0080 effalign(8) fda=0 bits=0000 __kernel_fd_set.fds_bits unsigned __int64[16];
//          0080 effalign(8) sda=0 bits=0000 __kernel_fd_set struct packalign=0

00000008 struct __kernel_fsid_t
{
  int val[2];
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 __kernel_fsid_t.val int[2];
//          0008 effalign(4) sda=0 bits=0000 __kernel_fsid_t struct packalign=0

00000002 typedef unsigned __int16 __kernel_gid16_t;
00000004 typedef unsigned int __kernel_gid32_t;
00000004 typedef unsigned int __kernel_gid_t;
00000008 typedef __kernel_ulong_t __kernel_ino_t;
00000004 typedef int __kernel_ipc_pid_t;
00000020 struct __kernel_itimerspec
{
  __kernel_timespec it_interval;
  __kernel_timespec it_value;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 __kernel_itimerspec.it_interval __kernel_timespec;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 __kernel_itimerspec.it_value __kernel_timespec;
//          0020 effalign(8) sda=0 bits=0000 __kernel_itimerspec struct packalign=0

00000004 typedef int __kernel_key_t;
00000008 typedef __int64 __kernel_loff_t;
00000008 typedef __int64 __kernel_long_t;
00000004 typedef unsigned int __kernel_mode_t;
00000004 typedef int __kernel_mqd_t;
00000008 typedef __kernel_long_t __kernel_off_t;
00000008 typedef unsigned __int64 __kernel_old_dev_t;
00000002 typedef unsigned __int16 __kernel_old_gid_t;
00000010 struct __kernel_old_timeval
{
  __kernel_long_t tv_sec;
  __kernel_long_t tv_usec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __kernel_old_timeval.tv_sec __kernel_long_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 __kernel_old_timeval.tv_usec __kernel_long_t;
//          0010 effalign(8) sda=0 bits=0000 __kernel_old_timeval struct packalign=0

00000002 typedef unsigned __int16 __kernel_old_uid_t;
00000004 typedef int __kernel_pid_t;
00000008 typedef __kernel_long_t __kernel_ptrdiff_t;
00000004 typedef int __kernel_rwf_t;
00000008 typedef void (__cdecl *__kernel_sighandler_t)(int);
00000008 typedef __kernel_ulong_t __kernel_size_t;
00000010 struct __kernel_sock_timeval
{
  __s64 tv_sec;
  __s64 tv_usec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __kernel_sock_timeval.tv_sec __s64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 __kernel_sock_timeval.tv_usec __s64;
//          0010 effalign(8) sda=0 bits=0000 __kernel_sock_timeval struct packalign=0

00000008 typedef __kernel_long_t __kernel_ssize_t;
00000008 typedef __kernel_long_t __kernel_suseconds_t;
00000008 typedef __int64 __kernel_time64_t;
00000008 typedef __kernel_long_t __kernel_time_t;
00000004 typedef int __kernel_timer_t;
00000010 struct __kernel_timespec
{
  __kernel_time64_t tv_sec;
  __int64 tv_nsec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __kernel_timespec.tv_sec __kernel_time64_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 __kernel_timespec.tv_nsec __int64;
//          0010 effalign(8) sda=0 bits=0000 __kernel_timespec struct packalign=0

000000D0 struct __kernel_timex
{
  unsigned int modes;
  __int32 : 32;
  __int64 offset;
  __int64 freq;
  __int64 maxerror;
  __int64 esterror;
  int status;
  __int32 : 32;
  __int64 constant;
  __int64 precision;
  __int64 tolerance;
  struct
  {
    __kernel_time64_t tv_sec;
    __int64 tv_usec;
  } time;
  __int64 tick;
  __int64 ppsfreq;
  __int64 jitter;
  int shift;
  __int32 : 32;
  __int64 stabil;
  __int64 jitcnt;
  __int64 calcnt;
  __int64 errcnt;
  __int64 stbcnt;
  int tai;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __kernel_timex.modes unsigned int;
//  1. 0004. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
//  2. 0008 0008 effalign(8) fda=0 bits=0000 __kernel_timex.offset __int64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 __kernel_timex.freq __int64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 __kernel_timex.maxerror __int64;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 __kernel_timex.esterror __int64;
//  6. 0028 0004 effalign(4) fda=0 bits=0000 __kernel_timex.status int;
//  7. 002C. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
//  8. 0030 0008 effalign(8) fda=0 bits=0000 __kernel_timex.constant __int64;
//  9. 0038 0008 effalign(8) fda=0 bits=0000 __kernel_timex.precision __int64;
// 10. 0040 0008 effalign(8) fda=0 bits=0000 __kernel_timex.tolerance __int64;
// 11. 0048 0010 effalign(8) fda=0 bits=0000 __kernel_timex.time __kernel_timex_timeval;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 __kernel_timex.tick __int64;
// 13. 0060 0008 effalign(8) fda=0 bits=0000 __kernel_timex.ppsfreq __int64;
// 14. 0068 0008 effalign(8) fda=0 bits=0000 __kernel_timex.jitter __int64;
// 15. 0070 0004 effalign(4) fda=0 bits=0000 __kernel_timex.shift int;
// 16. 0074. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 17. 0078 0008 effalign(8) fda=0 bits=0000 __kernel_timex.stabil __int64;
// 18. 0080 0008 effalign(8) fda=0 bits=0000 __kernel_timex.jitcnt __int64;
// 19. 0088 0008 effalign(8) fda=0 bits=0000 __kernel_timex.calcnt __int64;
// 20. 0090 0008 effalign(8) fda=0 bits=0000 __kernel_timex.errcnt __int64;
// 21. 0098 0008 effalign(8) fda=0 bits=0000 __kernel_timex.stbcnt __int64;
// 22. 00A0 0004 effalign(4) fda=0 bits=0000 __kernel_timex.tai int;
// 23. 00A4. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 24. 00A8. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 25. 00AC. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 26. 00B0. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 27. 00B4. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 28. 00B8. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 29. 00BC. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 30. 00C0. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 31. 00C4. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 32. 00C8. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
// 33. 00CC. 0 32 effalign(4) fda=0 bits=0000 __kernel_timex.(null) bi.nbytes=4 S
//          00D0 effalign(8) sda=0 bits=0000 __kernel_timex struct packalign=0

00000010 struct __kernel_timex_timeval
{
  __kernel_time64_t tv_sec;
  __int64 tv_usec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __kernel_timex_timeval.tv_sec __kernel_time64_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 __kernel_timex_timeval.tv_usec __int64;
//          0010 effalign(8) sda=0 bits=0000 __kernel_timex_timeval struct packalign=0

00000002 typedef unsigned __int16 __kernel_uid16_t;
00000004 typedef unsigned int __kernel_uid32_t;
00000004 typedef unsigned int __kernel_uid_t;
00000008 typedef unsigned __int64 __kernel_ulong_t;
FFFFFFFF struct __key_reference_with_attributes;
00000320 struct __large_struct
{
  unsigned __int64 buf[100];
};
//  0. 0000 0320 effalign(8) fda=0 bits=0000 __large_struct.buf unsigned __int64[100];
//          0320 effalign(8) sda=0 bits=0000 __large_struct struct packalign=0

00000002 typedef __u16 __le16;
00000004 typedef __u32 __le32;
00000008 typedef __u64 __le64;
00000020 struct __old_kernel_stat
{
  unsigned __int16 st_dev;
  unsigned __int16 st_ino;
  unsigned __int16 st_mode;
  unsigned __int16 st_nlink;
  unsigned __int16 st_uid;
  unsigned __int16 st_gid;
  unsigned __int16 st_rdev;
  unsigned int st_size;
  unsigned int st_atime;
  unsigned int st_mtime;
  unsigned int st_ctime;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_dev unsigned __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_ino unsigned __int16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_mode unsigned __int16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_nlink unsigned __int16;
//  4. 0008 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_uid unsigned __int16;
//  5. 000A 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_gid unsigned __int16;
//  6. 000C 0002 effalign(2) fda=0 bits=0000 __old_kernel_stat.st_rdev unsigned __int16;
//  7. 0010 0004 effalign(4) fda=0 bits=0000 __old_kernel_stat.st_size unsigned int;
//  8. 0014 0004 effalign(4) fda=0 bits=0000 __old_kernel_stat.st_atime unsigned int;
//  9. 0018 0004 effalign(4) fda=0 bits=0000 __old_kernel_stat.st_mtime unsigned int;
// 10. 001C 0004 effalign(4) fda=0 bits=0000 __old_kernel_stat.st_ctime unsigned int;
//          0020 effalign(4) sda=0 bits=0000 __old_kernel_stat struct packalign=0

00000004 typedef unsigned int __poll_t;
FFFFFFFF typedef void __restorefn_t(void);
00000002 typedef __int16 __s16;
00000004 typedef int __s32;
00000008 typedef __int64 __s64;
00000001 typedef char __s8;
00000020 union __sifields
{
  __sifields::$781F622659705A3ED26C10F885D10ED1 _kill;
  __sifields::$4C9EF475FA8D7F83067E301A4903CFFA _timer;
  __sifields::$B0AD34E5C8A152814DB2F16036208CE6 _rt;
  __sifields::$F1366510234E27C8C23A16A0CF6CF0CC _sigchld;
  __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643 _sigfault;
  __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7 _sigpoll;
  __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 __sifields._kill __sifields::$781F622659705A3ED26C10F885D10ED1;
//  1. 0000 0018 effalign(8) fda=0 bits=0000 __sifields._timer __sifields::$4C9EF475FA8D7F83067E301A4903CFFA;
//  2. 0000 0010 effalign(8) fda=0 bits=0000 __sifields._rt __sifields::$B0AD34E5C8A152814DB2F16036208CE6;
//  3. 0000 0020 effalign(8) fda=0 bits=0000 __sifields._sigchld __sifields::$F1366510234E27C8C23A16A0CF6CF0CC;
//  4. 0000 0020 effalign(8) fda=0 bits=0000 __sifields._sigfault __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643;
//  5. 0000 0010 effalign(8) fda=0 bits=0000 __sifields._sigpoll __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7;
//  6. 0000 0010 effalign(8) fda=0 bits=0000 __sifields._sigsys __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E;
//          0020 effalign(8) sda=0 bits=0000 __sifields union packalign=0

00000020 struct __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643
{
  void *_addr;
  union
  {
    __int16 _addr_lsb;
    $F5C1C9C04BCDB0ADA1B147BEDD0D212C _addr_bnd;
    $AE7699F1C0F08D928DAB88E00BBC947C _addr_pkey;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643._addr void *;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643.$2B0C88ED88ED3BB73D04C51F76AE706D $2B0C88ED88ED3BB73D04C51F76AE706D;
//          0020 effalign(8) sda=0 bits=0000 __sifields::$3AE2D8CD61F7AC2471CFAC8FA1F7E643 struct packalign=0

00000010 struct __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E._call_addr void *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E._syscall int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E._arch unsigned int;
//          0010 effalign(8) sda=0 bits=0000 __sifields::$4B29161E04CAD4BCDD788B201A5E8E5E struct packalign=0

00000018 struct __sifields::$4C9EF475FA8D7F83067E301A4903CFFA
{
  __kernel_timer_t _tid;
  int _overrun;
  sigval_t _sigval;
  int _sys_private;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __sifields::$4C9EF475FA8D7F83067E301A4903CFFA._tid __kernel_timer_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __sifields::$4C9EF475FA8D7F83067E301A4903CFFA._overrun int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 __sifields::$4C9EF475FA8D7F83067E301A4903CFFA._sigval sigval_t;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 __sifields::$4C9EF475FA8D7F83067E301A4903CFFA._sys_private int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 __sifields::$4C9EF475FA8D7F83067E301A4903CFFA struct packalign=0

00000008 struct __sifields::$781F622659705A3ED26C10F885D10ED1
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __sifields::$781F622659705A3ED26C10F885D10ED1._pid __kernel_pid_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __sifields::$781F622659705A3ED26C10F885D10ED1._uid __kernel_uid32_t;
//          0008 effalign(4) sda=0 bits=0000 __sifields::$781F622659705A3ED26C10F885D10ED1 struct packalign=0

00000010 struct __sifields::$B0AD34E5C8A152814DB2F16036208CE6
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  sigval_t _sigval;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __sifields::$B0AD34E5C8A152814DB2F16036208CE6._pid __kernel_pid_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __sifields::$B0AD34E5C8A152814DB2F16036208CE6._uid __kernel_uid32_t;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 __sifields::$B0AD34E5C8A152814DB2F16036208CE6._sigval sigval_t;
//          0010 effalign(8) sda=0 bits=0000 __sifields::$B0AD34E5C8A152814DB2F16036208CE6 struct packalign=0

00000010 struct __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7
{
  __int64 _band;
  int _fd;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7._band __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7._fd int;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 __sifields::$B9B6628F51B16DCE593F87C04ABDB9F7 struct packalign=0

00000020 struct __sifields::$F1366510234E27C8C23A16A0CF6CF0CC
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  int _status;
  __kernel_clock_t _utime;
  __kernel_clock_t _stime;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC._pid __kernel_pid_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC._uid __kernel_uid32_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC._status int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC._utime __kernel_clock_t;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC._stime __kernel_clock_t;
//          0020 effalign(8) sda=0 bits=0000 __sifields::$F1366510234E27C8C23A16A0CF6CF0CC struct packalign=0

00000008 typedef __signalfn_t *__sighandler_t;
FFFFFFFF typedef void __cdecl __signalfn_t(int);
00000008 typedef __restorefn_t *__sigrestore_t;
000000B0 struct __sk_buff
{
  __u32 len;
  __u32 pkt_type;
  __u32 mark;
  __u32 queue_mapping;
  __u32 protocol;
  __u32 vlan_present;
  __u32 vlan_tci;
  __u32 vlan_proto;
  __u32 priority;
  __u32 ingress_ifindex;
  __u32 ifindex;
  __u32 tc_index;
  __u32 cb[5];
  __u32 hash;
  __u32 tc_classid;
  __u32 data;
  __u32 data_end;
  __u32 napi_id;
  __u32 family;
  __u32 remote_ip4;
  __u32 local_ip4;
  __u32 remote_ip6[4];
  __u32 local_ip6[4];
  __u32 remote_port;
  __u32 local_port;
  __u32 data_meta;
  union __attribute__((aligned(8)))
  {
    bpf_flow_keys *flow_keys;
    unsigned __int64 : 64;
  };
  unsigned __int64 tstamp;
  __u32 wire_len;
  __u32 gso_segs;
  union __attribute__((aligned(8)))
  {
    bpf_sock *sk;
    unsigned __int64 : 64;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __sk_buff.len __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __sk_buff.pkt_type __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 __sk_buff.mark __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 __sk_buff.queue_mapping __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 __sk_buff.protocol __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 __sk_buff.vlan_present __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 __sk_buff.vlan_tci __u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 __sk_buff.vlan_proto __u32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 __sk_buff.priority __u32;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 __sk_buff.ingress_ifindex __u32;
// 10. 0028 0004 effalign(4) fda=0 bits=0000 __sk_buff.ifindex __u32;
// 11. 002C 0004 effalign(4) fda=0 bits=0000 __sk_buff.tc_index __u32;
// 12. 0030 0014 effalign(4) fda=0 bits=0000 __sk_buff.cb __u32[5];
// 13. 0044 0004 effalign(4) fda=0 bits=0000 __sk_buff.hash __u32;
// 14. 0048 0004 effalign(4) fda=0 bits=0000 __sk_buff.tc_classid __u32;
// 15. 004C 0004 effalign(4) fda=0 bits=0000 __sk_buff.data __u32;
// 16. 0050 0004 effalign(4) fda=0 bits=0000 __sk_buff.data_end __u32;
// 17. 0054 0004 effalign(4) fda=0 bits=0000 __sk_buff.napi_id __u32;
// 18. 0058 0004 effalign(4) fda=0 bits=0000 __sk_buff.family __u32;
// 19. 005C 0004 effalign(4) fda=0 bits=0000 __sk_buff.remote_ip4 __u32;
// 20. 0060 0004 effalign(4) fda=0 bits=0000 __sk_buff.local_ip4 __u32;
// 21. 0064 0010 effalign(4) fda=0 bits=0000 __sk_buff.remote_ip6 __u32[4];
// 22. 0074 0010 effalign(4) fda=0 bits=0000 __sk_buff.local_ip6 __u32[4];
// 23. 0084 0004 effalign(4) fda=0 bits=0000 __sk_buff.remote_port __u32;
// 24. 0088 0004 effalign(4) fda=0 bits=0000 __sk_buff.local_port __u32;
// 25. 008C 0004 effalign(4) fda=0 bits=0000 __sk_buff.data_meta __u32;
// 26. 0090 0008 effalign(8) fda=0 bits=0000 __sk_buff.__sk_buff::$9306D3E5A723B85A3E75A35D5847C933 __sk_buff::$9306D3E5A723B85A3E75A35D5847C933;
// 27. 0098 0008 effalign(8) fda=0 bits=0000 __sk_buff.tstamp __u64;
// 28. 00A0 0004 effalign(4) fda=0 bits=0000 __sk_buff.wire_len __u32;
// 29. 00A4 0004 effalign(4) fda=0 bits=0000 __sk_buff.gso_segs __u32;
// 30. 00A8 0008 effalign(8) fda=0 bits=0000 __sk_buff.__sk_buff::$000FA75B077373DB1E9F715A746A0F31 __sk_buff::$000FA75B077373DB1E9F715A746A0F31;
//          00B0 effalign(8) sda=0 bits=0000 __sk_buff struct packalign=0

00000008 union __attribute__((aligned(8))) __sk_buff::$000FA75B077373DB1E9F715A746A0F31
{
  bpf_sock *sk;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sk_buff::$000FA75B077373DB1E9F715A746A0F31.sk bpf_sock *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 __sk_buff::$000FA75B077373DB1E9F715A746A0F31.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 __sk_buff::$000FA75B077373DB1E9F715A746A0F31 union packalign=0

00000008 union __attribute__((aligned(8))) __sk_buff::$9306D3E5A723B85A3E75A35D5847C933
{
  bpf_flow_keys *flow_keys;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sk_buff::$9306D3E5A723B85A3E75A35D5847C933.flow_keys bpf_flow_keys *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 __sk_buff::$9306D3E5A723B85A3E75A35D5847C933.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 __sk_buff::$9306D3E5A723B85A3E75A35D5847C933 union packalign=0

00000002 typedef __u16 __sum16;
00000050 struct __sysctl_args
{
  int *name;
  int nlen;
  void *oldval;
  size_t *oldlenp;
  void *newval;
  size_t newlen;
  unsigned __int64 __unused[4];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 __sysctl_args.name int *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 __sysctl_args.nlen int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 __sysctl_args.oldval void *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 __sysctl_args.oldlenp size_t *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 __sysctl_args.newval void *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 __sysctl_args.newlen size_t;
//  6. 0030 0020 effalign(8) fda=0 bits=0000 __sysctl_args.__unused unsigned __int64[4];
//          0050 effalign(8) sda=0 bits=0000 __sysctl_args struct packalign=0

00000002 typedef u16 __ticket_t;
00000004 typedef u32 __ticketpair_t;
00000002 typedef unsigned __int16 __u16;
00000004 typedef unsigned int __u32;
00000008 typedef unsigned __int64 __u64;
00000001 typedef unsigned __int8 __u8;
0000000C struct __user_cap_data_struct
{
  __u32 effective;
  __u32 permitted;
  __u32 inheritable;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __user_cap_data_struct.effective __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __user_cap_data_struct.permitted __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 __user_cap_data_struct.inheritable __u32;
//          000C effalign(4) sda=0 bits=0000 __user_cap_data_struct struct packalign=0

00000008 struct __user_cap_header_struct
{
  __u32 version;
  int pid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __user_cap_header_struct.version __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __user_cap_header_struct.pid int;
//          0008 effalign(4) sda=0 bits=0000 __user_cap_header_struct struct packalign=0

00000018 struct __va_list_tag
{
  unsigned int gp_offset;
  unsigned int fp_offset;
  void *overflow_arg_area;
  void *reg_save_area;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 __va_list_tag.gp_offset unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 __va_list_tag.fp_offset unsigned int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 __va_list_tag.overflow_arg_area void *;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 __va_list_tag.reg_save_area void *;
//          0018 effalign(8) sda=0 bits=0000 __va_list_tag struct packalign=0

00000004 typedef __u32 __wsum;
00000038 struct __attribute__((aligned(8))) _ddebug
{
  const char *modname;
  const char *function;
  const char *filename;
  const char *format;
  unsigned __int32 lineno : 18;
  unsigned __int32 flags : 8;
  _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812 key;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 _ddebug.modname const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 _ddebug.function const char *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 _ddebug.filename const char *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 _ddebug.format const char *;
//  4. 0020. 0 18 effalign(4) fda=0 bits=0000 _ddebug.lineno bi.nbytes=4 U
//  5. 0020.18 8 effalign(4) fda=0 bits=0000 _ddebug.flags bi.nbytes=4 U
//  6. 0028 0010 effalign(8) fda=0 bits=0000 _ddebug.key _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812;
//          0038 effalign(8) sda=4 bits=0000 _ddebug struct packalign=0

00000010 union _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812
{
  static_key_true dd_key_true;
  static_key_false dd_key_false;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812.dd_key_true static_key_true;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812.dd_key_false static_key_false;
//          0010 effalign(8) sda=0 bits=0000 _ddebug::$E95E4B3544406CC7FFA4E1A01EB1D812 union packalign=0

00000058 struct _efi_file_handle
{
  u64 revision;
  efi_status_t (__cdecl *open)(_efi_file_handle *, _efi_file_handle **, efi_char16_t *, u64, u64);
  efi_status_t (__cdecl *close)(_efi_file_handle *);
  void *delete;
  efi_status_t (__cdecl *read)(_efi_file_handle *, unsigned __int64 *, void *);
  void *write;
  void *get_position;
  void *set_position;
  efi_status_t (__cdecl *get_info)(_efi_file_handle *, efi_guid_t *, unsigned __int64 *, void *);
  void *set_info;
  void *flush;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.revision u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.open efi_status_t (__cdecl *)(_efi_file_handle *, _efi_file_handle **, efi_char16_t *, u64, u64);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.close efi_status_t (__cdecl *)(_efi_file_handle *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.delete void *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.read efi_status_t (__cdecl *)(_efi_file_handle *, unsigned __int64 *, void *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.write void *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.get_position void *;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.set_position void *;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.get_info efi_status_t (__cdecl *)(_efi_file_handle *, efi_guid_t *, unsigned __int64 *, void *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.set_info void *;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 _efi_file_handle.flush void *;
//          0058 effalign(8) sda=0 bits=0000 _efi_file_handle struct packalign=0

00000010 struct _efi_file_io_interface
{
  u64 revision;
  int (__cdecl *open_volume)(_efi_file_io_interface *, efi_file_handle_t **);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 _efi_file_io_interface.revision u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 _efi_file_io_interface.open_volume int (__cdecl *)(_efi_file_io_interface *, efi_file_handle_t **);
//          0010 effalign(8) sda=0 bits=0000 _efi_file_io_interface struct packalign=0

0000000A struct _fpreg
{
  __u16 significand[4];
  __u16 exponent;
};
//  0. 0000 0008 effalign(2) fda=0 bits=0000 _fpreg.significand __u16[4];
//  1. 0008 0002 effalign(2) fda=0 bits=0000 _fpreg.exponent __u16;
//          000A effalign(2) sda=0 bits=0000 _fpreg struct packalign=0

00000270 struct _fpstate_32
{
  __u32 cw;
  __u32 sw;
  __u32 tag;
  __u32 ipoff;
  __u32 cssel;
  __u32 dataoff;
  __u32 datasel;
  _fpreg _st[8];
  __u16 status;
  __u16 magic;
  __u32 _fxsr_env[6];
  __u32 mxcsr;
  __u32 reserved;
  _fpxreg _fxsr_st[8];
  _xmmreg _xmm[8];
  union
  {
    __u32 padding1[44];
    __u32 padding[44];
  };
  union
  {
    __u32 padding2[12];
    _fpx_sw_bytes sw_reserved;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 _fpstate_32.cw __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 _fpstate_32.sw __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 _fpstate_32.tag __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 _fpstate_32.ipoff __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 _fpstate_32.cssel __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 _fpstate_32.dataoff __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 _fpstate_32.datasel __u32;
//  7. 001C 0050 effalign(2) fda=0 bits=0000 _fpstate_32._st _fpreg[8];
//  8. 006C 0002 effalign(2) fda=0 bits=0000 _fpstate_32.status __u16;
//  9. 006E 0002 effalign(2) fda=0 bits=0000 _fpstate_32.magic __u16;
// 10. 0070 0018 effalign(4) fda=0 bits=0000 _fpstate_32._fxsr_env __u32[6];
// 11. 0088 0004 effalign(4) fda=0 bits=0000 _fpstate_32.mxcsr __u32;
// 12. 008C 0004 effalign(4) fda=0 bits=0000 _fpstate_32.reserved __u32;
// 13. 0090 0080 effalign(2) fda=0 bits=0000 _fpstate_32._fxsr_st _fpxreg[8];
// 14. 0110 0080 effalign(4) fda=0 bits=0000 _fpstate_32._xmm _xmmreg[8];
// 15. 0190 00B0 effalign(4) fda=0 bits=0000 _fpstate_32._fpstate_32::$E3C4C946EE330A56E07A8822FBA02343 _fpstate_32::$E3C4C946EE330A56E07A8822FBA02343;
// 16. 0240 0030 effalign(8) fda=0 bits=0000 _fpstate_32._fpstate_32::$F53E08A1112A44117E15DDC77CF7677D _fpstate_32::$F53E08A1112A44117E15DDC77CF7677D;
//          0270 effalign(8) sda=0 bits=0000 _fpstate_32 struct packalign=0

000000B0 union _fpstate_32::$E3C4C946EE330A56E07A8822FBA02343
{
  __u32 padding1[44];
  __u32 padding[44];
};
//  0. 0000 00B0 effalign(4) fda=0 bits=0000 _fpstate_32::$E3C4C946EE330A56E07A8822FBA02343.padding1 __u32[44];
//  1. 0000 00B0 effalign(4) fda=0 bits=0000 _fpstate_32::$E3C4C946EE330A56E07A8822FBA02343.padding __u32[44];
//          00B0 effalign(4) sda=0 bits=0000 _fpstate_32::$E3C4C946EE330A56E07A8822FBA02343 union packalign=0

00000030 union _fpstate_32::$F53E08A1112A44117E15DDC77CF7677D
{
  __u32 padding2[12];
  _fpx_sw_bytes sw_reserved;
};
//  0. 0000 0030 effalign(4) fda=0 bits=0000 _fpstate_32::$F53E08A1112A44117E15DDC77CF7677D.padding2 __u32[12];
//  1. 0000 0030 effalign(8) fda=0 bits=0000 _fpstate_32::$F53E08A1112A44117E15DDC77CF7677D.sw_reserved _fpx_sw_bytes;
//          0030 effalign(8) sda=0 bits=0000 _fpstate_32::$F53E08A1112A44117E15DDC77CF7677D union packalign=0

00000200 struct _fpstate_64
{
  __u16 cwd;
  __u16 swd;
  __u16 twd;
  __u16 fop;
  __u64 rip;
  __u64 rdp;
  __u32 mxcsr;
  __u32 mxcsr_mask;
  __u32 st_space[32];
  __u32 xmm_space[64];
  __u32 reserved2[12];
  union
  {
    __u32 reserved3[12];
    _fpx_sw_bytes sw_reserved;
  };
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 _fpstate_64.cwd __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 _fpstate_64.swd __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 _fpstate_64.twd __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 _fpstate_64.fop __u16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 _fpstate_64.rip __u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 _fpstate_64.rdp __u64;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 _fpstate_64.mxcsr __u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 _fpstate_64.mxcsr_mask __u32;
//  8. 0020 0080 effalign(4) fda=0 bits=0000 _fpstate_64.st_space __u32[32];
//  9. 00A0 0100 effalign(4) fda=0 bits=0000 _fpstate_64.xmm_space __u32[64];
// 10. 01A0 0030 effalign(4) fda=0 bits=0000 _fpstate_64.reserved2 __u32[12];
// 11. 01D0 0030 effalign(8) fda=0 bits=0000 _fpstate_64._fpstate_64::$C507B745A9922F76D2E67477D225C77B _fpstate_64::$C507B745A9922F76D2E67477D225C77B;
//          0200 effalign(8) sda=0 bits=0000 _fpstate_64 struct packalign=0

00000030 union _fpstate_64::$C507B745A9922F76D2E67477D225C77B
{
  __u32 reserved3[12];
  _fpx_sw_bytes sw_reserved;
};
//  0. 0000 0030 effalign(4) fda=0 bits=0000 _fpstate_64::$C507B745A9922F76D2E67477D225C77B.reserved3 __u32[12];
//  1. 0000 0030 effalign(8) fda=0 bits=0000 _fpstate_64::$C507B745A9922F76D2E67477D225C77B.sw_reserved _fpx_sw_bytes;
//          0030 effalign(8) sda=0 bits=0000 _fpstate_64::$C507B745A9922F76D2E67477D225C77B union packalign=0

00000030 struct _fpx_sw_bytes
{
  __u32 magic1;
  __u32 extended_size;
  __u64 xfeatures;
  __u32 xstate_size;
  __u32 padding[7];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 _fpx_sw_bytes.magic1 __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 _fpx_sw_bytes.extended_size __u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 _fpx_sw_bytes.xfeatures __u64;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 _fpx_sw_bytes.xstate_size __u32;
//  4. 0014 001C effalign(4) fda=0 bits=0000 _fpx_sw_bytes.padding __u32[7];
//          0030 effalign(8) sda=0 bits=0000 _fpx_sw_bytes struct packalign=0

00000010 struct _fpxreg
{
  __u16 significand[4];
  __u16 exponent;
  __u16 padding[3];
};
//  0. 0000 0008 effalign(2) fda=0 bits=0000 _fpxreg.significand __u16[4];
//  1. 0008 0002 effalign(2) fda=0 bits=0000 _fpxreg.exponent __u16;
//  2. 000A 0006 effalign(2) fda=0 bits=0000 _fpxreg.padding __u16[3];
//          0010 effalign(2) sda=0 bits=0000 _fpxreg struct packalign=0

00000040 struct _header
{
  __u64 xfeatures;
  __u64 reserved1[2];
  __u64 reserved2[5];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 _header.xfeatures __u64;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 _header.reserved1 __u64[2];
//  2. 0018 0028 effalign(8) fda=0 bits=0000 _header.reserved2 __u64[5];
//          0040 effalign(8) sda=0 bits=0000 _header struct packalign=0

00000010 struct _xmmreg
{
  __u32 element[4];
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 _xmmreg.element __u32[4];
//          0010 effalign(4) sda=0 bits=0000 _xmmreg struct packalign=0

00000340 struct _xstate
{
  _fpstate_64 fpstate;
  _header xstate_hdr;
  _ymmh_state ymmh;
};
//  0. 0000 0200 effalign(8) fda=0 bits=0000 _xstate.fpstate _fpstate_64;
//  1. 0200 0040 effalign(8) fda=0 bits=0000 _xstate.xstate_hdr _header;
//  2. 0240 0100 effalign(4) fda=0 bits=0000 _xstate.ymmh _ymmh_state;
//          0340 effalign(8) sda=0 bits=0000 _xstate struct packalign=0

00000100 struct _ymmh_state
{
  __u32 ymmh_space[64];
};
//  0. 0000 0100 effalign(4) fda=0 bits=0000 _ymmh_state.ymmh_space __u32[64];
//          0100 effalign(4) sda=0 bits=0000 _ymmh_state struct packalign=0

0000000A #pragma pack(push, 1)
struct acpi_address16_attribute
{
  u16 granularity;
  u16 minimum;
  u16 maximum;
  u16 translation_offset;
  u16 address_length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_address16_attribute.granularity u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_address16_attribute.minimum u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 acpi_address16_attribute.maximum u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_address16_attribute.translation_offset u16;
//  4. 0008 0002 effalign(2) fda=0 bits=0000 acpi_address16_attribute.address_length u16;
//          000A effalign(1) sda=0 bits=0000 acpi_address16_attribute struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_address32_attribute
{
  u32 granularity;
  u32 minimum;
  u32 maximum;
  u32 translation_offset;
  u32 address_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_address32_attribute.granularity u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_address32_attribute.minimum u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_address32_attribute.maximum u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_address32_attribute.translation_offset u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_address32_attribute.address_length u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_address32_attribute struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_address64_attribute
{
  u64 granularity;
  u64 minimum;
  u64 maximum;
  u64 translation_offset;
  u64 address_length;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_address64_attribute.granularity u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_address64_attribute.minimum u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_address64_attribute.maximum u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 acpi_address64_attribute.translation_offset u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 acpi_address64_attribute.address_length u64;
//          0028 effalign(1) sda=0 bits=0000 acpi_address64_attribute struct packalign=1

00000004 enum acpi_address_range_id : unsigned __int32
{
  ACPI_ADDRESS_RANGE_MEMORY = 0x1,
  ACPI_ADDRESS_RANGE_RESERVED = 0x2,
  ACPI_ADDRESS_RANGE_ACPI = 0x3,
  ACPI_ADDRESS_RANGE_NVS = 0x4,
  ACPI_ADDRESS_RANGE_COUNT = 0x5,
};
00000008 typedef acpi_status (__cdecl *acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);
00000008 typedef acpi_status (__cdecl *acpi_adr_space_setup)(acpi_handle, u32, void *, void **);
00000001 typedef u8 acpi_adr_space_type;
00000006 #pragma pack(push, 1)
struct acpi_asf_address
{
  acpi_asf_header header;
  u8 eprom_address;
  u8 devices;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_asf_address.header acpi_asf_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_asf_address.eprom_address u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_asf_address.devices u8;
//          0006 effalign(1) sda=0 bits=0000 acpi_asf_address struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_asf_alert
{
  acpi_asf_header header;
  u8 assert_mask;
  u8 deassert_mask;
  u8 alerts;
  u8 data_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_asf_alert.header acpi_asf_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert.assert_mask u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert.deassert_mask u8;
//  3. 0006 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert.alerts u8;
//  4. 0007 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert.data_length u8;
//          0008 effalign(1) sda=0 bits=0000 acpi_asf_alert struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_asf_alert_data
{
  u8 address;
  u8 command;
  u8 mask;
  u8 value;
  u8 sensor_type;
  u8 type;
  u8 offset;
  u8 source_type;
  u8 severity;
  u8 sensor_number;
  u8 entity;
  u8 instance;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.address u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.command u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.mask u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.value u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.sensor_type u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.type u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.offset u8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.source_type u8;
//  8. 0008 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.severity u8;
//  9. 0009 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.sensor_number u8;
// 10. 000A 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.entity u8;
// 11. 000B 0001 effalign(1) fda=0 bits=0000 acpi_asf_alert_data.instance u8;
//          000C effalign(1) sda=0 bits=0000 acpi_asf_alert_data struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_asf_control_data
{
  u8 function;
  u8 address;
  u8 command;
  u8 value;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_asf_control_data.function u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_asf_control_data.address u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_asf_control_data.command u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_asf_control_data.value u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_asf_control_data struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_asf_header
{
  u8 type;
  u8 reserved;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_asf_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_asf_header.reserved u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_asf_header.length u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_asf_header struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_asf_info
{
  acpi_asf_header header;
  u8 min_reset_value;
  u8 min_poll_interval;
  u16 system_id;
  u32 mfg_id;
  u8 flags;
  u8 reserved2[3];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_asf_info.header acpi_asf_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_asf_info.min_reset_value u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_asf_info.min_poll_interval u8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_asf_info.system_id u16;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_asf_info.mfg_id u32;
//  5. 000C 0001 effalign(1) fda=0 bits=0000 acpi_asf_info.flags u8;
//  6. 000D 0003 effalign(1) fda=0 bits=0000 acpi_asf_info.reserved2 u8[3];
//          0010 effalign(1) sda=0 bits=0000 acpi_asf_info struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_asf_remote
{
  acpi_asf_header header;
  u8 controls;
  u8 data_length;
  u16 reserved2;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_asf_remote.header acpi_asf_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_asf_remote.controls u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_asf_remote.data_length u8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_asf_remote.reserved2 u16;
//          0008 effalign(1) sda=0 bits=0000 acpi_asf_remote struct packalign=1

00000017 #pragma pack(push, 1)
struct acpi_asf_rmcp
{
  acpi_asf_header header;
  u8 capabilities[7];
  u8 completion_code;
  u32 enterprise_id;
  u8 command;
  u16 parameter;
  u16 boot_options;
  u16 oem_parameters;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_asf_rmcp.header acpi_asf_header;
//  1. 0004 0007 effalign(1) fda=0 bits=0000 acpi_asf_rmcp.capabilities u8[7];
//  2. 000B 0001 effalign(1) fda=0 bits=0000 acpi_asf_rmcp.completion_code u8;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_asf_rmcp.enterprise_id u32;
//  4. 0010 0001 effalign(1) fda=0 bits=0000 acpi_asf_rmcp.command u8;
//  5. 0011 0002 effalign(2) fda=0 bits=0000 acpi_asf_rmcp.parameter u16;
//  6. 0013 0002 effalign(2) fda=0 bits=0000 acpi_asf_rmcp.boot_options u16;
//  7. 0015 0002 effalign(2) fda=0 bits=0000 acpi_asf_rmcp.oem_parameters u16;
//          0017 effalign(1) sda=0 bits=0000 acpi_asf_rmcp struct packalign=1

00000004 enum acpi_asf_type : unsigned __int32
{
  ACPI_ASF_TYPE_INFO = 0x0,
  ACPI_ASF_TYPE_ALERT = 0x1,
  ACPI_ASF_TYPE_CONTROL = 0x2,
  ACPI_ASF_TYPE_BOOT = 0x3,
  ACPI_ASF_TYPE_ADDRESS = 0x4,
  ACPI_ASF_TYPE_RESERVED = 0x5,
};
00000004 enum acpi_bert_error_severity : unsigned __int32
{
  ACPI_BERT_ERROR_CORRECTABLE = 0x0,
  ACPI_BERT_ERROR_FATAL = 0x1,
  ACPI_BERT_ERROR_CORRECTED = 0x2,
  ACPI_BERT_ERROR_NONE = 0x3,
  ACPI_BERT_ERROR_RESERVED = 0x4,
};
00000014 #pragma pack(push, 1)
struct acpi_bert_region
{
  u32 block_status;
  u32 raw_data_offset;
  u32 raw_data_length;
  u32 data_length;
  u32 error_severity;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_bert_region.block_status u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_bert_region.raw_data_offset u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_bert_region.raw_data_length u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_bert_region.data_length u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_bert_region.error_severity u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_bert_region struct packalign=1

00000010 struct acpi_buffer
{
  acpi_size length;
  void *pointer;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_buffer.length acpi_size;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_buffer.pointer void *;
//          0010 effalign(8) sda=0 bits=0000 acpi_buffer struct packalign=0

00000008 typedef u64 acpi_bus_address;
00000004 enum acpi_bus_device_type : unsigned __int32
{
  ACPI_BUS_TYPE_DEVICE = 0x0,
  ACPI_BUS_TYPE_POWER = 0x1,
  ACPI_BUS_TYPE_PROCESSOR = 0x2,
  ACPI_BUS_TYPE_THERMAL = 0x3,
  ACPI_BUS_TYPE_POWER_BUTTON = 0x4,
  ACPI_BUS_TYPE_SLEEP_BUTTON = 0x5,
  ACPI_BUS_TYPE_ECDT_EC = 0x6,
  ACPI_BUS_DEVICE_TYPE_COUNT = 0x7,
};
00000038 struct acpi_bus_event
{
  list_head node;
  acpi_device_class device_class;
  acpi_bus_id bus_id;
  u32 type;
  u32 data;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 acpi_bus_event.node list_head;
//  1. 0010 0014 effalign(1) fda=0 bits=0000 acpi_bus_event.device_class acpi_device_class;
//  2. 0024 0008 effalign(1) fda=0 bits=0000 acpi_bus_event.bus_id acpi_bus_id;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 acpi_bus_event.type u32;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 acpi_bus_event.data u32;
//          0034 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 acpi_bus_event struct packalign=0

00000008 typedef char acpi_bus_id[8];
00000038 struct acpi_bus_type
{
  list_head list;
  const char *name;
  bool (__cdecl *match)(device *);
  acpi_device *(__cdecl *find_companion)(device *);
  void (__cdecl *setup)(device *);
  void (__cdecl *cleanup)(device *);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 acpi_bus_type.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 acpi_bus_type.name const char *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 acpi_bus_type.match bool (__cdecl *)(device *);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 acpi_bus_type.find_companion acpi_device *(__cdecl *)(device *);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 acpi_bus_type.setup void (__cdecl *)(device *);
//  5. 0030 0008 effalign(8) fda=0 bits=0000 acpi_bus_type.cleanup void (__cdecl *)(device *);
//          0038 effalign(8) sda=0 bits=0000 acpi_bus_type struct packalign=0

00000010 struct acpi_connection_info
{
  u8 *connection;
  u16 length;
  u8 access_length;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_connection_info.connection u8 *;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 acpi_connection_info.length u16;
//  2. 000A 0001 effalign(1) fda=0 bits=0000 acpi_connection_info.access_length u8;
//          000B unpadded_size
//          0010 effalign(8) sda=0 bits=0000 acpi_connection_info struct packalign=0

00000008 #pragma pack(push, 1)
struct acpi_cpep_polling
{
  acpi_subtable_header header;
  u8 id;
  u8 eid;
  u32 interval;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_cpep_polling.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_cpep_polling.id u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_cpep_polling.eid u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_cpep_polling.interval u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_cpep_polling struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_csrt_descriptor
{
  u32 length;
  u16 type;
  u16 subtype;
  u32 uid;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_csrt_descriptor.length u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_csrt_descriptor.type u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_csrt_descriptor.subtype u16;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_csrt_descriptor.uid u32;
//          000C effalign(1) sda=0 bits=0000 acpi_csrt_descriptor struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_csrt_group
{
  u32 length;
  u32 vendor_id;
  u32 subvendor_id;
  u16 device_id;
  u16 subdevice_id;
  u16 revision;
  u16 reserved;
  u32 shared_info_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_csrt_group.length u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_csrt_group.vendor_id u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_csrt_group.subvendor_id u32;
//  3. 000C 0002 effalign(2) fda=0 bits=0000 acpi_csrt_group.device_id u16;
//  4. 000E 0002 effalign(2) fda=0 bits=0000 acpi_csrt_group.subdevice_id u16;
//  5. 0010 0002 effalign(2) fda=0 bits=0000 acpi_csrt_group.revision u16;
//  6. 0012 0002 effalign(2) fda=0 bits=0000 acpi_csrt_group.reserved u16;
//  7. 0014 0004 effalign(4) fda=0 bits=0000 acpi_csrt_group.shared_info_length u32;
//          0018 effalign(1) sda=0 bits=0000 acpi_csrt_group struct packalign=1

0000001C #pragma pack(push, 1)
struct acpi_csrt_shared_info
{
  u16 major_version;
  u16 minor_version;
  u32 mmio_base_low;
  u32 mmio_base_high;
  u32 gsi_interrupt;
  u8 interrupt_polarity;
  u8 interrupt_mode;
  u8 num_channels;
  u8 dma_address_width;
  u16 base_request_line;
  u16 num_handshake_signals;
  u32 max_block_size;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_csrt_shared_info.major_version u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_csrt_shared_info.minor_version u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_csrt_shared_info.mmio_base_low u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_csrt_shared_info.mmio_base_high u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_csrt_shared_info.gsi_interrupt u32;
//  5. 0010 0001 effalign(1) fda=0 bits=0000 acpi_csrt_shared_info.interrupt_polarity u8;
//  6. 0011 0001 effalign(1) fda=0 bits=0000 acpi_csrt_shared_info.interrupt_mode u8;
//  7. 0012 0001 effalign(1) fda=0 bits=0000 acpi_csrt_shared_info.num_channels u8;
//  8. 0013 0001 effalign(1) fda=0 bits=0000 acpi_csrt_shared_info.dma_address_width u8;
//  9. 0014 0002 effalign(2) fda=0 bits=0000 acpi_csrt_shared_info.base_request_line u16;
// 10. 0016 0002 effalign(2) fda=0 bits=0000 acpi_csrt_shared_info.num_handshake_signals u16;
// 11. 0018 0004 effalign(4) fda=0 bits=0000 acpi_csrt_shared_info.max_block_size u32;
//          001C effalign(1) sda=0 bits=0000 acpi_csrt_shared_info struct packalign=1

000000C8 struct acpi_data_node
{
  const char *name;
  acpi_handle handle;
  fwnode_handle fwnode;
  fwnode_handle *parent;
  acpi_device_data data;
  list_head sibling;
  kobject kobj;
  completion kobj_done;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_data_node.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_data_node.handle acpi_handle;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 acpi_data_node.fwnode fwnode_handle;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 acpi_data_node.parent fwnode_handle *;
//  4. 0028 0030 effalign(8) fda=0 bits=0000 acpi_data_node.data acpi_device_data;
//  5. 0058 0010 effalign(8) fda=0 bits=0000 acpi_data_node.sibling list_head;
//  6. 0068 0040 effalign(8) fda=0 bits=0000 acpi_data_node.kobj kobject;
//  7. 00A8 0020 effalign(8) fda=0 bits=0000 acpi_data_node.kobj_done completion;
//          00C8 effalign(8) sda=0 bits=0000 acpi_data_node struct packalign=0

00000016 #pragma pack(push, 1)
struct acpi_dbg2_device
{
  u8 revision;
  u16 length;
  u8 register_count;
  u16 namepath_length;
  u16 namepath_offset;
  u16 oem_data_length;
  u16 oem_data_offset;
  u16 port_type;
  u16 port_subtype;
  u16 reserved;
  u16 base_address_offset;
  u16 address_size_offset;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_dbg2_device.revision u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.length u16;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_dbg2_device.register_count u8;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.namepath_length u16;
//  4. 0006 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.namepath_offset u16;
//  5. 0008 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.oem_data_length u16;
//  6. 000A 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.oem_data_offset u16;
//  7. 000C 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.port_type u16;
//  8. 000E 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.port_subtype u16;
//  9. 0010 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.reserved u16;
// 10. 0012 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.base_address_offset u16;
// 11. 0014 0002 effalign(2) fda=0 bits=0000 acpi_dbg2_device.address_size_offset u16;
//          0016 effalign(1) sda=0 bits=0000 acpi_dbg2_device struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_dbg2_header
{
  u32 info_offset;
  u32 info_count;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_dbg2_header.info_offset u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_dbg2_header.info_count u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_dbg2_header struct packalign=1

00000030 struct acpi_debugger
{
  const acpi_debugger_ops *ops;
  module *owner;
  mutex lock;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_debugger.ops const acpi_debugger_ops *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_debugger.owner module *;
//  2. 0010 0020 effalign(8) fda=0 bits=0000 acpi_debugger.lock mutex;
//          0030 effalign(8) sda=0 bits=0000 acpi_debugger struct packalign=0

00000028 struct acpi_debugger_ops
{
  int (__cdecl *create_thread)(acpi_osd_exec_callback, void *);
  ssize_t (__cdecl *write_log)(const char *);
  ssize_t (__cdecl *read_cmd)(char *, size_t);
  int (__cdecl *wait_command_ready)(bool, char *, size_t);
  int (*notify_command_complete)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_debugger_ops.create_thread int (__cdecl *)(acpi_osd_exec_callback, void *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_debugger_ops.write_log ssize_t (__cdecl *)(const char *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_debugger_ops.read_cmd ssize_t (__cdecl *)(char *, size_t);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 acpi_debugger_ops.wait_command_ready int (__cdecl *)(bool, char *, size_t);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 acpi_debugger_ops.notify_command_complete int (*)(void);
//          0028 effalign(8) sda=0 bits=0000 acpi_debugger_ops struct packalign=0

00000570 struct acpi_device
{
  int device_type;
  acpi_handle handle;
  fwnode_handle fwnode;
  acpi_device *parent;
  list_head children;
  list_head node;
  list_head wakeup_list;
  list_head del_list;
  acpi_device_status status;
  acpi_device_flags flags;
  acpi_device_pnp pnp;
  acpi_device_power power;
  acpi_device_wakeup wakeup;
  acpi_device_perf performance;
  acpi_device_dir dir;
  acpi_device_data data;
  acpi_scan_handler *handler;
  acpi_hotplug_context *hp;
  acpi_driver *driver;
  const acpi_gpio_mapping *driver_gpios;
  void *driver_data;
  device dev;
  unsigned int physical_node_count;
  unsigned int dep_unmet;
  list_head physical_node_list;
  mutex physical_node_lock;
  void (__cdecl *remove)(acpi_device *);
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_device.device_type int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_device.handle acpi_handle;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 acpi_device.fwnode fwnode_handle;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 acpi_device.parent acpi_device *;
//  4. 0028 0010 effalign(8) fda=0 bits=0000 acpi_device.children list_head;
//  5. 0038 0010 effalign(8) fda=0 bits=0000 acpi_device.node list_head;
//  6. 0048 0010 effalign(8) fda=0 bits=0000 acpi_device.wakeup_list list_head;
//  7. 0058 0010 effalign(8) fda=0 bits=0000 acpi_device.del_list list_head;
//  8. 0068 0004 effalign(4) fda=0 bits=0000 acpi_device.status acpi_device_status;
//  9. 006C 0004 effalign(4) fda=0 bits=0000 acpi_device.flags acpi_device_flags;
// 10. 0070 0078 effalign(8) fda=0 bits=0000 acpi_device.pnp acpi_device_pnp;
// 11. 00E8 00A8 effalign(8) fda=0 bits=0000 acpi_device.power acpi_device_power;
// 12. 0190 0050 effalign(8) fda=0 bits=0000 acpi_device.wakeup acpi_device_wakeup;
// 13. 01E0 0018 effalign(8) fda=0 bits=0000 acpi_device.performance acpi_device_perf;
// 14. 01F8 0008 effalign(8) fda=0 bits=0000 acpi_device.dir acpi_device_dir;
// 15. 0200 0030 effalign(8) fda=0 bits=0000 acpi_device.data acpi_device_data;
// 16. 0230 0008 effalign(8) fda=0 bits=0000 acpi_device.handler acpi_scan_handler *;
// 17. 0238 0008 effalign(8) fda=0 bits=0000 acpi_device.hp acpi_hotplug_context *;
// 18. 0240 0008 effalign(8) fda=0 bits=0000 acpi_device.driver acpi_driver *;
// 19. 0248 0008 effalign(8) fda=0 bits=0000 acpi_device.driver_gpios const acpi_gpio_mapping *;
// 20. 0250 0008 effalign(8) fda=0 bits=0000 acpi_device.driver_data void *;
// 21. 0258 02D8 effalign(8) fda=0 bits=0000 acpi_device.dev device;
// 22. 0530 0004 effalign(4) fda=0 bits=0000 acpi_device.physical_node_count unsigned int;
// 23. 0534 0004 effalign(4) fda=0 bits=0000 acpi_device.dep_unmet unsigned int;
// 24. 0538 0010 effalign(8) fda=0 bits=0000 acpi_device.physical_node_list list_head;
// 25. 0548 0020 effalign(8) fda=0 bits=0000 acpi_device.physical_node_lock mutex;
// 26. 0568 0008 effalign(8) fda=0 bits=0000 acpi_device.remove void (__cdecl *)(acpi_device *);
//          0570 effalign(8) sda=0 bits=0000 acpi_device struct packalign=0

00000014 typedef char acpi_device_class[20];
00000030 struct acpi_device_data
{
  const acpi_object *pointer;
  list_head properties;
  const acpi_object *of_compatible;
  list_head subnodes;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_data.pointer const acpi_object *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 acpi_device_data.properties list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 acpi_device_data.of_compatible const acpi_object *;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 acpi_device_data.subnodes list_head;
//          0030 effalign(8) sda=0 bits=0000 acpi_device_data struct packalign=0

00000008 struct acpi_device_dir
{
  proc_dir_entry *entry;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_dir.entry proc_dir_entry *;
//          0008 effalign(8) sda=0 bits=0000 acpi_device_dir struct packalign=0

00000004 struct acpi_device_flags
{
  unsigned __int32 dynamic_status : 1;
  unsigned __int32 removable : 1;
  unsigned __int32 ejectable : 1;
  unsigned __int32 power_manageable : 1;
  unsigned __int32 match_driver : 1;
  unsigned __int32 initialized : 1;
  unsigned __int32 visited : 1;
  unsigned __int32 hotplug_notify : 1;
  unsigned __int32 is_dock_station : 1;
  unsigned __int32 of_compatible_ok : 1;
  unsigned __int32 coherent_dma : 1;
  unsigned __int32 cca_seen : 1;
  unsigned __int32 enumeration_by_parent : 1;
  unsigned __int32 reserved : 19;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_flags.dynamic_status bi.nbytes=4 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_device_flags.removable bi.nbytes=4 U
//  2. 0000. 2 1 effalign(1) fda=0 bits=0000 acpi_device_flags.ejectable bi.nbytes=4 U
//  3. 0000. 3 1 effalign(1) fda=0 bits=0000 acpi_device_flags.power_manageable bi.nbytes=4 U
//  4. 0000. 4 1 effalign(1) fda=0 bits=0000 acpi_device_flags.match_driver bi.nbytes=4 U
//  5. 0000. 5 1 effalign(1) fda=0 bits=0000 acpi_device_flags.initialized bi.nbytes=4 U
//  6. 0000. 6 1 effalign(1) fda=0 bits=0000 acpi_device_flags.visited bi.nbytes=4 U
//  7. 0000. 7 1 effalign(1) fda=0 bits=0000 acpi_device_flags.hotplug_notify bi.nbytes=4 U
//  8. 0000. 8 1 effalign(1) fda=0 bits=0000 acpi_device_flags.is_dock_station bi.nbytes=4 U
//  9. 0000. 9 1 effalign(1) fda=0 bits=0000 acpi_device_flags.of_compatible_ok bi.nbytes=4 U
// 10. 0000.10 1 effalign(1) fda=0 bits=0000 acpi_device_flags.coherent_dma bi.nbytes=4 U
// 11. 0000.11 1 effalign(1) fda=0 bits=0000 acpi_device_flags.cca_seen bi.nbytes=4 U
// 12. 0000.12 1 effalign(1) fda=0 bits=0000 acpi_device_flags.enumeration_by_parent bi.nbytes=4 U
// 13. 0000.13 19 effalign(1) fda=0 bits=0000 acpi_device_flags.reserved bi.nbytes=4 U
//          0004 effalign(4) sda=0 bits=0000 acpi_device_flags struct packalign=0

00000020 struct acpi_device_id
{
  __u8 id[9];
  kernel_ulong_t driver_data;
  __u32 cls;
  __u32 cls_msk;
};
//  0. 0000 0009 effalign(1) fda=0 bits=0000 acpi_device_id.id __u8[9];
//  1. 0010 0008 effalign(8) fda=0 bits=0000 acpi_device_id.driver_data kernel_ulong_t;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 acpi_device_id.cls __u32;
//  3. 001C 0004 effalign(4) fda=0 bits=0000 acpi_device_id.cls_msk __u32;
//          0020 effalign(8) sda=0 bits=0000 acpi_device_id struct packalign=0

00000070 struct acpi_device_info
{
  u32 info_size;
  u32 name;
  acpi_object_type type;
  u8 param_count;
  u16 valid;
  u8 flags;
  u8 highest_dstates[4];
  u8 lowest_dstates[5];
  u64 address;
  acpi_pnp_device_id hardware_id;
  acpi_pnp_device_id unique_id;
  acpi_pnp_device_id class_code;
  acpi_pnp_device_id_list compatible_id_list;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_device_info.info_size u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_device_info.name u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_device_info.type acpi_object_type;
//  3. 000C 0001 effalign(1) fda=0 bits=0000 acpi_device_info.param_count u8;
//  4. 000E 0002 effalign(2) fda=0 bits=0000 acpi_device_info.valid u16;
//  5. 0010 0001 effalign(1) fda=0 bits=0000 acpi_device_info.flags u8;
//  6. 0011 0004 effalign(1) fda=0 bits=0000 acpi_device_info.highest_dstates u8[4];
//  7. 0015 0005 effalign(1) fda=0 bits=0000 acpi_device_info.lowest_dstates u8[5];
//  8. 0020 0008 effalign(8) fda=0 bits=0000 acpi_device_info.address u64;
//  9. 0028 0010 effalign(8) fda=0 bits=0000 acpi_device_info.hardware_id acpi_pnp_device_id;
// 10. 0038 0010 effalign(8) fda=0 bits=0000 acpi_device_info.unique_id acpi_pnp_device_id;
// 11. 0048 0010 effalign(8) fda=0 bits=0000 acpi_device_info.class_code acpi_pnp_device_id;
// 12. 0058 0018 effalign(8) fda=0 bits=0000 acpi_device_info.compatible_id_list acpi_pnp_device_id_list;
//          0070 effalign(8) sda=0 bits=0000 acpi_device_info struct packalign=0

00000028 typedef char acpi_device_name[40];
00000018 struct acpi_device_ops
{
  acpi_op_add add;
  acpi_op_remove remove;
  acpi_op_notify notify;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_ops.add acpi_op_add;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_device_ops.remove acpi_op_remove;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_device_ops.notify acpi_op_notify;
//          0018 effalign(8) sda=0 bits=0000 acpi_device_ops struct packalign=0

00000018 struct acpi_device_perf
{
  int state;
  acpi_device_perf_flags flags;
  int state_count;
  acpi_device_perf_state *states;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_device_perf.state int;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_device_perf.flags acpi_device_perf_flags;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_device_perf.state_count int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_device_perf.states acpi_device_perf_state *;
//          0018 effalign(8) sda=0 bits=0000 acpi_device_perf struct packalign=0

00000001 struct acpi_device_perf_flags
{
  unsigned __int8 reserved : 8;
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 acpi_device_perf_flags.reserved bi.nbytes=1 U
//          0001 effalign(1) sda=0 bits=0000 acpi_device_perf_flags struct packalign=0

00000008 struct acpi_device_perf_state
{
  acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771 flags;
  u8 power;
  u8 performance;
  int latency;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_device_perf_state.flags acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_device_perf_state.power u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_device_perf_state.performance u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_device_perf_state.latency int;
//          0008 effalign(4) sda=0 bits=0000 acpi_device_perf_state struct packalign=0

00000001 struct acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771
{
  unsigned __int8 valid : 1;
  unsigned __int8 reserved : 7;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771.valid bi.nbytes=1 U
//  1. 0000. 1 7 effalign(1) fda=0 bits=0000 acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771.reserved bi.nbytes=1 U
//          0001 effalign(1) sda=0 bits=0000 acpi_device_perf_state::$1E4AC0D418205500FE47A4B6B6145771 struct packalign=0

00000028 struct acpi_device_physical_node
{
  unsigned int node_id;
  list_head node;
  device *dev;
  __int8 put_online : 1;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_device_physical_node.node_id unsigned int;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 acpi_device_physical_node.node list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 acpi_device_physical_node.dev device *;
//  3. 0020. 0 1 effalign(1) fda=0 bits=0000 acpi_device_physical_node.put_online bi.nbytes=1 S
//          0021 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 acpi_device_physical_node struct packalign=0

00000078 struct acpi_device_pnp
{
  acpi_bus_id bus_id;
  int instance_no;
  acpi_pnp_type type;
  acpi_bus_address bus_address;
  char *unique_id;
  list_head ids;
  acpi_device_name device_name;
  acpi_device_class device_class;
  acpi_object *str_obj;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_device_pnp.bus_id acpi_bus_id;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_device_pnp.instance_no int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_device_pnp.type acpi_pnp_type;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_device_pnp.bus_address acpi_bus_address;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 acpi_device_pnp.unique_id char *;
//  5. 0020 0010 effalign(8) fda=0 bits=0000 acpi_device_pnp.ids list_head;
//  6. 0030 0028 effalign(1) fda=0 bits=0000 acpi_device_pnp.device_name acpi_device_name;
//  7. 0058 0014 effalign(1) fda=0 bits=0000 acpi_device_pnp.device_class acpi_device_class;
//  8. 0070 0008 effalign(8) fda=0 bits=0000 acpi_device_pnp.str_obj acpi_object *;
//          0078 effalign(8) sda=0 bits=0000 acpi_device_pnp struct packalign=0

000000A8 struct acpi_device_power
{
  int state;
  acpi_device_power_flags flags;
  acpi_device_power_state states[5];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_device_power.state int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_device_power.flags acpi_device_power_flags;
//  2. 0008 00A0 effalign(8) fda=0 bits=0000 acpi_device_power.states acpi_device_power_state[5];
//          00A8 effalign(8) sda=0 bits=0000 acpi_device_power struct packalign=0

00000004 struct acpi_device_power_flags
{
  unsigned __int32 explicit_get : 1;
  unsigned __int32 power_resources : 1;
  unsigned __int32 inrush_current : 1;
  unsigned __int32 power_removed : 1;
  unsigned __int32 ignore_parent : 1;
  unsigned __int32 dsw_present : 1;
  unsigned __int32 reserved : 26;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.explicit_get bi.nbytes=4 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.power_resources bi.nbytes=4 U
//  2. 0000. 2 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.inrush_current bi.nbytes=4 U
//  3. 0000. 3 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.power_removed bi.nbytes=4 U
//  4. 0000. 4 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.ignore_parent bi.nbytes=4 U
//  5. 0000. 5 1 effalign(1) fda=0 bits=0000 acpi_device_power_flags.dsw_present bi.nbytes=4 U
//  6. 0000. 6 26 effalign(1) fda=0 bits=0000 acpi_device_power_flags.reserved bi.nbytes=4 U
//          0004 effalign(4) sda=0 bits=0000 acpi_device_power_flags struct packalign=0

00000020 struct acpi_device_power_state
{
  acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137 flags;
  int power;
  int latency;
  list_head resources;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_device_power_state.flags acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_device_power_state.power int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_device_power_state.latency int;
//  3. 0010 0010 effalign(8) fda=0 bits=0000 acpi_device_power_state.resources list_head;
//          0020 effalign(8) sda=0 bits=0000 acpi_device_power_state struct packalign=0

00000001 struct acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137
{
  unsigned __int8 valid : 1;
  unsigned __int8 explicit_set : 1;
  unsigned __int8 reserved : 6;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137.valid bi.nbytes=1 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137.explicit_set bi.nbytes=1 U
//  2. 0000. 2 6 effalign(1) fda=0 bits=0000 acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137.reserved bi.nbytes=1 U
//          0001 effalign(1) sda=0 bits=0000 acpi_device_power_state::$91A2264DB6421FBA7363D1A56B327137 struct packalign=0

00000020 struct acpi_device_properties
{
  const guid_t *guid;
  const acpi_object *properties;
  list_head list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_properties.guid const guid_t *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_device_properties.properties const acpi_object *;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 acpi_device_properties.list list_head;
//          0020 effalign(8) sda=0 bits=0000 acpi_device_properties struct packalign=0

00000004 struct acpi_device_status
{
  unsigned __int32 present : 1;
  unsigned __int32 enabled : 1;
  unsigned __int32 show_in_ui : 1;
  unsigned __int32 functional : 1;
  unsigned __int32 battery_present : 1;
  unsigned __int32 reserved : 27;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_status.present bi.nbytes=4 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_device_status.enabled bi.nbytes=4 U
//  2. 0000. 2 1 effalign(1) fda=0 bits=0000 acpi_device_status.show_in_ui bi.nbytes=4 U
//  3. 0000. 3 1 effalign(1) fda=0 bits=0000 acpi_device_status.functional bi.nbytes=4 U
//  4. 0000. 4 1 effalign(1) fda=0 bits=0000 acpi_device_status.battery_present bi.nbytes=4 U
//  5. 0000. 5 27 effalign(1) fda=0 bits=0000 acpi_device_status.reserved bi.nbytes=4 U
//          0004 effalign(4) sda=0 bits=0000 acpi_device_status struct packalign=0

00000050 struct acpi_device_wakeup
{
  acpi_handle gpe_device;
  u64 gpe_number;
  u64 sleep_state;
  list_head resources;
  acpi_device_wakeup_flags flags;
  acpi_device_wakeup_context context;
  wakeup_source *ws;
  int prepare_count;
  int enable_count;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup.gpe_device acpi_handle;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup.gpe_number u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup.sleep_state u64;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 acpi_device_wakeup.resources list_head;
//  4. 0028 0001 effalign(1) fda=0 bits=0000 acpi_device_wakeup.flags acpi_device_wakeup_flags;
//  5. 0030 0010 effalign(8) fda=0 bits=0000 acpi_device_wakeup.context acpi_device_wakeup_context;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup.ws wakeup_source *;
//  7. 0048 0004 effalign(4) fda=0 bits=0000 acpi_device_wakeup.prepare_count int;
//  8. 004C 0004 effalign(4) fda=0 bits=0000 acpi_device_wakeup.enable_count int;
//          0050 effalign(8) sda=0 bits=0000 acpi_device_wakeup struct packalign=0

00000010 struct acpi_device_wakeup_context
{
  void (__cdecl *func)(acpi_device_wakeup_context *);
  device *dev;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup_context.func void (__cdecl *)(acpi_device_wakeup_context *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_device_wakeup_context.dev device *;
//          0010 effalign(8) sda=0 bits=0000 acpi_device_wakeup_context struct packalign=0

00000001 struct acpi_device_wakeup_flags
{
  unsigned __int8 valid : 1;
  unsigned __int8 notifier_present : 1;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_device_wakeup_flags.valid bi.nbytes=1 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_device_wakeup_flags.notifier_present bi.nbytes=1 U
//          0001 effalign(1) sda=0 bits=0000 acpi_device_wakeup_flags struct packalign=0

00000009 #pragma pack(push, 1)
struct acpi_dmar_andd
{
  acpi_dmar_header header;
  u8 reserved[3];
  u8 device_number;
  char device_name[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_dmar_andd.header acpi_dmar_header;
//  1. 0004 0003 effalign(1) fda=0 bits=0000 acpi_dmar_andd.reserved u8[3];
//  2. 0007 0001 effalign(1) fda=0 bits=0000 acpi_dmar_andd.device_number u8;
//  3. 0008 0001 effalign(1) fda=0 bits=0000 acpi_dmar_andd.device_name char[1];
//          0009 effalign(1) sda=0 bits=0000 acpi_dmar_andd struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_dmar_atsr
{
  acpi_dmar_header header;
  u8 flags;
  u8 reserved;
  u16 segment;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_dmar_atsr.header acpi_dmar_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_dmar_atsr.flags u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_dmar_atsr.reserved u8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_dmar_atsr.segment u16;
//          0008 effalign(1) sda=0 bits=0000 acpi_dmar_atsr struct packalign=1

00000006 #pragma pack(push, 1)
struct acpi_dmar_device_scope
{
  u8 entry_type;
  u8 length;
  u16 reserved;
  u8 enumeration_id;
  u8 bus;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_dmar_device_scope.entry_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_dmar_device_scope.length u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_dmar_device_scope.reserved u16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 acpi_dmar_device_scope.enumeration_id u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 acpi_dmar_device_scope.bus u8;
//          0006 effalign(1) sda=0 bits=0000 acpi_dmar_device_scope struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_dmar_hardware_unit
{
  acpi_dmar_header header;
  u8 flags;
  u8 reserved;
  u16 segment;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_dmar_hardware_unit.header acpi_dmar_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_dmar_hardware_unit.flags u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_dmar_hardware_unit.reserved u8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_dmar_hardware_unit.segment u16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_dmar_hardware_unit.address u64;
//          0010 effalign(1) sda=0 bits=0000 acpi_dmar_hardware_unit struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_dmar_header
{
  u16 type;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_dmar_header.type u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_dmar_header.length u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_dmar_header struct packalign=1

00000002 #pragma pack(push, 1)
struct acpi_dmar_pci_path
{
  u8 device;
  u8 function;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_dmar_pci_path.device u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_dmar_pci_path.function u8;
//          0002 effalign(1) sda=0 bits=0000 acpi_dmar_pci_path struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_dmar_reserved_memory
{
  acpi_dmar_header header;
  u16 reserved;
  u16 segment;
  u64 base_address;
  u64 end_address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_dmar_reserved_memory.header acpi_dmar_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_dmar_reserved_memory.reserved u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_dmar_reserved_memory.segment u16;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_dmar_reserved_memory.base_address u64;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_dmar_reserved_memory.end_address u64;
//          0018 effalign(1) sda=0 bits=0000 acpi_dmar_reserved_memory struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_dmar_rhsa
{
  acpi_dmar_header header;
  u32 reserved;
  u64 base_address;
  u32 proximity_domain;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_dmar_rhsa.header acpi_dmar_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_dmar_rhsa.reserved u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_dmar_rhsa.base_address u64;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 acpi_dmar_rhsa.proximity_domain u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_dmar_rhsa struct packalign=1

00000004 enum acpi_dmar_scope_type : unsigned __int32
{
  ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0x0,
  ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 0x1,
  ACPI_DMAR_SCOPE_TYPE_BRIDGE = 0x2,
  ACPI_DMAR_SCOPE_TYPE_IOAPIC = 0x3,
  ACPI_DMAR_SCOPE_TYPE_HPET = 0x4,
  ACPI_DMAR_SCOPE_TYPE_NAMESPACE = 0x5,
  ACPI_DMAR_SCOPE_TYPE_RESERVED = 0x6,
};
00000004 enum acpi_dmar_type : unsigned __int32
{
  ACPI_DMAR_TYPE_HARDWARE_UNIT = 0x0,
  ACPI_DMAR_TYPE_RESERVED_MEMORY = 0x1,
  ACPI_DMAR_TYPE_ROOT_ATS = 0x2,
  ACPI_DMAR_TYPE_HARDWARE_AFFINITY = 0x3,
  ACPI_DMAR_TYPE_NAMESPACE = 0x4,
  ACPI_DMAR_TYPE_RESERVED = 0x5,
};
00000158 struct acpi_driver
{
  char name[80];
  char class[80];
  const acpi_device_id *ids;
  unsigned int flags;
  acpi_device_ops ops;
  device_driver drv;
  module *owner;
};
//  0. 0000 0050 effalign(1) fda=0 bits=0000 acpi_driver.name char[80];
//  1. 0050 0050 effalign(1) fda=0 bits=0000 acpi_driver.class char[80];
//  2. 00A0 0008 effalign(8) fda=0 bits=0000 acpi_driver.ids const acpi_device_id *;
//  3. 00A8 0004 effalign(4) fda=0 bits=0000 acpi_driver.flags unsigned int;
//  4. 00B0 0018 effalign(8) fda=0 bits=0000 acpi_driver.ops acpi_device_ops;
//  5. 00C8 0088 effalign(8) fda=0 bits=0000 acpi_driver.drv device_driver;
//  6. 0150 0008 effalign(8) fda=0 bits=0000 acpi_driver.owner module *;
//          0158 effalign(8) sda=0 bits=0000 acpi_driver struct packalign=0

00000014 #pragma pack(push, 1)
struct acpi_drtm_dps_id
{
  u32 dps_id_length;
  u8 dps_id[16];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_drtm_dps_id.dps_id_length u32;
//  1. 0004 0010 effalign(1) fda=0 bits=0000 acpi_drtm_dps_id.dps_id u8[16];
//          0014 effalign(1) sda=0 bits=0000 acpi_drtm_dps_id struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_drtm_resource
{
  u8 size[7];
  u8 type;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0007 effalign(1) fda=0 bits=0000 acpi_drtm_resource.size u8[7];
//  1. 0007 0001 effalign(1) fda=0 bits=0000 acpi_drtm_resource.type u8;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_drtm_resource.address u64;
//          0010 effalign(1) sda=0 bits=0000 acpi_drtm_resource struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_drtm_resource_list
{
  u32 resource_count;
  acpi_drtm_resource resources[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_drtm_resource_list.resource_count u32;
//  1. 0004 0010 effalign(1) fda=0 bits=0000 acpi_drtm_resource_list.resources acpi_drtm_resource[1];
//          0014 effalign(1) sda=0 bits=0000 acpi_drtm_resource_list struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_drtm_vtable_list
{
  u32 validated_table_count;
  u64 validated_tables[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_drtm_vtable_list.validated_table_count u32;
//  1. 0004 0008 effalign(8) fda=0 bits=0000 acpi_drtm_vtable_list.validated_tables u64[1];
//          000C effalign(1) sda=0 bits=0000 acpi_drtm_vtable_list struct packalign=1

00000004 enum acpi_einj_actions : unsigned __int32
{
  ACPI_EINJ_BEGIN_OPERATION = 0x0,
  ACPI_EINJ_GET_TRIGGER_TABLE = 0x1,
  ACPI_EINJ_SET_ERROR_TYPE = 0x2,
  ACPI_EINJ_GET_ERROR_TYPE = 0x3,
  ACPI_EINJ_END_OPERATION = 0x4,
  ACPI_EINJ_EXECUTE_OPERATION = 0x5,
  ACPI_EINJ_CHECK_BUSY_STATUS = 0x6,
  ACPI_EINJ_GET_COMMAND_STATUS = 0x7,
  ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS = 0x8,
  ACPI_EINJ_GET_EXECUTE_TIMINGS = 0x9,
  ACPI_EINJ_ACTION_RESERVED = 0xA,
  ACPI_EINJ_TRIGGER_ERROR = 0xFF,
};
00000004 enum acpi_einj_command_status : unsigned __int32
{
  ACPI_EINJ_SUCCESS = 0x0,
  ACPI_EINJ_FAILURE = 0x1,
  ACPI_EINJ_INVALID_ACCESS = 0x2,
  ACPI_EINJ_STATUS_RESERVED = 0x3,
};
00000020 #pragma pack(push, 1)
struct acpi_einj_entry
{
  acpi_whea_header whea_header;
};
#pragma pack(pop)
//  0. 0000 0020 effalign(1) fda=0 bits=0000 acpi_einj_entry.whea_header acpi_whea_header;
//          0020 effalign(1) sda=0 bits=0000 acpi_einj_entry struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_einj_error_type_with_addr
{
  u32 error_type;
  u32 vendor_struct_offset;
  u32 flags;
  u32 apic_id;
  u64 address;
  u64 range;
  u32 pcie_id;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_einj_error_type_with_addr.error_type u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_einj_error_type_with_addr.vendor_struct_offset u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_einj_error_type_with_addr.flags u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_einj_error_type_with_addr.apic_id u32;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_einj_error_type_with_addr.address u64;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 acpi_einj_error_type_with_addr.range u64;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 acpi_einj_error_type_with_addr.pcie_id u32;
//          0024 effalign(1) sda=0 bits=0000 acpi_einj_error_type_with_addr struct packalign=1

00000004 enum acpi_einj_instructions : unsigned __int32
{
  ACPI_EINJ_READ_REGISTER = 0x0,
  ACPI_EINJ_READ_REGISTER_VALUE = 0x1,
  ACPI_EINJ_WRITE_REGISTER = 0x2,
  ACPI_EINJ_WRITE_REGISTER_VALUE = 0x3,
  ACPI_EINJ_NOOP = 0x4,
  ACPI_EINJ_FLUSH_CACHELINE = 0x5,
  ACPI_EINJ_INSTRUCTION_RESERVED = 0x6,
};
00000010 #pragma pack(push, 1)
struct acpi_einj_trigger
{
  u32 header_size;
  u32 revision;
  u32 table_size;
  u32 entry_count;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_einj_trigger.header_size u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_einj_trigger.revision u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_einj_trigger.table_size u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_einj_trigger.entry_count u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_einj_trigger struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_einj_vendor
{
  u32 length;
  u32 pcie_id;
  u16 vendor_id;
  u16 device_id;
  u8 revision_id;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_einj_vendor.length u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_einj_vendor.pcie_id u32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 acpi_einj_vendor.vendor_id u16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 acpi_einj_vendor.device_id u16;
//  4. 000C 0001 effalign(1) fda=0 bits=0000 acpi_einj_vendor.revision_id u8;
//  5. 000D 0003 effalign(1) fda=0 bits=0000 acpi_einj_vendor.reserved u8[3];
//          0010 effalign(1) sda=0 bits=0000 acpi_einj_vendor struct packalign=1

00000004 enum acpi_erst_actions : unsigned __int32
{
  ACPI_ERST_BEGIN_WRITE = 0x0,
  ACPI_ERST_BEGIN_READ = 0x1,
  ACPI_ERST_BEGIN_CLEAR = 0x2,
  ACPI_ERST_END = 0x3,
  ACPI_ERST_SET_RECORD_OFFSET = 0x4,
  ACPI_ERST_EXECUTE_OPERATION = 0x5,
  ACPI_ERST_CHECK_BUSY_STATUS = 0x6,
  ACPI_ERST_GET_COMMAND_STATUS = 0x7,
  ACPI_ERST_GET_RECORD_ID = 0x8,
  ACPI_ERST_SET_RECORD_ID = 0x9,
  ACPI_ERST_GET_RECORD_COUNT = 0xA,
  ACPI_ERST_BEGIN_DUMMY_WRIITE = 0xB,
  ACPI_ERST_NOT_USED = 0xC,
  ACPI_ERST_GET_ERROR_RANGE = 0xD,
  ACPI_ERST_GET_ERROR_LENGTH = 0xE,
  ACPI_ERST_GET_ERROR_ATTRIBUTES = 0xF,
  ACPI_ERST_EXECUTE_TIMINGS = 0x10,
  ACPI_ERST_ACTION_RESERVED = 0x11,
};
00000004 enum acpi_erst_command_status : unsigned __int32
{
  ACPI_ERST_SUCESS = 0x0,
  ACPI_ERST_NO_SPACE = 0x1,
  ACPI_ERST_NOT_AVAILABLE = 0x2,
  ACPI_ERST_FAILURE = 0x3,
  ACPI_ERST_RECORD_EMPTY = 0x4,
  ACPI_ERST_NOT_FOUND = 0x5,
  ACPI_ERST_STATUS_RESERVED = 0x6,
};
00000020 #pragma pack(push, 1)
struct acpi_erst_entry
{
  acpi_whea_header whea_header;
};
#pragma pack(pop)
//  0. 0000 0020 effalign(1) fda=0 bits=0000 acpi_erst_entry.whea_header acpi_whea_header;
//          0020 effalign(1) sda=0 bits=0000 acpi_erst_entry struct packalign=1

00000032 #pragma pack(push, 1)
struct acpi_erst_info
{
  u16 signature;
  u8 data[48];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_erst_info.signature u16;
//  1. 0002 0030 effalign(1) fda=0 bits=0000 acpi_erst_info.data u8[48];
//          0032 effalign(1) sda=0 bits=0000 acpi_erst_info struct packalign=1

00000004 enum acpi_erst_instructions : unsigned __int32
{
  ACPI_ERST_READ_REGISTER = 0x0,
  ACPI_ERST_READ_REGISTER_VALUE = 0x1,
  ACPI_ERST_WRITE_REGISTER = 0x2,
  ACPI_ERST_WRITE_REGISTER_VALUE = 0x3,
  ACPI_ERST_NOOP = 0x4,
  ACPI_ERST_LOAD_VAR1 = 0x5,
  ACPI_ERST_LOAD_VAR2 = 0x6,
  ACPI_ERST_STORE_VAR1 = 0x7,
  ACPI_ERST_ADD = 0x8,
  ACPI_ERST_SUBTRACT = 0x9,
  ACPI_ERST_ADD_VALUE = 0xA,
  ACPI_ERST_SUBTRACT_VALUE = 0xB,
  ACPI_ERST_STALL = 0xC,
  ACPI_ERST_STALL_WHILE_TRUE = 0xD,
  ACPI_ERST_SKIP_NEXT_IF_TRUE = 0xE,
  ACPI_ERST_GOTO = 0xF,
  ACPI_ERST_SET_SRC_ADDRESS_BASE = 0x10,
  ACPI_ERST_SET_DST_ADDRESS_BASE = 0x11,
  ACPI_ERST_MOVE_DATA = 0x12,
  ACPI_ERST_INSTRUCTION_RESERVED = 0x13,
};
00000008 typedef u32 (__cdecl *acpi_event_handler)(void *);
00000004 typedef u32 acpi_event_status;
00000004 typedef u32 acpi_event_type;
00000008 typedef acpi_status (__cdecl *acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);
00000008 struct acpi_exception_info
{
  char *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_exception_info.name char *;
//          0008 effalign(8) sda=0 bits=0000 acpi_exception_info struct packalign=0

00000004 enum acpi_execute_type : unsigned __int32
{
  OSL_GLOBAL_LOCK_HANDLER = 0x0,
  OSL_NOTIFY_HANDLER = 0x1,
  OSL_GPE_HANDLER = 0x2,
  OSL_DEBUGGER_MAIN_THREAD = 0x3,
  OSL_DEBUGGER_EXEC_THREAD = 0x4,
  OSL_EC_POLL_HANDLER = 0x5,
  OSL_EC_BURST_HANDLER = 0x6,
};
00000014 struct acpi_fde_info
{
  u32 floppy0;
  u32 floppy1;
  u32 floppy2;
  u32 floppy3;
  u32 tape;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_fde_info.floppy0 u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_fde_info.floppy1 u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_fde_info.floppy2 u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_fde_info.floppy3 u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_fde_info.tape u32;
//          0014 effalign(4) sda=0 bits=0000 acpi_fde_info struct packalign=0

00000030 #pragma pack(push, 1)
struct acpi_fpdt_boot
{
  acpi_fpdt_header header;
  u8 reserved[4];
  u64 reset_end;
  u64 load_start;
  u64 startup_start;
  u64 exit_services_entry;
  u64 exit_services_exit;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_boot.header acpi_fpdt_header;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_boot.reserved u8[4];
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot.reset_end u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot.load_start u64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot.startup_start u64;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot.exit_services_entry u64;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot.exit_services_exit u64;
//          0030 effalign(1) sda=0 bits=0000 acpi_fpdt_boot struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_fpdt_boot_pointer
{
  acpi_fpdt_header header;
  u8 reserved[4];
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_boot_pointer.header acpi_fpdt_header;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_boot_pointer.reserved u8[4];
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_boot_pointer.address u64;
//          0010 effalign(1) sda=0 bits=0000 acpi_fpdt_boot_pointer struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_fpdt_header
{
  u16 type;
  u8 length;
  u8 revision;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_fpdt_header.type u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_fpdt_header.length u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_fpdt_header.revision u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_fpdt_header struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_fpdt_s3pt_pointer
{
  acpi_fpdt_header header;
  u8 reserved[4];
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_s3pt_pointer.header acpi_fpdt_header;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 acpi_fpdt_s3pt_pointer.reserved u8[4];
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_fpdt_s3pt_pointer.address u64;
//          0010 effalign(1) sda=0 bits=0000 acpi_fpdt_s3pt_pointer struct packalign=1

00000004 enum acpi_fpdt_type : unsigned __int32
{
  ACPI_FPDT_TYPE_BOOT = 0x0,
  ACPI_FPDT_TYPE_S3PERF = 0x1,
};
00000008 typedef void (__cdecl *acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);
0000000C #pragma pack(push, 1)
struct acpi_generic_address
{
  u8 space_id;
  u8 bit_width;
  u8 bit_offset;
  u8 access_width;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_generic_address.space_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_generic_address.bit_width u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_generic_address.bit_offset u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_generic_address.access_width u8;
//  4. 0004 0008 effalign(8) fda=0 bits=0000 acpi_generic_address.address u64;
//          000C effalign(1) sda=0 bits=0000 acpi_generic_address struct packalign=1

00000008 typedef u32 (__cdecl *acpi_gpe_handler)(acpi_handle, u32, void *);
FFFFFFFF struct acpi_gpio_mapping;
00000010 struct acpi_grt_info
{
  u16 year;
  u8 month;
  u8 day;
  u8 hour;
  u8 minute;
  u8 second;
  u8 valid;
  u16 milliseconds;
  u16 timezone;
  u8 daylight;
  u8 reserved[3];
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_grt_info.year u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.month u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.day u8;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.hour u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.minute u8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.second u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.valid u8;
//  7. 0008 0002 effalign(2) fda=0 bits=0000 acpi_grt_info.milliseconds u16;
//  8. 000A 0002 effalign(2) fda=0 bits=0000 acpi_grt_info.timezone u16;
//  9. 000C 0001 effalign(1) fda=0 bits=0000 acpi_grt_info.daylight u8;
// 10. 000D 0003 effalign(1) fda=0 bits=0000 acpi_grt_info.reserved u8[3];
//          0010 effalign(2) sda=0 bits=0000 acpi_grt_info struct packalign=0

00000008 #pragma pack(push, 1)
struct acpi_gtdt_el2
{
  u32 virtual_el2_timer_gsiv;
  u32 virtual_el2_timer_flags;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_el2.virtual_el2_timer_gsiv u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_el2.virtual_el2_timer_flags u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_gtdt_el2 struct packalign=1

00000003 #pragma pack(push, 1)
struct acpi_gtdt_header
{
  u8 type;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_gtdt_header.type u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_gtdt_header.length u16;
//          0003 effalign(1) sda=0 bits=0000 acpi_gtdt_header struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_gtdt_timer_block
{
  acpi_gtdt_header header;
  u8 reserved;
  u64 block_address;
  u32 timer_count;
  u32 timer_offset;
};
#pragma pack(pop)
//  0. 0000 0003 effalign(1) fda=0 bits=0000 acpi_gtdt_timer_block.header acpi_gtdt_header;
//  1. 0003 0001 effalign(1) fda=0 bits=0000 acpi_gtdt_timer_block.reserved u8;
//  2. 0004 0008 effalign(8) fda=0 bits=0000 acpi_gtdt_timer_block.block_address u64;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_block.timer_count u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_block.timer_offset u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_gtdt_timer_block struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_gtdt_timer_entry
{
  u8 frame_number;
  u8 reserved[3];
  u64 base_address;
  u64 el0_base_address;
  u32 timer_interrupt;
  u32 timer_flags;
  u32 virtual_timer_interrupt;
  u32 virtual_timer_flags;
  u32 common_flags;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_gtdt_timer_entry.frame_number u8;
//  1. 0001 0003 effalign(1) fda=0 bits=0000 acpi_gtdt_timer_entry.reserved u8[3];
//  2. 0004 0008 effalign(8) fda=0 bits=0000 acpi_gtdt_timer_entry.base_address u64;
//  3. 000C 0008 effalign(8) fda=0 bits=0000 acpi_gtdt_timer_entry.el0_base_address u64;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_entry.timer_interrupt u32;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_entry.timer_flags u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_entry.virtual_timer_interrupt u32;
//  7. 0020 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_entry.virtual_timer_flags u32;
//  8. 0024 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_timer_entry.common_flags u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_gtdt_timer_entry struct packalign=1

00000004 enum acpi_gtdt_type : unsigned __int32
{
  ACPI_GTDT_TYPE_TIMER_BLOCK = 0x0,
  ACPI_GTDT_TYPE_WATCHDOG = 0x1,
  ACPI_GTDT_TYPE_RESERVED = 0x2,
};
0000001C #pragma pack(push, 1)
struct acpi_gtdt_watchdog
{
  acpi_gtdt_header header;
  u8 reserved;
  u64 refresh_frame_address;
  u64 control_frame_address;
  u32 timer_interrupt;
  u32 timer_flags;
};
#pragma pack(pop)
//  0. 0000 0003 effalign(1) fda=0 bits=0000 acpi_gtdt_watchdog.header acpi_gtdt_header;
//  1. 0003 0001 effalign(1) fda=0 bits=0000 acpi_gtdt_watchdog.reserved u8;
//  2. 0004 0008 effalign(8) fda=0 bits=0000 acpi_gtdt_watchdog.refresh_frame_address u64;
//  3. 000C 0008 effalign(8) fda=0 bits=0000 acpi_gtdt_watchdog.control_frame_address u64;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_watchdog.timer_interrupt u32;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_gtdt_watchdog.timer_flags u32;
//          001C effalign(1) sda=0 bits=0000 acpi_gtdt_watchdog struct packalign=1

00000014 struct acpi_gtm_info
{
  u32 pio_speed0;
  u32 dma_speed0;
  u32 pio_speed1;
  u32 dma_speed1;
  u32 flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_gtm_info.pio_speed0 u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_gtm_info.dma_speed0 u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_gtm_info.pio_speed1 u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_gtm_info.dma_speed1 u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_gtm_info.flags u32;
//          0014 effalign(4) sda=0 bits=0000 acpi_gtm_info struct packalign=0

00000008 typedef void *acpi_handle;
00000058 struct acpi_handle_list
{
  u32 count;
  acpi_handle handles[10];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_handle_list.count u32;
//  1. 0008 0050 effalign(8) fda=0 bits=0000 acpi_handle_list.handles acpi_handle[10];
//          0058 effalign(8) sda=0 bits=0000 acpi_handle_list struct packalign=0

00000018 struct acpi_hardware_id
{
  list_head list;
  const char *id;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 acpi_hardware_id.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 acpi_hardware_id.id const char *;
//          0018 effalign(8) sda=0 bits=0000 acpi_hardware_id struct packalign=0

0000002C #pragma pack(push, 1)
struct acpi_hest_aer
{
  acpi_hest_header header;
  acpi_hest_aer_common aer;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_aer.header acpi_hest_header;
//  1. 0004 0028 effalign(1) fda=0 bits=0000 acpi_hest_aer.aer acpi_hest_aer_common;
//          002C effalign(1) sda=0 bits=0000 acpi_hest_aer struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_hest_aer_bridge
{
  acpi_hest_header header;
  acpi_hest_aer_common aer;
  u32 uncorrectable_mask2;
  u32 uncorrectable_severity2;
  u32 advanced_capabilities2;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_aer_bridge.header acpi_hest_header;
//  1. 0004 0028 effalign(1) fda=0 bits=0000 acpi_hest_aer_bridge.aer acpi_hest_aer_common;
//  2. 002C 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_bridge.uncorrectable_mask2 u32;
//  3. 0030 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_bridge.uncorrectable_severity2 u32;
//  4. 0034 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_bridge.advanced_capabilities2 u32;
//          0038 effalign(1) sda=0 bits=0000 acpi_hest_aer_bridge struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_hest_aer_common
{
  u16 reserved1;
  u8 flags;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  u32 bus;
  u16 device;
  u16 function;
  u16 device_control;
  u16 reserved2;
  u32 uncorrectable_mask;
  u32 uncorrectable_severity;
  u32 correctable_mask;
  u32 advanced_capabilities;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_hest_aer_common.reserved1 u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_hest_aer_common.flags u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_hest_aer_common.enabled u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.records_to_preallocate u32;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.max_sections_per_record u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.bus u32;
//  6. 0010 0002 effalign(2) fda=0 bits=0000 acpi_hest_aer_common.device u16;
//  7. 0012 0002 effalign(2) fda=0 bits=0000 acpi_hest_aer_common.function u16;
//  8. 0014 0002 effalign(2) fda=0 bits=0000 acpi_hest_aer_common.device_control u16;
//  9. 0016 0002 effalign(2) fda=0 bits=0000 acpi_hest_aer_common.reserved2 u16;
// 10. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.uncorrectable_mask u32;
// 11. 001C 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.uncorrectable_severity u32;
// 12. 0020 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.correctable_mask u32;
// 13. 0024 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_common.advanced_capabilities u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_hest_aer_common struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_hest_aer_root
{
  acpi_hest_header header;
  acpi_hest_aer_common aer;
  u32 root_error_command;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_aer_root.header acpi_hest_header;
//  1. 0004 0028 effalign(1) fda=0 bits=0000 acpi_hest_aer_root.aer acpi_hest_aer_common;
//  2. 002C 0004 effalign(4) fda=0 bits=0000 acpi_hest_aer_root.root_error_command u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_hest_aer_root struct packalign=1

00000040 #pragma pack(push, 1)
struct acpi_hest_generic
{
  acpi_hest_header header;
  u16 related_source_id;
  u8 reserved;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  u32 max_raw_data_length;
  acpi_generic_address error_status_address;
  acpi_hest_notify notify;
  u32 error_block_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_generic.header acpi_hest_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_hest_generic.related_source_id u16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic.reserved u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic.enabled u8;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic.records_to_preallocate u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic.max_sections_per_record u32;
//  6. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic.max_raw_data_length u32;
//  7. 0014 000C effalign(1) fda=0 bits=0000 acpi_hest_generic.error_status_address acpi_generic_address;
//  8. 0020 001C effalign(1) fda=0 bits=0000 acpi_hest_generic.notify acpi_hest_notify;
//  9. 003C 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic.error_block_length u32;
//          0040 effalign(1) sda=0 bits=0000 acpi_hest_generic struct packalign=1

00000040 #pragma pack(push, 1)
struct acpi_hest_generic_data
{
  u8 section_type[16];
  u32 error_severity;
  u16 revision;
  u8 validation_bits;
  u8 flags;
  u32 error_data_length;
  u8 fru_id[16];
  u8 fru_text[20];
};
#pragma pack(pop)
//  0. 0000 0010 effalign(1) fda=0 bits=0000 acpi_hest_generic_data.section_type u8[16];
//  1. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_data.error_severity u32;
//  2. 0014 0002 effalign(2) fda=0 bits=0000 acpi_hest_generic_data.revision u16;
//  3. 0016 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_data.validation_bits u8;
//  4. 0017 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_data.flags u8;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_data.error_data_length u32;
//  6. 001C 0010 effalign(1) fda=0 bits=0000 acpi_hest_generic_data.fru_id u8[16];
//  7. 002C 0014 effalign(1) fda=0 bits=0000 acpi_hest_generic_data.fru_text u8[20];
//          0040 effalign(1) sda=0 bits=0000 acpi_hest_generic_data struct packalign=1

00000048 #pragma pack(push, 1)
struct acpi_hest_generic_data_v300
{
  u8 section_type[16];
  u32 error_severity;
  u16 revision;
  u8 validation_bits;
  u8 flags;
  u32 error_data_length;
  u8 fru_id[16];
  u8 fru_text[20];
  u64 time_stamp;
};
#pragma pack(pop)
//  0. 0000 0010 effalign(1) fda=0 bits=0000 acpi_hest_generic_data_v300.section_type u8[16];
//  1. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_data_v300.error_severity u32;
//  2. 0014 0002 effalign(2) fda=0 bits=0000 acpi_hest_generic_data_v300.revision u16;
//  3. 0016 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_data_v300.validation_bits u8;
//  4. 0017 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_data_v300.flags u8;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_data_v300.error_data_length u32;
//  6. 001C 0010 effalign(1) fda=0 bits=0000 acpi_hest_generic_data_v300.fru_id u8[16];
//  7. 002C 0014 effalign(1) fda=0 bits=0000 acpi_hest_generic_data_v300.fru_text u8[20];
//  8. 0040 0008 effalign(8) fda=0 bits=0000 acpi_hest_generic_data_v300.time_stamp u64;
//          0048 effalign(1) sda=0 bits=0000 acpi_hest_generic_data_v300 struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_hest_generic_status
{
  u32 block_status;
  u32 raw_data_offset;
  u32 raw_data_length;
  u32 data_length;
  u32 error_severity;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_status.block_status u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_status.raw_data_offset u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_status.raw_data_length u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_status.data_length u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_status.error_severity u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_hest_generic_status struct packalign=1

0000005C #pragma pack(push, 1)
struct acpi_hest_generic_v2
{
  acpi_hest_header header;
  u16 related_source_id;
  u8 reserved;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  u32 max_raw_data_length;
  acpi_generic_address error_status_address;
  acpi_hest_notify notify;
  u32 error_block_length;
  acpi_generic_address read_ack_register;
  u64 read_ack_preserve;
  u64 read_ack_write;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.header acpi_hest_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_hest_generic_v2.related_source_id u16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.reserved u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.enabled u8;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_v2.records_to_preallocate u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_v2.max_sections_per_record u32;
//  6. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_v2.max_raw_data_length u32;
//  7. 0014 000C effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.error_status_address acpi_generic_address;
//  8. 0020 001C effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.notify acpi_hest_notify;
//  9. 003C 0004 effalign(4) fda=0 bits=0000 acpi_hest_generic_v2.error_block_length u32;
// 10. 0040 000C effalign(1) fda=0 bits=0000 acpi_hest_generic_v2.read_ack_register acpi_generic_address;
// 11. 004C 0008 effalign(8) fda=0 bits=0000 acpi_hest_generic_v2.read_ack_preserve u64;
// 12. 0054 0008 effalign(8) fda=0 bits=0000 acpi_hest_generic_v2.read_ack_write u64;
//          005C effalign(1) sda=0 bits=0000 acpi_hest_generic_v2 struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_hest_header
{
  u16 type;
  u16 source_id;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_hest_header.type u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_hest_header.source_id u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_hest_header struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_hest_ia_corrected
{
  acpi_hest_header header;
  u16 reserved1;
  u8 flags;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  acpi_hest_notify notify;
  u8 num_hardware_banks;
  u8 reserved2[3];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.header acpi_hest_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_hest_ia_corrected.reserved1 u16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.enabled u8;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_corrected.records_to_preallocate u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_corrected.max_sections_per_record u32;
//  6. 0010 001C effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.notify acpi_hest_notify;
//  7. 002C 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.num_hardware_banks u8;
//  8. 002D 0003 effalign(1) fda=0 bits=0000 acpi_hest_ia_corrected.reserved2 u8[3];
//          0030 effalign(1) sda=0 bits=0000 acpi_hest_ia_corrected struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_hest_ia_deferred_check
{
  acpi_hest_header header;
  u16 reserved1;
  u8 flags;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  acpi_hest_notify notify;
  u8 num_hardware_banks;
  u8 reserved2[3];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.header acpi_hest_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_hest_ia_deferred_check.reserved1 u16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.enabled u8;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_deferred_check.records_to_preallocate u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_deferred_check.max_sections_per_record u32;
//  6. 0010 001C effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.notify acpi_hest_notify;
//  7. 002C 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.num_hardware_banks u8;
//  8. 002D 0003 effalign(1) fda=0 bits=0000 acpi_hest_ia_deferred_check.reserved2 u8[3];
//          0030 effalign(1) sda=0 bits=0000 acpi_hest_ia_deferred_check struct packalign=1

0000001C #pragma pack(push, 1)
struct acpi_hest_ia_error_bank
{
  u8 bank_number;
  u8 clear_status_on_init;
  u8 status_format;
  u8 reserved;
  u32 control_register;
  u64 control_data;
  u32 status_register;
  u32 address_register;
  u32 misc_register;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_error_bank.bank_number u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_error_bank.clear_status_on_init u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_error_bank.status_format u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_error_bank.reserved u8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_error_bank.control_register u32;
//  5. 0008 0008 effalign(8) fda=0 bits=0000 acpi_hest_ia_error_bank.control_data u64;
//  6. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_error_bank.status_register u32;
//  7. 0014 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_error_bank.address_register u32;
//  8. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_error_bank.misc_register u32;
//          001C effalign(1) sda=0 bits=0000 acpi_hest_ia_error_bank struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_hest_ia_machine_check
{
  acpi_hest_header header;
  u16 reserved1;
  u8 flags;
  u8 enabled;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  u64 global_capability_data;
  u64 global_control_data;
  u8 num_hardware_banks;
  u8 reserved3[7];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_ia_machine_check.header acpi_hest_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_hest_ia_machine_check.reserved1 u16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_machine_check.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_machine_check.enabled u8;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_machine_check.records_to_preallocate u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_machine_check.max_sections_per_record u32;
//  6. 0010 0008 effalign(8) fda=0 bits=0000 acpi_hest_ia_machine_check.global_capability_data u64;
//  7. 0018 0008 effalign(8) fda=0 bits=0000 acpi_hest_ia_machine_check.global_control_data u64;
//  8. 0020 0001 effalign(1) fda=0 bits=0000 acpi_hest_ia_machine_check.num_hardware_banks u8;
//  9. 0021 0007 effalign(1) fda=0 bits=0000 acpi_hest_ia_machine_check.reserved3 u8[7];
//          0028 effalign(1) sda=0 bits=0000 acpi_hest_ia_machine_check struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_hest_ia_nmi
{
  acpi_hest_header header;
  u32 reserved;
  u32 records_to_preallocate;
  u32 max_sections_per_record;
  u32 max_raw_data_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_hest_ia_nmi.header acpi_hest_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_nmi.reserved u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_nmi.records_to_preallocate u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_nmi.max_sections_per_record u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_ia_nmi.max_raw_data_length u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_hest_ia_nmi struct packalign=1

0000001C #pragma pack(push, 1)
struct acpi_hest_notify
{
  u8 type;
  u8 length;
  u16 config_write_enable;
  u32 poll_interval;
  u32 vector;
  u32 polling_threshold_value;
  u32 polling_threshold_window;
  u32 error_threshold_value;
  u32 error_threshold_window;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_hest_notify.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_hest_notify.length u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_hest_notify.config_write_enable u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.poll_interval u32;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.vector u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.polling_threshold_value u32;
//  6. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.polling_threshold_window u32;
//  7. 0014 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.error_threshold_value u32;
//  8. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hest_notify.error_threshold_window u32;
//          001C effalign(1) sda=0 bits=0000 acpi_hest_notify struct packalign=1

00000004 enum acpi_hest_notify_types : unsigned __int32
{
  ACPI_HEST_NOTIFY_POLLED = 0x0,
  ACPI_HEST_NOTIFY_EXTERNAL = 0x1,
  ACPI_HEST_NOTIFY_LOCAL = 0x2,
  ACPI_HEST_NOTIFY_SCI = 0x3,
  ACPI_HEST_NOTIFY_NMI = 0x4,
  ACPI_HEST_NOTIFY_CMCI = 0x5,
  ACPI_HEST_NOTIFY_MCE = 0x6,
  ACPI_HEST_NOTIFY_GPIO = 0x7,
  ACPI_HEST_NOTIFY_SEA = 0x8,
  ACPI_HEST_NOTIFY_SEI = 0x9,
  ACPI_HEST_NOTIFY_GSIV = 0xA,
  ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED = 0xB,
  ACPI_HEST_NOTIFY_RESERVED = 0xC,
};
00000004 enum acpi_hest_types : unsigned __int32
{
  ACPI_HEST_TYPE_IA32_CHECK = 0x0,
  ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 0x1,
  ACPI_HEST_TYPE_IA32_NMI = 0x2,
  ACPI_HEST_TYPE_NOT_USED3 = 0x3,
  ACPI_HEST_TYPE_NOT_USED4 = 0x4,
  ACPI_HEST_TYPE_NOT_USED5 = 0x5,
  ACPI_HEST_TYPE_AER_ROOT_PORT = 0x6,
  ACPI_HEST_TYPE_AER_ENDPOINT = 0x7,
  ACPI_HEST_TYPE_AER_BRIDGE = 0x8,
  ACPI_HEST_TYPE_GENERIC_ERROR = 0x9,
  ACPI_HEST_TYPE_GENERIC_ERROR_V2 = 0xA,
  ACPI_HEST_TYPE_IA32_DEFERRED_CHECK = 0xB,
  ACPI_HEST_TYPE_RESERVED = 0xC,
};
00000020 #pragma pack(push, 1)
struct acpi_hmat_cache
{
  acpi_hmat_structure header;
  u32 memory_PD;
  u32 reserved1;
  u64 cache_size;
  u32 cache_attributes;
  u16 reserved2;
  u16 number_of_SMBIOShandles;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_hmat_cache.header acpi_hmat_structure;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_hmat_cache.memory_PD u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hmat_cache.reserved1 u32;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_hmat_cache.cache_size u64;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 acpi_hmat_cache.cache_attributes u32;
//  5. 001C 0002 effalign(2) fda=0 bits=0000 acpi_hmat_cache.reserved2 u16;
//  6. 001E 0002 effalign(2) fda=0 bits=0000 acpi_hmat_cache.number_of_SMBIOShandles u16;
//          0020 effalign(1) sda=0 bits=0000 acpi_hmat_cache struct packalign=1

00000020 #pragma pack(push, 1)
struct acpi_hmat_locality
{
  acpi_hmat_structure header;
  u8 flags;
  u8 data_type;
  u16 reserved1;
  u32 number_of_initiator_Pds;
  u32 number_of_target_Pds;
  u32 reserved2;
  u64 entry_base_unit;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_hmat_locality.header acpi_hmat_structure;
//  1. 0008 0001 effalign(1) fda=0 bits=0000 acpi_hmat_locality.flags u8;
//  2. 0009 0001 effalign(1) fda=0 bits=0000 acpi_hmat_locality.data_type u8;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 acpi_hmat_locality.reserved1 u16;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hmat_locality.number_of_initiator_Pds u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hmat_locality.number_of_target_Pds u32;
//  6. 0014 0004 effalign(4) fda=0 bits=0000 acpi_hmat_locality.reserved2 u32;
//  7. 0018 0008 effalign(8) fda=0 bits=0000 acpi_hmat_locality.entry_base_unit u64;
//          0020 effalign(1) sda=0 bits=0000 acpi_hmat_locality struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_hmat_proximity_domain
{
  acpi_hmat_structure header;
  u16 flags;
  u16 reserved1;
  u32 processor_PD;
  u32 memory_PD;
  u32 reserved2;
  u64 reserved3;
  u64 reserved4;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_hmat_proximity_domain.header acpi_hmat_structure;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 acpi_hmat_proximity_domain.flags u16;
//  2. 000A 0002 effalign(2) fda=0 bits=0000 acpi_hmat_proximity_domain.reserved1 u16;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_hmat_proximity_domain.processor_PD u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_hmat_proximity_domain.memory_PD u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_hmat_proximity_domain.reserved2 u32;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 acpi_hmat_proximity_domain.reserved3 u64;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 acpi_hmat_proximity_domain.reserved4 u64;
//          0028 effalign(1) sda=0 bits=0000 acpi_hmat_proximity_domain struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_hmat_structure
{
  u16 type;
  u16 reserved;
  u32 length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_hmat_structure.type u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_hmat_structure.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_hmat_structure.length u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_hmat_structure struct packalign=1

00000004 enum acpi_hmat_type : unsigned __int32
{
  ACPI_HMAT_TYPE_PROXIMITY = 0x0,
  ACPI_HMAT_TYPE_LOCALITY = 0x1,
  ACPI_HMAT_TYPE_CACHE = 0x2,
  ACPI_HMAT_TYPE_RESERVED = 0x3,
};
00000020 struct acpi_hotplug_context
{
  acpi_device *self;
  int (__cdecl *notify)(acpi_device *, u32);
  void (__cdecl *uevent)(acpi_device *, u32);
  void (__cdecl *fixup)(acpi_device *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_context.self acpi_device *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_context.notify int (__cdecl *)(acpi_device *, u32);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_context.uevent void (__cdecl *)(acpi_device *, u32);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_context.fixup void (__cdecl *)(acpi_device *);
//          0020 effalign(8) sda=0 bits=0000 acpi_hotplug_context struct packalign=0

00000058 struct acpi_hotplug_profile
{
  kobject kobj;
  int (__cdecl *scan_dependent)(acpi_device *);
  void (__cdecl *notify_online)(acpi_device *);
  __int8 enabled : 1;
  __int8 demand_offline : 1;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 acpi_hotplug_profile.kobj kobject;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_profile.scan_dependent int (__cdecl *)(acpi_device *);
//  2. 0048 0008 effalign(8) fda=0 bits=0000 acpi_hotplug_profile.notify_online void (__cdecl *)(acpi_device *);
//  3. 0050. 0 1 effalign(1) fda=0 bits=0000 acpi_hotplug_profile.enabled bi.nbytes=1 S
//  4. 0050. 1 1 effalign(1) fda=0 bits=0000 acpi_hotplug_profile.demand_offline bi.nbytes=1 S
//          0051 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 acpi_hotplug_profile struct packalign=0

00000004 enum acpi_hpet_page_protect : unsigned __int32
{
  ACPI_HPET_NO_PAGE_PROTECT = 0x0,
  ACPI_HPET_PAGE_PROTECT4 = 0x1,
  ACPI_HPET_PAGE_PROTECT64 = 0x2,
};
00000012 #pragma pack(push, 1)
struct acpi_ibft_control
{
  acpi_ibft_header header;
  u16 extensions;
  u16 initiator_offset;
  u16 nic0_offset;
  u16 target0_offset;
  u16 nic1_offset;
  u16 target1_offset;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ibft_control.header acpi_ibft_header;
//  1. 0006 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.extensions u16;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.initiator_offset u16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.nic0_offset u16;
//  4. 000C 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.target0_offset u16;
//  5. 000E 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.nic1_offset u16;
//  6. 0010 0002 effalign(2) fda=0 bits=0000 acpi_ibft_control.target1_offset u16;
//          0012 effalign(1) sda=0 bits=0000 acpi_ibft_control struct packalign=1

00000006 #pragma pack(push, 1)
struct acpi_ibft_header
{
  u8 type;
  u8 version;
  u16 length;
  u8 index;
  u8 flags;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_ibft_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_ibft_header.version u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_ibft_header.length u16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 acpi_ibft_header.index u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 acpi_ibft_header.flags u8;
//          0006 effalign(1) sda=0 bits=0000 acpi_ibft_header struct packalign=1

0000004A #pragma pack(push, 1)
struct acpi_ibft_initiator
{
  acpi_ibft_header header;
  u8 sns_server[16];
  u8 slp_server[16];
  u8 primary_server[16];
  u8 secondary_server[16];
  u16 name_length;
  u16 name_offset;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ibft_initiator.header acpi_ibft_header;
//  1. 0006 0010 effalign(1) fda=0 bits=0000 acpi_ibft_initiator.sns_server u8[16];
//  2. 0016 0010 effalign(1) fda=0 bits=0000 acpi_ibft_initiator.slp_server u8[16];
//  3. 0026 0010 effalign(1) fda=0 bits=0000 acpi_ibft_initiator.primary_server u8[16];
//  4. 0036 0010 effalign(1) fda=0 bits=0000 acpi_ibft_initiator.secondary_server u8[16];
//  5. 0046 0002 effalign(2) fda=0 bits=0000 acpi_ibft_initiator.name_length u16;
//  6. 0048 0002 effalign(2) fda=0 bits=0000 acpi_ibft_initiator.name_offset u16;
//          004A effalign(1) sda=0 bits=0000 acpi_ibft_initiator struct packalign=1

00000066 #pragma pack(push, 1)
struct acpi_ibft_nic
{
  acpi_ibft_header header;
  u8 ip_address[16];
  u8 subnet_mask_prefix;
  u8 origin;
  u8 gateway[16];
  u8 primary_dns[16];
  u8 secondary_dns[16];
  u8 dhcp[16];
  u16 vlan;
  u8 mac_address[6];
  u16 pci_address;
  u16 name_length;
  u16 name_offset;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ibft_nic.header acpi_ibft_header;
//  1. 0006 0010 effalign(1) fda=0 bits=0000 acpi_ibft_nic.ip_address u8[16];
//  2. 0016 0001 effalign(1) fda=0 bits=0000 acpi_ibft_nic.subnet_mask_prefix u8;
//  3. 0017 0001 effalign(1) fda=0 bits=0000 acpi_ibft_nic.origin u8;
//  4. 0018 0010 effalign(1) fda=0 bits=0000 acpi_ibft_nic.gateway u8[16];
//  5. 0028 0010 effalign(1) fda=0 bits=0000 acpi_ibft_nic.primary_dns u8[16];
//  6. 0038 0010 effalign(1) fda=0 bits=0000 acpi_ibft_nic.secondary_dns u8[16];
//  7. 0048 0010 effalign(1) fda=0 bits=0000 acpi_ibft_nic.dhcp u8[16];
//  8. 0058 0002 effalign(2) fda=0 bits=0000 acpi_ibft_nic.vlan u16;
//  9. 005A 0006 effalign(1) fda=0 bits=0000 acpi_ibft_nic.mac_address u8[6];
// 10. 0060 0002 effalign(2) fda=0 bits=0000 acpi_ibft_nic.pci_address u16;
// 11. 0062 0002 effalign(2) fda=0 bits=0000 acpi_ibft_nic.name_length u16;
// 12. 0064 0002 effalign(2) fda=0 bits=0000 acpi_ibft_nic.name_offset u16;
//          0066 effalign(1) sda=0 bits=0000 acpi_ibft_nic struct packalign=1

00000036 #pragma pack(push, 1)
struct acpi_ibft_target
{
  acpi_ibft_header header;
  u8 target_ip_address[16];
  u16 target_ip_socket;
  u8 target_boot_lun[8];
  u8 chap_type;
  u8 nic_association;
  u16 target_name_length;
  u16 target_name_offset;
  u16 chap_name_length;
  u16 chap_name_offset;
  u16 chap_secret_length;
  u16 chap_secret_offset;
  u16 reverse_chap_name_length;
  u16 reverse_chap_name_offset;
  u16 reverse_chap_secret_length;
  u16 reverse_chap_secret_offset;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ibft_target.header acpi_ibft_header;
//  1. 0006 0010 effalign(1) fda=0 bits=0000 acpi_ibft_target.target_ip_address u8[16];
//  2. 0016 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.target_ip_socket u16;
//  3. 0018 0008 effalign(1) fda=0 bits=0000 acpi_ibft_target.target_boot_lun u8[8];
//  4. 0020 0001 effalign(1) fda=0 bits=0000 acpi_ibft_target.chap_type u8;
//  5. 0021 0001 effalign(1) fda=0 bits=0000 acpi_ibft_target.nic_association u8;
//  6. 0022 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.target_name_length u16;
//  7. 0024 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.target_name_offset u16;
//  8. 0026 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.chap_name_length u16;
//  9. 0028 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.chap_name_offset u16;
// 10. 002A 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.chap_secret_length u16;
// 11. 002C 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.chap_secret_offset u16;
// 12. 002E 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.reverse_chap_name_length u16;
// 13. 0030 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.reverse_chap_name_offset u16;
// 14. 0032 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.reverse_chap_secret_length u16;
// 15. 0034 0002 effalign(2) fda=0 bits=0000 acpi_ibft_target.reverse_chap_secret_offset u16;
//          0036 effalign(1) sda=0 bits=0000 acpi_ibft_target struct packalign=1

00000004 enum acpi_ibft_type : unsigned __int32
{
  ACPI_IBFT_TYPE_NOT_USED = 0x0,
  ACPI_IBFT_TYPE_CONTROL = 0x1,
  ACPI_IBFT_TYPE_INITIATOR = 0x2,
  ACPI_IBFT_TYPE_NIC = 0x3,
  ACPI_IBFT_TYPE_TARGET = 0x4,
  ACPI_IBFT_TYPE_EXTENSIONS = 0x5,
  ACPI_IBFT_TYPE_RESERVED = 0x6,
};
00000008 typedef acpi_status (__cdecl *acpi_init_handler)(acpi_handle, u32);
00000008 typedef u64 acpi_integer;
00000008 typedef u32 (__cdecl *acpi_interface_handler)(acpi_string, u32);
00000004 enum acpi_interrupt_id : unsigned __int32
{
  ACPI_INTERRUPT_PMI = 0x1,
  ACPI_INTERRUPT_INIT = 0x2,
  ACPI_INTERRUPT_CPEI = 0x3,
  ACPI_INTERRUPT_COUNT = 0x4,
};
00000008 typedef u64 acpi_io_address;
00000004 #pragma pack(push, 1)
struct acpi_io_attribute
{
  u8 range_type;
  u8 translation;
  u8 translation_type;
  u8 reserved1;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_io_attribute.range_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_io_attribute.translation u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_io_attribute.translation_type u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_io_attribute.reserved1 u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_io_attribute struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_iort_id_mapping
{
  u32 input_base;
  u32 id_count;
  u32 output_base;
  u32 output_reference;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_iort_id_mapping.input_base u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_iort_id_mapping.id_count u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_id_mapping.output_base u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_id_mapping.output_reference u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_iort_id_mapping.flags u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_iort_id_mapping struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_iort_its_group
{
  u32 its_count;
  u32 identifiers[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_iort_its_group.its_count u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_iort_its_group.identifiers u32[1];
//          0008 effalign(1) sda=0 bits=0000 acpi_iort_its_group struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_iort_memory_access
{
  u32 cache_coherency;
  u8 hints;
  u16 reserved;
  u8 memory_flags;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_iort_memory_access.cache_coherency u32;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_iort_memory_access.hints u8;
//  2. 0005 0002 effalign(2) fda=0 bits=0000 acpi_iort_memory_access.reserved u16;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_iort_memory_access.memory_flags u8;
//          0008 effalign(1) sda=0 bits=0000 acpi_iort_memory_access struct packalign=1

0000000E #pragma pack(push, 1)
struct acpi_iort_named_component
{
  u32 node_flags;
  u64 memory_properties;
  u8 memory_address_limit;
  char device_name[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_iort_named_component.node_flags u32;
//  1. 0004 0008 effalign(8) fda=0 bits=0000 acpi_iort_named_component.memory_properties u64;
//  2. 000C 0001 effalign(1) fda=0 bits=0000 acpi_iort_named_component.memory_address_limit u8;
//  3. 000D 0001 effalign(1) fda=0 bits=0000 acpi_iort_named_component.device_name char[1];
//          000E effalign(1) sda=0 bits=0000 acpi_iort_named_component struct packalign=1

00000011 #pragma pack(push, 1)
struct acpi_iort_node
{
  u8 type;
  u16 length;
  u8 revision;
  u32 reserved;
  u32 mapping_count;
  u32 mapping_offset;
  char node_data[1];
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_iort_node.type u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_iort_node.length u16;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_iort_node.revision u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_iort_node.reserved u32;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_node.mapping_count u32;
//  5. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_node.mapping_offset u32;
//  6. 0010 0001 effalign(1) fda=0 bits=0000 acpi_iort_node.node_data char[1];
//          0011 effalign(1) sda=0 bits=0000 acpi_iort_node struct packalign=1

00000004 enum acpi_iort_node_type : unsigned __int32
{
  ACPI_IORT_NODE_ITS_GROUP = 0x0,
  ACPI_IORT_NODE_NAMED_COMPONENT = 0x1,
  ACPI_IORT_NODE_PCI_ROOT_COMPLEX = 0x2,
  ACPI_IORT_NODE_SMMU = 0x3,
  ACPI_IORT_NODE_SMMU_V3 = 0x4,
  ACPI_IORT_NODE_PMCG = 0x5,
};
00000018 #pragma pack(push, 1)
struct acpi_iort_pmcg
{
  u64 page0_base_address;
  u32 overflow_gsiv;
  u32 node_reference;
  u64 page1_base_address;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_iort_pmcg.page0_base_address u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_pmcg.overflow_gsiv u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_pmcg.node_reference u32;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_iort_pmcg.page1_base_address u64;
//          0018 effalign(1) sda=0 bits=0000 acpi_iort_pmcg struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_iort_root_complex
{
  u64 memory_properties;
  u32 ats_attribute;
  u32 pci_segment_number;
  u8 memory_address_limit;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_iort_root_complex.memory_properties u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_root_complex.ats_attribute u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_root_complex.pci_segment_number u32;
//  3. 0010 0001 effalign(1) fda=0 bits=0000 acpi_iort_root_complex.memory_address_limit u8;
//  4. 0011 0003 effalign(1) fda=0 bits=0000 acpi_iort_root_complex.reserved u8[3];
//          0014 effalign(1) sda=0 bits=0000 acpi_iort_root_complex struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_iort_smmu
{
  u64 base_address;
  u64 span;
  u32 model;
  u32 flags;
  u32 global_interrupt_offset;
  u32 context_interrupt_count;
  u32 context_interrupt_offset;
  u32 pmu_interrupt_count;
  u32 pmu_interrupt_offset;
  u64 interrupts[1];
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_iort_smmu.base_address u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_iort_smmu.span u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.model u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.flags u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.global_interrupt_offset u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.context_interrupt_count u32;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.context_interrupt_offset u32;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.pmu_interrupt_count u32;
//  8. 0028 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu.pmu_interrupt_offset u32;
//  9. 002C 0008 effalign(8) fda=0 bits=0000 acpi_iort_smmu.interrupts u64[1];
//          0034 effalign(1) sda=0 bits=0000 acpi_iort_smmu struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_iort_smmu_gsi
{
  u32 nsg_irpt;
  u32 nsg_irpt_flags;
  u32 nsg_cfg_irpt;
  u32 nsg_cfg_irpt_flags;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_gsi.nsg_irpt u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_gsi.nsg_irpt_flags u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_gsi.nsg_cfg_irpt u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_gsi.nsg_cfg_irpt_flags u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_iort_smmu_gsi struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_iort_smmu_v3
{
  u64 base_address;
  u32 flags;
  u32 reserved;
  u64 vatos_address;
  u32 model;
  u32 event_gsiv;
  u32 pri_gsiv;
  u32 gerr_gsiv;
  u32 sync_gsiv;
  u32 pxm;
  u32 id_mapping_index;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_iort_smmu_v3.base_address u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.flags u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.reserved u32;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_iort_smmu_v3.vatos_address u64;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.model u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.event_gsiv u32;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.pri_gsiv u32;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.gerr_gsiv u32;
//  8. 0028 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.sync_gsiv u32;
//  9. 002C 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.pxm u32;
// 10. 0030 0004 effalign(4) fda=0 bits=0000 acpi_iort_smmu_v3.id_mapping_index u32;
//          0034 effalign(1) sda=0 bits=0000 acpi_iort_smmu_v3 struct packalign=1

00000004 enum acpi_irq_model_id : unsigned __int32
{
  ACPI_IRQ_MODEL_PIC = 0x0,
  ACPI_IRQ_MODEL_IOAPIC = 0x1,
  ACPI_IRQ_MODEL_IOSAPIC = 0x2,
  ACPI_IRQ_MODEL_PLATFORM = 0x3,
  ACPI_IRQ_MODEL_GIC = 0x4,
  ACPI_IRQ_MODEL_COUNT = 0x5,
};
00000004 #pragma pack(push, 1)
struct acpi_ivrs_de_header
{
  u8 type;
  u16 id;
  u8 data_setting;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_de_header.type u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_de_header.id u16;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_de_header.data_setting u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_ivrs_de_header struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_ivrs_device4
{
  acpi_ivrs_de_header header;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_ivrs_device4.header acpi_ivrs_de_header;
//          0004 effalign(1) sda=0 bits=0000 acpi_ivrs_device4 struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_ivrs_device8a
{
  acpi_ivrs_de_header header;
  u8 reserved1;
  u16 used_id;
  u8 reserved2;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_ivrs_device8a.header acpi_ivrs_de_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_device8a.reserved1 u8;
//  2. 0005 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_device8a.used_id u16;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_device8a.reserved2 u8;
//          0008 effalign(1) sda=0 bits=0000 acpi_ivrs_device8a struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_ivrs_device8b
{
  acpi_ivrs_de_header header;
  u32 extended_data;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_ivrs_device8b.header acpi_ivrs_de_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_ivrs_device8b.extended_data u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_ivrs_device8b struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_ivrs_device8c
{
  acpi_ivrs_de_header header;
  u8 handle;
  u16 used_id;
  u8 variety;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_ivrs_device8c.header acpi_ivrs_de_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_device8c.handle u8;
//  2. 0005 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_device8c.used_id u16;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_device8c.variety u8;
//          0008 effalign(1) sda=0 bits=0000 acpi_ivrs_device8c struct packalign=1

00000004 enum acpi_ivrs_device_entry_type : unsigned __int32
{
  ACPI_IVRS_TYPE_PAD4 = 0x0,
  ACPI_IVRS_TYPE_ALL = 0x1,
  ACPI_IVRS_TYPE_SELECT = 0x2,
  ACPI_IVRS_TYPE_START = 0x3,
  ACPI_IVRS_TYPE_END = 0x4,
  ACPI_IVRS_TYPE_PAD8 = 0x40,
  ACPI_IVRS_TYPE_NOT_USED = 0x41,
  ACPI_IVRS_TYPE_ALIAS_SELECT = 0x42,
  ACPI_IVRS_TYPE_ALIAS_START = 0x43,
  ACPI_IVRS_TYPE_EXT_SELECT = 0x46,
  ACPI_IVRS_TYPE_EXT_START = 0x47,
  ACPI_IVRS_TYPE_SPECIAL = 0x48,
};
00000018 #pragma pack(push, 1)
struct acpi_ivrs_hardware
{
  acpi_ivrs_header header;
  u16 capability_offset;
  u64 base_address;
  u16 pci_segment_group;
  u16 info;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ivrs_hardware.header acpi_ivrs_header;
//  1. 0006 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_hardware.capability_offset u16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_ivrs_hardware.base_address u64;
//  3. 0010 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_hardware.pci_segment_group u16;
//  4. 0012 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_hardware.info u16;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_ivrs_hardware.reserved u32;
//          0018 effalign(1) sda=0 bits=0000 acpi_ivrs_hardware struct packalign=1

00000006 #pragma pack(push, 1)
struct acpi_ivrs_header
{
  u8 type;
  u8 flags;
  u16 length;
  u16 device_id;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_ivrs_header.flags u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_header.length u16;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_header.device_id u16;
//          0006 effalign(1) sda=0 bits=0000 acpi_ivrs_header struct packalign=1

00000020 #pragma pack(push, 1)
struct acpi_ivrs_memory
{
  acpi_ivrs_header header;
  u16 aux_data;
  u64 reserved;
  u64 start_address;
  u64 memory_length;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_ivrs_memory.header acpi_ivrs_header;
//  1. 0006 0002 effalign(2) fda=0 bits=0000 acpi_ivrs_memory.aux_data u16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_ivrs_memory.reserved u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_ivrs_memory.start_address u64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 acpi_ivrs_memory.memory_length u64;
//          0020 effalign(1) sda=0 bits=0000 acpi_ivrs_memory struct packalign=1

00000004 enum acpi_ivrs_type : unsigned __int32
{
  ACPI_IVRS_TYPE_HARDWARE = 0x10,
  ACPI_IVRS_TYPE_MEMORY1 = 0x20,
  ACPI_IVRS_TYPE_MEMORY2 = 0x21,
  ACPI_IVRS_TYPE_MEMORY3 = 0x22,
};
00000010 #pragma pack(push, 1)
struct acpi_lpit_header
{
  u32 type;
  u32 length;
  u16 unique_id;
  u16 reserved;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_lpit_header.type u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_lpit_header.length u32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 acpi_lpit_header.unique_id u16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 acpi_lpit_header.reserved u16;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_lpit_header.flags u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_lpit_header struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_lpit_native
{
  acpi_lpit_header header;
  acpi_generic_address entry_trigger;
  u32 residency;
  u32 latency;
  acpi_generic_address residency_counter;
  u64 counter_frequency;
};
#pragma pack(pop)
//  0. 0000 0010 effalign(1) fda=0 bits=0000 acpi_lpit_native.header acpi_lpit_header;
//  1. 0010 000C effalign(1) fda=0 bits=0000 acpi_lpit_native.entry_trigger acpi_generic_address;
//  2. 001C 0004 effalign(4) fda=0 bits=0000 acpi_lpit_native.residency u32;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 acpi_lpit_native.latency u32;
//  4. 0024 000C effalign(1) fda=0 bits=0000 acpi_lpit_native.residency_counter acpi_generic_address;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 acpi_lpit_native.counter_frequency u64;
//          0038 effalign(1) sda=0 bits=0000 acpi_lpit_native struct packalign=1

00000004 enum acpi_lpit_type : unsigned __int32
{
  ACPI_LPIT_TYPE_NATIVE_CSTATE = 0x0,
  ACPI_LPIT_TYPE_RESERVED = 0x1,
};
00000018 #pragma pack(push, 1)
struct acpi_madt_generic_distributor
{
  acpi_subtable_header header;
  u16 reserved;
  u32 gic_id;
  u64 base_address;
  u32 global_irq_base;
  u8 version;
  u8 reserved2[3];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_generic_distributor.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_distributor.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_distributor.gic_id u32;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_distributor.base_address u64;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_distributor.global_irq_base u32;
//  5. 0014 0001 effalign(1) fda=0 bits=0000 acpi_madt_generic_distributor.version u8;
//  6. 0015 0003 effalign(1) fda=0 bits=0000 acpi_madt_generic_distributor.reserved2 u8[3];
//          0018 effalign(1) sda=0 bits=0000 acpi_madt_generic_distributor struct packalign=1

00000050 #pragma pack(push, 1)
struct acpi_madt_generic_interrupt
{
  acpi_subtable_header header;
  u16 reserved;
  u32 cpu_interface_number;
  u32 uid;
  u32 flags;
  u32 parking_version;
  u32 performance_interrupt;
  u64 parked_address;
  u64 base_address;
  u64 gicv_base_address;
  u64 gich_base_address;
  u32 vgic_interrupt;
  u64 gicr_base_address;
  u64 arm_mpidr;
  u8 efficiency_class;
  u8 reserved2[1];
  u16 spe_interrupt;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_generic_interrupt.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_interrupt.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.cpu_interface_number u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.uid u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.flags u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.parking_version u32;
//  6. 0014 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.performance_interrupt u32;
//  7. 0018 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.parked_address u64;
//  8. 0020 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.base_address u64;
//  9. 0028 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.gicv_base_address u64;
// 10. 0030 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.gich_base_address u64;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_interrupt.vgic_interrupt u32;
// 12. 003C 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.gicr_base_address u64;
// 13. 0044 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_interrupt.arm_mpidr u64;
// 14. 004C 0001 effalign(1) fda=0 bits=0000 acpi_madt_generic_interrupt.efficiency_class u8;
// 15. 004D 0001 effalign(1) fda=0 bits=0000 acpi_madt_generic_interrupt.reserved2 u8[1];
// 16. 004E 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_interrupt.spe_interrupt u16;
//          0050 effalign(1) sda=0 bits=0000 acpi_madt_generic_interrupt struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_madt_generic_msi_frame
{
  acpi_subtable_header header;
  u16 reserved;
  u32 msi_frame_id;
  u64 base_address;
  u32 flags;
  u16 spi_count;
  u16 spi_base;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_generic_msi_frame.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_msi_frame.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_msi_frame.msi_frame_id u32;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_msi_frame.base_address u64;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_msi_frame.flags u32;
//  5. 0014 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_msi_frame.spi_count u16;
//  6. 0016 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_msi_frame.spi_base u16;
//          0018 effalign(1) sda=0 bits=0000 acpi_madt_generic_msi_frame struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_madt_generic_redistributor
{
  acpi_subtable_header header;
  u16 reserved;
  u64 base_address;
  u32 length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_generic_redistributor.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_redistributor.reserved u16;
//  2. 0004 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_redistributor.base_address u64;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_redistributor.length u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_madt_generic_redistributor struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_madt_generic_translator
{
  acpi_subtable_header header;
  u16 reserved;
  u32 translation_id;
  u64 base_address;
  u32 reserved2;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_generic_translator.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_generic_translator.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_translator.translation_id u32;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_madt_generic_translator.base_address u64;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_madt_generic_translator.reserved2 u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_madt_generic_translator struct packalign=1

00000004 enum acpi_madt_gic_version : unsigned __int32
{
  ACPI_MADT_GIC_VERSION_NONE = 0x0,
  ACPI_MADT_GIC_VERSION_V1 = 0x1,
  ACPI_MADT_GIC_VERSION_V2 = 0x2,
  ACPI_MADT_GIC_VERSION_V3 = 0x3,
  ACPI_MADT_GIC_VERSION_V4 = 0x4,
  ACPI_MADT_GIC_VERSION_RESERVED = 0x5,
};
0000000A #pragma pack(push, 1)
struct acpi_madt_interrupt_override
{
  acpi_subtable_header header;
  u8 bus;
  u8 source_irq;
  u32 global_irq;
  u16 inti_flags;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_override.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_override.bus u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_override.source_irq u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_interrupt_override.global_irq u32;
//  4. 0008 0002 effalign(2) fda=0 bits=0000 acpi_madt_interrupt_override.inti_flags u16;
//          000A effalign(1) sda=0 bits=0000 acpi_madt_interrupt_override struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_madt_interrupt_source
{
  acpi_subtable_header header;
  u16 inti_flags;
  u8 type;
  u8 id;
  u8 eid;
  u8 io_sapic_vector;
  u32 global_irq;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_source.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_interrupt_source.inti_flags u16;
//  2. 0004 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_source.type u8;
//  3. 0005 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_source.id u8;
//  4. 0006 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_source.eid u8;
//  5. 0007 0001 effalign(1) fda=0 bits=0000 acpi_madt_interrupt_source.io_sapic_vector u8;
//  6. 0008 0004 effalign(4) fda=0 bits=0000 acpi_madt_interrupt_source.global_irq u32;
//  7. 000C 0004 effalign(4) fda=0 bits=0000 acpi_madt_interrupt_source.flags u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_madt_interrupt_source struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_madt_io_apic
{
  acpi_subtable_header header;
  u8 id;
  u8 reserved;
  u32 address;
  u32 global_irq_base;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_io_apic.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_io_apic.id u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_madt_io_apic.reserved u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_io_apic.address u32;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_madt_io_apic.global_irq_base u32;
//          000C effalign(1) sda=0 bits=0000 acpi_madt_io_apic struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_madt_io_sapic
{
  acpi_subtable_header header;
  u8 id;
  u8 reserved;
  u32 global_irq_base;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_io_sapic.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_io_sapic.id u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_madt_io_sapic.reserved u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_io_sapic.global_irq_base u32;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_madt_io_sapic.address u64;
//          0010 effalign(1) sda=0 bits=0000 acpi_madt_io_sapic struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_madt_local_apic
{
  acpi_subtable_header header;
  u8 processor_id;
  u8 id;
  u32 lapic_flags;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_apic.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_apic.processor_id u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_apic.id u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_apic.lapic_flags u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_madt_local_apic struct packalign=1

00000006 #pragma pack(push, 1)
struct acpi_madt_local_apic_nmi
{
  acpi_subtable_header header;
  u8 processor_id;
  u16 inti_flags;
  u8 lint;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_apic_nmi.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_apic_nmi.processor_id u8;
//  2. 0003 0002 effalign(2) fda=0 bits=0000 acpi_madt_local_apic_nmi.inti_flags u16;
//  3. 0005 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_apic_nmi.lint u8;
//          0006 effalign(1) sda=0 bits=0000 acpi_madt_local_apic_nmi struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_madt_local_apic_override
{
  acpi_subtable_header header;
  u16 reserved;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_apic_override.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_local_apic_override.reserved u16;
//  2. 0004 0008 effalign(8) fda=0 bits=0000 acpi_madt_local_apic_override.address u64;
//          000C effalign(1) sda=0 bits=0000 acpi_madt_local_apic_override struct packalign=1

00000011 #pragma pack(push, 1)
struct acpi_madt_local_sapic
{
  acpi_subtable_header header;
  u8 processor_id;
  u8 id;
  u8 eid;
  u8 reserved[3];
  u32 lapic_flags;
  u32 uid;
  char uid_string[1];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.processor_id u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.id u8;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.eid u8;
//  4. 0005 0003 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.reserved u8[3];
//  5. 0008 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_sapic.lapic_flags u32;
//  6. 000C 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_sapic.uid u32;
//  7. 0010 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_sapic.uid_string char[1];
//          0011 effalign(1) sda=0 bits=0000 acpi_madt_local_sapic struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_madt_local_x2apic
{
  acpi_subtable_header header;
  u16 reserved;
  u32 local_apic_id;
  u32 lapic_flags;
  u32 uid;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_x2apic.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_local_x2apic.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_x2apic.local_apic_id u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_x2apic.lapic_flags u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_x2apic.uid u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_madt_local_x2apic struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_madt_local_x2apic_nmi
{
  acpi_subtable_header header;
  u16 inti_flags;
  u32 uid;
  u8 lint;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_local_x2apic_nmi.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_local_x2apic_nmi.inti_flags u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_local_x2apic_nmi.uid u32;
//  3. 0008 0001 effalign(1) fda=0 bits=0000 acpi_madt_local_x2apic_nmi.lint u8;
//  4. 0009 0003 effalign(1) fda=0 bits=0000 acpi_madt_local_x2apic_nmi.reserved u8[3];
//          000C effalign(1) sda=0 bits=0000 acpi_madt_local_x2apic_nmi struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_madt_nmi_source
{
  acpi_subtable_header header;
  u16 inti_flags;
  u32 global_irq;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_madt_nmi_source.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_madt_nmi_source.inti_flags u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_madt_nmi_source.global_irq u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_madt_nmi_source struct packalign=1

00000004 enum acpi_madt_type : unsigned __int32
{
  ACPI_MADT_TYPE_LOCAL_APIC = 0x0,
  ACPI_MADT_TYPE_IO_APIC = 0x1,
  ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 0x2,
  ACPI_MADT_TYPE_NMI_SOURCE = 0x3,
  ACPI_MADT_TYPE_LOCAL_APIC_NMI = 0x4,
  ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 0x5,
  ACPI_MADT_TYPE_IO_SAPIC = 0x6,
  ACPI_MADT_TYPE_LOCAL_SAPIC = 0x7,
  ACPI_MADT_TYPE_INTERRUPT_SOURCE = 0x8,
  ACPI_MADT_TYPE_LOCAL_X2APIC = 0x9,
  ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 0xA,
  ACPI_MADT_TYPE_GENERIC_INTERRUPT = 0xB,
  ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 0xC,
  ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 0xD,
  ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 0xE,
  ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 0xF,
  ACPI_MADT_TYPE_RESERVED = 0x10,
};
00000010 #pragma pack(push, 1)
struct acpi_mcfg_allocation
{
  u64 address;
  u16 pci_segment;
  u8 start_bus_number;
  u8 end_bus_number;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_mcfg_allocation.address u64;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 acpi_mcfg_allocation.pci_segment u16;
//  2. 000A 0001 effalign(1) fda=0 bits=0000 acpi_mcfg_allocation.start_bus_number u8;
//  3. 000B 0001 effalign(1) fda=0 bits=0000 acpi_mcfg_allocation.end_bus_number u8;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_mcfg_allocation.reserved u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_mcfg_allocation struct packalign=1

00000028 struct acpi_mem_space_context
{
  u32 length;
  acpi_physical_address address;
  acpi_physical_address mapped_physical_address;
  u8 *mapped_logical_address;
  acpi_size mapped_length;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_mem_space_context.length u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_mem_space_context.address acpi_physical_address;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_mem_space_context.mapped_physical_address acpi_physical_address;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 acpi_mem_space_context.mapped_logical_address u8 *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 acpi_mem_space_context.mapped_length acpi_size;
//          0028 effalign(8) sda=0 bits=0000 acpi_mem_space_context struct packalign=0

00000004 #pragma pack(push, 1)
struct acpi_memory_attribute
{
  u8 write_protect;
  u8 caching;
  u8 range_type;
  u8 translation;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_memory_attribute.write_protect u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_memory_attribute.caching u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_memory_attribute.range_type u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_memory_attribute.translation u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_memory_attribute struct packalign=1

00000018 struct acpi_memory_list
{
  const char *list_name;
  void *list_head;
  u16 object_size;
  u16 max_depth;
  u16 current_depth;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_memory_list.list_name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_memory_list.list_head void *;
//  2. 0010 0002 effalign(2) fda=0 bits=0000 acpi_memory_list.object_size u16;
//  3. 0012 0002 effalign(2) fda=0 bits=0000 acpi_memory_list.max_depth u16;
//  4. 0014 0002 effalign(2) fda=0 bits=0000 acpi_memory_list.current_depth u16;
//          0016 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 acpi_memory_list struct packalign=0

00000008 #pragma pack(push, 1)
struct acpi_mpst_channel
{
  u8 channel_id;
  u8 reserved1[3];
  u16 power_node_count;
  u16 reserved2;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_mpst_channel.channel_id u8;
//  1. 0001 0003 effalign(1) fda=0 bits=0000 acpi_mpst_channel.reserved1 u8[3];
//  2. 0004 0002 effalign(2) fda=0 bits=0000 acpi_mpst_channel.power_node_count u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_mpst_channel.reserved2 u16;
//          0008 effalign(1) sda=0 bits=0000 acpi_mpst_channel struct packalign=1

00000002 #pragma pack(push, 1)
struct acpi_mpst_component
{
  u16 component_id;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_mpst_component.component_id u16;
//          0002 effalign(1) sda=0 bits=0000 acpi_mpst_component struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_mpst_data_hdr
{
  u16 characteristics_count;
  u16 reserved;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_mpst_data_hdr.characteristics_count u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_mpst_data_hdr.reserved u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_mpst_data_hdr struct packalign=1

0000001C #pragma pack(push, 1)
struct acpi_mpst_power_data
{
  u8 structure_id;
  u8 flags;
  u16 reserved1;
  u32 average_power;
  u32 power_saving;
  u64 exit_latency;
  u64 reserved2;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_data.structure_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_data.flags u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_mpst_power_data.reserved1 u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_mpst_power_data.average_power u32;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_mpst_power_data.power_saving u32;
//  5. 000C 0008 effalign(8) fda=0 bits=0000 acpi_mpst_power_data.exit_latency u64;
//  6. 0014 0008 effalign(8) fda=0 bits=0000 acpi_mpst_power_data.reserved2 u64;
//          001C effalign(1) sda=0 bits=0000 acpi_mpst_power_data struct packalign=1

00000020 #pragma pack(push, 1)
struct acpi_mpst_power_node
{
  u8 flags;
  u8 reserved1;
  u16 node_id;
  u32 length;
  u64 range_address;
  u64 range_length;
  u32 num_power_states;
  u32 num_physical_components;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_node.flags u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_node.reserved1 u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_mpst_power_node.node_id u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_mpst_power_node.length u32;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_mpst_power_node.range_address u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 acpi_mpst_power_node.range_length u64;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 acpi_mpst_power_node.num_power_states u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 acpi_mpst_power_node.num_physical_components u32;
//          0020 effalign(1) sda=0 bits=0000 acpi_mpst_power_node struct packalign=1

00000002 #pragma pack(push, 1)
struct acpi_mpst_power_state
{
  u8 power_state;
  u8 info_index;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_state.power_state u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_mpst_power_state.info_index u8;
//          0002 effalign(1) sda=0 bits=0000 acpi_mpst_power_state struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_mpst_shared
{
  u32 signature;
  u16 pcc_command;
  u16 pcc_status;
  u32 command_register;
  u32 status_register;
  u32 power_state_id;
  u32 power_node_id;
  u64 energy_consumed;
  u64 average_power;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_mpst_shared.signature u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_mpst_shared.pcc_command u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_mpst_shared.pcc_status u16;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_mpst_shared.command_register u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_mpst_shared.status_register u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_mpst_shared.power_state_id u32;
//  6. 0014 0004 effalign(4) fda=0 bits=0000 acpi_mpst_shared.power_node_id u32;
//  7. 0018 0008 effalign(8) fda=0 bits=0000 acpi_mpst_shared.energy_consumed u64;
//  8. 0020 0008 effalign(8) fda=0 bits=0000 acpi_mpst_shared.average_power u64;
//          0028 effalign(1) sda=0 bits=0000 acpi_mpst_shared struct packalign=1

00000016 #pragma pack(push, 1)
struct acpi_msct_proximity
{
  u8 revision;
  u8 length;
  u32 range_start;
  u32 range_end;
  u32 processor_capacity;
  u64 memory_capacity;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_msct_proximity.revision u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_msct_proximity.length u8;
//  2. 0002 0004 effalign(4) fda=0 bits=0000 acpi_msct_proximity.range_start u32;
//  3. 0006 0004 effalign(4) fda=0 bits=0000 acpi_msct_proximity.range_end u32;
//  4. 000A 0004 effalign(4) fda=0 bits=0000 acpi_msct_proximity.processor_capacity u32;
//  5. 000E 0008 effalign(8) fda=0 bits=0000 acpi_msct_proximity.memory_capacity u64;
//          0016 effalign(1) sda=0 bits=0000 acpi_msct_proximity struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_mtmr_entry
{
  acpi_generic_address physical_address;
  u32 frequency;
  u32 irq;
};
#pragma pack(pop)
//  0. 0000 000C effalign(1) fda=0 bits=0000 acpi_mtmr_entry.physical_address acpi_generic_address;
//  1. 000C 0004 effalign(4) fda=0 bits=0000 acpi_mtmr_entry.frequency u32;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 acpi_mtmr_entry.irq u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_mtmr_entry struct packalign=1

00000004 typedef u32 acpi_name;
00000004 union acpi_name_union
{
  u32 integer;
  char ascii[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_name_union.integer u32;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 acpi_name_union.ascii char[4];
//          0004 effalign(4) sda=0 bits=0000 acpi_name_union union packalign=0

00000008 typedef s64 acpi_native_int;
00000010 #pragma pack(push, 1)
struct acpi_nfit_capabilities
{
  acpi_nfit_header header;
  u8 highest_capability;
  u8 reserved[3];
  u32 capabilities;
  u32 reserved2;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_capabilities.header acpi_nfit_header;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_nfit_capabilities.highest_capability u8;
//  2. 0005 0003 effalign(1) fda=0 bits=0000 acpi_nfit_capabilities.reserved u8[3];
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_nfit_capabilities.capabilities u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_nfit_capabilities.reserved2 u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_nfit_capabilities struct packalign=1

00000050 #pragma pack(push, 1)
struct acpi_nfit_control_region
{
  acpi_nfit_header header;
  u16 region_index;
  u16 vendor_id;
  u16 device_id;
  u16 revision_id;
  u16 subsystem_vendor_id;
  u16 subsystem_device_id;
  u16 subsystem_revision_id;
  u8 valid_fields;
  u8 manufacturing_location;
  u16 manufacturing_date;
  u8 reserved[2];
  u32 serial_number;
  u16 code;
  u16 windows;
  u64 window_size;
  u64 command_offset;
  u64 command_size;
  u64 status_offset;
  u64 status_size;
  u16 flags;
  u8 reserved1[6];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_control_region.header acpi_nfit_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.region_index u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.vendor_id u16;
//  3. 0008 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.device_id u16;
//  4. 000A 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.revision_id u16;
//  5. 000C 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.subsystem_vendor_id u16;
//  6. 000E 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.subsystem_device_id u16;
//  7. 0010 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.subsystem_revision_id u16;
//  8. 0012 0001 effalign(1) fda=0 bits=0000 acpi_nfit_control_region.valid_fields u8;
//  9. 0013 0001 effalign(1) fda=0 bits=0000 acpi_nfit_control_region.manufacturing_location u8;
// 10. 0014 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.manufacturing_date u16;
// 11. 0016 0002 effalign(1) fda=0 bits=0000 acpi_nfit_control_region.reserved u8[2];
// 12. 0018 0004 effalign(4) fda=0 bits=0000 acpi_nfit_control_region.serial_number u32;
// 13. 001C 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.code u16;
// 14. 001E 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.windows u16;
// 15. 0020 0008 effalign(8) fda=0 bits=0000 acpi_nfit_control_region.window_size u64;
// 16. 0028 0008 effalign(8) fda=0 bits=0000 acpi_nfit_control_region.command_offset u64;
// 17. 0030 0008 effalign(8) fda=0 bits=0000 acpi_nfit_control_region.command_size u64;
// 18. 0038 0008 effalign(8) fda=0 bits=0000 acpi_nfit_control_region.status_offset u64;
// 19. 0040 0008 effalign(8) fda=0 bits=0000 acpi_nfit_control_region.status_size u64;
// 20. 0048 0002 effalign(2) fda=0 bits=0000 acpi_nfit_control_region.flags u16;
// 21. 004A 0006 effalign(1) fda=0 bits=0000 acpi_nfit_control_region.reserved1 u8[6];
//          0050 effalign(1) sda=0 bits=0000 acpi_nfit_control_region struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_nfit_data_region
{
  acpi_nfit_header header;
  u16 region_index;
  u16 windows;
  u64 offset;
  u64 size;
  u64 capacity;
  u64 start_address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_data_region.header acpi_nfit_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_nfit_data_region.region_index u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_nfit_data_region.windows u16;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_nfit_data_region.offset u64;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_nfit_data_region.size u64;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 acpi_nfit_data_region.capacity u64;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 acpi_nfit_data_region.start_address u64;
//          0028 effalign(1) sda=0 bits=0000 acpi_nfit_data_region struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_nfit_flush_address
{
  acpi_nfit_header header;
  u32 device_handle;
  u16 hint_count;
  u8 reserved[6];
  u64 hint_address[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_flush_address.header acpi_nfit_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_nfit_flush_address.device_handle u32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 acpi_nfit_flush_address.hint_count u16;
//  3. 000A 0006 effalign(1) fda=0 bits=0000 acpi_nfit_flush_address.reserved u8[6];
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_nfit_flush_address.hint_address u64[1];
//          0018 effalign(1) sda=0 bits=0000 acpi_nfit_flush_address struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_nfit_header
{
  u16 type;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_nfit_header.type u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_nfit_header.length u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_nfit_header struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_nfit_interleave
{
  acpi_nfit_header header;
  u16 interleave_index;
  u16 reserved;
  u32 line_count;
  u32 line_size;
  u32 line_offset[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_interleave.header acpi_nfit_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_nfit_interleave.interleave_index u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_nfit_interleave.reserved u16;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_nfit_interleave.line_count u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_nfit_interleave.line_size u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_nfit_interleave.line_offset u32[1];
//          0014 effalign(1) sda=0 bits=0000 acpi_nfit_interleave struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_nfit_memory_map
{
  acpi_nfit_header header;
  u32 device_handle;
  u16 physical_id;
  u16 region_id;
  u16 range_index;
  u16 region_index;
  u64 region_size;
  u64 region_offset;
  u64 address;
  u16 interleave_index;
  u16 interleave_ways;
  u16 flags;
  u16 reserved;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_memory_map.header acpi_nfit_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_nfit_memory_map.device_handle u32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.physical_id u16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.region_id u16;
//  4. 000C 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.range_index u16;
//  5. 000E 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.region_index u16;
//  6. 0010 0008 effalign(8) fda=0 bits=0000 acpi_nfit_memory_map.region_size u64;
//  7. 0018 0008 effalign(8) fda=0 bits=0000 acpi_nfit_memory_map.region_offset u64;
//  8. 0020 0008 effalign(8) fda=0 bits=0000 acpi_nfit_memory_map.address u64;
//  9. 0028 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.interleave_index u16;
// 10. 002A 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.interleave_ways u16;
// 11. 002C 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.flags u16;
// 12. 002E 0002 effalign(2) fda=0 bits=0000 acpi_nfit_memory_map.reserved u16;
//          0030 effalign(1) sda=0 bits=0000 acpi_nfit_memory_map struct packalign=1

00000009 #pragma pack(push, 1)
struct acpi_nfit_smbios
{
  acpi_nfit_header header;
  u32 reserved;
  u8 data[1];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_smbios.header acpi_nfit_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_nfit_smbios.reserved u32;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 acpi_nfit_smbios.data u8[1];
//          0009 effalign(1) sda=0 bits=0000 acpi_nfit_smbios struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_nfit_system_address
{
  acpi_nfit_header header;
  u16 range_index;
  u16 flags;
  u32 reserved;
  u32 proximity_domain;
  u8 range_guid[16];
  u64 address;
  u64 length;
  u64 memory_mapping;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_nfit_system_address.header acpi_nfit_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_nfit_system_address.range_index u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_nfit_system_address.flags u16;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_nfit_system_address.reserved u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_nfit_system_address.proximity_domain u32;
//  5. 0010 0010 effalign(1) fda=0 bits=0000 acpi_nfit_system_address.range_guid u8[16];
//  6. 0020 0008 effalign(8) fda=0 bits=0000 acpi_nfit_system_address.address u64;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 acpi_nfit_system_address.length u64;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 acpi_nfit_system_address.memory_mapping u64;
//          0038 effalign(1) sda=0 bits=0000 acpi_nfit_system_address struct packalign=1

00000004 enum acpi_nfit_type : unsigned __int32
{
  ACPI_NFIT_TYPE_SYSTEM_ADDRESS = 0x0,
  ACPI_NFIT_TYPE_MEMORY_MAP = 0x1,
  ACPI_NFIT_TYPE_INTERLEAVE = 0x2,
  ACPI_NFIT_TYPE_SMBIOS = 0x3,
  ACPI_NFIT_TYPE_CONTROL_REGION = 0x4,
  ACPI_NFIT_TYPE_DATA_REGION = 0x5,
  ACPI_NFIT_TYPE_FLUSH_ADDRESS = 0x6,
  ACPI_NFIT_TYPE_CAPABILITIES = 0x7,
  ACPI_NFIT_TYPE_RESERVED = 0x8,
};
00000008 typedef void (__cdecl *acpi_notify_handler)(acpi_handle, u32, void *);
00000018 union acpi_object
{
  acpi_object_type type;
  acpi_object::$BC956EAF1611C47C2CE80601631E1282 integer;
  acpi_object::$99495C4131EE9BE146A26B9278DEBC59 string;
  acpi_object::$A8B095DB8626177C994664FFD6284067 buffer;
  acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F package;
  acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B reference;
  acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF processor;
  acpi_object::$2FDB974D2EC078F608E68C964FFA0786 power_resource;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object.type acpi_object_type;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 acpi_object.integer acpi_object::$BC956EAF1611C47C2CE80601631E1282;
//  2. 0000 0010 effalign(8) fda=0 bits=0000 acpi_object.string acpi_object::$99495C4131EE9BE146A26B9278DEBC59;
//  3. 0000 0010 effalign(8) fda=0 bits=0000 acpi_object.buffer acpi_object::$A8B095DB8626177C994664FFD6284067;
//  4. 0000 0010 effalign(8) fda=0 bits=0000 acpi_object.package acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F;
//  5. 0000 0010 effalign(8) fda=0 bits=0000 acpi_object.reference acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B;
//  6. 0000 0018 effalign(8) fda=0 bits=0000 acpi_object.processor acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF;
//  7. 0000 000C effalign(4) fda=0 bits=0000 acpi_object.power_resource acpi_object::$2FDB974D2EC078F608E68C964FFA0786;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 acpi_object union packalign=0

00000018 struct acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF
{
  acpi_object_type type;
  u32 proc_id;
  acpi_io_address pblk_address;
  u32 pblk_length;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF.proc_id u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF.pblk_address acpi_io_address;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF.pblk_length u32;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 acpi_object::$1C3B3D91FB1CE68DB7EC9815BEC4D3CF struct packalign=0

00000010 struct acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B
{
  acpi_object_type type;
  acpi_object_type actual_type;
  acpi_handle handle;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B.actual_type acpi_object_type;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B.handle acpi_handle;
//          0010 effalign(8) sda=0 bits=0000 acpi_object::$1FA18E306C61DA9CC414F34500CFCA9B struct packalign=0

0000000C struct acpi_object::$2FDB974D2EC078F608E68C964FFA0786
{
  acpi_object_type type;
  u32 system_level;
  u32 resource_order;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$2FDB974D2EC078F608E68C964FFA0786.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$2FDB974D2EC078F608E68C964FFA0786.system_level u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_object::$2FDB974D2EC078F608E68C964FFA0786.resource_order u32;
//          000C effalign(4) sda=0 bits=0000 acpi_object::$2FDB974D2EC078F608E68C964FFA0786 struct packalign=0

00000010 struct acpi_object::$99495C4131EE9BE146A26B9278DEBC59
{
  acpi_object_type type;
  u32 length;
  char *pointer;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$99495C4131EE9BE146A26B9278DEBC59.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$99495C4131EE9BE146A26B9278DEBC59.length u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$99495C4131EE9BE146A26B9278DEBC59.pointer char *;
//          0010 effalign(8) sda=0 bits=0000 acpi_object::$99495C4131EE9BE146A26B9278DEBC59 struct packalign=0

00000010 struct acpi_object::$A8B095DB8626177C994664FFD6284067
{
  acpi_object_type type;
  u32 length;
  u8 *pointer;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$A8B095DB8626177C994664FFD6284067.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$A8B095DB8626177C994664FFD6284067.length u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$A8B095DB8626177C994664FFD6284067.pointer u8 *;
//          0010 effalign(8) sda=0 bits=0000 acpi_object::$A8B095DB8626177C994664FFD6284067 struct packalign=0

00000010 struct acpi_object::$BC956EAF1611C47C2CE80601631E1282
{
  acpi_object_type type;
  u64 value;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$BC956EAF1611C47C2CE80601631E1282.type acpi_object_type;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$BC956EAF1611C47C2CE80601631E1282.value u64;
//          0010 effalign(8) sda=0 bits=0000 acpi_object::$BC956EAF1611C47C2CE80601631E1282 struct packalign=0

00000010 struct acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F
{
  acpi_object_type type;
  u32 count;
  acpi_object *elements;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F.type acpi_object_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F.count u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F.elements acpi_object *;
//          0010 effalign(8) sda=0 bits=0000 acpi_object::$D1F7A8419A89FE2172798E44F2D3B06F struct packalign=0

00000008 typedef void (__cdecl *acpi_object_handler)(acpi_handle, void *);
00000010 struct acpi_object_list
{
  u32 count;
  acpi_object *pointer;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_object_list.count u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_object_list.pointer acpi_object *;
//          0010 effalign(8) sda=0 bits=0000 acpi_object_list struct packalign=0

00000004 typedef u32 acpi_object_type;
00000008 typedef int (__cdecl *acpi_op_add)(acpi_device *);
00000008 typedef void (__cdecl *acpi_op_notify)(acpi_device *, u32);
00000008 typedef int (__cdecl *acpi_op_remove)(acpi_device *);
00000030 struct acpi_osc_context
{
  char *uuid_str;
  int rev;
  acpi_buffer cap;
  acpi_buffer ret;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_osc_context.uuid_str char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_osc_context.rev int;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 acpi_osc_context.cap acpi_buffer;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 acpi_osc_context.ret acpi_buffer;
//          0030 effalign(8) sda=0 bits=0000 acpi_osc_context struct packalign=0

00000008 typedef void (__cdecl *acpi_osd_exec_callback)(void *);
00000008 typedef u32 (__cdecl *acpi_osd_handler)(void *);
00000002 typedef u16 acpi_owner_id;
000000A4 #pragma pack(push, 1)
struct acpi_pcct_ext_pcc_master
{
  acpi_subtable_header header;
  u32 platform_interrupt;
  u8 flags;
  u8 reserved1;
  u64 base_address;
  u32 length;
  acpi_generic_address doorbell_register;
  u64 preserve_mask;
  u64 write_mask;
  u32 latency;
  u32 max_access_rate;
  u32 min_turnaround_time;
  acpi_generic_address platform_ack_register;
  u64 ack_preserve_mask;
  u64 ack_set_mask;
  u64 reserved2;
  acpi_generic_address cmd_complete_register;
  u64 cmd_complete_mask;
  acpi_generic_address cmd_update_register;
  u64 cmd_update_preserve_mask;
  u64 cmd_update_set_mask;
  acpi_generic_address error_status_register;
  u64 error_status_mask;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_master.platform_interrupt u32;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.reserved1 u8;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.base_address u64;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_master.length u32;
//  6. 0014 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.doorbell_register acpi_generic_address;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.preserve_mask u64;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.write_mask u64;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_master.latency u32;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_master.max_access_rate u32;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_master.min_turnaround_time u32;
// 12. 003C 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.platform_ack_register acpi_generic_address;
// 13. 0048 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.ack_preserve_mask u64;
// 14. 0050 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.ack_set_mask u64;
// 15. 0058 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.reserved2 u64;
// 16. 0060 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.cmd_complete_register acpi_generic_address;
// 17. 006C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.cmd_complete_mask u64;
// 18. 0074 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.cmd_update_register acpi_generic_address;
// 19. 0080 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.cmd_update_preserve_mask u64;
// 20. 0088 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.cmd_update_set_mask u64;
// 21. 0090 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_master.error_status_register acpi_generic_address;
// 22. 009C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_master.error_status_mask u64;
//          00A4 effalign(1) sda=0 bits=0000 acpi_pcct_ext_pcc_master struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_pcct_ext_pcc_shared_memory
{
  u32 signature;
  u32 flags;
  u32 length;
  u32 command;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_shared_memory.signature u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_shared_memory.flags u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_shared_memory.length u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_shared_memory.command u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_pcct_ext_pcc_shared_memory struct packalign=1

000000A4 #pragma pack(push, 1)
struct acpi_pcct_ext_pcc_slave
{
  acpi_subtable_header header;
  u32 platform_interrupt;
  u8 flags;
  u8 reserved1;
  u64 base_address;
  u32 length;
  acpi_generic_address doorbell_register;
  u64 preserve_mask;
  u64 write_mask;
  u32 latency;
  u32 max_access_rate;
  u32 min_turnaround_time;
  acpi_generic_address platform_ack_register;
  u64 ack_preserve_mask;
  u64 ack_set_mask;
  u64 reserved2;
  acpi_generic_address cmd_complete_register;
  u64 cmd_complete_mask;
  acpi_generic_address cmd_update_register;
  u64 cmd_update_preserve_mask;
  u64 cmd_update_set_mask;
  acpi_generic_address error_status_register;
  u64 error_status_mask;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.platform_interrupt u32;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.reserved1 u8;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.base_address u64;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.length u32;
//  6. 0014 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.doorbell_register acpi_generic_address;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.preserve_mask u64;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.write_mask u64;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.latency u32;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.max_access_rate u32;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.min_turnaround_time u32;
// 12. 003C 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.platform_ack_register acpi_generic_address;
// 13. 0048 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.ack_preserve_mask u64;
// 14. 0050 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.ack_set_mask u64;
// 15. 0058 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.reserved2 u64;
// 16. 0060 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.cmd_complete_register acpi_generic_address;
// 17. 006C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.cmd_complete_mask u64;
// 18. 0074 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.cmd_update_register acpi_generic_address;
// 19. 0080 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.cmd_update_preserve_mask u64;
// 20. 0088 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.cmd_update_set_mask u64;
// 21. 0090 000C effalign(1) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.error_status_register acpi_generic_address;
// 22. 009C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_ext_pcc_slave.error_status_mask u64;
//          00A4 effalign(1) sda=0 bits=0000 acpi_pcct_ext_pcc_slave struct packalign=1

0000003E #pragma pack(push, 1)
struct acpi_pcct_hw_reduced
{
  acpi_subtable_header header;
  u32 platform_interrupt;
  u8 flags;
  u8 reserved;
  u64 base_address;
  u64 length;
  acpi_generic_address doorbell_register;
  u64 preserve_mask;
  u64 write_mask;
  u32 latency;
  u32 max_access_rate;
  u16 min_turnaround_time;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced.platform_interrupt u32;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced.reserved u8;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced.base_address u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced.length u64;
//  6. 0018 000C effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced.doorbell_register acpi_generic_address;
//  7. 0024 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced.preserve_mask u64;
//  8. 002C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced.write_mask u64;
//  9. 0034 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced.latency u32;
// 10. 0038 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced.max_access_rate u32;
// 11. 003C 0002 effalign(2) fda=0 bits=0000 acpi_pcct_hw_reduced.min_turnaround_time u16;
//          003E effalign(1) sda=0 bits=0000 acpi_pcct_hw_reduced struct packalign=1

0000005A #pragma pack(push, 1)
struct acpi_pcct_hw_reduced_type2
{
  acpi_subtable_header header;
  u32 platform_interrupt;
  u8 flags;
  u8 reserved;
  u64 base_address;
  u64 length;
  acpi_generic_address doorbell_register;
  u64 preserve_mask;
  u64 write_mask;
  u32 latency;
  u32 max_access_rate;
  u16 min_turnaround_time;
  acpi_generic_address platform_ack_register;
  u64 ack_preserve_mask;
  u64 ack_write_mask;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.platform_interrupt u32;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.flags u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.reserved u8;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.base_address u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.length u64;
//  6. 0018 000C effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.doorbell_register acpi_generic_address;
//  7. 0024 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.preserve_mask u64;
//  8. 002C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.write_mask u64;
//  9. 0034 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.latency u32;
// 10. 0038 0004 effalign(4) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.max_access_rate u32;
// 11. 003C 0002 effalign(2) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.min_turnaround_time u16;
// 12. 003E 000C effalign(1) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.platform_ack_register acpi_generic_address;
// 13. 004A 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.ack_preserve_mask u64;
// 14. 0052 0008 effalign(8) fda=0 bits=0000 acpi_pcct_hw_reduced_type2.ack_write_mask u64;
//          005A effalign(1) sda=0 bits=0000 acpi_pcct_hw_reduced_type2 struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_pcct_shared_memory
{
  u32 signature;
  u16 command;
  u16 status;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pcct_shared_memory.signature u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_pcct_shared_memory.command u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_pcct_shared_memory.status u16;
//          0008 effalign(1) sda=0 bits=0000 acpi_pcct_shared_memory struct packalign=1

0000003E #pragma pack(push, 1)
struct acpi_pcct_subspace
{
  acpi_subtable_header header;
  u8 reserved[6];
  u64 base_address;
  u64 length;
  acpi_generic_address doorbell_register;
  u64 preserve_mask;
  u64 write_mask;
  u32 latency;
  u32 max_access_rate;
  u16 min_turnaround_time;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pcct_subspace.header acpi_subtable_header;
//  1. 0002 0006 effalign(1) fda=0 bits=0000 acpi_pcct_subspace.reserved u8[6];
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pcct_subspace.base_address u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_pcct_subspace.length u64;
//  4. 0018 000C effalign(1) fda=0 bits=0000 acpi_pcct_subspace.doorbell_register acpi_generic_address;
//  5. 0024 0008 effalign(8) fda=0 bits=0000 acpi_pcct_subspace.preserve_mask u64;
//  6. 002C 0008 effalign(8) fda=0 bits=0000 acpi_pcct_subspace.write_mask u64;
//  7. 0034 0004 effalign(4) fda=0 bits=0000 acpi_pcct_subspace.latency u32;
//  8. 0038 0004 effalign(4) fda=0 bits=0000 acpi_pcct_subspace.max_access_rate u32;
//  9. 003C 0002 effalign(2) fda=0 bits=0000 acpi_pcct_subspace.min_turnaround_time u16;
//          003E effalign(1) sda=0 bits=0000 acpi_pcct_subspace struct packalign=1

00000004 enum acpi_pcct_type : unsigned __int32
{
  ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0x0,
  ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 0x1,
  ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 0x2,
  ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 0x3,
  ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 0x4,
  ACPI_PCCT_TYPE_RESERVED = 0x5,
};
00000008 struct acpi_pci_id
{
  u16 segment;
  u16 bus;
  u16 device;
  u16 function;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_pci_id.segment u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_pci_id.bus u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 acpi_pci_id.device u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_pci_id.function u16;
//          0008 effalign(2) sda=0 bits=0000 acpi_pci_id struct packalign=0

00000068 struct acpi_pci_root
{
  acpi_device *device;
  pci_bus *bus;
  u16 segment;
  resource secondary;
  u32 osc_support_set;
  u32 osc_control_set;
  phys_addr_t mcfg_addr;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_pci_root.device acpi_device *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pci_root.bus pci_bus *;
//  2. 0010 0002 effalign(2) fda=0 bits=0000 acpi_pci_root.segment u16;
//  3. 0018 0040 effalign(8) fda=0 bits=0000 acpi_pci_root.secondary resource;
//  4. 0058 0004 effalign(4) fda=0 bits=0000 acpi_pci_root.osc_support_set u32;
//  5. 005C 0004 effalign(4) fda=0 bits=0000 acpi_pci_root.osc_control_set u32;
//  6. 0060 0008 effalign(8) fda=0 bits=0000 acpi_pci_root.mcfg_addr phys_addr_t;
//          0068 effalign(8) sda=0 bits=0000 acpi_pci_root struct packalign=0

00000018 struct acpi_pci_routing_table
{
  u32 length;
  u32 pin;
  u64 address;
  u32 source_index;
  char source[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pci_routing_table.length u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pci_routing_table.pin u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pci_routing_table.address u64;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pci_routing_table.source_index u32;
//  4. 0014 0004 effalign(1) fda=0 bits=0000 acpi_pci_routing_table.source char[4];
//          0018 effalign(8) sda=0 bits=0000 acpi_pci_routing_table struct packalign=0

00000002 #pragma pack(push, 1)
struct acpi_pdtt_channel
{
  u8 subchannel_id;
  u8 flags;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_pdtt_channel.subchannel_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_pdtt_channel.flags u8;
//          0002 effalign(1) sda=0 bits=0000 acpi_pdtt_channel struct packalign=1

00000008 typedef u64 acpi_physical_address;
00000038 struct acpi_platform_list
{
  char oem_id[7];
  char oem_table_id[9];
  u32 oem_revision;
  char *table;
  acpi_predicate pred;
  char *reason;
  u32 data;
};
//  0. 0000 0007 effalign(1) fda=0 bits=0000 acpi_platform_list.oem_id char[7];
//  1. 0007 0009 effalign(1) fda=0 bits=0000 acpi_platform_list.oem_table_id char[9];
//  2. 0010 0004 effalign(4) fda=0 bits=0000 acpi_platform_list.oem_revision u32;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 acpi_platform_list.table char *;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 acpi_platform_list.pred acpi_predicate;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 acpi_platform_list.reason char *;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 acpi_platform_list.data u32;
//          0034 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 acpi_platform_list struct packalign=0

00000022 struct acpi_pld_info
{
  u8 revision;
  u8 ignore_color;
  u8 red;
  u8 green;
  u8 blue;
  u16 width;
  u16 height;
  u8 user_visible;
  u8 dock;
  u8 lid;
  u8 panel;
  u8 vertical_position;
  u8 horizontal_position;
  u8 shape;
  u8 group_orientation;
  u8 group_token;
  u8 group_position;
  u8 bay;
  u8 ejectable;
  u8 ospm_eject_required;
  u8 cabinet_number;
  u8 card_cage_number;
  u8 reference;
  u8 rotation;
  u8 order;
  u8 reserved;
  u16 vertical_offset;
  u16 horizontal_offset;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.revision u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.ignore_color u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.red u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.green u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.blue u8;
//  5. 0006 0002 effalign(2) fda=0 bits=0000 acpi_pld_info.width u16;
//  6. 0008 0002 effalign(2) fda=0 bits=0000 acpi_pld_info.height u16;
//  7. 000A 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.user_visible u8;
//  8. 000B 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.dock u8;
//  9. 000C 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.lid u8;
// 10. 000D 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.panel u8;
// 11. 000E 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.vertical_position u8;
// 12. 000F 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.horizontal_position u8;
// 13. 0010 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.shape u8;
// 14. 0011 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.group_orientation u8;
// 15. 0012 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.group_token u8;
// 16. 0013 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.group_position u8;
// 17. 0014 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.bay u8;
// 18. 0015 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.ejectable u8;
// 19. 0016 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.ospm_eject_required u8;
// 20. 0017 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.cabinet_number u8;
// 21. 0018 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.card_cage_number u8;
// 22. 0019 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.reference u8;
// 23. 001A 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.rotation u8;
// 24. 001B 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.order u8;
// 25. 001C 0001 effalign(1) fda=0 bits=0000 acpi_pld_info.reserved u8;
// 26. 001E 0002 effalign(2) fda=0 bits=0000 acpi_pld_info.vertical_offset u16;
// 27. 0020 0002 effalign(2) fda=0 bits=0000 acpi_pld_info.horizontal_offset u16;
//          0022 effalign(2) sda=0 bits=0000 acpi_pld_info struct packalign=0

00000020 #pragma pack(push, 1)
struct acpi_pmtt_controller
{
  acpi_pmtt_header header;
  u32 read_latency;
  u32 write_latency;
  u32 read_bandwidth;
  u32 write_bandwidth;
  u16 access_width;
  u16 alignment;
  u16 reserved;
  u16 domain_count;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_pmtt_controller.header acpi_pmtt_header;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_controller.read_latency u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_controller.write_latency u32;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_controller.read_bandwidth u32;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_controller.write_bandwidth u32;
//  5. 0018 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_controller.access_width u16;
//  6. 001A 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_controller.alignment u16;
//  7. 001C 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_controller.reserved u16;
//  8. 001E 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_controller.domain_count u16;
//          0020 effalign(1) sda=0 bits=0000 acpi_pmtt_controller struct packalign=1

00000004 #pragma pack(push, 1)
struct acpi_pmtt_domain
{
  u32 proximity_domain;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_domain.proximity_domain u32;
//          0004 effalign(1) sda=0 bits=0000 acpi_pmtt_domain struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_pmtt_header
{
  u8 type;
  u8 reserved1;
  u16 length;
  u16 flags;
  u16 reserved2;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_pmtt_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_pmtt_header.reserved1 u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_header.length u16;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_header.flags u16;
//  4. 0006 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_header.reserved2 u16;
//          0008 effalign(1) sda=0 bits=0000 acpi_pmtt_header struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_pmtt_physical_component
{
  acpi_pmtt_header header;
  u16 component_id;
  u16 reserved;
  u32 memory_size;
  u32 bios_handle;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_pmtt_physical_component.header acpi_pmtt_header;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_physical_component.component_id u16;
//  2. 000A 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_physical_component.reserved u16;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_physical_component.memory_size u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pmtt_physical_component.bios_handle u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_pmtt_physical_component struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_pmtt_socket
{
  acpi_pmtt_header header;
  u16 socket_id;
  u16 reserved;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_pmtt_socket.header acpi_pmtt_header;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_socket.socket_id u16;
//  2. 000A 0002 effalign(2) fda=0 bits=0000 acpi_pmtt_socket.reserved u16;
//          000C effalign(1) sda=0 bits=0000 acpi_pmtt_socket struct packalign=1

00000010 struct acpi_pnp_device_id
{
  u32 length;
  char *string;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pnp_device_id.length u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pnp_device_id.string char *;
//          0010 effalign(8) sda=0 bits=0000 acpi_pnp_device_id struct packalign=0

00000018 struct acpi_pnp_device_id_list
{
  u32 count;
  u32 list_size;
  acpi_pnp_device_id ids[1];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_pnp_device_id_list.count u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pnp_device_id_list.list_size u32;
//  2. 0008 0010 effalign(8) fda=0 bits=0000 acpi_pnp_device_id_list.ids acpi_pnp_device_id[1];
//          0018 effalign(8) sda=0 bits=0000 acpi_pnp_device_id_list struct packalign=0

00000004 struct acpi_pnp_type
{
  unsigned __int32 hardware_id : 1;
  unsigned __int32 bus_address : 1;
  unsigned __int32 platform_id : 1;
  unsigned __int32 reserved : 29;
};
//  0. 0000. 0 1 effalign(1) fda=0 bits=0000 acpi_pnp_type.hardware_id bi.nbytes=4 U
//  1. 0000. 1 1 effalign(1) fda=0 bits=0000 acpi_pnp_type.bus_address bi.nbytes=4 U
//  2. 0000. 2 1 effalign(1) fda=0 bits=0000 acpi_pnp_type.platform_id bi.nbytes=4 U
//  3. 0000. 3 29 effalign(1) fda=0 bits=0000 acpi_pnp_type.reserved bi.nbytes=4 U
//          0004 effalign(4) sda=0 bits=0000 acpi_pnp_type struct packalign=0

00000018 #pragma pack(push, 1)
struct acpi_pptt_cache
{
  acpi_subtable_header header;
  u16 reserved;
  u32 flags;
  u32 next_level_of_cache;
  u32 size;
  u32 number_of_sets;
  u8 associativity;
  u8 attributes;
  u16 line_size;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pptt_cache.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_pptt_cache.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pptt_cache.flags u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_pptt_cache.next_level_of_cache u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_pptt_cache.size u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pptt_cache.number_of_sets u32;
//  6. 0014 0001 effalign(1) fda=0 bits=0000 acpi_pptt_cache.associativity u8;
//  7. 0015 0001 effalign(1) fda=0 bits=0000 acpi_pptt_cache.attributes u8;
//  8. 0016 0002 effalign(2) fda=0 bits=0000 acpi_pptt_cache.line_size u16;
//          0018 effalign(1) sda=0 bits=0000 acpi_pptt_cache struct packalign=1

0000001E #pragma pack(push, 1)
struct acpi_pptt_id
{
  acpi_subtable_header header;
  u16 reserved;
  u32 vendor_id;
  u64 level1_id;
  u64 level2_id;
  u16 major_rev;
  u16 minor_rev;
  u16 spin_rev;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pptt_id.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_pptt_id.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pptt_id.vendor_id u32;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_pptt_id.level1_id u64;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_pptt_id.level2_id u64;
//  5. 0018 0002 effalign(2) fda=0 bits=0000 acpi_pptt_id.major_rev u16;
//  6. 001A 0002 effalign(2) fda=0 bits=0000 acpi_pptt_id.minor_rev u16;
//  7. 001C 0002 effalign(2) fda=0 bits=0000 acpi_pptt_id.spin_rev u16;
//          001E effalign(1) sda=0 bits=0000 acpi_pptt_id struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_pptt_processor
{
  acpi_subtable_header header;
  u16 reserved;
  u32 flags;
  u32 parent;
  u32 acpi_processor_id;
  u32 number_of_priv_resources;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_pptt_processor.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_pptt_processor.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_pptt_processor.flags u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_pptt_processor.parent u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_pptt_processor.acpi_processor_id u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_pptt_processor.number_of_priv_resources u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_pptt_processor struct packalign=1

00000004 enum acpi_pptt_type : unsigned __int32
{
  ACPI_PPTT_TYPE_PROCESSOR = 0x0,
  ACPI_PPTT_TYPE_CACHE = 0x1,
  ACPI_PPTT_TYPE_ID = 0x2,
  ACPI_PPTT_TYPE_RESERVED = 0x3,
};
00000018 struct acpi_predefined_names
{
  const char *name;
  u8 type;
  char *val;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_predefined_names.name const char *;
//  1. 0008 0001 effalign(1) fda=0 bits=0000 acpi_predefined_names.type u8;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_predefined_names.val char *;
//          0018 effalign(8) sda=0 bits=0000 acpi_predefined_names struct packalign=0

00000004 enum acpi_predicate : unsigned __int32
{
  all_versions = 0x0,
  less_than_or_equal = 0x1,
  equal = 0x2,
  greater_than_or_equal = 0x3,
};
00000004 enum acpi_preferred_pm_profiles : unsigned __int32
{
  PM_UNSPECIFIED = 0x0,
  PM_DESKTOP = 0x1,
  PM_MOBILE = 0x2,
  PM_WORKSTATION = 0x3,
  PM_ENTERPRISE_SERVER = 0x4,
  PM_SOHO_SERVER = 0x5,
  PM_APPLIANCE_PC = 0x6,
  PM_PERFORMANCE_SERVER = 0x7,
  PM_TABLET = 0x8,
};
00000020 struct acpi_probe_entry
{
  __u8 id[5];
  __u8 type;
  acpi_probe_entry_validate_subtbl subtable_valid;
  union
  {
    acpi_tbl_table_handler probe_table;
    acpi_tbl_entry_handler probe_subtbl;
  };
  kernel_ulong_t driver_data;
};
//  0. 0000 0005 effalign(1) fda=0 bits=0000 acpi_probe_entry.id __u8[5];
//  1. 0005 0001 effalign(1) fda=0 bits=0000 acpi_probe_entry.type __u8;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_probe_entry.subtable_valid acpi_probe_entry_validate_subtbl;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_probe_entry.acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 acpi_probe_entry.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 acpi_probe_entry struct packalign=0

00000008 union acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC
{
  acpi_tbl_table_handler probe_table;
  acpi_tbl_entry_handler probe_subtbl;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC.probe_table acpi_tbl_table_handler;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC.probe_subtbl acpi_tbl_entry_handler;
//          0008 effalign(8) sda=0 bits=0000 acpi_probe_entry::$812AA370A783E976F4E2370A73988ABC union packalign=0

00000008 typedef bool (__cdecl *acpi_probe_entry_validate_subtbl)(acpi_subtable_header *, acpi_probe_entry *);
00000004 enum acpi_rasf_capabiliities : unsigned __int32
{
  ACPI_HW_PATROL_SCRUB_SUPPORTED = 0x0,
  ACPI_SW_PATROL_SCRUB_EXPOSED = 0x1,
};
00000004 enum acpi_rasf_commands : unsigned __int32
{
  ACPI_RASF_EXECUTE_RASF_COMMAND = 0x1,
};
00000006 #pragma pack(push, 1)
struct acpi_rasf_parameter_block
{
  u16 type;
  u16 version;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_rasf_parameter_block.type u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_rasf_parameter_block.version u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 acpi_rasf_parameter_block.length u16;
//          0006 effalign(1) sda=0 bits=0000 acpi_rasf_parameter_block struct packalign=1

00000004 enum acpi_rasf_patrol_scrub_commands : unsigned __int32
{
  ACPI_RASF_GET_PATROL_PARAMETERS = 0x1,
  ACPI_RASF_START_PATROL_SCRUBBER = 0x2,
  ACPI_RASF_STOP_PATROL_SCRUBBER = 0x3,
};
0000002B #pragma pack(push, 1)
struct acpi_rasf_patrol_scrub_parameter
{
  acpi_rasf_parameter_block header;
  u16 patrol_scrub_command;
  u64 requested_address_range[2];
  u64 actual_address_range[2];
  u16 flags;
  u8 requested_speed;
};
#pragma pack(pop)
//  0. 0000 0006 effalign(1) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.header acpi_rasf_parameter_block;
//  1. 0006 0002 effalign(2) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.patrol_scrub_command u16;
//  2. 0008 0010 effalign(8) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.requested_address_range u64[2];
//  3. 0018 0010 effalign(8) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.actual_address_range u64[2];
//  4. 0028 0002 effalign(2) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.flags u16;
//  5. 002A 0001 effalign(1) fda=0 bits=0000 acpi_rasf_patrol_scrub_parameter.requested_speed u8;
//          002B effalign(1) sda=0 bits=0000 acpi_rasf_patrol_scrub_parameter struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_rasf_shared_memory
{
  u32 signature;
  u16 command;
  u16 status;
  u16 version;
  u8 capabilities[16];
  u8 set_capabilities[16];
  u16 num_parameter_blocks;
  u32 set_capabilities_status;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_rasf_shared_memory.signature u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_rasf_shared_memory.command u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_rasf_shared_memory.status u16;
//  3. 0008 0002 effalign(2) fda=0 bits=0000 acpi_rasf_shared_memory.version u16;
//  4. 000A 0010 effalign(1) fda=0 bits=0000 acpi_rasf_shared_memory.capabilities u8[16];
//  5. 001A 0010 effalign(1) fda=0 bits=0000 acpi_rasf_shared_memory.set_capabilities u8[16];
//  6. 002A 0002 effalign(2) fda=0 bits=0000 acpi_rasf_shared_memory.num_parameter_blocks u16;
//  7. 002C 0004 effalign(4) fda=0 bits=0000 acpi_rasf_shared_memory.set_capabilities_status u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_rasf_shared_memory struct packalign=1

00000004 enum acpi_rasf_status : unsigned __int32
{
  ACPI_RASF_SUCCESS = 0x0,
  ACPI_RASF_NOT_VALID = 0x1,
  ACPI_RASF_NOT_SUPPORTED = 0x2,
  ACPI_RASF_BUSY = 0x3,
  ACPI_RASF_FAILED = 0x4,
  ACPI_RASF_ABORTED = 0x5,
  ACPI_RASF_INVALID_DATA = 0x6,
};
00000004 enum acpi_reconfig_event : unsigned __int32
{
  ACPI_RECONFIG_DEVICE_ADD = 0x0,
  ACPI_RECONFIG_DEVICE_REMOVE = 0x1,
};
00000044 #pragma pack(push, 1)
struct acpi_resource
{
  u32 type;
  u32 length;
  acpi_resource_data data;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_resource.type u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_resource.length u32;
//  2. 0008 003C effalign(1) fda=0 bits=0000 acpi_resource.data acpi_resource_data;
//          0044 effalign(1) sda=0 bits=0000 acpi_resource struct packalign=1

00000009 #pragma pack(push, 1)
struct acpi_resource_address
{
  u8 resource_type;
  u8 producer_consumer;
  u8 decode;
  u8 min_address_fixed;
  u8 max_address_fixed;
  acpi_resource_attribute info;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_address.resource_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_address.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_address.decode u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_address.min_address_fixed u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_address.max_address_fixed u8;
//  5. 0005 0004 effalign(1) fda=0 bits=0000 acpi_resource_address.info acpi_resource_attribute;
//          0009 effalign(1) sda=0 bits=0000 acpi_resource_address struct packalign=1

0000001E #pragma pack(push, 1)
struct acpi_resource_address16
{
  u8 resource_type;
  u8 producer_consumer;
  u8 decode;
  u8 min_address_fixed;
  u8 max_address_fixed;
  acpi_resource_attribute info;
  acpi_address16_attribute address;
  acpi_resource_source resource_source;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_address16.resource_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_address16.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_address16.decode u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_address16.min_address_fixed u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_address16.max_address_fixed u8;
//  5. 0005 0004 effalign(1) fda=0 bits=0000 acpi_resource_address16.info acpi_resource_attribute;
//  6. 0009 000A effalign(1) fda=0 bits=0000 acpi_resource_address16.address acpi_address16_attribute;
//  7. 0013 000B effalign(1) fda=0 bits=0000 acpi_resource_address16.resource_source acpi_resource_source;
//          001E effalign(1) sda=0 bits=0000 acpi_resource_address16 struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_resource_address32
{
  u8 resource_type;
  u8 producer_consumer;
  u8 decode;
  u8 min_address_fixed;
  u8 max_address_fixed;
  acpi_resource_attribute info;
  acpi_address32_attribute address;
  acpi_resource_source resource_source;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_address32.resource_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_address32.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_address32.decode u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_address32.min_address_fixed u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_address32.max_address_fixed u8;
//  5. 0005 0004 effalign(1) fda=0 bits=0000 acpi_resource_address32.info acpi_resource_attribute;
//  6. 0009 0014 effalign(1) fda=0 bits=0000 acpi_resource_address32.address acpi_address32_attribute;
//  7. 001D 000B effalign(1) fda=0 bits=0000 acpi_resource_address32.resource_source acpi_resource_source;
//          0028 effalign(1) sda=0 bits=0000 acpi_resource_address32 struct packalign=1

0000003C #pragma pack(push, 1)
struct acpi_resource_address64
{
  u8 resource_type;
  u8 producer_consumer;
  u8 decode;
  u8 min_address_fixed;
  u8 max_address_fixed;
  acpi_resource_attribute info;
  acpi_address64_attribute address;
  acpi_resource_source resource_source;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_address64.resource_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_address64.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_address64.decode u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_address64.min_address_fixed u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_address64.max_address_fixed u8;
//  5. 0005 0004 effalign(1) fda=0 bits=0000 acpi_resource_address64.info acpi_resource_attribute;
//  6. 0009 0028 effalign(1) fda=0 bits=0000 acpi_resource_address64.address acpi_address64_attribute;
//  7. 0031 000B effalign(1) fda=0 bits=0000 acpi_resource_address64.resource_source acpi_resource_source;
//          003C effalign(1) sda=0 bits=0000 acpi_resource_address64 struct packalign=1

00000004 #pragma pack(push, 1)
union acpi_resource_attribute
{
  acpi_memory_attribute mem;
  acpi_io_attribute io;
  u8 type_specific;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_resource_attribute.mem acpi_memory_attribute;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 acpi_resource_attribute.io acpi_io_attribute;
//  2. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_attribute.type_specific u8;
//          0004 effalign(1) sda=0 bits=0000 acpi_resource_attribute union packalign=1

0000001D #pragma pack(push, 1)
struct acpi_resource_common_serialbus
{
  u8 revision_id;
  u8 type;
  u8 producer_consumer;
  u8 slave_mode;
  u8 connection_sharing;
  u8 type_revision_id;
  u16 type_data_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.type u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.producer_consumer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.slave_mode u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.connection_sharing u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.type_revision_id u8;
//  6. 0006 0002 effalign(2) fda=0 bits=0000 acpi_resource_common_serialbus.type_data_length u16;
//  7. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_common_serialbus.vendor_length u16;
//  8. 000A 000B effalign(1) fda=0 bits=0000 acpi_resource_common_serialbus.resource_source acpi_resource_source;
//  9. 0015 0008 effalign(8) fda=0 bits=0000 acpi_resource_common_serialbus.vendor_data u8 *;
//          001D effalign(1) sda=0 bits=0000 acpi_resource_common_serialbus struct packalign=1

0000003C #pragma pack(push, 1)
union acpi_resource_data
{
  acpi_resource_irq irq;
  acpi_resource_dma dma;
  acpi_resource_start_dependent start_dpf;
  acpi_resource_io io;
  acpi_resource_fixed_io fixed_io;
  acpi_resource_fixed_dma fixed_dma;
  acpi_resource_vendor vendor;
  acpi_resource_vendor_typed vendor_typed;
  acpi_resource_end_tag end_tag;
  acpi_resource_memory24 memory24;
  acpi_resource_memory32 memory32;
  acpi_resource_fixed_memory32 fixed_memory32;
  acpi_resource_address16 address16;
  acpi_resource_address32 address32;
  acpi_resource_address64 address64;
  acpi_resource_extended_address64 ext_address64;
  acpi_resource_extended_irq extended_irq;
  acpi_resource_generic_register generic_reg;
  acpi_resource_gpio gpio;
  acpi_resource_i2c_serialbus i2c_serial_bus;
  acpi_resource_spi_serialbus spi_serial_bus;
  acpi_resource_uart_serialbus uart_serial_bus;
  acpi_resource_common_serialbus common_serial_bus;
  acpi_resource_pin_function pin_function;
  acpi_resource_pin_config pin_config;
  acpi_resource_pin_group pin_group;
  acpi_resource_pin_group_function pin_group_function;
  acpi_resource_pin_group_config pin_group_config;
  acpi_resource_address address;
};
#pragma pack(pop)
//  0. 0000 0007 effalign(1) fda=0 bits=0000 acpi_resource_data.irq acpi_resource_irq;
//  1. 0000 0005 effalign(1) fda=0 bits=0000 acpi_resource_data.dma acpi_resource_dma;
//  2. 0000 0003 effalign(1) fda=0 bits=0000 acpi_resource_data.start_dpf acpi_resource_start_dependent;
//  3. 0000 0007 effalign(1) fda=0 bits=0000 acpi_resource_data.io acpi_resource_io;
//  4. 0000 0003 effalign(1) fda=0 bits=0000 acpi_resource_data.fixed_io acpi_resource_fixed_io;
//  5. 0000 0005 effalign(1) fda=0 bits=0000 acpi_resource_data.fixed_dma acpi_resource_fixed_dma;
//  6. 0000 0003 effalign(1) fda=0 bits=0000 acpi_resource_data.vendor acpi_resource_vendor;
//  7. 0000 0014 effalign(1) fda=0 bits=0000 acpi_resource_data.vendor_typed acpi_resource_vendor_typed;
//  8. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_data.end_tag acpi_resource_end_tag;
//  9. 0000 0009 effalign(1) fda=0 bits=0000 acpi_resource_data.memory24 acpi_resource_memory24;
// 10. 0000 0011 effalign(1) fda=0 bits=0000 acpi_resource_data.memory32 acpi_resource_memory32;
// 11. 0000 0009 effalign(1) fda=0 bits=0000 acpi_resource_data.fixed_memory32 acpi_resource_fixed_memory32;
// 12. 0000 001E effalign(1) fda=0 bits=0000 acpi_resource_data.address16 acpi_resource_address16;
// 13. 0000 0028 effalign(1) fda=0 bits=0000 acpi_resource_data.address32 acpi_resource_address32;
// 14. 0000 003C effalign(1) fda=0 bits=0000 acpi_resource_data.address64 acpi_resource_address64;
// 15. 0000 003A effalign(1) fda=0 bits=0000 acpi_resource_data.ext_address64 acpi_resource_extended_address64;
// 16. 0000 0015 effalign(1) fda=0 bits=0000 acpi_resource_data.extended_irq acpi_resource_extended_irq;
// 17. 0000 000C effalign(1) fda=0 bits=0000 acpi_resource_data.generic_reg acpi_resource_generic_register;
// 18. 0000 002C effalign(1) fda=0 bits=0000 acpi_resource_data.gpio acpi_resource_gpio;
// 19. 0000 0024 effalign(1) fda=0 bits=0000 acpi_resource_data.i2c_serial_bus acpi_resource_i2c_serialbus;
// 20. 0000 0028 effalign(1) fda=0 bits=0000 acpi_resource_data.spi_serial_bus acpi_resource_spi_serialbus;
// 21. 0000 002B effalign(1) fda=0 bits=0000 acpi_resource_data.uart_serial_bus acpi_resource_uart_serialbus;
// 22. 0000 001D effalign(1) fda=0 bits=0000 acpi_resource_data.common_serial_bus acpi_resource_common_serialbus;
// 23. 0000 0024 effalign(1) fda=0 bits=0000 acpi_resource_data.pin_function acpi_resource_pin_function;
// 24. 0000 0027 effalign(1) fda=0 bits=0000 acpi_resource_data.pin_config acpi_resource_pin_config;
// 25. 0000 0020 effalign(1) fda=0 bits=0000 acpi_resource_data.pin_group acpi_resource_pin_group;
// 26. 0000 0024 effalign(1) fda=0 bits=0000 acpi_resource_data.pin_group_function acpi_resource_pin_group_function;
// 27. 0000 0027 effalign(1) fda=0 bits=0000 acpi_resource_data.pin_group_config acpi_resource_pin_group_config;
// 28. 0000 0009 effalign(1) fda=0 bits=0000 acpi_resource_data.address acpi_resource_address;
//          003C effalign(1) sda=0 bits=0000 acpi_resource_data union packalign=1

00000005 #pragma pack(push, 1)
struct acpi_resource_dma
{
  u8 type;
  u8 bus_master;
  u8 transfer;
  u8 channel_count;
  u8 channels[1];
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_dma.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_dma.bus_master u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_dma.transfer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_dma.channel_count u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_dma.channels u8[1];
//          0005 effalign(1) sda=0 bits=0000 acpi_resource_dma struct packalign=1

00000001 #pragma pack(push, 1)
struct acpi_resource_end_tag
{
  u8 checksum;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_end_tag.checksum u8;
//          0001 effalign(1) sda=0 bits=0000 acpi_resource_end_tag struct packalign=1

0000003A #pragma pack(push, 1)
struct acpi_resource_extended_address64
{
  u8 resource_type;
  u8 producer_consumer;
  u8 decode;
  u8 min_address_fixed;
  u8 max_address_fixed;
  acpi_resource_attribute info;
  u8 revision_ID;
  acpi_address64_attribute address;
  u64 type_specific;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.resource_type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.decode u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.min_address_fixed u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.max_address_fixed u8;
//  5. 0005 0004 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.info acpi_resource_attribute;
//  6. 0009 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.revision_ID u8;
//  7. 000A 0028 effalign(1) fda=0 bits=0000 acpi_resource_extended_address64.address acpi_address64_attribute;
//  8. 0032 0008 effalign(8) fda=0 bits=0000 acpi_resource_extended_address64.type_specific u64;
//          003A effalign(1) sda=0 bits=0000 acpi_resource_extended_address64 struct packalign=1

00000015 #pragma pack(push, 1)
struct acpi_resource_extended_irq
{
  u8 producer_consumer;
  u8 triggering;
  u8 polarity;
  u8 shareable;
  u8 wake_capable;
  u8 interrupt_count;
  acpi_resource_source resource_source;
  u32 interrupts[1];
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.producer_consumer u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.triggering u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.polarity u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.shareable u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.wake_capable u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.interrupt_count u8;
//  6. 0006 000B effalign(1) fda=0 bits=0000 acpi_resource_extended_irq.resource_source acpi_resource_source;
//  7. 0011 0004 effalign(4) fda=0 bits=0000 acpi_resource_extended_irq.interrupts u32[1];
//          0015 effalign(1) sda=0 bits=0000 acpi_resource_extended_irq struct packalign=1

00000005 #pragma pack(push, 1)
struct acpi_resource_fixed_dma
{
  u16 request_lines;
  u16 channels;
  u8 width;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_resource_fixed_dma.request_lines u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_resource_fixed_dma.channels u16;
//  2. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_fixed_dma.width u8;
//          0005 effalign(1) sda=0 bits=0000 acpi_resource_fixed_dma struct packalign=1

00000003 #pragma pack(push, 1)
struct acpi_resource_fixed_io
{
  u16 address;
  u8 address_length;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_resource_fixed_io.address u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_fixed_io.address_length u8;
//          0003 effalign(1) sda=0 bits=0000 acpi_resource_fixed_io struct packalign=1

00000009 #pragma pack(push, 1)
struct acpi_resource_fixed_memory32
{
  u8 write_protect;
  u32 address;
  u32 address_length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_fixed_memory32.write_protect u8;
//  1. 0001 0004 effalign(4) fda=0 bits=0000 acpi_resource_fixed_memory32.address u32;
//  2. 0005 0004 effalign(4) fda=0 bits=0000 acpi_resource_fixed_memory32.address_length u32;
//          0009 effalign(1) sda=0 bits=0000 acpi_resource_fixed_memory32 struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_resource_generic_register
{
  u8 space_id;
  u8 bit_width;
  u8 bit_offset;
  u8 access_size;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_generic_register.space_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_generic_register.bit_width u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_generic_register.bit_offset u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_generic_register.access_size u8;
//  4. 0004 0008 effalign(8) fda=0 bits=0000 acpi_resource_generic_register.address u64;
//          000C effalign(1) sda=0 bits=0000 acpi_resource_generic_register struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_resource_gpio
{
  u8 revision_id;
  u8 connection_type;
  u8 producer_consumer;
  u8 pin_config;
  u8 shareable;
  u8 wake_capable;
  u8 io_restriction;
  u8 triggering;
  u8 polarity;
  u16 drive_strength;
  u16 debounce_timeout;
  u16 pin_table_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u16 *pin_table;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.connection_type u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.producer_consumer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.pin_config u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.shareable u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.wake_capable u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.io_restriction u8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.triggering u8;
//  8. 0008 0001 effalign(1) fda=0 bits=0000 acpi_resource_gpio.polarity u8;
//  9. 0009 0002 effalign(2) fda=0 bits=0000 acpi_resource_gpio.drive_strength u16;
// 10. 000B 0002 effalign(2) fda=0 bits=0000 acpi_resource_gpio.debounce_timeout u16;
// 11. 000D 0002 effalign(2) fda=0 bits=0000 acpi_resource_gpio.pin_table_length u16;
// 12. 000F 0002 effalign(2) fda=0 bits=0000 acpi_resource_gpio.vendor_length u16;
// 13. 0011 000B effalign(1) fda=0 bits=0000 acpi_resource_gpio.resource_source acpi_resource_source;
// 14. 001C 0008 effalign(8) fda=0 bits=0000 acpi_resource_gpio.pin_table u16 *;
// 15. 0024 0008 effalign(8) fda=0 bits=0000 acpi_resource_gpio.vendor_data u8 *;
//          002C effalign(1) sda=0 bits=0000 acpi_resource_gpio struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_resource_i2c_serialbus
{
  u8 revision_id;
  u8 type;
  u8 producer_consumer;
  u8 slave_mode;
  u8 connection_sharing;
  u8 type_revision_id;
  u16 type_data_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u8 *vendor_data;
  u8 access_mode;
  u16 slave_address;
  u32 connection_speed;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.type u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.producer_consumer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.slave_mode u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.connection_sharing u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.type_revision_id u8;
//  6. 0006 0002 effalign(2) fda=0 bits=0000 acpi_resource_i2c_serialbus.type_data_length u16;
//  7. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_i2c_serialbus.vendor_length u16;
//  8. 000A 000B effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.resource_source acpi_resource_source;
//  9. 0015 0008 effalign(8) fda=0 bits=0000 acpi_resource_i2c_serialbus.vendor_data u8 *;
// 10. 001D 0001 effalign(1) fda=0 bits=0000 acpi_resource_i2c_serialbus.access_mode u8;
// 11. 001E 0002 effalign(2) fda=0 bits=0000 acpi_resource_i2c_serialbus.slave_address u16;
// 12. 0020 0004 effalign(4) fda=0 bits=0000 acpi_resource_i2c_serialbus.connection_speed u32;
//          0024 effalign(1) sda=0 bits=0000 acpi_resource_i2c_serialbus struct packalign=1

00000007 #pragma pack(push, 1)
struct acpi_resource_io
{
  u8 io_decode;
  u8 alignment;
  u8 address_length;
  u16 minimum;
  u16 maximum;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_io.io_decode u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_io.alignment u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_io.address_length u8;
//  3. 0003 0002 effalign(2) fda=0 bits=0000 acpi_resource_io.minimum u16;
//  4. 0005 0002 effalign(2) fda=0 bits=0000 acpi_resource_io.maximum u16;
//          0007 effalign(1) sda=0 bits=0000 acpi_resource_io struct packalign=1

00000007 #pragma pack(push, 1)
struct acpi_resource_irq
{
  u8 descriptor_length;
  u8 triggering;
  u8 polarity;
  u8 shareable;
  u8 wake_capable;
  u8 interrupt_count;
  u8 interrupts[1];
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.descriptor_length u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.triggering u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.polarity u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.shareable u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.wake_capable u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.interrupt_count u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 acpi_resource_irq.interrupts u8[1];
//          0007 effalign(1) sda=0 bits=0000 acpi_resource_irq struct packalign=1

0000000A #pragma pack(push, 1)
struct acpi_resource_label
{
  u16 string_length;
  char *string_ptr;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_resource_label.string_length u16;
//  1. 0002 0008 effalign(8) fda=0 bits=0000 acpi_resource_label.string_ptr char *;
//          000A effalign(1) sda=0 bits=0000 acpi_resource_label struct packalign=1

00000009 #pragma pack(push, 1)
struct acpi_resource_memory24
{
  u8 write_protect;
  u16 minimum;
  u16 maximum;
  u16 alignment;
  u16 address_length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_memory24.write_protect u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_resource_memory24.minimum u16;
//  2. 0003 0002 effalign(2) fda=0 bits=0000 acpi_resource_memory24.maximum u16;
//  3. 0005 0002 effalign(2) fda=0 bits=0000 acpi_resource_memory24.alignment u16;
//  4. 0007 0002 effalign(2) fda=0 bits=0000 acpi_resource_memory24.address_length u16;
//          0009 effalign(1) sda=0 bits=0000 acpi_resource_memory24 struct packalign=1

00000011 #pragma pack(push, 1)
struct acpi_resource_memory32
{
  u8 write_protect;
  u32 minimum;
  u32 maximum;
  u32 alignment;
  u32 address_length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_memory32.write_protect u8;
//  1. 0001 0004 effalign(4) fda=0 bits=0000 acpi_resource_memory32.minimum u32;
//  2. 0005 0004 effalign(4) fda=0 bits=0000 acpi_resource_memory32.maximum u32;
//  3. 0009 0004 effalign(4) fda=0 bits=0000 acpi_resource_memory32.alignment u32;
//  4. 000D 0004 effalign(4) fda=0 bits=0000 acpi_resource_memory32.address_length u32;
//          0011 effalign(1) sda=0 bits=0000 acpi_resource_memory32 struct packalign=1

00000027 #pragma pack(push, 1)
struct acpi_resource_pin_config
{
  u8 revision_id;
  u8 producer_consumer;
  u8 shareable;
  u8 pin_config_type;
  u32 pin_config_value;
  u16 pin_table_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u16 *pin_table;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_config.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_config.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_config.shareable u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_config.pin_config_type u8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 acpi_resource_pin_config.pin_config_value u32;
//  5. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_config.pin_table_length u16;
//  6. 000A 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_config.vendor_length u16;
//  7. 000C 000B effalign(1) fda=0 bits=0000 acpi_resource_pin_config.resource_source acpi_resource_source;
//  8. 0017 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_config.pin_table u16 *;
//  9. 001F 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_config.vendor_data u8 *;
//          0027 effalign(1) sda=0 bits=0000 acpi_resource_pin_config struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_resource_pin_function
{
  u8 revision_id;
  u8 pin_config;
  u8 shareable;
  u16 function_number;
  u16 pin_table_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u16 *pin_table;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_function.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_function.pin_config u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_function.shareable u8;
//  3. 0003 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_function.function_number u16;
//  4. 0005 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_function.pin_table_length u16;
//  5. 0007 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_function.vendor_length u16;
//  6. 0009 000B effalign(1) fda=0 bits=0000 acpi_resource_pin_function.resource_source acpi_resource_source;
//  7. 0014 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_function.pin_table u16 *;
//  8. 001C 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_function.vendor_data u8 *;
//          0024 effalign(1) sda=0 bits=0000 acpi_resource_pin_function struct packalign=1

00000020 #pragma pack(push, 1)
struct acpi_resource_pin_group
{
  u8 revision_id;
  u8 producer_consumer;
  u16 pin_table_length;
  u16 vendor_length;
  u16 *pin_table;
  acpi_resource_label resource_label;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group.producer_consumer u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_group.pin_table_length u16;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_group.vendor_length u16;
//  4. 0006 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_group.pin_table u16 *;
//  5. 000E 000A effalign(1) fda=0 bits=0000 acpi_resource_pin_group.resource_label acpi_resource_label;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_group.vendor_data u8 *;
//          0020 effalign(1) sda=0 bits=0000 acpi_resource_pin_group struct packalign=1

00000027 #pragma pack(push, 1)
struct acpi_resource_pin_group_config
{
  u8 revision_id;
  u8 producer_consumer;
  u8 shareable;
  u8 pin_config_type;
  u32 pin_config_value;
  u16 vendor_length;
  acpi_resource_source resource_source;
  acpi_resource_label resource_source_label;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.shareable u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.pin_config_type u8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 acpi_resource_pin_group_config.pin_config_value u32;
//  5. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_group_config.vendor_length u16;
//  6. 000A 000B effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.resource_source acpi_resource_source;
//  7. 0015 000A effalign(1) fda=0 bits=0000 acpi_resource_pin_group_config.resource_source_label acpi_resource_label;
//  8. 001F 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_group_config.vendor_data u8 *;
//          0027 effalign(1) sda=0 bits=0000 acpi_resource_pin_group_config struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_resource_pin_group_function
{
  u8 revision_id;
  u8 producer_consumer;
  u8 shareable;
  u16 function_number;
  u16 vendor_length;
  acpi_resource_source resource_source;
  acpi_resource_label resource_source_label;
  u8 *vendor_data;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_function.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_function.producer_consumer u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_pin_group_function.shareable u8;
//  3. 0003 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_group_function.function_number u16;
//  4. 0005 0002 effalign(2) fda=0 bits=0000 acpi_resource_pin_group_function.vendor_length u16;
//  5. 0007 000B effalign(1) fda=0 bits=0000 acpi_resource_pin_group_function.resource_source acpi_resource_source;
//  6. 0012 000A effalign(1) fda=0 bits=0000 acpi_resource_pin_group_function.resource_source_label acpi_resource_label;
//  7. 001C 0008 effalign(8) fda=0 bits=0000 acpi_resource_pin_group_function.vendor_data u8 *;
//          0024 effalign(1) sda=0 bits=0000 acpi_resource_pin_group_function struct packalign=1

0000000B #pragma pack(push, 1)
struct acpi_resource_source
{
  u8 index;
  u16 string_length;
  char *string_ptr;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_source.index u8;
//  1. 0001 0002 effalign(2) fda=0 bits=0000 acpi_resource_source.string_length u16;
//  2. 0003 0008 effalign(8) fda=0 bits=0000 acpi_resource_source.string_ptr char *;
//          000B effalign(1) sda=0 bits=0000 acpi_resource_source struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_resource_spi_serialbus
{
  u8 revision_id;
  u8 type;
  u8 producer_consumer;
  u8 slave_mode;
  u8 connection_sharing;
  u8 type_revision_id;
  u16 type_data_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u8 *vendor_data;
  u8 wire_mode;
  u8 device_polarity;
  u8 data_bit_length;
  u8 clock_phase;
  u8 clock_polarity;
  u16 device_selection;
  u32 connection_speed;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.type u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.producer_consumer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.slave_mode u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.connection_sharing u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.type_revision_id u8;
//  6. 0006 0002 effalign(2) fda=0 bits=0000 acpi_resource_spi_serialbus.type_data_length u16;
//  7. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_spi_serialbus.vendor_length u16;
//  8. 000A 000B effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.resource_source acpi_resource_source;
//  9. 0015 0008 effalign(8) fda=0 bits=0000 acpi_resource_spi_serialbus.vendor_data u8 *;
// 10. 001D 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.wire_mode u8;
// 11. 001E 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.device_polarity u8;
// 12. 001F 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.data_bit_length u8;
// 13. 0020 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.clock_phase u8;
// 14. 0021 0001 effalign(1) fda=0 bits=0000 acpi_resource_spi_serialbus.clock_polarity u8;
// 15. 0022 0002 effalign(2) fda=0 bits=0000 acpi_resource_spi_serialbus.device_selection u16;
// 16. 0024 0004 effalign(4) fda=0 bits=0000 acpi_resource_spi_serialbus.connection_speed u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_resource_spi_serialbus struct packalign=1

00000003 #pragma pack(push, 1)
struct acpi_resource_start_dependent
{
  u8 descriptor_length;
  u8 compatibility_priority;
  u8 performance_robustness;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_start_dependent.descriptor_length u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_start_dependent.compatibility_priority u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_start_dependent.performance_robustness u8;
//          0003 effalign(1) sda=0 bits=0000 acpi_resource_start_dependent struct packalign=1

0000002B #pragma pack(push, 1)
struct acpi_resource_uart_serialbus
{
  u8 revision_id;
  u8 type;
  u8 producer_consumer;
  u8 slave_mode;
  u8 connection_sharing;
  u8 type_revision_id;
  u16 type_data_length;
  u16 vendor_length;
  acpi_resource_source resource_source;
  u8 *vendor_data;
  u8 endian;
  u8 data_bits;
  u8 stop_bits;
  u8 flow_control;
  u8 parity;
  u8 lines_enabled;
  u16 rx_fifo_size;
  u16 tx_fifo_size;
  u32 default_baud_rate;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.revision_id u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.type u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.producer_consumer u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.slave_mode u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.connection_sharing u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.type_revision_id u8;
//  6. 0006 0002 effalign(2) fda=0 bits=0000 acpi_resource_uart_serialbus.type_data_length u16;
//  7. 0008 0002 effalign(2) fda=0 bits=0000 acpi_resource_uart_serialbus.vendor_length u16;
//  8. 000A 000B effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.resource_source acpi_resource_source;
//  9. 0015 0008 effalign(8) fda=0 bits=0000 acpi_resource_uart_serialbus.vendor_data u8 *;
// 10. 001D 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.endian u8;
// 11. 001E 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.data_bits u8;
// 12. 001F 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.stop_bits u8;
// 13. 0020 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.flow_control u8;
// 14. 0021 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.parity u8;
// 15. 0022 0001 effalign(1) fda=0 bits=0000 acpi_resource_uart_serialbus.lines_enabled u8;
// 16. 0023 0002 effalign(2) fda=0 bits=0000 acpi_resource_uart_serialbus.rx_fifo_size u16;
// 17. 0025 0002 effalign(2) fda=0 bits=0000 acpi_resource_uart_serialbus.tx_fifo_size u16;
// 18. 0027 0004 effalign(4) fda=0 bits=0000 acpi_resource_uart_serialbus.default_baud_rate u32;
//          002B effalign(1) sda=0 bits=0000 acpi_resource_uart_serialbus struct packalign=1

00000003 #pragma pack(push, 1)
struct acpi_resource_vendor
{
  u16 byte_length;
  u8 byte_data[1];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_resource_vendor.byte_length u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_vendor.byte_data u8[1];
//          0003 effalign(1) sda=0 bits=0000 acpi_resource_vendor struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_resource_vendor_typed
{
  u16 byte_length;
  u8 uuid_subtype;
  u8 uuid[16];
  u8 byte_data[1];
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_resource_vendor_typed.byte_length u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_resource_vendor_typed.uuid_subtype u8;
//  2. 0003 0010 effalign(1) fda=0 bits=0000 acpi_resource_vendor_typed.uuid u8[16];
//  3. 0013 0001 effalign(1) fda=0 bits=0000 acpi_resource_vendor_typed.byte_data u8[1];
//          0014 effalign(1) sda=0 bits=0000 acpi_resource_vendor_typed struct packalign=1

00000002 typedef u16 acpi_rs_length;
00000004 typedef u32 acpi_rsdesc_size;
00000014 #pragma pack(push, 1)
struct acpi_rsdp_common
{
  char signature[8];
  u8 checksum;
  char oem_id[6];
  u8 revision;
  u32 rsdt_physical_address;
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_rsdp_common.signature char[8];
//  1. 0008 0001 effalign(1) fda=0 bits=0000 acpi_rsdp_common.checksum u8;
//  2. 0009 0006 effalign(1) fda=0 bits=0000 acpi_rsdp_common.oem_id char[6];
//  3. 000F 0001 effalign(1) fda=0 bits=0000 acpi_rsdp_common.revision u8;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_rsdp_common.rsdt_physical_address u32;
//          0014 effalign(1) sda=0 bits=0000 acpi_rsdp_common struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_rsdp_extension
{
  u32 length;
  u64 xsdt_physical_address;
  u8 extended_checksum;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_rsdp_extension.length u32;
//  1. 0004 0008 effalign(8) fda=0 bits=0000 acpi_rsdp_extension.xsdt_physical_address u64;
//  2. 000C 0001 effalign(1) fda=0 bits=0000 acpi_rsdp_extension.extended_checksum u8;
//  3. 000D 0003 effalign(1) fda=0 bits=0000 acpi_rsdp_extension.reserved u8[3];
//          0010 effalign(1) sda=0 bits=0000 acpi_rsdp_extension struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_s3pt_resume
{
  acpi_fpdt_header header;
  u32 resume_count;
  u64 full_resume;
  u64 average_resume;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_s3pt_resume.header acpi_fpdt_header;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_s3pt_resume.resume_count u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 acpi_s3pt_resume.full_resume u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 acpi_s3pt_resume.average_resume u64;
//          0018 effalign(1) sda=0 bits=0000 acpi_s3pt_resume struct packalign=1

00000014 #pragma pack(push, 1)
struct acpi_s3pt_suspend
{
  acpi_fpdt_header header;
  u64 suspend_start;
  u64 suspend_end;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_s3pt_suspend.header acpi_fpdt_header;
//  1. 0004 0008 effalign(8) fda=0 bits=0000 acpi_s3pt_suspend.suspend_start u64;
//  2. 000C 0008 effalign(8) fda=0 bits=0000 acpi_s3pt_suspend.suspend_end u64;
//          0014 effalign(1) sda=0 bits=0000 acpi_s3pt_suspend struct packalign=1

00000004 enum acpi_s3pt_type : unsigned __int32
{
  ACPI_S3PT_TYPE_RESUME = 0x0,
  ACPI_S3PT_TYPE_SUSPEND = 0x1,
  ACPI_FPDT_BOOT_PERFORMANCE = 0x2,
};
00000098 struct acpi_scan_handler
{
  const acpi_device_id *ids;
  list_head list_node;
  bool (__cdecl *match)(const char *, const acpi_device_id **);
  int (__cdecl *attach)(acpi_device *, const acpi_device_id *);
  void (__cdecl *detach)(acpi_device *);
  void (__cdecl *bind)(device *);
  void (__cdecl *unbind)(device *);
  acpi_hotplug_profile hotplug;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.ids const acpi_device_id *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 acpi_scan_handler.list_node list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.match bool (__cdecl *)(const char *, const acpi_device_id **);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.attach int (__cdecl *)(acpi_device *, const acpi_device_id *);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.detach void (__cdecl *)(acpi_device *);
//  5. 0030 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.bind void (__cdecl *)(device *);
//  6. 0038 0008 effalign(8) fda=0 bits=0000 acpi_scan_handler.unbind void (__cdecl *)(device *);
//  7. 0040 0058 effalign(8) fda=0 bits=0000 acpi_scan_handler.hotplug acpi_hotplug_profile;
//          0091 unpadded_size
//          0098 effalign(8) sda=0 bits=0000 acpi_scan_handler struct packalign=0

00000008 typedef u32 (__cdecl *acpi_sci_handler)(void *);
00000004 #pragma pack(push, 1)
struct acpi_sdev_header
{
  u8 type;
  u8 flags;
  u16 length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_sdev_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_sdev_header.flags u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_sdev_header.length u16;
//          0004 effalign(1) sda=0 bits=0000 acpi_sdev_header struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_sdev_namespace
{
  acpi_sdev_header header;
  u16 device_id_offset;
  u16 device_id_length;
  u16 vendor_data_offset;
  u16 vendor_data_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_sdev_namespace.header acpi_sdev_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_sdev_namespace.device_id_offset u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_sdev_namespace.device_id_length u16;
//  3. 0008 0002 effalign(2) fda=0 bits=0000 acpi_sdev_namespace.vendor_data_offset u16;
//  4. 000A 0002 effalign(2) fda=0 bits=0000 acpi_sdev_namespace.vendor_data_length u16;
//          000C effalign(1) sda=0 bits=0000 acpi_sdev_namespace struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_sdev_pcie
{
  acpi_sdev_header header;
  u16 segment;
  u16 start_bus;
  u16 path_offset;
  u16 path_length;
  u16 vendor_data_offset;
  u16 vendor_data_length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_sdev_pcie.header acpi_sdev_header;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.segment u16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.start_bus u16;
//  3. 0008 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.path_offset u16;
//  4. 000A 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.path_length u16;
//  5. 000C 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.vendor_data_offset u16;
//  6. 000E 0002 effalign(2) fda=0 bits=0000 acpi_sdev_pcie.vendor_data_length u16;
//          0010 effalign(1) sda=0 bits=0000 acpi_sdev_pcie struct packalign=1

00000002 #pragma pack(push, 1)
struct acpi_sdev_pcie_path
{
  u8 device;
  u8 function;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_sdev_pcie_path.device u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_sdev_pcie_path.function u8;
//          0002 effalign(1) sda=0 bits=0000 acpi_sdev_pcie_path struct packalign=1

00000004 enum acpi_sdev_type : unsigned __int32
{
  ACPI_SDEV_TYPE_NAMESPACE_DEVICE = 0x0,
  ACPI_SDEV_TYPE_PCIE_ENDPOINT_DEVICE = 0x1,
  ACPI_SDEV_TYPE_RESERVED = 0x2,
};
0000000C struct acpi_signal_fatal_info
{
  u32 type;
  u32 code;
  u32 argument;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_signal_fatal_info.type u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_signal_fatal_info.code u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_signal_fatal_info.argument u32;
//          000C effalign(4) sda=0 bits=0000 acpi_signal_fatal_info struct packalign=0

00000008 typedef u64 acpi_size;
00000004 enum acpi_spmi_interface_types : unsigned __int32
{
  ACPI_SPMI_NOT_USED = 0x0,
  ACPI_SPMI_KEYBOARD = 0x1,
  ACPI_SPMI_SMI = 0x2,
  ACPI_SPMI_BLOCK_TRANSFER = 0x3,
  ACPI_SPMI_SMBUS = 0x4,
  ACPI_SPMI_RESERVED = 0x5,
};
00000010 #pragma pack(push, 1)
struct acpi_srat_cpu_affinity
{
  acpi_subtable_header header;
  u8 proximity_domain_lo;
  u8 apic_id;
  u32 flags;
  u8 local_sapic_eid;
  u8 proximity_domain_hi[3];
  u32 clock_domain;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_cpu_affinity.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_srat_cpu_affinity.proximity_domain_lo u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_srat_cpu_affinity.apic_id u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_srat_cpu_affinity.flags u32;
//  4. 0008 0001 effalign(1) fda=0 bits=0000 acpi_srat_cpu_affinity.local_sapic_eid u8;
//  5. 0009 0003 effalign(1) fda=0 bits=0000 acpi_srat_cpu_affinity.proximity_domain_hi u8[3];
//  6. 000C 0004 effalign(4) fda=0 bits=0000 acpi_srat_cpu_affinity.clock_domain u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_srat_cpu_affinity struct packalign=1

00000020 #pragma pack(push, 1)
struct acpi_srat_generic_affinity
{
  acpi_subtable_header header;
  u8 reserved;
  u8 device_handle_type;
  u32 proximity_domain;
  u8 device_handle[16];
  u32 flags;
  u32 reserved1;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_generic_affinity.header acpi_subtable_header;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 acpi_srat_generic_affinity.reserved u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 acpi_srat_generic_affinity.device_handle_type u8;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 acpi_srat_generic_affinity.proximity_domain u32;
//  4. 0008 0010 effalign(1) fda=0 bits=0000 acpi_srat_generic_affinity.device_handle u8[16];
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_srat_generic_affinity.flags u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 acpi_srat_generic_affinity.reserved1 u32;
//          0020 effalign(1) sda=0 bits=0000 acpi_srat_generic_affinity struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_srat_gic_its_affinity
{
  acpi_subtable_header header;
  u32 proximity_domain;
  u16 reserved;
  u32 its_id;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_gic_its_affinity.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_srat_gic_its_affinity.proximity_domain u32;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_srat_gic_its_affinity.reserved u16;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_srat_gic_its_affinity.its_id u32;
//          000C effalign(1) sda=0 bits=0000 acpi_srat_gic_its_affinity struct packalign=1

00000012 #pragma pack(push, 1)
struct acpi_srat_gicc_affinity
{
  acpi_subtable_header header;
  u32 proximity_domain;
  u32 acpi_processor_uid;
  u32 flags;
  u32 clock_domain;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_gicc_affinity.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_srat_gicc_affinity.proximity_domain u32;
//  2. 0006 0004 effalign(4) fda=0 bits=0000 acpi_srat_gicc_affinity.acpi_processor_uid u32;
//  3. 000A 0004 effalign(4) fda=0 bits=0000 acpi_srat_gicc_affinity.flags u32;
//  4. 000E 0004 effalign(4) fda=0 bits=0000 acpi_srat_gicc_affinity.clock_domain u32;
//          0012 effalign(1) sda=0 bits=0000 acpi_srat_gicc_affinity struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_srat_mem_affinity
{
  acpi_subtable_header header;
  u32 proximity_domain;
  u16 reserved;
  u64 base_address;
  u64 length;
  u32 reserved1;
  u32 flags;
  u64 reserved2;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_mem_affinity.header acpi_subtable_header;
//  1. 0002 0004 effalign(4) fda=0 bits=0000 acpi_srat_mem_affinity.proximity_domain u32;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 acpi_srat_mem_affinity.reserved u16;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 acpi_srat_mem_affinity.base_address u64;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 acpi_srat_mem_affinity.length u64;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 acpi_srat_mem_affinity.reserved1 u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 acpi_srat_mem_affinity.flags u32;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 acpi_srat_mem_affinity.reserved2 u64;
//          0028 effalign(1) sda=0 bits=0000 acpi_srat_mem_affinity struct packalign=1

00000004 enum acpi_srat_type : unsigned __int32
{
  ACPI_SRAT_TYPE_CPU_AFFINITY = 0x0,
  ACPI_SRAT_TYPE_MEMORY_AFFINITY = 0x1,
  ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 0x2,
  ACPI_SRAT_TYPE_GICC_AFFINITY = 0x3,
  ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 0x4,
  ACPI_SRAT_TYPE_GENERIC_AFFINITY = 0x5,
  ACPI_SRAT_TYPE_RESERVED = 0x6,
};
00000018 #pragma pack(push, 1)
struct acpi_srat_x2apic_cpu_affinity
{
  acpi_subtable_header header;
  u16 reserved;
  u32 proximity_domain;
  u32 apic_id;
  u32 flags;
  u32 clock_domain;
  u32 reserved2;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.header acpi_subtable_header;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.reserved u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.proximity_domain u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.apic_id u32;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.flags u32;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.clock_domain u32;
//  6. 0014 0004 effalign(4) fda=0 bits=0000 acpi_srat_x2apic_cpu_affinity.reserved2 u32;
//          0018 effalign(1) sda=0 bits=0000 acpi_srat_x2apic_cpu_affinity struct packalign=1

00000020 struct acpi_statistics
{
  u32 sci_count;
  u32 gpe_count;
  u32 fixed_event_count[5];
  u32 method_count;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_statistics.sci_count u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_statistics.gpe_count u32;
//  2. 0008 0014 effalign(4) fda=0 bits=0000 acpi_statistics.fixed_event_count u32[5];
//  3. 001C 0004 effalign(4) fda=0 bits=0000 acpi_statistics.method_count u32;
//          0020 effalign(4) sda=0 bits=0000 acpi_statistics struct packalign=0

00000004 typedef u32 acpi_status;
00000008 typedef char *acpi_string;
00000002 #pragma pack(push, 1)
struct acpi_subtable_header
{
  u8 type;
  u8 length;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_subtable_header.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_subtable_header.length u8;
//          0002 effalign(1) sda=0 bits=0000 acpi_subtable_header struct packalign=1

00000008 union acpi_subtable_headers
{
  acpi_subtable_header common;
  acpi_hmat_structure hmat;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 acpi_subtable_headers.common acpi_subtable_header;
//  1. 0000 0008 effalign(1) fda=0 bits=0000 acpi_subtable_headers.hmat acpi_hmat_structure;
//          0008 effalign(1) sda=0 bits=0000 acpi_subtable_headers union packalign=0

00000018 struct acpi_subtable_proc
{
  int id;
  acpi_tbl_entry_handler handler;
  int count;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_subtable_proc.id int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_subtable_proc.handler acpi_tbl_entry_handler;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 acpi_subtable_proc.count int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 acpi_subtable_proc struct packalign=0

0000001C struct acpi_system_info
{
  u32 acpi_ca_version;
  u32 flags;
  u32 timer_resolution;
  u32 reserved1;
  u32 reserved2;
  u32 debug_level;
  u32 debug_layer;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_system_info.acpi_ca_version u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_system_info.flags u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_system_info.timer_resolution u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_system_info.reserved1 u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_system_info.reserved2 u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_system_info.debug_level u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 acpi_system_info.debug_layer u32;
//          001C effalign(4) sda=0 bits=0000 acpi_system_info struct packalign=0

00000024 #pragma pack(push, 1)
struct acpi_table_asf
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_asf.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_asf struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_bert
{
  acpi_table_header header;
  u32 region_length;
  u64 address;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_bert.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_bert.region_length u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_bert.address u64;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_bert struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_table_bgrt
{
  acpi_table_header header;
  u16 version;
  u8 status;
  u8 image_type;
  u64 image_address;
  u32 image_offset_x;
  u32 image_offset_y;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_bgrt.header acpi_table_header;
//  1. 0024 0002 effalign(2) fda=0 bits=0000 acpi_table_bgrt.version u16;
//  2. 0026 0001 effalign(1) fda=0 bits=0000 acpi_table_bgrt.status u8;
//  3. 0027 0001 effalign(1) fda=0 bits=0000 acpi_table_bgrt.image_type u8;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_bgrt.image_address u64;
//  5. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_bgrt.image_offset_x u32;
//  6. 0034 0004 effalign(4) fda=0 bits=0000 acpi_table_bgrt.image_offset_y u32;
//          0038 effalign(1) sda=0 bits=0000 acpi_table_bgrt struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_boot
{
  acpi_table_header header;
  u8 cmos_index;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_boot.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_boot.cmos_index u8;
//  2. 0025 0003 effalign(1) fda=0 bits=0000 acpi_table_boot.reserved u8[3];
//          0028 effalign(1) sda=0 bits=0000 acpi_table_boot struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_cpep
{
  acpi_table_header header;
  u64 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_cpep.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_cpep.reserved u64;
//          002C effalign(1) sda=0 bits=0000 acpi_table_cpep struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_csrt
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_csrt.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_csrt struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_dbg2
{
  acpi_table_header header;
  u32 info_offset;
  u32 info_count;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_dbg2.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_dbg2.info_offset u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_dbg2.info_count u32;
//          002C effalign(1) sda=0 bits=0000 acpi_table_dbg2 struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_table_dbgp
{
  acpi_table_header header;
  u8 type;
  u8 reserved[3];
  acpi_generic_address debug_port;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_dbgp.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_dbgp.type u8;
//  2. 0025 0003 effalign(1) fda=0 bits=0000 acpi_table_dbgp.reserved u8[3];
//  3. 0028 000C effalign(1) fda=0 bits=0000 acpi_table_dbgp.debug_port acpi_generic_address;
//          0034 effalign(1) sda=0 bits=0000 acpi_table_dbgp struct packalign=1

00000020 struct acpi_table_desc
{
  acpi_physical_address address;
  acpi_table_header *pointer;
  u32 length;
  acpi_name_union signature;
  acpi_owner_id owner_id;
  u8 flags;
  u16 validation_count;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 acpi_table_desc.address acpi_physical_address;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 acpi_table_desc.pointer acpi_table_header *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 acpi_table_desc.length u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 acpi_table_desc.signature acpi_name_union;
//  4. 0018 0002 effalign(2) fda=0 bits=0000 acpi_table_desc.owner_id acpi_owner_id;
//  5. 001A 0001 effalign(1) fda=0 bits=0000 acpi_table_desc.flags u8;
//  6. 001C 0002 effalign(2) fda=0 bits=0000 acpi_table_desc.validation_count u16;
//          001E unpadded_size
//          0020 effalign(8) sda=0 bits=0000 acpi_table_desc struct packalign=0

00000030 #pragma pack(push, 1)
struct acpi_table_dmar
{
  acpi_table_header header;
  u8 width;
  u8 flags;
  u8 reserved[10];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_dmar.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_dmar.width u8;
//  2. 0025 0001 effalign(1) fda=0 bits=0000 acpi_table_dmar.flags u8;
//  3. 0026 000A effalign(1) fda=0 bits=0000 acpi_table_dmar.reserved u8[10];
//          0030 effalign(1) sda=0 bits=0000 acpi_table_dmar struct packalign=1

00000060 #pragma pack(push, 1)
struct acpi_table_drtm
{
  acpi_table_header header;
  u64 entry_base_address;
  u64 entry_length;
  u32 entry_address32;
  u64 entry_address64;
  u64 exit_address;
  u64 log_area_address;
  u32 log_area_length;
  u64 arch_dependent_address;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_drtm.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.entry_base_address u64;
//  2. 002C 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.entry_length u64;
//  3. 0034 0004 effalign(4) fda=0 bits=0000 acpi_table_drtm.entry_address32 u32;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.entry_address64 u64;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.exit_address u64;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.log_area_address u64;
//  7. 0050 0004 effalign(4) fda=0 bits=0000 acpi_table_drtm.log_area_length u32;
//  8. 0054 0008 effalign(8) fda=0 bits=0000 acpi_table_drtm.arch_dependent_address u64;
//  9. 005C 0004 effalign(4) fda=0 bits=0000 acpi_table_drtm.flags u32;
//          0060 effalign(1) sda=0 bits=0000 acpi_table_drtm struct packalign=1

00000042 #pragma pack(push, 1)
struct acpi_table_ecdt
{
  acpi_table_header header;
  acpi_generic_address control;
  acpi_generic_address data;
  u32 uid;
  u8 gpe;
  u8 id[1];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_ecdt.header acpi_table_header;
//  1. 0024 000C effalign(1) fda=0 bits=0000 acpi_table_ecdt.control acpi_generic_address;
//  2. 0030 000C effalign(1) fda=0 bits=0000 acpi_table_ecdt.data acpi_generic_address;
//  3. 003C 0004 effalign(4) fda=0 bits=0000 acpi_table_ecdt.uid u32;
//  4. 0040 0001 effalign(1) fda=0 bits=0000 acpi_table_ecdt.gpe u8;
//  5. 0041 0001 effalign(1) fda=0 bits=0000 acpi_table_ecdt.id u8[1];
//          0042 effalign(1) sda=0 bits=0000 acpi_table_ecdt struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_einj
{
  acpi_table_header header;
  u32 header_length;
  u8 flags;
  u8 reserved[3];
  u32 entries;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_einj.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_einj.header_length u32;
//  2. 0028 0001 effalign(1) fda=0 bits=0000 acpi_table_einj.flags u8;
//  3. 0029 0003 effalign(1) fda=0 bits=0000 acpi_table_einj.reserved u8[3];
//  4. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_einj.entries u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_einj struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_erst
{
  acpi_table_header header;
  u32 header_length;
  u32 reserved;
  u32 entries;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_erst.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_erst.header_length u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_erst.reserved u32;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_erst.entries u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_erst struct packalign=1

00000040 #pragma pack(push, 1)
struct acpi_table_facs
{
  char signature[4];
  u32 length;
  u32 hardware_signature;
  u32 firmware_waking_vector;
  u32 global_lock;
  u32 flags;
  u64 xfirmware_waking_vector;
  u8 version;
  u8 reserved[3];
  u32 ospm_flags;
  u8 reserved1[24];
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_table_facs.signature char[4];
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.length u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.hardware_signature u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.firmware_waking_vector u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.global_lock u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.flags u32;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 acpi_table_facs.xfirmware_waking_vector u64;
//  7. 0020 0001 effalign(1) fda=0 bits=0000 acpi_table_facs.version u8;
//  8. 0021 0003 effalign(1) fda=0 bits=0000 acpi_table_facs.reserved u8[3];
//  9. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_facs.ospm_flags u32;
// 10. 0028 0018 effalign(1) fda=0 bits=0000 acpi_table_facs.reserved1 u8[24];
//          0040 effalign(1) sda=0 bits=0000 acpi_table_facs struct packalign=1

00000114 #pragma pack(push, 1)
struct acpi_table_fadt
{
  acpi_table_header header;
  u32 facs;
  u32 dsdt;
  u8 model;
  u8 preferred_profile;
  u16 sci_interrupt;
  u32 smi_command;
  u8 acpi_enable;
  u8 acpi_disable;
  u8 s4_bios_request;
  u8 pstate_control;
  u32 pm1a_event_block;
  u32 pm1b_event_block;
  u32 pm1a_control_block;
  u32 pm1b_control_block;
  u32 pm2_control_block;
  u32 pm_timer_block;
  u32 gpe0_block;
  u32 gpe1_block;
  u8 pm1_event_length;
  u8 pm1_control_length;
  u8 pm2_control_length;
  u8 pm_timer_length;
  u8 gpe0_block_length;
  u8 gpe1_block_length;
  u8 gpe1_base;
  u8 cst_control;
  u16 c2_latency;
  u16 c3_latency;
  u16 flush_size;
  u16 flush_stride;
  u8 duty_offset;
  u8 duty_width;
  u8 day_alarm;
  u8 month_alarm;
  u8 century;
  u16 boot_flags;
  u8 reserved;
  u32 flags;
  acpi_generic_address reset_register;
  u8 reset_value;
  u16 arm_boot_flags;
  u8 minor_revision;
  u64 Xfacs;
  u64 Xdsdt;
  acpi_generic_address xpm1a_event_block;
  acpi_generic_address xpm1b_event_block;
  acpi_generic_address xpm1a_control_block;
  acpi_generic_address xpm1b_control_block;
  acpi_generic_address xpm2_control_block;
  acpi_generic_address xpm_timer_block;
  acpi_generic_address xgpe0_block;
  acpi_generic_address xgpe1_block;
  acpi_generic_address sleep_control;
  acpi_generic_address sleep_status;
  u64 hypervisor_id;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_fadt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.facs u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.dsdt u32;
//  3. 002C 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.model u8;
//  4. 002D 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.preferred_profile u8;
//  5. 002E 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.sci_interrupt u16;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.smi_command u32;
//  7. 0034 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.acpi_enable u8;
//  8. 0035 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.acpi_disable u8;
//  9. 0036 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.s4_bios_request u8;
// 10. 0037 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.pstate_control u8;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm1a_event_block u32;
// 12. 003C 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm1b_event_block u32;
// 13. 0040 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm1a_control_block u32;
// 14. 0044 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm1b_control_block u32;
// 15. 0048 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm2_control_block u32;
// 16. 004C 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.pm_timer_block u32;
// 17. 0050 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.gpe0_block u32;
// 18. 0054 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.gpe1_block u32;
// 19. 0058 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.pm1_event_length u8;
// 20. 0059 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.pm1_control_length u8;
// 21. 005A 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.pm2_control_length u8;
// 22. 005B 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.pm_timer_length u8;
// 23. 005C 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.gpe0_block_length u8;
// 24. 005D 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.gpe1_block_length u8;
// 25. 005E 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.gpe1_base u8;
// 26. 005F 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.cst_control u8;
// 27. 0060 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.c2_latency u16;
// 28. 0062 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.c3_latency u16;
// 29. 0064 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.flush_size u16;
// 30. 0066 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.flush_stride u16;
// 31. 0068 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.duty_offset u8;
// 32. 0069 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.duty_width u8;
// 33. 006A 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.day_alarm u8;
// 34. 006B 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.month_alarm u8;
// 35. 006C 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.century u8;
// 36. 006D 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.boot_flags u16;
// 37. 006F 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.reserved u8;
// 38. 0070 0004 effalign(4) fda=0 bits=0000 acpi_table_fadt.flags u32;
// 39. 0074 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.reset_register acpi_generic_address;
// 40. 0080 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.reset_value u8;
// 41. 0081 0002 effalign(2) fda=0 bits=0000 acpi_table_fadt.arm_boot_flags u16;
// 42. 0083 0001 effalign(1) fda=0 bits=0000 acpi_table_fadt.minor_revision u8;
// 43. 0084 0008 effalign(8) fda=0 bits=0000 acpi_table_fadt.Xfacs u64;
// 44. 008C 0008 effalign(8) fda=0 bits=0000 acpi_table_fadt.Xdsdt u64;
// 45. 0094 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm1a_event_block acpi_generic_address;
// 46. 00A0 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm1b_event_block acpi_generic_address;
// 47. 00AC 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm1a_control_block acpi_generic_address;
// 48. 00B8 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm1b_control_block acpi_generic_address;
// 49. 00C4 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm2_control_block acpi_generic_address;
// 50. 00D0 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xpm_timer_block acpi_generic_address;
// 51. 00DC 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xgpe0_block acpi_generic_address;
// 52. 00E8 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.xgpe1_block acpi_generic_address;
// 53. 00F4 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.sleep_control acpi_generic_address;
// 54. 0100 000C effalign(1) fda=0 bits=0000 acpi_table_fadt.sleep_status acpi_generic_address;
// 55. 010C 0008 effalign(8) fda=0 bits=0000 acpi_table_fadt.hypervisor_id u64;
//          0114 effalign(1) sda=0 bits=0000 acpi_table_fadt struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_fpdt
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_fpdt.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_fpdt struct packalign=1

00000060 #pragma pack(push, 1)
struct acpi_table_gtdt
{
  acpi_table_header header;
  u64 counter_block_addresss;
  u32 reserved;
  u32 secure_el1_interrupt;
  u32 secure_el1_flags;
  u32 non_secure_el1_interrupt;
  u32 non_secure_el1_flags;
  u32 virtual_timer_interrupt;
  u32 virtual_timer_flags;
  u32 non_secure_el2_interrupt;
  u32 non_secure_el2_flags;
  u64 counter_read_block_address;
  u32 platform_timer_count;
  u32 platform_timer_offset;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_gtdt.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_gtdt.counter_block_addresss u64;
//  2. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.reserved u32;
//  3. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.secure_el1_interrupt u32;
//  4. 0034 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.secure_el1_flags u32;
//  5. 0038 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.non_secure_el1_interrupt u32;
//  6. 003C 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.non_secure_el1_flags u32;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.virtual_timer_interrupt u32;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.virtual_timer_flags u32;
//  9. 0048 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.non_secure_el2_interrupt u32;
// 10. 004C 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.non_secure_el2_flags u32;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 acpi_table_gtdt.counter_read_block_address u64;
// 12. 0058 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.platform_timer_count u32;
// 13. 005C 0004 effalign(4) fda=0 bits=0000 acpi_table_gtdt.platform_timer_offset u32;
//          0060 effalign(1) sda=0 bits=0000 acpi_table_gtdt struct packalign=1

00000008 typedef acpi_status (__cdecl *acpi_table_handler)(u32, void *, void *);
00000024 #pragma pack(push, 1)
struct acpi_table_header
{
  char signature[4];
  u32 length;
  u8 revision;
  u8 checksum;
  char oem_id[6];
  char oem_table_id[8];
  u32 oem_revision;
  char asl_compiler_id[4];
  u32 asl_compiler_revision;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_table_header.signature char[4];
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_table_header.length u32;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 acpi_table_header.revision u8;
//  3. 0009 0001 effalign(1) fda=0 bits=0000 acpi_table_header.checksum u8;
//  4. 000A 0006 effalign(1) fda=0 bits=0000 acpi_table_header.oem_id char[6];
//  5. 0010 0008 effalign(1) fda=0 bits=0000 acpi_table_header.oem_table_id char[8];
//  6. 0018 0004 effalign(4) fda=0 bits=0000 acpi_table_header.oem_revision u32;
//  7. 001C 0004 effalign(1) fda=0 bits=0000 acpi_table_header.asl_compiler_id char[4];
//  8. 0020 0004 effalign(4) fda=0 bits=0000 acpi_table_header.asl_compiler_revision u32;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_header struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_hest
{
  acpi_table_header header;
  u32 error_source_count;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_hest.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_hest.error_source_count u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_hest struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_hmat
{
  acpi_table_header header;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_hmat.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_hmat.reserved u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_hmat struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_table_hpet
{
  acpi_table_header header;
  u32 id;
  acpi_generic_address address;
  u8 sequence;
  u16 minimum_tick;
  u8 flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_hpet.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_hpet.id u32;
//  2. 0028 000C effalign(1) fda=0 bits=0000 acpi_table_hpet.address acpi_generic_address;
//  3. 0034 0001 effalign(1) fda=0 bits=0000 acpi_table_hpet.sequence u8;
//  4. 0035 0002 effalign(2) fda=0 bits=0000 acpi_table_hpet.minimum_tick u16;
//  5. 0037 0001 effalign(1) fda=0 bits=0000 acpi_table_hpet.flags u8;
//          0038 effalign(1) sda=0 bits=0000 acpi_table_hpet struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_ibft
{
  acpi_table_header header;
  u8 reserved[12];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_ibft.header acpi_table_header;
//  1. 0024 000C effalign(1) fda=0 bits=0000 acpi_table_ibft.reserved u8[12];
//          0030 effalign(1) sda=0 bits=0000 acpi_table_ibft struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_iort
{
  acpi_table_header header;
  u32 node_count;
  u32 node_offset;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_iort.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_iort.node_count u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_iort.node_offset u32;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_iort.reserved u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_iort struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_ivrs
{
  acpi_table_header header;
  u32 info;
  u64 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_ivrs.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_ivrs.info u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_ivrs.reserved u64;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_ivrs struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_lpit
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_lpit.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_lpit struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_madt
{
  acpi_table_header header;
  u32 address;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_madt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_madt.address u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_madt.flags u32;
//          002C effalign(1) sda=0 bits=0000 acpi_table_madt struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_mcfg
{
  acpi_table_header header;
  u8 reserved[8];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_mcfg.header acpi_table_header;
//  1. 0024 0008 effalign(1) fda=0 bits=0000 acpi_table_mcfg.reserved u8[8];
//          002C effalign(1) sda=0 bits=0000 acpi_table_mcfg struct packalign=1

00000045 #pragma pack(push, 1)
struct acpi_table_mchi
{
  acpi_table_header header;
  u8 interface_type;
  u8 protocol;
  u64 protocol_data;
  u8 interrupt_type;
  u8 gpe;
  u8 pci_device_flag;
  u32 global_interrupt;
  acpi_generic_address control_register;
  u8 pci_segment;
  u8 pci_bus;
  u8 pci_device;
  u8 pci_function;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_mchi.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.interface_type u8;
//  2. 0025 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.protocol u8;
//  3. 0026 0008 effalign(8) fda=0 bits=0000 acpi_table_mchi.protocol_data u64;
//  4. 002E 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.interrupt_type u8;
//  5. 002F 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.gpe u8;
//  6. 0030 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.pci_device_flag u8;
//  7. 0031 0004 effalign(4) fda=0 bits=0000 acpi_table_mchi.global_interrupt u32;
//  8. 0035 000C effalign(1) fda=0 bits=0000 acpi_table_mchi.control_register acpi_generic_address;
//  9. 0041 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.pci_segment u8;
// 10. 0042 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.pci_bus u8;
// 11. 0043 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.pci_device u8;
// 12. 0044 0001 effalign(1) fda=0 bits=0000 acpi_table_mchi.pci_function u8;
//          0045 effalign(1) sda=0 bits=0000 acpi_table_mchi struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_mpst
{
  acpi_table_header header;
  u8 channel_id;
  u8 reserved1[3];
  u16 power_node_count;
  u16 reserved2;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_mpst.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_mpst.channel_id u8;
//  2. 0025 0003 effalign(1) fda=0 bits=0000 acpi_table_mpst.reserved1 u8[3];
//  3. 0028 0002 effalign(2) fda=0 bits=0000 acpi_table_mpst.power_node_count u16;
//  4. 002A 0002 effalign(2) fda=0 bits=0000 acpi_table_mpst.reserved2 u16;
//          002C effalign(1) sda=0 bits=0000 acpi_table_mpst struct packalign=1

00000038 #pragma pack(push, 1)
struct acpi_table_msct
{
  acpi_table_header header;
  u32 proximity_offset;
  u32 max_proximity_domains;
  u32 max_clock_domains;
  u64 max_address;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_msct.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_msct.proximity_offset u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_msct.max_proximity_domains u32;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_msct.max_clock_domains u32;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 acpi_table_msct.max_address u64;
//          0038 effalign(1) sda=0 bits=0000 acpi_table_msct struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_msdm
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_msdm.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_msdm struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_mtmr
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_mtmr.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_mtmr struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_nfit
{
  acpi_table_header header;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_nfit.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_nfit.reserved u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_nfit struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_pcct
{
  acpi_table_header header;
  u32 flags;
  u64 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_pcct.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_pcct.flags u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_pcct.reserved u64;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_pcct struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_pdtt
{
  acpi_table_header header;
  u8 trigger_count;
  u8 reserved[3];
  u32 array_offset;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_pdtt.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_pdtt.trigger_count u8;
//  2. 0025 0003 effalign(1) fda=0 bits=0000 acpi_table_pdtt.reserved u8[3];
//  3. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_pdtt.array_offset u32;
//          002C effalign(1) sda=0 bits=0000 acpi_table_pdtt struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_pmtt
{
  acpi_table_header header;
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_pmtt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_pmtt.reserved u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_pmtt struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_pptt
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_pptt.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_pptt struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_rasf
{
  acpi_table_header header;
  u8 channel_id[12];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_rasf.header acpi_table_header;
//  1. 0024 000C effalign(1) fda=0 bits=0000 acpi_table_rasf.channel_id u8[12];
//          0030 effalign(1) sda=0 bits=0000 acpi_table_rasf struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_rsdp
{
  char signature[8];
  u8 checksum;
  char oem_id[6];
  u8 revision;
  u32 rsdt_physical_address;
  u32 length;
  u64 xsdt_physical_address;
  u8 extended_checksum;
  u8 reserved[3];
};
#pragma pack(pop)
//  0. 0000 0008 effalign(1) fda=0 bits=0000 acpi_table_rsdp.signature char[8];
//  1. 0008 0001 effalign(1) fda=0 bits=0000 acpi_table_rsdp.checksum u8;
//  2. 0009 0006 effalign(1) fda=0 bits=0000 acpi_table_rsdp.oem_id char[6];
//  3. 000F 0001 effalign(1) fda=0 bits=0000 acpi_table_rsdp.revision u8;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_table_rsdp.rsdt_physical_address u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_table_rsdp.length u32;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 acpi_table_rsdp.xsdt_physical_address u64;
//  7. 0020 0001 effalign(1) fda=0 bits=0000 acpi_table_rsdp.extended_checksum u8;
//  8. 0021 0003 effalign(1) fda=0 bits=0000 acpi_table_rsdp.reserved u8[3];
//          0024 effalign(1) sda=0 bits=0000 acpi_table_rsdp struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_rsdt
{
  acpi_table_header header;
  u32 table_offset_entry[1];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_rsdt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_rsdt.table_offset_entry u32[1];
//          0028 effalign(1) sda=0 bits=0000 acpi_table_rsdt struct packalign=1

00000008 #pragma pack(push, 1)
struct acpi_table_s3pt
{
  u8 signature[4];
  u32 length;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(1) fda=0 bits=0000 acpi_table_s3pt.signature u8[4];
//  1. 0004 0004 effalign(4) fda=0 bits=0000 acpi_table_s3pt.length u32;
//          0008 effalign(1) sda=0 bits=0000 acpi_table_s3pt struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_sbst
{
  acpi_table_header header;
  u32 warning_level;
  u32 low_level;
  u32 critical_level;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_sbst.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_sbst.warning_level u32;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 acpi_table_sbst.low_level u32;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_sbst.critical_level u32;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_sbst struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_sdei
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_sdei.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_sdei struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_sdev
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_sdev.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_sdev struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_slic
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_slic.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_slic struct packalign=1

0000002D #pragma pack(push, 1)
struct acpi_table_slit
{
  acpi_table_header header;
  u64 locality_count;
  u8 entry[1];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_slit.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_slit.locality_count u64;
//  2. 002C 0001 effalign(1) fda=0 bits=0000 acpi_table_slit.entry u8[1];
//          002D effalign(1) sda=0 bits=0000 acpi_table_slit struct packalign=1

00000050 #pragma pack(push, 1)
struct acpi_table_spcr
{
  acpi_table_header header;
  u8 interface_type;
  u8 reserved[3];
  acpi_generic_address serial_port;
  u8 interrupt_type;
  u8 pc_interrupt;
  u32 interrupt;
  u8 baud_rate;
  u8 parity;
  u8 stop_bits;
  u8 flow_control;
  u8 terminal_type;
  u8 reserved1;
  u16 pci_device_id;
  u16 pci_vendor_id;
  u8 pci_bus;
  u8 pci_device;
  u8 pci_function;
  u32 pci_flags;
  u8 pci_segment;
  u32 reserved2;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_spcr.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.interface_type u8;
//  2. 0025 0003 effalign(1) fda=0 bits=0000 acpi_table_spcr.reserved u8[3];
//  3. 0028 000C effalign(1) fda=0 bits=0000 acpi_table_spcr.serial_port acpi_generic_address;
//  4. 0034 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.interrupt_type u8;
//  5. 0035 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.pc_interrupt u8;
//  6. 0036 0004 effalign(4) fda=0 bits=0000 acpi_table_spcr.interrupt u32;
//  7. 003A 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.baud_rate u8;
//  8. 003B 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.parity u8;
//  9. 003C 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.stop_bits u8;
// 10. 003D 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.flow_control u8;
// 11. 003E 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.terminal_type u8;
// 12. 003F 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.reserved1 u8;
// 13. 0040 0002 effalign(2) fda=0 bits=0000 acpi_table_spcr.pci_device_id u16;
// 14. 0042 0002 effalign(2) fda=0 bits=0000 acpi_table_spcr.pci_vendor_id u16;
// 15. 0044 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.pci_bus u8;
// 16. 0045 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.pci_device u8;
// 17. 0046 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.pci_function u8;
// 18. 0047 0004 effalign(4) fda=0 bits=0000 acpi_table_spcr.pci_flags u32;
// 19. 004B 0001 effalign(1) fda=0 bits=0000 acpi_table_spcr.pci_segment u8;
// 20. 004C 0004 effalign(4) fda=0 bits=0000 acpi_table_spcr.reserved2 u32;
//          0050 effalign(1) sda=0 bits=0000 acpi_table_spcr struct packalign=1

00000041 #pragma pack(push, 1)
struct acpi_table_spmi
{
  acpi_table_header header;
  u8 interface_type;
  u8 reserved;
  u16 spec_revision;
  u8 interrupt_type;
  u8 gpe_number;
  u8 reserved1;
  u8 pci_device_flag;
  u32 interrupt;
  acpi_generic_address ipmi_register;
  u8 pci_segment;
  u8 pci_bus;
  u8 pci_device;
  u8 pci_function;
  u8 reserved2;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_spmi.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.interface_type u8;
//  2. 0025 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.reserved u8;
//  3. 0026 0002 effalign(2) fda=0 bits=0000 acpi_table_spmi.spec_revision u16;
//  4. 0028 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.interrupt_type u8;
//  5. 0029 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.gpe_number u8;
//  6. 002A 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.reserved1 u8;
//  7. 002B 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.pci_device_flag u8;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 acpi_table_spmi.interrupt u32;
//  9. 0030 000C effalign(1) fda=0 bits=0000 acpi_table_spmi.ipmi_register acpi_generic_address;
// 10. 003C 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.pci_segment u8;
// 11. 003D 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.pci_bus u8;
// 12. 003E 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.pci_device u8;
// 13. 003F 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.pci_function u8;
// 14. 0040 0001 effalign(1) fda=0 bits=0000 acpi_table_spmi.reserved2 u8;
//          0041 effalign(1) sda=0 bits=0000 acpi_table_spmi struct packalign=1

00000030 #pragma pack(push, 1)
struct acpi_table_srat
{
  acpi_table_header header;
  u32 table_revision;
  u64 reserved;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_srat.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_srat.table_revision u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_srat.reserved u64;
//          0030 effalign(1) sda=0 bits=0000 acpi_table_srat struct packalign=1

00000025 #pragma pack(push, 1)
struct acpi_table_stao
{
  acpi_table_header header;
  u8 ignore_uart;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_stao.header acpi_table_header;
//  1. 0024 0001 effalign(1) fda=0 bits=0000 acpi_table_stao.ignore_uart u8;
//          0025 effalign(1) sda=0 bits=0000 acpi_table_stao struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_table_tcpa_client
{
  u32 minimum_log_length;
  u64 log_address;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_table_tcpa_client.minimum_log_length u32;
//  1. 0004 0008 effalign(8) fda=0 bits=0000 acpi_table_tcpa_client.log_address u64;
//          000C effalign(1) sda=0 bits=0000 acpi_table_tcpa_client struct packalign=1

00000026 #pragma pack(push, 1)
struct acpi_table_tcpa_hdr
{
  acpi_table_header header;
  u16 platform_class;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_tcpa_hdr.header acpi_table_header;
//  1. 0024 0002 effalign(2) fda=0 bits=0000 acpi_table_tcpa_hdr.platform_class u16;
//          0026 effalign(1) sda=0 bits=0000 acpi_table_tcpa_hdr struct packalign=1

0000003E #pragma pack(push, 1)
struct acpi_table_tcpa_server
{
  u16 reserved;
  u64 minimum_log_length;
  u64 log_address;
  u16 spec_revision;
  u8 device_flags;
  u8 interrupt_flags;
  u8 gpe_number;
  u8 reserved2[3];
  u32 global_interrupt;
  acpi_generic_address address;
  u32 reserved3;
  acpi_generic_address config_address;
  u8 group;
  u8 bus;
  u8 device;
  u8 function;
};
#pragma pack(pop)
//  0. 0000 0002 effalign(2) fda=0 bits=0000 acpi_table_tcpa_server.reserved u16;
//  1. 0002 0008 effalign(8) fda=0 bits=0000 acpi_table_tcpa_server.minimum_log_length u64;
//  2. 000A 0008 effalign(8) fda=0 bits=0000 acpi_table_tcpa_server.log_address u64;
//  3. 0012 0002 effalign(2) fda=0 bits=0000 acpi_table_tcpa_server.spec_revision u16;
//  4. 0014 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.device_flags u8;
//  5. 0015 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.interrupt_flags u8;
//  6. 0016 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.gpe_number u8;
//  7. 0017 0003 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.reserved2 u8[3];
//  8. 001A 0004 effalign(4) fda=0 bits=0000 acpi_table_tcpa_server.global_interrupt u32;
//  9. 001E 000C effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.address acpi_generic_address;
// 10. 002A 0004 effalign(4) fda=0 bits=0000 acpi_table_tcpa_server.reserved3 u32;
// 11. 002E 000C effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.config_address acpi_generic_address;
// 12. 003A 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.group u8;
// 13. 003B 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.bus u8;
// 14. 003C 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.device u8;
// 15. 003D 0001 effalign(1) fda=0 bits=0000 acpi_table_tcpa_server.function u8;
//          003E effalign(1) sda=0 bits=0000 acpi_table_tcpa_server struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_table_tpm2
{
  acpi_table_header header;
  u16 platform_class;
  u16 reserved;
  u64 control_address;
  u32 start_method;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_tpm2.header acpi_table_header;
//  1. 0024 0002 effalign(2) fda=0 bits=0000 acpi_table_tpm2.platform_class u16;
//  2. 0026 0002 effalign(2) fda=0 bits=0000 acpi_table_tpm2.reserved u16;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_tpm2.control_address u64;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_tpm2.start_method u32;
//          0034 effalign(1) sda=0 bits=0000 acpi_table_tpm2 struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_table_tpm23
{
  acpi_table_header header;
  u32 reserved;
  u64 control_address;
  u32 start_method;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_tpm23.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_tpm23.reserved u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_tpm23.control_address u64;
//  3. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_tpm23.start_method u32;
//          0034 effalign(1) sda=0 bits=0000 acpi_table_tpm23 struct packalign=1

00000036 #pragma pack(push, 1)
struct acpi_table_uefi
{
  acpi_table_header header;
  u8 identifier[16];
  u16 data_offset;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_uefi.header acpi_table_header;
//  1. 0024 0010 effalign(1) fda=0 bits=0000 acpi_table_uefi.identifier u8[16];
//  2. 0034 0002 effalign(2) fda=0 bits=0000 acpi_table_uefi.data_offset u16;
//          0036 effalign(1) sda=0 bits=0000 acpi_table_uefi struct packalign=1

00000024 #pragma pack(push, 1)
struct acpi_table_vrtc
{
  acpi_table_header header;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_vrtc.header acpi_table_header;
//          0024 effalign(1) sda=0 bits=0000 acpi_table_vrtc struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_waet
{
  acpi_table_header header;
  u32 flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_waet.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_waet.flags u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_waet struct packalign=1

00000044 #pragma pack(push, 1)
struct acpi_table_wdat
{
  acpi_table_header header;
  u32 header_length;
  u16 pci_segment;
  u8 pci_bus;
  u8 pci_device;
  u8 pci_function;
  u8 reserved[3];
  u32 timer_period;
  u32 max_count;
  u32 min_count;
  u8 flags;
  u8 reserved2[3];
  u32 entries;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_wdat.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_wdat.header_length u32;
//  2. 0028 0002 effalign(2) fda=0 bits=0000 acpi_table_wdat.pci_segment u16;
//  3. 002A 0001 effalign(1) fda=0 bits=0000 acpi_table_wdat.pci_bus u8;
//  4. 002B 0001 effalign(1) fda=0 bits=0000 acpi_table_wdat.pci_device u8;
//  5. 002C 0001 effalign(1) fda=0 bits=0000 acpi_table_wdat.pci_function u8;
//  6. 002D 0003 effalign(1) fda=0 bits=0000 acpi_table_wdat.reserved u8[3];
//  7. 0030 0004 effalign(4) fda=0 bits=0000 acpi_table_wdat.timer_period u32;
//  8. 0034 0004 effalign(4) fda=0 bits=0000 acpi_table_wdat.max_count u32;
//  9. 0038 0004 effalign(4) fda=0 bits=0000 acpi_table_wdat.min_count u32;
// 10. 003C 0001 effalign(1) fda=0 bits=0000 acpi_table_wdat.flags u8;
// 11. 003D 0003 effalign(1) fda=0 bits=0000 acpi_table_wdat.reserved2 u8[3];
// 12. 0040 0004 effalign(4) fda=0 bits=0000 acpi_table_wdat.entries u32;
//          0044 effalign(1) sda=0 bits=0000 acpi_table_wdat struct packalign=1

00000040 #pragma pack(push, 1)
struct acpi_table_wddt
{
  acpi_table_header header;
  u16 spec_version;
  u16 table_version;
  u16 pci_vendor_id;
  acpi_generic_address address;
  u16 max_count;
  u16 min_count;
  u16 period;
  u16 status;
  u16 capability;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_wddt.header acpi_table_header;
//  1. 0024 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.spec_version u16;
//  2. 0026 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.table_version u16;
//  3. 0028 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.pci_vendor_id u16;
//  4. 002A 000C effalign(1) fda=0 bits=0000 acpi_table_wddt.address acpi_generic_address;
//  5. 0036 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.max_count u16;
//  6. 0038 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.min_count u16;
//  7. 003A 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.period u16;
//  8. 003C 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.status u16;
//  9. 003E 0002 effalign(2) fda=0 bits=0000 acpi_table_wddt.capability u16;
//          0040 effalign(1) sda=0 bits=0000 acpi_table_wddt struct packalign=1

00000047 #pragma pack(push, 1)
struct acpi_table_wdrt
{
  acpi_table_header header;
  acpi_generic_address control_register;
  acpi_generic_address count_register;
  u16 pci_device_id;
  u16 pci_vendor_id;
  u8 pci_bus;
  u8 pci_device;
  u8 pci_function;
  u8 pci_segment;
  u16 max_count;
  u8 units;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_wdrt.header acpi_table_header;
//  1. 0024 000C effalign(1) fda=0 bits=0000 acpi_table_wdrt.control_register acpi_generic_address;
//  2. 0030 000C effalign(1) fda=0 bits=0000 acpi_table_wdrt.count_register acpi_generic_address;
//  3. 003C 0002 effalign(2) fda=0 bits=0000 acpi_table_wdrt.pci_device_id u16;
//  4. 003E 0002 effalign(2) fda=0 bits=0000 acpi_table_wdrt.pci_vendor_id u16;
//  5. 0040 0001 effalign(1) fda=0 bits=0000 acpi_table_wdrt.pci_bus u8;
//  6. 0041 0001 effalign(1) fda=0 bits=0000 acpi_table_wdrt.pci_device u8;
//  7. 0042 0001 effalign(1) fda=0 bits=0000 acpi_table_wdrt.pci_function u8;
//  8. 0043 0001 effalign(1) fda=0 bits=0000 acpi_table_wdrt.pci_segment u8;
//  9. 0044 0002 effalign(2) fda=0 bits=0000 acpi_table_wdrt.max_count u16;
// 10. 0046 0001 effalign(1) fda=0 bits=0000 acpi_table_wdrt.units u8;
//          0047 effalign(1) sda=0 bits=0000 acpi_table_wdrt struct packalign=1

00000034 #pragma pack(push, 1)
struct acpi_table_wpbt
{
  acpi_table_header header;
  u32 handoff_size;
  u64 handoff_address;
  u8 layout;
  u8 type;
  u16 arguments_length;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_wpbt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_wpbt.handoff_size u32;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 acpi_table_wpbt.handoff_address u64;
//  3. 0030 0001 effalign(1) fda=0 bits=0000 acpi_table_wpbt.layout u8;
//  4. 0031 0001 effalign(1) fda=0 bits=0000 acpi_table_wpbt.type u8;
//  5. 0032 0002 effalign(2) fda=0 bits=0000 acpi_table_wpbt.arguments_length u16;
//          0034 effalign(1) sda=0 bits=0000 acpi_table_wpbt struct packalign=1

00000028 #pragma pack(push, 1)
struct acpi_table_wsmt
{
  acpi_table_header header;
  u32 protection_flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_wsmt.header acpi_table_header;
//  1. 0024 0004 effalign(4) fda=0 bits=0000 acpi_table_wsmt.protection_flags u32;
//          0028 effalign(1) sda=0 bits=0000 acpi_table_wsmt struct packalign=1

00000039 #pragma pack(push, 1)
struct acpi_table_xenv
{
  acpi_table_header header;
  u64 grant_table_address;
  u64 grant_table_size;
  u32 event_interrupt;
  u8 event_flags;
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_xenv.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_xenv.grant_table_address u64;
//  2. 002C 0008 effalign(8) fda=0 bits=0000 acpi_table_xenv.grant_table_size u64;
//  3. 0034 0004 effalign(4) fda=0 bits=0000 acpi_table_xenv.event_interrupt u32;
//  4. 0038 0001 effalign(1) fda=0 bits=0000 acpi_table_xenv.event_flags u8;
//          0039 effalign(1) sda=0 bits=0000 acpi_table_xenv struct packalign=1

0000002C #pragma pack(push, 1)
struct acpi_table_xsdt
{
  acpi_table_header header;
  u64 table_offset_entry[1];
};
#pragma pack(pop)
//  0. 0000 0024 effalign(1) fda=0 bits=0000 acpi_table_xsdt.header acpi_table_header;
//  1. 0024 0008 effalign(8) fda=0 bits=0000 acpi_table_xsdt.table_offset_entry u64[1];
//          002C effalign(1) sda=0 bits=0000 acpi_table_xsdt struct packalign=1

00000008 typedef int (__cdecl *acpi_tbl_entry_handler)(acpi_subtable_headers *, const unsigned __int64);
00000008 typedef int (__cdecl *acpi_tbl_table_handler)(acpi_table_header *);
00000004 #pragma pack(push, 1)
struct acpi_tmp23_trailer
{
  u32 reserved;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_tmp23_trailer.reserved u32;
//          0004 effalign(1) sda=0 bits=0000 acpi_tmp23_trailer struct packalign=1

0000000C #pragma pack(push, 1)
struct acpi_tpm2_arm_smc
{
  u32 global_interrupt;
  u8 interrupt_flags;
  u8 operation_flags;
  u16 reserved;
  u32 function_id;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 acpi_tpm2_arm_smc.global_interrupt u32;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 acpi_tpm2_arm_smc.interrupt_flags u8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 acpi_tpm2_arm_smc.operation_flags u8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 acpi_tpm2_arm_smc.reserved u16;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 acpi_tpm2_arm_smc.function_id u32;
//          000C effalign(1) sda=0 bits=0000 acpi_tpm2_arm_smc struct packalign=1

00000018 #pragma pack(push, 1)
struct acpi_tpm2_trailer
{
  u8 method_parameters[12];
  u32 minimum_log_length;
  u64 log_address;
};
#pragma pack(pop)
//  0. 0000 000C effalign(1) fda=0 bits=0000 acpi_tpm2_trailer.method_parameters u8[12];
//  1. 000C 0004 effalign(4) fda=0 bits=0000 acpi_tpm2_trailer.minimum_log_length u32;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 acpi_tpm2_trailer.log_address u64;
//          0018 effalign(1) sda=0 bits=0000 acpi_tpm2_trailer struct packalign=1

00000004 enum acpi_trace_event_type : unsigned __int32
{
  ACPI_TRACE_AML_METHOD = 0x0,
  ACPI_TRACE_AML_OPCODE = 0x1,
  ACPI_TRACE_AML_REGION = 0x2,
};
00000010 #pragma pack(push, 1)
struct acpi_uuid
{
  u8 data[16];
};
#pragma pack(pop)
//  0. 0000 0010 effalign(1) fda=0 bits=0000 acpi_uuid.data u8[16];
//          0010 effalign(1) sda=0 bits=0000 acpi_uuid struct packalign=1

00000011 #pragma pack(push, 1)
struct acpi_vendor_uuid
{
  u8 subtype;
  u8 data[16];
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_vendor_uuid.subtype u8;
//  1. 0001 0010 effalign(1) fda=0 bits=0000 acpi_vendor_uuid.data u8[16];
//          0011 effalign(1) sda=0 bits=0000 acpi_vendor_uuid struct packalign=1

00000010 #pragma pack(push, 1)
struct acpi_vrtc_entry
{
  acpi_generic_address physical_address;
  u32 irq;
};
#pragma pack(pop)
//  0. 0000 000C effalign(1) fda=0 bits=0000 acpi_vrtc_entry.physical_address acpi_generic_address;
//  1. 000C 0004 effalign(4) fda=0 bits=0000 acpi_vrtc_entry.irq u32;
//          0010 effalign(1) sda=0 bits=0000 acpi_vrtc_entry struct packalign=1

00000008 typedef acpi_status (__cdecl *acpi_walk_callback)(acpi_handle, u32, void *, void **);
00000008 typedef acpi_status (__cdecl *acpi_walk_resource_callback)(acpi_resource *, void *);
00000004 enum acpi_wdat_actions : unsigned __int32
{
  ACPI_WDAT_RESET = 0x1,
  ACPI_WDAT_GET_CURRENT_COUNTDOWN = 0x4,
  ACPI_WDAT_GET_COUNTDOWN = 0x5,
  ACPI_WDAT_SET_COUNTDOWN = 0x6,
  ACPI_WDAT_GET_RUNNING_STATE = 0x8,
  ACPI_WDAT_SET_RUNNING_STATE = 0x9,
  ACPI_WDAT_GET_STOPPED_STATE = 0xA,
  ACPI_WDAT_SET_STOPPED_STATE = 0xB,
  ACPI_WDAT_GET_REBOOT = 0x10,
  ACPI_WDAT_SET_REBOOT = 0x11,
  ACPI_WDAT_GET_SHUTDOWN = 0x12,
  ACPI_WDAT_SET_SHUTDOWN = 0x13,
  ACPI_WDAT_GET_STATUS = 0x20,
  ACPI_WDAT_SET_STATUS = 0x21,
  ACPI_WDAT_ACTION_RESERVED = 0x22,
};
00000018 #pragma pack(push, 1)
struct acpi_wdat_entry
{
  u8 action;
  u8 instruction;
  u16 reserved;
  acpi_generic_address register_region;
  u32 value;
  u32 mask;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_wdat_entry.action u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_wdat_entry.instruction u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 acpi_wdat_entry.reserved u16;
//  3. 0004 000C effalign(1) fda=0 bits=0000 acpi_wdat_entry.register_region acpi_generic_address;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 acpi_wdat_entry.value u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 acpi_wdat_entry.mask u32;
//          0018 effalign(1) sda=0 bits=0000 acpi_wdat_entry struct packalign=1

00000004 enum acpi_wdat_instructions : unsigned __int32
{
  ACPI_WDAT_READ_VALUE = 0x0,
  ACPI_WDAT_READ_COUNTDOWN = 0x1,
  ACPI_WDAT_WRITE_VALUE = 0x2,
  ACPI_WDAT_WRITE_COUNTDOWN = 0x3,
  ACPI_WDAT_INSTRUCTION_RESERVED = 0x4,
  ACPI_WDAT_PRESERVE_REGISTER = 0x80,
};
00000020 #pragma pack(push, 1)
struct acpi_whea_header
{
  u8 action;
  u8 instruction;
  u8 flags;
  u8 reserved;
  acpi_generic_address register_region;
  u64 value;
  u64 mask;
};
#pragma pack(pop)
//  0. 0000 0001 effalign(1) fda=0 bits=0000 acpi_whea_header.action u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 acpi_whea_header.instruction u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 acpi_whea_header.flags u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 acpi_whea_header.reserved u8;
//  4. 0004 000C effalign(1) fda=0 bits=0000 acpi_whea_header.register_region acpi_generic_address;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 acpi_whea_header.value u64;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 acpi_whea_header.mask u64;
//          0020 effalign(1) sda=0 bits=0000 acpi_whea_header struct packalign=1

000000A0 struct __attribute__((aligned(8))) address_space
{
  inode *host;
  xarray i_pages;
  gfp_t gfp_mask;
  atomic_t i_mmap_writable;
  rb_root_cached i_mmap;
  rw_semaphore i_mmap_rwsem;
  unsigned __int64 nrpages;
  unsigned __int64 nrexceptional;
  unsigned __int64 writeback_index;
  const address_space_operations *a_ops;
  unsigned __int64 flags;
  errseq_t wb_err;
  spinlock_t private_lock;
  list_head private_list;
  void *private_data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 address_space.host inode *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 address_space.i_pages xarray;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 address_space.gfp_mask gfp_t;
//  3. 001C 0004 effalign(4) fda=0 bits=0000 address_space.i_mmap_writable atomic_t;
//  4. 0020 0010 effalign(8) fda=0 bits=0000 address_space.i_mmap rb_root_cached;
//  5. 0030 0028 effalign(8) fda=0 bits=0000 address_space.i_mmap_rwsem rw_semaphore;
//  6. 0058 0008 effalign(8) fda=0 bits=0000 address_space.nrpages unsigned __int64;
//  7. 0060 0008 effalign(8) fda=0 bits=0000 address_space.nrexceptional unsigned __int64;
//  8. 0068 0008 effalign(8) fda=0 bits=0000 address_space.writeback_index unsigned __int64;
//  9. 0070 0008 effalign(8) fda=0 bits=0000 address_space.a_ops const address_space_operations *;
// 10. 0078 0008 effalign(8) fda=0 bits=0000 address_space.flags unsigned __int64;
// 11. 0080 0004 effalign(4) fda=0 bits=0000 address_space.wb_err errseq_t;
// 12. 0084 0004 effalign(4) fda=0 bits=0000 address_space.private_lock spinlock_t;
// 13. 0088 0010 effalign(8) fda=0 bits=0000 address_space.private_list list_head;
// 14. 0098 0008 effalign(8) fda=0 bits=0000 address_space.private_data void *;
//          00A0 effalign(8) sda=4 bits=0000 address_space struct packalign=0

000000A8 struct address_space_operations
{
  int (__cdecl *writepage)(page *, writeback_control *);
  int (__cdecl *readpage)(file *, page *);
  int (__cdecl *writepages)(address_space *, writeback_control *);
  int (__cdecl *set_page_dirty)(page *);
  int (__cdecl *readpages)(file *, address_space *, list_head *, unsigned int);
  int (__cdecl *write_begin)(file *, address_space *, loff_t, unsigned int, unsigned int, page **, void **);
  int (__cdecl *write_end)(file *, address_space *, loff_t, unsigned int, unsigned int, page *, void *);
  sector_t (__cdecl *bmap)(address_space *, sector_t);
  void (__cdecl *invalidatepage)(page *, unsigned int, unsigned int);
  int (__cdecl *releasepage)(page *, gfp_t);
  void (__cdecl *freepage)(page *);
  ssize_t (__cdecl *direct_IO)(kiocb *, iov_iter *);
  int (__cdecl *migratepage)(address_space *, page *, page *, migrate_mode);
  bool (__cdecl *isolate_page)(page *, isolate_mode_t);
  void (__cdecl *putback_page)(page *);
  int (__cdecl *launder_page)(page *);
  int (__cdecl *is_partially_uptodate)(page *, unsigned __int64, unsigned __int64);
  void (__cdecl *is_dirty_writeback)(page *, bool *, bool *);
  int (__cdecl *error_remove_page)(address_space *, page *);
  int (__cdecl *swap_activate)(swap_info_struct *, file *, sector_t *);
  void (__cdecl *swap_deactivate)(file *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 address_space_operations.writepage int (__cdecl *)(page *, writeback_control *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 address_space_operations.readpage int (__cdecl *)(file *, page *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 address_space_operations.writepages int (__cdecl *)(address_space *, writeback_control *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 address_space_operations.set_page_dirty int (__cdecl *)(page *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 address_space_operations.readpages int (__cdecl *)(file *, address_space *, list_head *, unsigned int);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 address_space_operations.write_begin int (__cdecl *)(file *, address_space *, loff_t, unsigned int, unsigned int, page **, void **);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 address_space_operations.write_end int (__cdecl *)(file *, address_space *, loff_t, unsigned int, unsigned int, page *, void *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 address_space_operations.bmap sector_t (__cdecl *)(address_space *, sector_t);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 address_space_operations.invalidatepage void (__cdecl *)(page *, unsigned int, unsigned int);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 address_space_operations.releasepage int (__cdecl *)(page *, gfp_t);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 address_space_operations.freepage void (__cdecl *)(page *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 address_space_operations.direct_IO ssize_t (__cdecl *)(kiocb *, iov_iter *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 address_space_operations.migratepage int (__cdecl *)(address_space *, page *, page *, migrate_mode);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 address_space_operations.isolate_page bool (__cdecl *)(page *, isolate_mode_t);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 address_space_operations.putback_page void (__cdecl *)(page *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 address_space_operations.launder_page int (__cdecl *)(page *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 address_space_operations.is_partially_uptodate int (__cdecl *)(page *, unsigned __int64, unsigned __int64);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 address_space_operations.is_dirty_writeback void (__cdecl *)(page *, bool *, bool *);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 address_space_operations.error_remove_page int (__cdecl *)(address_space *, page *);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 address_space_operations.swap_activate int (__cdecl *)(swap_info_struct *, file *, sector_t *);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 address_space_operations.swap_deactivate void (__cdecl *)(file *);
//          00A8 effalign(8) sda=0 bits=0000 address_space_operations struct packalign=0

00000078 struct alarm
{
  timerqueue_node node;
  hrtimer timer;
  alarmtimer_restart (__cdecl *function)(alarm *, ktime_t);
  alarmtimer_type type;
  int state;
  void *data;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 alarm.node timerqueue_node;
//  1. 0020 0040 effalign(8) fda=0 bits=0000 alarm.timer hrtimer;
//  2. 0060 0008 effalign(8) fda=0 bits=0000 alarm.function alarmtimer_restart (__cdecl *)(alarm *, ktime_t);
//  3. 0068 0004 effalign(4) fda=0 bits=0000 alarm.type alarmtimer_type;
//  4. 006C 0004 effalign(4) fda=0 bits=0000 alarm.state int;
//  5. 0070 0008 effalign(8) fda=0 bits=0000 alarm.data void *;
//          0078 effalign(8) sda=0 bits=0000 alarm struct packalign=0

00000004 enum alarmtimer_restart : unsigned __int32
{
  ALARMTIMER_NORESTART = 0x0,
  ALARMTIMER_RESTART = 0x1,
};
00000004 enum alarmtimer_type : unsigned __int32
{
  ALARM_REALTIME = 0x0,
  ALARM_BOOTTIME = 0x1,
  ALARM_NUMTYPE = 0x2,
  ALARM_REALTIME_FREEZER = 0x3,
  ALARM_BOOTTIME_FREEZER = 0x4,
};
00000004 enum align_flags : unsigned __int32
{
  ALIGN_VA_32 = 0x1,
  ALIGN_VA_64 = 0x2,
};
0000000D struct __attribute__((packed)) alt_instr
{
  s32 instr_offset;
  s32 repl_offset;
  u16 cpuid;
  u8 instrlen;
  u8 replacementlen;
  u8 padlen;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 alt_instr.instr_offset s32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 alt_instr.repl_offset s32;
//  2. 0008 0002 effalign(1) fda=0 bits=0000 alt_instr.cpuid u16;
//  3. 000A 0001 effalign(1) fda=0 bits=0000 alt_instr.instrlen u8;
//  4. 000B 0001 effalign(1) fda=0 bits=0000 alt_instr.replacementlen u8;
//  5. 000C 0001 effalign(1) fda=0 bits=0000 alt_instr.padlen u8;
//          000D effalign(1) sda=0 bits=0040 alt_instr struct packalign=0

00000010 struct amba_id
{
  unsigned int id;
  unsigned int mask;
  void *data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 amba_id.id unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 amba_id.mask unsigned int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 amba_id.data void *;
//          0010 effalign(8) sda=0 bits=0000 amba_id struct packalign=0

FFFFFFFF struct anon_vma;
FFFFFFFF struct anon_vma_chain;
00000010 struct ap_device_id
{
  __u16 match_flags;
  __u8 dev_type;
  kernel_ulong_t driver_info;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 ap_device_id.match_flags __u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 ap_device_id.dev_type __u8;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 ap_device_id.driver_info kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 ap_device_id struct packalign=0

00000110 struct apic
{
  void (__cdecl *eoi_write)(u32, u32);
  void (__cdecl *native_eoi_write)(u32, u32);
  void (__cdecl *write)(u32, u32);
  u32 (__cdecl *read)(u32);
  void (*wait_icr_idle)(void);
  u32 (*safe_wait_icr_idle)(void);
  void (__cdecl *send_IPI)(int, int);
  void (__cdecl *send_IPI_mask)(const cpumask *, int);
  void (__cdecl *send_IPI_mask_allbutself)(const cpumask *, int);
  void (__cdecl *send_IPI_allbutself)(int);
  void (__cdecl *send_IPI_all)(int);
  void (__cdecl *send_IPI_self)(int);
  u32 dest_logical;
  u32 disable_esr;
  u32 irq_delivery_mode;
  u32 irq_dest_mode;
  u32 (__cdecl *calc_dest_apicid)(unsigned int);
  u64 (*icr_read)(void);
  void (__cdecl *icr_write)(u32, u32);
  int (*probe)(void);
  int (__cdecl *acpi_madt_oem_check)(char *, char *);
  int (__cdecl *apic_id_valid)(u32);
  int (*apic_id_registered)(void);
  bool (__cdecl *check_apicid_used)(physid_mask_t *, int);
  void (*init_apic_ldr)(void);
  void (__cdecl *ioapic_phys_id_map)(physid_mask_t *, physid_mask_t *);
  void (*setup_apic_routing)(void);
  int (__cdecl *cpu_present_to_apicid)(int);
  void (__cdecl *apicid_to_cpu_present)(int, physid_mask_t *);
  int (__cdecl *check_phys_apicid_present)(int);
  int (__cdecl *phys_pkg_id)(int, int);
  u32 (__cdecl *get_apic_id)(unsigned __int64);
  u32 (__cdecl *set_apic_id)(unsigned int);
  int (__cdecl *wakeup_secondary_cpu)(int, unsigned __int64);
  void (__cdecl *inquire_remote_apic)(int);
  char *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 apic.eoi_write void (__cdecl *)(u32, u32);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 apic.native_eoi_write void (__cdecl *)(u32, u32);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 apic.write void (__cdecl *)(u32, u32);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 apic.read u32 (__cdecl *)(u32);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 apic.wait_icr_idle void (*)(void);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 apic.safe_wait_icr_idle u32 (*)(void);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 apic.send_IPI void (__cdecl *)(int, int);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 apic.send_IPI_mask void (__cdecl *)(const cpumask *, int);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 apic.send_IPI_mask_allbutself void (__cdecl *)(const cpumask *, int);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 apic.send_IPI_allbutself void (__cdecl *)(int);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 apic.send_IPI_all void (__cdecl *)(int);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 apic.send_IPI_self void (__cdecl *)(int);
// 12. 0060 0004 effalign(4) fda=0 bits=0000 apic.dest_logical u32;
// 13. 0064 0004 effalign(4) fda=0 bits=0000 apic.disable_esr u32;
// 14. 0068 0004 effalign(4) fda=0 bits=0000 apic.irq_delivery_mode u32;
// 15. 006C 0004 effalign(4) fda=0 bits=0000 apic.irq_dest_mode u32;
// 16. 0070 0008 effalign(8) fda=0 bits=0000 apic.calc_dest_apicid u32 (__cdecl *)(unsigned int);
// 17. 0078 0008 effalign(8) fda=0 bits=0000 apic.icr_read u64 (*)(void);
// 18. 0080 0008 effalign(8) fda=0 bits=0000 apic.icr_write void (__cdecl *)(u32, u32);
// 19. 0088 0008 effalign(8) fda=0 bits=0000 apic.probe int (*)(void);
// 20. 0090 0008 effalign(8) fda=0 bits=0000 apic.acpi_madt_oem_check int (__cdecl *)(char *, char *);
// 21. 0098 0008 effalign(8) fda=0 bits=0000 apic.apic_id_valid int (__cdecl *)(u32);
// 22. 00A0 0008 effalign(8) fda=0 bits=0000 apic.apic_id_registered int (*)(void);
// 23. 00A8 0008 effalign(8) fda=0 bits=0000 apic.check_apicid_used bool (__cdecl *)(physid_mask_t *, int);
// 24. 00B0 0008 effalign(8) fda=0 bits=0000 apic.init_apic_ldr void (*)(void);
// 25. 00B8 0008 effalign(8) fda=0 bits=0000 apic.ioapic_phys_id_map void (__cdecl *)(physid_mask_t *, physid_mask_t *);
// 26. 00C0 0008 effalign(8) fda=0 bits=0000 apic.setup_apic_routing void (*)(void);
// 27. 00C8 0008 effalign(8) fda=0 bits=0000 apic.cpu_present_to_apicid int (__cdecl *)(int);
// 28. 00D0 0008 effalign(8) fda=0 bits=0000 apic.apicid_to_cpu_present void (__cdecl *)(int, physid_mask_t *);
// 29. 00D8 0008 effalign(8) fda=0 bits=0000 apic.check_phys_apicid_present int (__cdecl *)(int);
// 30. 00E0 0008 effalign(8) fda=0 bits=0000 apic.phys_pkg_id int (__cdecl *)(int, int);
// 31. 00E8 0008 effalign(8) fda=0 bits=0000 apic.get_apic_id u32 (__cdecl *)(unsigned __int64);
// 32. 00F0 0008 effalign(8) fda=0 bits=0000 apic.set_apic_id u32 (__cdecl *)(unsigned int);
// 33. 00F8 0008 effalign(8) fda=0 bits=0000 apic.wakeup_secondary_cpu int (__cdecl *)(int, unsigned __int64);
// 34. 0100 0008 effalign(8) fda=0 bits=0000 apic.inquire_remote_apic void (__cdecl *)(int);
// 35. 0108 0008 effalign(8) fda=0 bits=0000 apic.name char *;
//          0110 effalign(8) sda=0 bits=0000 apic struct packalign=0

00000004 enum apic_intr_mode_id : unsigned __int32
{
  APIC_PIC = 0x0,
  APIC_VIRTUAL_WIRE = 0x1,
  APIC_VIRTUAL_WIRE_NO_CONFIG = 0x2,
  APIC_SYMMETRIC_IO = 0x3,
  APIC_SYMMETRIC_IO_NO_ROUTING = 0x4,
};
00000014 struct apm_bios_info
{
  __u16 version;
  __u16 cseg;
  __u32 offset;
  __u16 cseg_16;
  __u16 dseg;
  __u16 flags;
  __u16 cseg_len;
  __u16 cseg_16_len;
  __u16 dseg_len;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 apm_bios_info.version __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 apm_bios_info.cseg __u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 apm_bios_info.offset __u32;
//  3. 0008 0002 effalign(2) fda=0 bits=0000 apm_bios_info.cseg_16 __u16;
//  4. 000A 0002 effalign(2) fda=0 bits=0000 apm_bios_info.dseg __u16;
//  5. 000C 0002 effalign(2) fda=0 bits=0000 apm_bios_info.flags __u16;
//  6. 000E 0002 effalign(2) fda=0 bits=0000 apm_bios_info.cseg_len __u16;
//  7. 0010 0002 effalign(2) fda=0 bits=0000 apm_bios_info.cseg_16_len __u16;
//  8. 0012 0002 effalign(2) fda=0 bits=0000 apm_bios_info.dseg_len __u16;
//          0014 effalign(4) sda=0 bits=0000 apm_bios_info struct packalign=0

00000002 typedef unsigned __int16 apm_event_t;
00000002 typedef unsigned __int16 apm_eventinfo_t;
00000030 struct apm_info
{
  apm_bios_info bios;
  unsigned __int16 connection_version;
  int get_power_status_broken;
  int get_power_status_swabinminutes;
  int allow_ints;
  int forbid_idle;
  int realmode_power_off;
  int disabled;
};
//  0. 0000 0014 effalign(4) fda=0 bits=0000 apm_info.bios apm_bios_info;
//  1. 0014 0002 effalign(2) fda=0 bits=0000 apm_info.connection_version unsigned __int16;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 apm_info.get_power_status_broken int;
//  3. 001C 0004 effalign(4) fda=0 bits=0000 apm_info.get_power_status_swabinminutes int;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 apm_info.allow_ints int;
//  5. 0024 0004 effalign(4) fda=0 bits=0000 apm_info.forbid_idle int;
//  6. 0028 0004 effalign(4) fda=0 bits=0000 apm_info.realmode_power_off int;
//  7. 002C 0004 effalign(4) fda=0 bits=0000 apm_info.disabled int;
//          0030 effalign(4) sda=0 bits=0000 apm_info struct packalign=0

00000014 struct apple_properties_protocol_32_t
{
  u32 version;
  u32 get;
  u32 set;
  u32 del;
  u32 get_all;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 apple_properties_protocol_32_t.version u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 apple_properties_protocol_32_t.get u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 apple_properties_protocol_32_t.set u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 apple_properties_protocol_32_t.del u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 apple_properties_protocol_32_t.get_all u32;
//          0014 effalign(4) sda=0 bits=0000 apple_properties_protocol_32_t struct packalign=0

00000028 struct apple_properties_protocol_64_t
{
  u64 version;
  u64 get;
  u64 set;
  u64 del;
  u64 get_all;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 apple_properties_protocol_64_t.version u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 apple_properties_protocol_64_t.get u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 apple_properties_protocol_64_t.set u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 apple_properties_protocol_64_t.del u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 apple_properties_protocol_64_t.get_all u64;
//          0028 effalign(8) sda=0 bits=0000 apple_properties_protocol_64_t struct packalign=0

00000038 struct apr_device_id
{
  char name[32];
  __u32 domain_id;
  __u32 svc_id;
  __u32 svc_version;
  kernel_ulong_t driver_data;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 apr_device_id.name char[32];
//  1. 0020 0004 effalign(4) fda=0 bits=0000 apr_device_id.domain_id __u32;
//  2. 0024 0004 effalign(4) fda=0 bits=0000 apr_device_id.svc_id __u32;
//  3. 0028 0004 effalign(4) fda=0 bits=0000 apr_device_id.svc_version __u32;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 apr_device_id.driver_data kernel_ulong_t;
//          0038 effalign(8) sda=0 bits=0000 apr_device_id struct packalign=0

00000008 typedef qrwlock arch_rwlock_t;
FFFFFFFF struct arch_spinlock;
00000004 typedef qspinlock arch_spinlock_t;
00000400 struct arch_tlbflush_unmap_batch
{
  cpumask cpumask;
};
//  0. 0000 0400 effalign(8) fda=0 bits=0000 arch_tlbflush_unmap_batch.cpumask cpumask;
//          0400 effalign(8) sda=0 bits=0000 arch_tlbflush_unmap_batch struct packalign=0

00000020 struct arch_uprobe
{
  union
  {
    u8 insn[16];
    u8 ixol[16];
  };
  const uprobe_xol_ops *ops;
  union
  {
    $86C47FF540A4A51F0C907547963D9CB9 branch;
    $28773E666A9823AEB9EC03C7A199C944 defparam;
    $0A3F26CD0DA2348788F16A085A72286B push;
  };
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 arch_uprobe.arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322 arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 arch_uprobe.ops const uprobe_xol_ops *;
//  2. 0018 0008 effalign(4) fda=0 bits=0000 arch_uprobe.arch_uprobe::$84EF217DD097CD6D923D268985E82268 arch_uprobe::$84EF217DD097CD6D923D268985E82268;
//          001E unpadded_size
//          0020 effalign(8) sda=0 bits=0000 arch_uprobe struct packalign=0

00000008 union arch_uprobe::$84EF217DD097CD6D923D268985E82268
{
  $86C47FF540A4A51F0C907547963D9CB9 branch;
  $28773E666A9823AEB9EC03C7A199C944 defparam;
  $0A3F26CD0DA2348788F16A085A72286B push;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 arch_uprobe::$84EF217DD097CD6D923D268985E82268.branch $86C47FF540A4A51F0C907547963D9CB9;
//  1. 0000 0002 effalign(1) fda=0 bits=0000 arch_uprobe::$84EF217DD097CD6D923D268985E82268.defparam $28773E666A9823AEB9EC03C7A199C944;
//  2. 0000 0002 effalign(1) fda=0 bits=0000 arch_uprobe::$84EF217DD097CD6D923D268985E82268.push $0A3F26CD0DA2348788F16A085A72286B;
//          0006 unpadded_size
//          0008 effalign(4) sda=0 bits=0000 arch_uprobe::$84EF217DD097CD6D923D268985E82268 union packalign=0

00000010 union arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322
{
  u8 insn[16];
  u8 ixol[16];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322.insn u8[16];
//  1. 0000 0010 effalign(1) fda=0 bits=0000 arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322.ixol u8[16];
//          0010 effalign(1) sda=0 bits=0000 arch_uprobe::$AFB1F4B93D77334BBE4192D6DD078322 union packalign=0

00000010 struct arch_uprobe_task
{
  unsigned __int64 saved_scratch_register;
  unsigned int saved_trap_nr;
  unsigned int saved_tf;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 arch_uprobe_task.saved_scratch_register unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 arch_uprobe_task.saved_trap_nr unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 arch_uprobe_task.saved_tf unsigned int;
//          0010 effalign(8) sda=0 bits=0000 arch_uprobe_task struct packalign=0

00000010 struct assoc_array
{
  assoc_array_ptr *root;
  unsigned __int64 nr_leaves_on_tree;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 assoc_array.root assoc_array_ptr *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 assoc_array.nr_leaves_on_tree unsigned __int64;
//          0010 effalign(8) sda=0 bits=0000 assoc_array struct packalign=0

FFFFFFFF struct assoc_array_edit;
00000028 struct assoc_array_ops
{
  unsigned __int64 (__cdecl *get_key_chunk)(const void *, int);
  unsigned __int64 (__cdecl *get_object_key_chunk)(const void *, int);
  bool (__cdecl *compare_object)(const void *, const void *);
  int (__cdecl *diff_objects)(const void *, const void *);
  void (__cdecl *free_object)(void *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 assoc_array_ops.get_key_chunk unsigned __int64 (__cdecl *)(const void *, int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 assoc_array_ops.get_object_key_chunk unsigned __int64 (__cdecl *)(const void *, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 assoc_array_ops.compare_object bool (__cdecl *)(const void *, const void *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 assoc_array_ops.diff_objects int (__cdecl *)(const void *, const void *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 assoc_array_ops.free_object void (__cdecl *)(void *);
//          0028 effalign(8) sda=0 bits=0000 assoc_array_ops struct packalign=0

FFFFFFFF struct assoc_array_ptr;
00000008 struct atomic64_t
{
  s64 counter;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 atomic64_t.counter s64;
//          0008 effalign(8) sda=0 bits=0000 atomic64_t struct packalign=0

00000008 typedef atomic64_t atomic_long_t;
00000010 struct atomic_notifier_head
{
  spinlock_t lock;
  notifier_block *head;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 atomic_notifier_head.lock spinlock_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 atomic_notifier_head.head notifier_block *;
//          0010 effalign(8) sda=0 bits=0000 atomic_notifier_head struct packalign=0

00000004 struct atomic_t
{
  int counter;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 atomic_t.counter int;
//          0004 effalign(4) sda=0 bits=0000 atomic_t struct packalign=0

00000010 struct attribute
{
  const char *name;
  umode_t mode;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 attribute.name const char *;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 attribute.mode umode_t;
//          000A unpadded_size
//          0010 effalign(8) sda=0 bits=0000 attribute struct packalign=0

00000028 struct attribute_group
{
  const char *name;
  umode_t (__cdecl *is_visible)(kobject *, attribute *, int);
  umode_t (__cdecl *is_bin_visible)(kobject *, bin_attribute *, int);
  attribute **attrs;
  bin_attribute **bin_attrs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 attribute_group.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 attribute_group.is_visible umode_t (__cdecl *)(kobject *, attribute *, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 attribute_group.is_bin_visible umode_t (__cdecl *)(kobject *, bin_attribute *, int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 attribute_group.attrs attribute **;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 attribute_group.bin_attrs bin_attribute **;
//          0028 effalign(8) sda=0 bits=0000 attribute_group struct packalign=0

FFFFFFFF struct audit_context;
FFFFFFFF struct audit_names;
00000400 struct __attribute__((packed)) avx_512_hi16_state
{
  reg_512_bit hi16_zmm[16];
};
//  0. 0000 0400 effalign(1) fda=0 bits=0000 avx_512_hi16_state.hi16_zmm reg_512_bit[16];
//          0400 effalign(1) sda=0 bits=0040 avx_512_hi16_state struct packalign=0

00000040 struct __attribute__((packed)) avx_512_opmask_state
{
  u64 opmask_reg[8];
};
//  0. 0000 0040 effalign(1) fda=0 bits=0000 avx_512_opmask_state.opmask_reg u64[8];
//          0040 effalign(1) sda=0 bits=0040 avx_512_opmask_state struct packalign=0

00000200 struct __attribute__((packed)) avx_512_zmm_uppers_state
{
  reg_256_bit zmm_upper[16];
};
//  0. 0000 0200 effalign(1) fda=0 bits=0000 avx_512_zmm_uppers_state.zmm_upper reg_256_bit[16];
//          0200 effalign(1) sda=0 bits=0040 avx_512_zmm_uppers_state struct packalign=0

00000438 struct backing_dev_info
{
  u64 id;
  rb_node rb_node;
  list_head bdi_list;
  unsigned __int64 ra_pages;
  unsigned __int64 io_pages;
  congested_fn *congested_fn;
  void *congested_data;
  const char *name;
  kref refcnt;
  unsigned int capabilities;
  unsigned int min_ratio;
  unsigned int max_ratio;
  unsigned int max_prop_frac;
  atomic_long_t tot_write_bandwidth;
  bdi_writeback wb;
  list_head wb_list;
  xarray cgwb_tree;
  rb_root cgwb_congested_tree;
  mutex cgwb_release_mutex;
  rw_semaphore wb_switch_rwsem;
  wait_queue_head_t wb_waitq;
  device *dev;
  char dev_name[64];
  device *owner;
  timer_list laptop_mode_wb_timer;
  dentry *debug_dir;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 backing_dev_info.id u64;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 backing_dev_info.rb_node rb_node;
//  2. 0020 0010 effalign(8) fda=0 bits=0000 backing_dev_info.bdi_list list_head;
//  3. 0030 0008 effalign(8) fda=0 bits=0000 backing_dev_info.ra_pages unsigned __int64;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 backing_dev_info.io_pages unsigned __int64;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 backing_dev_info.congested_fn congested_fn *;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 backing_dev_info.congested_data void *;
//  7. 0050 0008 effalign(8) fda=0 bits=0000 backing_dev_info.name const char *;
//  8. 0058 0004 effalign(4) fda=0 bits=0000 backing_dev_info.refcnt kref;
//  9. 005C 0004 effalign(4) fda=0 bits=0000 backing_dev_info.capabilities unsigned int;
// 10. 0060 0004 effalign(4) fda=0 bits=0000 backing_dev_info.min_ratio unsigned int;
// 11. 0064 0004 effalign(4) fda=0 bits=0000 backing_dev_info.max_ratio unsigned int;
// 12. 0068 0004 effalign(4) fda=0 bits=0000 backing_dev_info.max_prop_frac unsigned int;
// 13. 0070 0008 effalign(8) fda=0 bits=0000 backing_dev_info.tot_write_bandwidth atomic_long_t;
// 14. 0078 02B8 effalign(8) fda=0 bits=0000 backing_dev_info.wb bdi_writeback;
// 15. 0330 0010 effalign(8) fda=0 bits=0000 backing_dev_info.wb_list list_head;
// 16. 0340 0010 effalign(8) fda=0 bits=0000 backing_dev_info.cgwb_tree xarray;
// 17. 0350 0008 effalign(8) fda=0 bits=0000 backing_dev_info.cgwb_congested_tree rb_root;
// 18. 0358 0020 effalign(8) fda=0 bits=0000 backing_dev_info.cgwb_release_mutex mutex;
// 19. 0378 0028 effalign(8) fda=0 bits=0000 backing_dev_info.wb_switch_rwsem rw_semaphore;
// 20. 03A0 0018 effalign(8) fda=0 bits=0000 backing_dev_info.wb_waitq wait_queue_head_t;
// 21. 03B8 0008 effalign(8) fda=0 bits=0000 backing_dev_info.dev device *;
// 22. 03C0 0040 effalign(1) fda=0 bits=0000 backing_dev_info.dev_name char[64];
// 23. 0400 0008 effalign(8) fda=0 bits=0000 backing_dev_info.owner device *;
// 24. 0408 0028 effalign(8) fda=0 bits=0000 backing_dev_info.laptop_mode_wb_timer timer_list;
// 25. 0430 0008 effalign(8) fda=0 bits=0000 backing_dev_info.debug_dir dentry *;
//          0438 effalign(8) sda=0 bits=0000 backing_dev_info struct packalign=0

FFFFFFFF struct badblocks;
00000006 struct __attribute__((packed)) __attribute__((aligned(2))) bcma_device_id
{
  __u16 manuf;
  __u16 id;
  __u8 rev;
  __u8 class;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 bcma_device_id.manuf __u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 bcma_device_id.id __u16;
//  2. 0004 0001 effalign(1) fda=0 bits=0000 bcma_device_id.rev __u8;
//  3. 0005 0001 effalign(1) fda=0 bits=0000 bcma_device_id.class __u8;
//          0006 effalign(2) sda=2 bits=0040 bcma_device_id struct packalign=0

000002B8 struct bdi_writeback
{
  backing_dev_info *bdi;
  unsigned __int64 state;
  unsigned __int64 last_old_flush;
  list_head b_dirty;
  list_head b_io;
  list_head b_more_io;
  list_head b_dirty_time;
  spinlock_t list_lock;
  percpu_counter stat[4];
  bdi_writeback_congested *congested;
  unsigned __int64 bw_time_stamp;
  unsigned __int64 dirtied_stamp;
  unsigned __int64 written_stamp;
  unsigned __int64 write_bandwidth;
  unsigned __int64 avg_write_bandwidth;
  unsigned __int64 dirty_ratelimit;
  unsigned __int64 balanced_dirty_ratelimit;
  fprop_local_percpu completions;
  int dirty_exceeded;
  wb_reason start_all_reason;
  spinlock_t work_lock;
  list_head work_list;
  delayed_work dwork;
  unsigned __int64 dirty_sleep;
  list_head bdi_node;
  percpu_ref refcnt;
  fprop_local_percpu memcg_completions;
  cgroup_subsys_state *memcg_css;
  cgroup_subsys_state *blkcg_css;
  list_head memcg_node;
  list_head blkcg_node;
  union
  {
    work_struct release_work;
    callback_head rcu;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bdi_writeback.bdi backing_dev_info *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bdi_writeback.state unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bdi_writeback.last_old_flush unsigned __int64;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 bdi_writeback.b_dirty list_head;
//  4. 0028 0010 effalign(8) fda=0 bits=0000 bdi_writeback.b_io list_head;
//  5. 0038 0010 effalign(8) fda=0 bits=0000 bdi_writeback.b_more_io list_head;
//  6. 0048 0010 effalign(8) fda=0 bits=0000 bdi_writeback.b_dirty_time list_head;
//  7. 0058 0004 effalign(4) fda=0 bits=0000 bdi_writeback.list_lock spinlock_t;
//  8. 0060 00A0 effalign(8) fda=0 bits=0000 bdi_writeback.stat percpu_counter[4];
//  9. 0100 0008 effalign(8) fda=0 bits=0000 bdi_writeback.congested bdi_writeback_congested *;
// 10. 0108 0008 effalign(8) fda=0 bits=0000 bdi_writeback.bw_time_stamp unsigned __int64;
// 11. 0110 0008 effalign(8) fda=0 bits=0000 bdi_writeback.dirtied_stamp unsigned __int64;
// 12. 0118 0008 effalign(8) fda=0 bits=0000 bdi_writeback.written_stamp unsigned __int64;
// 13. 0120 0008 effalign(8) fda=0 bits=0000 bdi_writeback.write_bandwidth unsigned __int64;
// 14. 0128 0008 effalign(8) fda=0 bits=0000 bdi_writeback.avg_write_bandwidth unsigned __int64;
// 15. 0130 0008 effalign(8) fda=0 bits=0000 bdi_writeback.dirty_ratelimit unsigned __int64;
// 16. 0138 0008 effalign(8) fda=0 bits=0000 bdi_writeback.balanced_dirty_ratelimit unsigned __int64;
// 17. 0140 0030 effalign(8) fda=0 bits=0000 bdi_writeback.completions fprop_local_percpu;
// 18. 0170 0004 effalign(4) fda=0 bits=0000 bdi_writeback.dirty_exceeded int;
// 19. 0174 0004 effalign(4) fda=0 bits=0000 bdi_writeback.start_all_reason wb_reason;
// 20. 0178 0004 effalign(4) fda=0 bits=0000 bdi_writeback.work_lock spinlock_t;
// 21. 0180 0010 effalign(8) fda=0 bits=0000 bdi_writeback.work_list list_head;
// 22. 0190 0058 effalign(8) fda=0 bits=0000 bdi_writeback.dwork delayed_work;
// 23. 01E8 0008 effalign(8) fda=0 bits=0000 bdi_writeback.dirty_sleep unsigned __int64;
// 24. 01F0 0010 effalign(8) fda=0 bits=0000 bdi_writeback.bdi_node list_head;
// 25. 0200 0038 effalign(8) fda=0 bits=0000 bdi_writeback.refcnt percpu_ref;
// 26. 0238 0030 effalign(8) fda=0 bits=0000 bdi_writeback.memcg_completions fprop_local_percpu;
// 27. 0268 0008 effalign(8) fda=0 bits=0000 bdi_writeback.memcg_css cgroup_subsys_state *;
// 28. 0270 0008 effalign(8) fda=0 bits=0000 bdi_writeback.blkcg_css cgroup_subsys_state *;
// 29. 0278 0010 effalign(8) fda=0 bits=0000 bdi_writeback.memcg_node list_head;
// 30. 0288 0010 effalign(8) fda=0 bits=0000 bdi_writeback.blkcg_node list_head;
// 31. 0298 0020 effalign(8) fda=0 bits=0000 bdi_writeback.bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4 bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4;
//          02B8 effalign(8) sda=0 bits=0000 bdi_writeback struct packalign=0

00000020 union bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4
{
  work_struct release_work;
  callback_head rcu;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4.release_work work_struct;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4.rcu callback_head;
//          0020 effalign(8) sda=0 bits=0000 bdi_writeback::$B42ACB336AA691C42998BF00149FAFF4 union packalign=0

00000038 struct bdi_writeback_congested
{
  unsigned __int64 state;
  refcount_t refcnt;
  backing_dev_info *__bdi;
  int blkcg_id;
  rb_node rb_node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bdi_writeback_congested.state unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bdi_writeback_congested.refcnt refcount_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bdi_writeback_congested.__bdi backing_dev_info *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 bdi_writeback_congested.blkcg_id int;
//  4. 0020 0018 effalign(8) fda=0 bits=0000 bdi_writeback_congested.rb_node rb_node;
//          0038 effalign(8) sda=0 bits=0000 bdi_writeback_congested struct packalign=0

00000038 struct bin_attribute
{
  attribute attr;
  size_t size;
  void *private;
  ssize_t (__cdecl *read)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
  ssize_t (__cdecl *write)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
  int (__cdecl *mmap)(file *, kobject *, bin_attribute *, vm_area_struct *);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 bin_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 bin_attribute.size size_t;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 bin_attribute.private void *;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 bin_attribute.read ssize_t (__cdecl *)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 bin_attribute.write ssize_t (__cdecl *)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
//  5. 0030 0008 effalign(8) fda=0 bits=0000 bin_attribute.mmap int (__cdecl *)(file *, kobject *, bin_attribute *, vm_area_struct *);
//          0038 effalign(8) sda=0 bits=0000 bin_attribute struct packalign=0

00000088 struct bio
{
  bio *bi_next;
  gendisk *bi_disk;
  unsigned int bi_opf;
  unsigned __int16 bi_flags;
  unsigned __int16 bi_ioprio;
  unsigned __int16 bi_write_hint;
  blk_status_t bi_status;
  u8 bi_partno;
  bvec_iter bi_iter;
  atomic_t __bi_remaining;
  bio_end_io_t *bi_end_io;
  void *bi_private;
  blkcg_gq *bi_blkg;
  bio_issue bi_issue;
  u64 bi_iocost_cost;
  union
  {
    bio_integrity_payload *bi_integrity;
  };
  unsigned __int16 bi_vcnt;
  unsigned __int16 bi_max_vecs;
  atomic_t __bi_cnt;
  bio_vec *bi_io_vec;
  bio_set *bi_pool;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio.bi_next bio *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bio.bi_disk gendisk *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 bio.bi_opf unsigned int;
//  3. 0014 0002 effalign(2) fda=0 bits=0000 bio.bi_flags unsigned __int16;
//  4. 0016 0002 effalign(2) fda=0 bits=0000 bio.bi_ioprio unsigned __int16;
//  5. 0018 0002 effalign(2) fda=0 bits=0000 bio.bi_write_hint unsigned __int16;
//  6. 001A 0001 effalign(1) fda=0 bits=0000 bio.bi_status blk_status_t;
//  7. 001B 0001 effalign(1) fda=0 bits=0000 bio.bi_partno u8;
//  8. 0020 0018 effalign(8) fda=0 bits=0000 bio.bi_iter bvec_iter;
//  9. 0038 0004 effalign(4) fda=0 bits=0000 bio.__bi_remaining atomic_t;
// 10. 0040 0008 effalign(8) fda=0 bits=0000 bio.bi_end_io bio_end_io_t *;
// 11. 0048 0008 effalign(8) fda=0 bits=0000 bio.bi_private void *;
// 12. 0050 0008 effalign(8) fda=0 bits=0000 bio.bi_blkg blkcg_gq *;
// 13. 0058 0008 effalign(8) fda=0 bits=0000 bio.bi_issue bio_issue;
// 14. 0060 0008 effalign(8) fda=0 bits=0000 bio.bi_iocost_cost u64;
// 15. 0068 0008 effalign(8) fda=0 bits=0000 bio.bio::$291AD3FA4559CB9C9D589415BF07F077 bio::$291AD3FA4559CB9C9D589415BF07F077;
// 16. 0070 0002 effalign(2) fda=0 bits=0000 bio.bi_vcnt unsigned __int16;
// 17. 0072 0002 effalign(2) fda=0 bits=0000 bio.bi_max_vecs unsigned __int16;
// 18. 0074 0004 effalign(4) fda=0 bits=0000 bio.__bi_cnt atomic_t;
// 19. 0078 0008 effalign(8) fda=0 bits=0000 bio.bi_io_vec bio_vec *;
// 20. 0080 0008 effalign(8) fda=0 bits=0000 bio.bi_pool bio_set *;
//          0088 effalign(8) sda=0 bits=0000 bio struct packalign=0

00000008 union bio::$291AD3FA4559CB9C9D589415BF07F077
{
  bio_integrity_payload *bi_integrity;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio::$291AD3FA4559CB9C9D589415BF07F077.bi_integrity bio_integrity_payload *;
//          0008 effalign(8) sda=0 bits=0000 bio::$291AD3FA4559CB9C9D589415BF07F077 union packalign=0

FFFFFFFF typedef void __cdecl bio_end_io_t(bio *);
00000068 struct bio_integrity_payload
{
  bio *bip_bio;
  bvec_iter bip_iter;
  unsigned __int16 bip_slab;
  unsigned __int16 bip_vcnt;
  unsigned __int16 bip_max_vcnt;
  unsigned __int16 bip_flags;
  bvec_iter bio_iter;
  work_struct bip_work;
  bio_vec *bip_vec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio_integrity_payload.bip_bio bio *;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 bio_integrity_payload.bip_iter bvec_iter;
//  2. 0020 0002 effalign(2) fda=0 bits=0000 bio_integrity_payload.bip_slab unsigned __int16;
//  3. 0022 0002 effalign(2) fda=0 bits=0000 bio_integrity_payload.bip_vcnt unsigned __int16;
//  4. 0024 0002 effalign(2) fda=0 bits=0000 bio_integrity_payload.bip_max_vcnt unsigned __int16;
//  5. 0026 0002 effalign(2) fda=0 bits=0000 bio_integrity_payload.bip_flags unsigned __int16;
//  6. 0028 0018 effalign(8) fda=0 bits=0000 bio_integrity_payload.bio_iter bvec_iter;
//  7. 0040 0020 effalign(8) fda=0 bits=0000 bio_integrity_payload.bip_work work_struct;
//  8. 0060 0008 effalign(8) fda=0 bits=0000 bio_integrity_payload.bip_vec bio_vec *;
//          0068 effalign(8) sda=0 bits=0000 bio_integrity_payload struct packalign=0

00000008 struct bio_issue
{
  u64 value;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio_issue.value u64;
//          0008 effalign(8) sda=0 bits=0000 bio_issue struct packalign=0

00000010 struct bio_list
{
  bio *head;
  bio *tail;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio_list.head bio *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bio_list.tail bio *;
//          0010 effalign(8) sda=0 bits=0000 bio_list struct packalign=0

00000170 struct bio_set
{
  kmem_cache *bio_slab;
  unsigned int front_pad;
  mempool_t bio_pool;
  mempool_t bvec_pool;
  mempool_t bio_integrity_pool;
  mempool_t bvec_integrity_pool;
  spinlock_t rescue_lock;
  bio_list rescue_list;
  work_struct rescue_work;
  workqueue_struct *rescue_workqueue;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio_set.bio_slab kmem_cache *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bio_set.front_pad unsigned int;
//  2. 0010 0048 effalign(8) fda=0 bits=0000 bio_set.bio_pool mempool_t;
//  3. 0058 0048 effalign(8) fda=0 bits=0000 bio_set.bvec_pool mempool_t;
//  4. 00A0 0048 effalign(8) fda=0 bits=0000 bio_set.bio_integrity_pool mempool_t;
//  5. 00E8 0048 effalign(8) fda=0 bits=0000 bio_set.bvec_integrity_pool mempool_t;
//  6. 0130 0004 effalign(4) fda=0 bits=0000 bio_set.rescue_lock spinlock_t;
//  7. 0138 0010 effalign(8) fda=0 bits=0000 bio_set.rescue_list bio_list;
//  8. 0148 0020 effalign(8) fda=0 bits=0000 bio_set.rescue_work work_struct;
//  9. 0168 0008 effalign(8) fda=0 bits=0000 bio_set.rescue_workqueue workqueue_struct *;
//          0170 effalign(8) sda=0 bits=0000 bio_set struct packalign=0

00000010 struct bio_vec
{
  page *bv_page;
  unsigned int bv_len;
  unsigned int bv_offset;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bio_vec.bv_page page *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bio_vec.bv_len unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 bio_vec.bv_offset unsigned int;
//          0010 effalign(8) sda=0 bits=0000 bio_vec struct packalign=0

00000018 struct biovec_slab
{
  int nr_vecs;
  char *name;
  kmem_cache *slab;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 biovec_slab.nr_vecs int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 biovec_slab.name char *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 biovec_slab.slab kmem_cache *;
//          0018 effalign(8) sda=0 bits=0000 biovec_slab struct packalign=0

00000004 enum bip_flags : unsigned __int32
{
  BIP_BLOCK_INTEGRITY = 0x1,
  BIP_MAPPED_INTEGRITY = 0x2,
  BIP_CTRL_NOCHECK = 0x4,
  BIP_DISK_NOCHECK = 0x8,
  BIP_IP_CHECKSUM = 0x10,
};
00000004 enum blk_default_limits : unsigned __int32
{
  BLK_MAX_SEGMENTS = 0x80,
  BLK_SAFE_MAX_SECTORS = 0xFF,
  BLK_DEF_MAX_SECTORS = 0xA00,
  BLK_MAX_SEGMENT_SIZE = 0x10000,
  BLK_SEG_BOUNDARY_MASK = 0xFFFFFFFF,
};
00000004 enum blk_eh_timer_return : unsigned __int32
{
  BLK_EH_DONE = 0x0,
  BLK_EH_RESET_TIMER = 0x1,
};
FFFFFFFF struct blk_flush_queue;
00000010 struct blk_integrity
{
  const blk_integrity_profile *profile;
  unsigned __int8 flags;
  unsigned __int8 tuple_size;
  unsigned __int8 interval_exp;
  unsigned __int8 tag_size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_integrity.profile const blk_integrity_profile *;
//  1. 0008 0001 effalign(1) fda=0 bits=0000 blk_integrity.flags unsigned __int8;
//  2. 0009 0001 effalign(1) fda=0 bits=0000 blk_integrity.tuple_size unsigned __int8;
//  3. 000A 0001 effalign(1) fda=0 bits=0000 blk_integrity.interval_exp unsigned __int8;
//  4. 000B 0001 effalign(1) fda=0 bits=0000 blk_integrity.tag_size unsigned __int8;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 blk_integrity struct packalign=0

00000004 enum blk_integrity_flags : unsigned __int32
{
  BLK_INTEGRITY_VERIFY = 0x1,
  BLK_INTEGRITY_GENERATE = 0x2,
  BLK_INTEGRITY_DEVICE_CAPABLE = 0x4,
  BLK_INTEGRITY_IP_CHECKSUM = 0x8,
};
00000028 struct blk_integrity_iter
{
  void *prot_buf;
  void *data_buf;
  sector_t seed;
  unsigned int data_size;
  unsigned __int16 interval;
  const char *disk_name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_integrity_iter.prot_buf void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 blk_integrity_iter.data_buf void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 blk_integrity_iter.seed sector_t;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 blk_integrity_iter.data_size unsigned int;
//  4. 001C 0002 effalign(2) fda=0 bits=0000 blk_integrity_iter.interval unsigned __int16;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 blk_integrity_iter.disk_name const char *;
//          0028 effalign(8) sda=0 bits=0000 blk_integrity_iter struct packalign=0

00000028 struct blk_integrity_profile
{
  integrity_processing_fn *generate_fn;
  integrity_processing_fn *verify_fn;
  integrity_prepare_fn *prepare_fn;
  integrity_complete_fn *complete_fn;
  const char *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_integrity_profile.generate_fn integrity_processing_fn *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 blk_integrity_profile.verify_fn integrity_processing_fn *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 blk_integrity_profile.prepare_fn integrity_prepare_fn *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 blk_integrity_profile.complete_fn integrity_complete_fn *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 blk_integrity_profile.name const char *;
//          0028 effalign(8) sda=0 bits=0000 blk_integrity_profile struct packalign=0

FFFFFFFF struct blk_mq_alloc_data;
FFFFFFFF struct blk_mq_ctx;
FFFFFFFF struct blk_mq_debugfs_attr;
FFFFFFFF struct blk_mq_hw_ctx;
FFFFFFFF struct blk_mq_ops;
00000004 typedef __u32 blk_mq_req_flags_t;
FFFFFFFF struct blk_mq_tag_set;
00000028 struct blk_plug
{
  list_head mq_list;
  list_head cb_list;
  unsigned __int16 rq_count;
  bool multiple_queues;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 blk_plug.mq_list list_head;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 blk_plug.cb_list list_head;
//  2. 0020 0002 effalign(2) fda=0 bits=0000 blk_plug.rq_count unsigned __int16;
//  3. 0022 0001 effalign(1) fda=0 bits=0000 blk_plug.multiple_queues bool;
//          0023 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 blk_plug struct packalign=0

00000020 struct blk_plug_cb
{
  list_head list;
  blk_plug_cb_fn callback;
  void *data;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 blk_plug_cb.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 blk_plug_cb.callback blk_plug_cb_fn;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 blk_plug_cb.data void *;
//          0020 effalign(8) sda=0 bits=0000 blk_plug_cb struct packalign=0

00000008 typedef void (__cdecl *blk_plug_cb_fn)(blk_plug_cb *, bool);
00000004 typedef unsigned int blk_qc_t;
FFFFFFFF struct blk_queue_ctx;
00000004 enum blk_queue_state : unsigned __int32
{
  Queue_down = 0x0,
  Queue_up = 0x1,
};
FFFFFFFF struct blk_queue_stats;
00000028 struct blk_rq_stat
{
  u64 mean;
  u64 min;
  u64 max;
  u32 nr_samples;
  u64 batch;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_rq_stat.mean u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 blk_rq_stat.min u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 blk_rq_stat.max u64;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 blk_rq_stat.nr_samples u32;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 blk_rq_stat.batch u64;
//          0028 effalign(8) sda=0 bits=0000 blk_rq_stat struct packalign=0

FFFFFFFF struct blk_stat_callback;
00000001 typedef u8 blk_status_t;
FFFFFFFF struct blk_trace;
00000040 struct blk_zone
{
  __u64 start;
  __u64 len;
  __u64 wp;
  __u8 type;
  __u8 cond;
  __u8 non_seq;
  __u8 reset;
  __u8 reserved[36];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_zone.start __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 blk_zone.len __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 blk_zone.wp __u64;
//  3. 0018 0001 effalign(1) fda=0 bits=0000 blk_zone.type __u8;
//  4. 0019 0001 effalign(1) fda=0 bits=0000 blk_zone.cond __u8;
//  5. 001A 0001 effalign(1) fda=0 bits=0000 blk_zone.non_seq __u8;
//  6. 001B 0001 effalign(1) fda=0 bits=0000 blk_zone.reset __u8;
//  7. 001C 0024 effalign(1) fda=0 bits=0000 blk_zone.reserved __u8[36];
//          0040 effalign(8) sda=0 bits=0000 blk_zone struct packalign=0

00000004 enum blk_zone_cond : unsigned __int32
{
  BLK_ZONE_COND_NOT_WP = 0x0,
  BLK_ZONE_COND_EMPTY = 0x1,
  BLK_ZONE_COND_IMP_OPEN = 0x2,
  BLK_ZONE_COND_EXP_OPEN = 0x3,
  BLK_ZONE_COND_CLOSED = 0x4,
  BLK_ZONE_COND_READONLY = 0xD,
  BLK_ZONE_COND_FULL = 0xE,
  BLK_ZONE_COND_OFFLINE = 0xF,
};
00000010 struct blk_zone_range
{
  __u64 sector;
  __u64 nr_sectors;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_zone_range.sector __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 blk_zone_range.nr_sectors __u64;
//          0010 effalign(8) sda=0 bits=0000 blk_zone_range struct packalign=0

00000010 struct blk_zone_report
{
  __u64 sector;
  __u32 nr_zones;
  __u8 reserved[4];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 blk_zone_report.sector __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 blk_zone_report.nr_zones __u32;
//  2. 000C 0004 effalign(1) fda=0 bits=0000 blk_zone_report.reserved __u8[4];
//          0010 effalign(8) sda=0 bits=0000 blk_zone_report struct packalign=0

00000004 enum blk_zone_type : unsigned __int32
{
  BLK_ZONE_TYPE_CONVENTIONAL = 0x1,
  BLK_ZONE_TYPE_SEQWRITE_REQ = 0x2,
  BLK_ZONE_TYPE_SEQWRITE_PREF = 0x3,
};
00000004 enum blk_zoned_model : unsigned __int32
{
  BLK_ZONED_NONE = 0x0,
  BLK_ZONED_HA = 0x1,
  BLK_ZONED_HM = 0x2,
};
FFFFFFFF struct blkcg_gq;
00000008 typedef u64 blkcnt_t;
000000D8 struct block_device
{
  dev_t bd_dev;
  int bd_openers;
  inode *bd_inode;
  super_block *bd_super;
  mutex bd_mutex;
  void *bd_claiming;
  void *bd_holder;
  int bd_holders;
  bool bd_write_holder;
  list_head bd_holder_disks;
  block_device *bd_contains;
  unsigned int bd_block_size;
  u8 bd_partno;
  hd_struct *bd_part;
  unsigned int bd_part_count;
  int bd_invalidated;
  gendisk *bd_disk;
  request_queue *bd_queue;
  backing_dev_info *bd_bdi;
  list_head bd_list;
  unsigned __int64 bd_private;
  int bd_fsfreeze_count;
  mutex bd_fsfreeze_mutex;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 block_device.bd_dev dev_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 block_device.bd_openers int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 block_device.bd_inode inode *;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 block_device.bd_super super_block *;
//  4. 0018 0020 effalign(8) fda=0 bits=0000 block_device.bd_mutex mutex;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 block_device.bd_claiming void *;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 block_device.bd_holder void *;
//  7. 0048 0004 effalign(4) fda=0 bits=0000 block_device.bd_holders int;
//  8. 004C 0001 effalign(1) fda=0 bits=0000 block_device.bd_write_holder bool;
//  9. 0050 0010 effalign(8) fda=0 bits=0000 block_device.bd_holder_disks list_head;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 block_device.bd_contains block_device *;
// 11. 0068 0004 effalign(4) fda=0 bits=0000 block_device.bd_block_size unsigned int;
// 12. 006C 0001 effalign(1) fda=0 bits=0000 block_device.bd_partno u8;
// 13. 0070 0008 effalign(8) fda=0 bits=0000 block_device.bd_part hd_struct *;
// 14. 0078 0004 effalign(4) fda=0 bits=0000 block_device.bd_part_count unsigned int;
// 15. 007C 0004 effalign(4) fda=0 bits=0000 block_device.bd_invalidated int;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 block_device.bd_disk gendisk *;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 block_device.bd_queue request_queue *;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 block_device.bd_bdi backing_dev_info *;
// 19. 0098 0010 effalign(8) fda=0 bits=0000 block_device.bd_list list_head;
// 20. 00A8 0008 effalign(8) fda=0 bits=0000 block_device.bd_private unsigned __int64;
// 21. 00B0 0004 effalign(4) fda=0 bits=0000 block_device.bd_fsfreeze_count int;
// 22. 00B8 0020 effalign(8) fda=0 bits=0000 block_device.bd_fsfreeze_mutex mutex;
//          00D8 effalign(8) sda=0 bits=0000 block_device struct packalign=0

00000070 struct block_device_operations
{
  int (__cdecl *open)(block_device *, fmode_t);
  void (__cdecl *release)(gendisk *, fmode_t);
  int (__cdecl *rw_page)(block_device *, sector_t, page *, unsigned int);
  int (__cdecl *ioctl)(block_device *, fmode_t, unsigned int, unsigned __int64);
  int (__cdecl *compat_ioctl)(block_device *, fmode_t, unsigned int, unsigned __int64);
  unsigned int (__cdecl *check_events)(gendisk *, unsigned int);
  int (__cdecl *media_changed)(gendisk *);
  void (__cdecl *unlock_native_capacity)(gendisk *);
  int (__cdecl *revalidate_disk)(gendisk *);
  int (__cdecl *getgeo)(block_device *, hd_geometry *);
  void (__cdecl *swap_slot_free_notify)(block_device *, unsigned __int64);
  int (__cdecl *report_zones)(gendisk *, sector_t, blk_zone *, unsigned int *);
  module *owner;
  const pr_ops *pr_ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 block_device_operations.open int (__cdecl *)(block_device *, fmode_t);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 block_device_operations.release void (__cdecl *)(gendisk *, fmode_t);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 block_device_operations.rw_page int (__cdecl *)(block_device *, sector_t, page *, unsigned int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 block_device_operations.ioctl int (__cdecl *)(block_device *, fmode_t, unsigned int, unsigned __int64);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 block_device_operations.compat_ioctl int (__cdecl *)(block_device *, fmode_t, unsigned int, unsigned __int64);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 block_device_operations.check_events unsigned int (__cdecl *)(gendisk *, unsigned int);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 block_device_operations.media_changed int (__cdecl *)(gendisk *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 block_device_operations.unlock_native_capacity void (__cdecl *)(gendisk *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 block_device_operations.revalidate_disk int (__cdecl *)(gendisk *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 block_device_operations.getgeo int (__cdecl *)(block_device *, hd_geometry *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 block_device_operations.swap_slot_free_notify void (__cdecl *)(block_device *, unsigned __int64);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 block_device_operations.report_zones int (__cdecl *)(gendisk *, sector_t, blk_zone *, unsigned int *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 block_device_operations.owner module *;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 block_device_operations.pr_ops const pr_ops *;
//          0070 effalign(8) sda=0 bits=0000 block_device_operations struct packalign=0

00000030 struct blocking_notifier_head
{
  rw_semaphore rwsem;
  notifier_block *head;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 blocking_notifier_head.rwsem rw_semaphore;
//  1. 0028 0008 effalign(8) fda=0 bits=0000 blocking_notifier_head.head notifier_block *;
//          0030 effalign(8) sda=0 bits=0000 blocking_notifier_head struct packalign=0

00000001 typedef bool bool;
00000014 struct __attribute__((packed)) boot_e820_entry
{
  __u64 addr;
  __u64 size;
  __u32 type;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 boot_e820_entry.addr __u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 boot_e820_entry.size __u64;
//  2. 0010 0004 effalign(1) fda=0 bits=0000 boot_e820_entry.type __u32;
//          0014 effalign(1) sda=0 bits=0040 boot_e820_entry struct packalign=0

00001000 struct __attribute__((packed)) boot_params
{
  screen_info screen_info;
  apm_bios_info apm_bios_info;
  __u8 _pad2[4];
  __u64 tboot_addr;
  ist_info ist_info;
  __u64 acpi_rsdp_addr;
  __u8 _pad3[8];
  __u8 hd0_info[16];
  __u8 hd1_info[16];
  sys_desc_table sys_desc_table;
  olpc_ofw_header olpc_ofw_header;
  __u32 ext_ramdisk_image;
  __u32 ext_ramdisk_size;
  __u32 ext_cmd_line_ptr;
  __u8 _pad4[116];
  edid_info edid_info;
  efi_info efi_info;
  __u32 alt_mem_k;
  __u32 scratch;
  __u8 e820_entries;
  __u8 eddbuf_entries;
  __u8 edd_mbr_sig_buf_entries;
  __u8 kbd_status;
  __u8 secure_boot;
  __u8 _pad5[2];
  __u8 sentinel;
  __u8 _pad6[1];
  setup_header hdr;
  __u8 _pad7[40];
  __u32 edd_mbr_sig_buffer[16];
  boot_e820_entry e820_table[128];
  __u8 _pad8[48];
  edd_info eddbuf[6];
  __u8 _pad9[276];
};
//  0. 0000 0040 effalign(1) fda=0 bits=0000 boot_params.screen_info screen_info;
//  1. 0040 0014 effalign(1) fda=0 bits=0000 boot_params.apm_bios_info apm_bios_info;
//  2. 0054 0004 effalign(1) fda=0 bits=0000 boot_params._pad2 __u8[4];
//  3. 0058 0008 effalign(1) fda=0 bits=0000 boot_params.tboot_addr __u64;
//  4. 0060 0010 effalign(1) fda=0 bits=0000 boot_params.ist_info ist_info;
//  5. 0070 0008 effalign(1) fda=0 bits=0000 boot_params.acpi_rsdp_addr __u64;
//  6. 0078 0008 effalign(1) fda=0 bits=0000 boot_params._pad3 __u8[8];
//  7. 0080 0010 effalign(1) fda=0 bits=0000 boot_params.hd0_info __u8[16];
//  8. 0090 0010 effalign(1) fda=0 bits=0000 boot_params.hd1_info __u8[16];
//  9. 00A0 0010 effalign(1) fda=0 bits=0000 boot_params.sys_desc_table sys_desc_table;
// 10. 00B0 0010 effalign(1) fda=0 bits=0000 boot_params.olpc_ofw_header olpc_ofw_header;
// 11. 00C0 0004 effalign(1) fda=0 bits=0000 boot_params.ext_ramdisk_image __u32;
// 12. 00C4 0004 effalign(1) fda=0 bits=0000 boot_params.ext_ramdisk_size __u32;
// 13. 00C8 0004 effalign(1) fda=0 bits=0000 boot_params.ext_cmd_line_ptr __u32;
// 14. 00CC 0074 effalign(1) fda=0 bits=0000 boot_params._pad4 __u8[116];
// 15. 0140 0080 effalign(1) fda=0 bits=0000 boot_params.edid_info edid_info;
// 16. 01C0 0020 effalign(1) fda=0 bits=0000 boot_params.efi_info efi_info;
// 17. 01E0 0004 effalign(1) fda=0 bits=0000 boot_params.alt_mem_k __u32;
// 18. 01E4 0004 effalign(1) fda=0 bits=0000 boot_params.scratch __u32;
// 19. 01E8 0001 effalign(1) fda=0 bits=0000 boot_params.e820_entries __u8;
// 20. 01E9 0001 effalign(1) fda=0 bits=0000 boot_params.eddbuf_entries __u8;
// 21. 01EA 0001 effalign(1) fda=0 bits=0000 boot_params.edd_mbr_sig_buf_entries __u8;
// 22. 01EB 0001 effalign(1) fda=0 bits=0000 boot_params.kbd_status __u8;
// 23. 01EC 0001 effalign(1) fda=0 bits=0000 boot_params.secure_boot __u8;
// 24. 01ED 0002 effalign(1) fda=0 bits=0000 boot_params._pad5 __u8[2];
// 25. 01EF 0001 effalign(1) fda=0 bits=0000 boot_params.sentinel __u8;
// 26. 01F0 0001 effalign(1) fda=0 bits=0000 boot_params._pad6 __u8[1];
// 27. 01F1 0077 effalign(1) fda=0 bits=0000 boot_params.hdr setup_header;
// 28. 0268 0028 effalign(1) fda=0 bits=0000 boot_params._pad7 __u8[40];
// 29. 0290 0040 effalign(1) fda=0 bits=0000 boot_params.edd_mbr_sig_buffer __u32[16];
// 30. 02D0 0A00 effalign(1) fda=0 bits=0000 boot_params.e820_table boot_e820_entry[128];
// 31. 0CD0 0030 effalign(1) fda=0 bits=0000 boot_params._pad8 __u8[48];
// 32. 0D00 01EC effalign(1) fda=0 bits=0000 boot_params.eddbuf edd_info[6];
// 33. 0EEC 0114 effalign(1) fda=0 bits=0000 boot_params._pad9 __u8[276];
//          1000 effalign(1) sda=0 bits=0040 boot_params struct packalign=0

FFFFFFFF struct bootmem_data;
00000004 enum bpf_access_type : unsigned __int32
{
  BPF_READ = 0x1,
  BPF_WRITE = 0x2,
};
00000004 enum bpf_adj_room_mode : unsigned __int32
{
  BPF_ADJ_ROOM_NET = 0x0,
  BPF_ADJ_ROOM_MAC = 0x1,
};
00000004 enum bpf_arg_type : unsigned __int32
{
  ARG_DONTCARE = 0x0,
  ARG_CONST_MAP_PTR = 0x1,
  ARG_PTR_TO_MAP_KEY = 0x2,
  ARG_PTR_TO_MAP_VALUE = 0x3,
  ARG_PTR_TO_UNINIT_MAP_VALUE = 0x4,
  ARG_PTR_TO_MAP_VALUE_OR_NULL = 0x5,
  ARG_PTR_TO_MEM = 0x6,
  ARG_PTR_TO_MEM_OR_NULL = 0x7,
  ARG_PTR_TO_UNINIT_MEM = 0x8,
  ARG_CONST_SIZE = 0x9,
  ARG_CONST_SIZE_OR_ZERO = 0xA,
  ARG_PTR_TO_CTX = 0xB,
  ARG_ANYTHING = 0xC,
  ARG_PTR_TO_SPIN_LOCK = 0xD,
  ARG_PTR_TO_SOCK_COMMON = 0xE,
  ARG_PTR_TO_INT = 0xF,
  ARG_PTR_TO_LONG = 0x10,
  ARG_PTR_TO_SOCKET = 0x11,
};
00000100 struct bpf_array
{
  bpf_map map;
  u32 elem_size;
  u32 index_mask;
  bpf_prog_type owner_prog_type;
  bool owner_jited;
};
//  0. 0000 00C0 effalign(64) fda=0 bits=0000 bpf_array.map bpf_map;
//  1. 00C0 0004 effalign(4) fda=0 bits=0000 bpf_array.elem_size u32;
//  2. 00C4 0004 effalign(4) fda=0 bits=0000 bpf_array.index_mask u32;
//  3. 00C8 0004 effalign(4) fda=0 bits=0000 bpf_array.owner_prog_type bpf_prog_type;
//  4. 00CC 0001 effalign(1) fda=0 bits=0000 bpf_array.owner_jited bool;
//          00CD unpadded_size
//          0100 effalign(64) sda=0 bits=0000 bpf_array struct packalign=0

00000004 enum bpf_attach_type : unsigned __int32
{
  BPF_CGROUP_INET_INGRESS = 0x0,
  BPF_CGROUP_INET_EGRESS = 0x1,
  BPF_CGROUP_INET_SOCK_CREATE = 0x2,
  BPF_CGROUP_SOCK_OPS = 0x3,
  BPF_SK_SKB_STREAM_PARSER = 0x4,
  BPF_SK_SKB_STREAM_VERDICT = 0x5,
  BPF_CGROUP_DEVICE = 0x6,
  BPF_SK_MSG_VERDICT = 0x7,
  BPF_CGROUP_INET4_BIND = 0x8,
  BPF_CGROUP_INET6_BIND = 0x9,
  BPF_CGROUP_INET4_CONNECT = 0xA,
  BPF_CGROUP_INET6_CONNECT = 0xB,
  BPF_CGROUP_INET4_POST_BIND = 0xC,
  BPF_CGROUP_INET6_POST_BIND = 0xD,
  BPF_CGROUP_UDP4_SENDMSG = 0xE,
  BPF_CGROUP_UDP6_SENDMSG = 0xF,
  BPF_LIRC_MODE2 = 0x10,
  BPF_FLOW_DISSECTOR = 0x11,
  BPF_CGROUP_SYSCTL = 0x12,
  BPF_CGROUP_UDP4_RECVMSG = 0x13,
  BPF_CGROUP_UDP6_RECVMSG = 0x14,
  BPF_CGROUP_GETSOCKOPT = 0x15,
  BPF_CGROUP_SETSOCKOPT = 0x16,
  __MAX_BPF_ATTACH_TYPE = 0x17,
};
00000070 union __attribute__((aligned(8))) bpf_attr
{
  struct
  {
    __u32 map_type;
    __u32 key_size;
    __u32 value_size;
    __u32 max_entries;
    __u32 map_flags;
    __u32 inner_map_fd;
    __u32 numa_node;
    char map_name[16];
    __u32 map_ifindex;
    __u32 btf_fd;
    __u32 btf_key_type_id;
    __u32 btf_value_type_id;
  };
  struct
  {
    __u32 map_fd;
    __attribute__((aligned(8))) __u64 key;
    union
    {
      __attribute__((aligned(8))) __u64 value;
      __attribute__((aligned(8))) __u64 next_key;
    };
    __u64 flags;
  };
  struct
  {
    __u32 prog_type;
    __u32 insn_cnt;
    __attribute__((aligned(8))) __u64 insns;
    __attribute__((aligned(8))) __u64 license;
    __u32 log_level;
    __u32 log_size;
    __attribute__((aligned(8))) __u64 log_buf;
    __u32 kern_version;
    __u32 prog_flags;
    char prog_name[16];
    __u32 prog_ifindex;
    __u32 expected_attach_type;
    __u32 prog_btf_fd;
    __u32 func_info_rec_size;
    __attribute__((aligned(8))) __u64 func_info;
    __u32 func_info_cnt;
    __u32 line_info_rec_size;
    __attribute__((aligned(8))) __u64 line_info;
    __u32 line_info_cnt;
  };
  struct
  {
    __attribute__((aligned(8))) __u64 pathname;
    __u32 bpf_fd;
    __u32 file_flags;
  };
  struct
  {
    __u32 target_fd;
    __u32 attach_bpf_fd;
    __u32 attach_type;
    __u32 attach_flags;
  };
  bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB test;
  struct
  {
    union
    {
      __u32 start_id;
      __u32 prog_id;
      __u32 map_id;
      __u32 btf_id;
    };
    __u32 next_id;
    __u32 open_flags;
  };
  bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5 info;
  bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53 query;
  bpf_attr::$29187BDD05BED55130ACEB7157F04007 raw_tracepoint;
  struct
  {
    __attribute__((aligned(8))) __u64 btf;
    __attribute__((aligned(8))) __u64 btf_log_buf;
    __u32 btf_size;
    __u32 btf_log_size;
    __u32 btf_log_level;
  };
  bpf_attr::$297DAE436CEB69EB0A891FD644896324 task_fd_query;
};
//  0. 0000 003C effalign(4) fda=0 bits=0000 bpf_attr.bpf_attr::$10BC7C48BC362A4A17445639C51E628D bpf_attr::$10BC7C48BC362A4A17445639C51E628D;
//  1. 0000 0020 effalign(8) fda=0 bits=0000 bpf_attr.bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820;
//  2. 0000 0070 effalign(8) fda=0 bits=0000 bpf_attr.bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4;
//  3. 0000 0010 effalign(8) fda=0 bits=0000 bpf_attr.bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002 bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002;
//  4. 0000 0010 effalign(4) fda=0 bits=0000 bpf_attr.bpf_attr::$8C49213BB30B837F33B5ABCD62234B28 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28;
//  5. 0000 0040 effalign(8) fda=0 bits=0000 bpf_attr.test bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB;
//  6. 0000 000C effalign(4) fda=0 bits=0000 bpf_attr.bpf_attr::$2F3D411E67B119599981F5EC2FFFA458 bpf_attr::$2F3D411E67B119599981F5EC2FFFA458;
//  7. 0000 0010 effalign(8) fda=0 bits=0000 bpf_attr.info bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5;
//  8. 0000 0020 effalign(8) fda=0 bits=0000 bpf_attr.query bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53;
//  9. 0000 0010 effalign(8) fda=0 bits=0000 bpf_attr.raw_tracepoint bpf_attr::$29187BDD05BED55130ACEB7157F04007;
// 10. 0000 0020 effalign(8) fda=0 bits=0000 bpf_attr.bpf_attr::$FF38F8497154DC1D452B62DACB366640 bpf_attr::$FF38F8497154DC1D452B62DACB366640;
// 11. 0000 0030 effalign(8) fda=0 bits=0000 bpf_attr.task_fd_query bpf_attr::$297DAE436CEB69EB0A891FD644896324;
//          006C unpadded_size
//          0070 effalign(8) sda=4 bits=0000 bpf_attr union packalign=0

00000020 struct bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820
{
  __u32 map_fd;
  __attribute__((aligned(8))) __u64 key;
  union
  {
    __attribute__((aligned(8))) __u64 value;
    __attribute__((aligned(8))) __u64 next_key;
  };
  __u64 flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820.map_fd __u32;
//  1. 0008 0008 effalign(8) fda=4 bits=0000 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820.key __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820.$0256C37A800425CA166D3F6F142F680B $0256C37A800425CA166D3F6F142F680B;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820.flags __u64;
//          0020 effalign(8) sda=0 bits=0000 bpf_attr::$06DAEC1EE2BD6C4D42247F4E7AE8F820 struct packalign=0

00000010 struct bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5
{
  __u32 bpf_fd;
  __u32 info_len;
  __attribute__((aligned(8))) __u64 info;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5.bpf_fd __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5.info_len __u32;
//  2. 0008 0008 effalign(8) fda=4 bits=0000 bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5.info __u64;
//          0010 effalign(8) sda=0 bits=0000 bpf_attr::$106EB7659E5F68E53A604CB0DE103DC5 struct packalign=0

0000003C struct bpf_attr::$10BC7C48BC362A4A17445639C51E628D
{
  __u32 map_type;
  __u32 key_size;
  __u32 value_size;
  __u32 max_entries;
  __u32 map_flags;
  __u32 inner_map_fd;
  __u32 numa_node;
  char map_name[16];
  __u32 map_ifindex;
  __u32 btf_fd;
  __u32 btf_key_type_id;
  __u32 btf_value_type_id;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.map_type __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.key_size __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.value_size __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.max_entries __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.map_flags __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.inner_map_fd __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.numa_node __u32;
//  7. 001C 0010 effalign(1) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.map_name char[16];
//  8. 002C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.map_ifindex __u32;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.btf_fd __u32;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.btf_key_type_id __u32;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D.btf_value_type_id __u32;
//          003C effalign(4) sda=0 bits=0000 bpf_attr::$10BC7C48BC362A4A17445639C51E628D struct packalign=0

00000010 struct bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002
{
  __attribute__((aligned(8))) __u64 pathname;
  __u32 bpf_fd;
  __u32 file_flags;
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002.pathname __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002.bpf_fd __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002.file_flags __u32;
//          0010 effalign(8) sda=0 bits=0000 bpf_attr::$279BB1CF09AB8AE2BCB53A8F806BF002 struct packalign=0

00000010 struct bpf_attr::$29187BDD05BED55130ACEB7157F04007
{
  __u64 name;
  __u32 prog_fd;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_attr::$29187BDD05BED55130ACEB7157F04007.name __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$29187BDD05BED55130ACEB7157F04007.prog_fd __u32;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 bpf_attr::$29187BDD05BED55130ACEB7157F04007 struct packalign=0

00000030 struct bpf_attr::$297DAE436CEB69EB0A891FD644896324
{
  __u32 pid;
  __u32 fd;
  __u32 flags;
  __u32 buf_len;
  __attribute__((aligned(8))) __u64 buf;
  __u32 prog_id;
  __u32 fd_type;
  __u64 probe_offset;
  __u64 probe_addr;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.pid __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.fd __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.flags __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.buf_len __u32;
//  4. 0010 0008 effalign(8) fda=4 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.buf __u64;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.prog_id __u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.fd_type __u32;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.probe_offset __u64;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324.probe_addr __u64;
//          0030 effalign(8) sda=0 bits=0000 bpf_attr::$297DAE436CEB69EB0A891FD644896324 struct packalign=0

0000000C struct bpf_attr::$2F3D411E67B119599981F5EC2FFFA458
{
  union
  {
    __u32 start_id;
    __u32 prog_id;
    __u32 map_id;
    __u32 btf_id;
  };
  __u32 next_id;
  __u32 open_flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$2F3D411E67B119599981F5EC2FFFA458.$4A79DFF647024094CE87A60332B16610 $4A79DFF647024094CE87A60332B16610;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$2F3D411E67B119599981F5EC2FFFA458.next_id __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$2F3D411E67B119599981F5EC2FFFA458.open_flags __u32;
//          000C effalign(4) sda=0 bits=0000 bpf_attr::$2F3D411E67B119599981F5EC2FFFA458 struct packalign=0

00000020 struct bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53
{
  __u32 target_fd;
  __u32 attach_type;
  __u32 query_flags;
  __u32 attach_flags;
  __attribute__((aligned(8))) __u64 prog_ids;
  __u32 prog_cnt;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.target_fd __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.attach_type __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.query_flags __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.attach_flags __u32;
//  4. 0010 0008 effalign(8) fda=4 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.prog_ids __u64;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53.prog_cnt __u32;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 bpf_attr::$66B4809B010D616EC02AE9CB4F1D6F53 struct packalign=0

00000010 struct bpf_attr::$8C49213BB30B837F33B5ABCD62234B28
{
  __u32 target_fd;
  __u32 attach_bpf_fd;
  __u32 attach_type;
  __u32 attach_flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28.target_fd __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28.attach_bpf_fd __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28.attach_type __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28.attach_flags __u32;
//          0010 effalign(4) sda=0 bits=0000 bpf_attr::$8C49213BB30B837F33B5ABCD62234B28 struct packalign=0

00000040 struct bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB
{
  __u32 prog_fd;
  __u32 retval;
  __u32 data_size_in;
  __u32 data_size_out;
  __attribute__((aligned(8))) __u64 data_in;
  __attribute__((aligned(8))) __u64 data_out;
  __u32 repeat;
  __u32 duration;
  __u32 ctx_size_in;
  __u32 ctx_size_out;
  __attribute__((aligned(8))) __u64 ctx_in;
  __attribute__((aligned(8))) __u64 ctx_out;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.prog_fd __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.retval __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.data_size_in __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.data_size_out __u32;
//  4. 0010 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.data_in __u64;
//  5. 0018 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.data_out __u64;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.repeat __u32;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.duration __u32;
//  8. 0028 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.ctx_size_in __u32;
//  9. 002C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.ctx_size_out __u32;
// 10. 0030 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.ctx_in __u64;
// 11. 0038 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB.ctx_out __u64;
//          0040 effalign(8) sda=0 bits=0000 bpf_attr::$C06AFFAE96DC94344A539CD5D92995BB struct packalign=0

00000070 struct bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4
{
  __u32 prog_type;
  __u32 insn_cnt;
  __attribute__((aligned(8))) __u64 insns;
  __attribute__((aligned(8))) __u64 license;
  __u32 log_level;
  __u32 log_size;
  __attribute__((aligned(8))) __u64 log_buf;
  __u32 kern_version;
  __u32 prog_flags;
  char prog_name[16];
  __u32 prog_ifindex;
  __u32 expected_attach_type;
  __u32 prog_btf_fd;
  __u32 func_info_rec_size;
  __attribute__((aligned(8))) __u64 func_info;
  __u32 func_info_cnt;
  __u32 line_info_rec_size;
  __attribute__((aligned(8))) __u64 line_info;
  __u32 line_info_cnt;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.prog_type __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.insn_cnt __u32;
//  2. 0008 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.insns __u64;
//  3. 0010 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.license __u64;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.log_level __u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.log_size __u32;
//  6. 0020 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.log_buf __u64;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.kern_version __u32;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.prog_flags __u32;
//  9. 0030 0010 effalign(1) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.prog_name char[16];
// 10. 0040 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.prog_ifindex __u32;
// 11. 0044 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.expected_attach_type __u32;
// 12. 0048 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.prog_btf_fd __u32;
// 13. 004C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.func_info_rec_size __u32;
// 14. 0050 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.func_info __u64;
// 15. 0058 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.func_info_cnt __u32;
// 16. 005C 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.line_info_rec_size __u32;
// 17. 0060 0008 effalign(8) fda=4 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.line_info __u64;
// 18. 0068 0004 effalign(4) fda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4.line_info_cnt __u32;
//          006C unpadded_size
//          0070 effalign(8) sda=0 bits=0000 bpf_attr::$C3DA0BA9AA5A91685F83F5C1209A36A4 struct packalign=0

00000020 struct bpf_attr::$FF38F8497154DC1D452B62DACB366640
{
  __attribute__((aligned(8))) __u64 btf;
  __attribute__((aligned(8))) __u64 btf_log_buf;
  __u32 btf_size;
  __u32 btf_log_size;
  __u32 btf_log_level;
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640.btf __u64;
//  1. 0008 0008 effalign(8) fda=4 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640.btf_log_buf __u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640.btf_size __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640.btf_log_size __u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640.btf_log_level __u32;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 bpf_attr::$FF38F8497154DC1D452B62DACB366640 struct packalign=0

00000010 struct __attribute__((aligned(8))) bpf_btf_info
{
  __attribute__((aligned(8))) __u64 btf;
  __u32 btf_size;
  __u32 id;
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 bpf_btf_info.btf __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bpf_btf_info.btf_size __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 bpf_btf_info.id __u32;
//          0010 effalign(8) sda=4 bits=0000 bpf_btf_info struct packalign=0

0000000C struct bpf_cgroup_dev_ctx
{
  __u32 access_type;
  __u32 major;
  __u32 minor;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_cgroup_dev_ctx.access_type __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_cgroup_dev_ctx.major __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_cgroup_dev_ctx.minor __u32;
//          000C effalign(4) sda=0 bits=0000 bpf_cgroup_dev_ctx struct packalign=0

FFFFFFFF struct bpf_cgroup_storage;
00000010 struct bpf_cgroup_storage_key
{
  __u64 cgroup_inode_id;
  __u32 attach_type;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_cgroup_storage_key.cgroup_inode_id __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bpf_cgroup_storage_key.attach_type __u32;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 bpf_cgroup_storage_key struct packalign=0

00000004 enum bpf_cgroup_storage_type : unsigned __int32
{
  BPF_CGROUP_STORAGE_SHARED = 0x0,
  BPF_CGROUP_STORAGE_PERCPU = 0x1,
  __BPF_CGROUP_STORAGE_MAX = 0x2,
};
00000004 enum bpf_cmd : unsigned __int32
{
  BPF_MAP_CREATE = 0x0,
  BPF_MAP_LOOKUP_ELEM = 0x1,
  BPF_MAP_UPDATE_ELEM = 0x2,
  BPF_MAP_DELETE_ELEM = 0x3,
  BPF_MAP_GET_NEXT_KEY = 0x4,
  BPF_PROG_LOAD = 0x5,
  BPF_OBJ_PIN = 0x6,
  BPF_OBJ_GET = 0x7,
  BPF_PROG_ATTACH = 0x8,
  BPF_PROG_DETACH = 0x9,
  BPF_PROG_TEST_RUN = 0xA,
  BPF_PROG_GET_NEXT_ID = 0xB,
  BPF_MAP_GET_NEXT_ID = 0xC,
  BPF_PROG_GET_FD_BY_ID = 0xD,
  BPF_MAP_GET_FD_BY_ID = 0xE,
  BPF_OBJ_GET_INFO_BY_FD = 0xF,
  BPF_PROG_QUERY = 0x10,
  BPF_RAW_TRACEPOINT_OPEN = 0x11,
  BPF_BTF_LOAD = 0x12,
  BPF_BTF_GET_FD_BY_ID = 0x13,
  BPF_TASK_FD_QUERY = 0x14,
  BPF_MAP_LOOKUP_AND_DELETE_ELEM = 0x15,
  BPF_MAP_FREEZE = 0x16,
  BPF_BTF_GET_NEXT_ID = 0x17,
};
FFFFFFFF struct bpf_context;
00000008 typedef u32 (__cdecl *bpf_convert_ctx_access_t)(bpf_access_type, const bpf_insn *, bpf_insn *, bpf_prog *, u32 *);
FFFFFFFF struct bpf_cpu_map_entry;
00000008 typedef unsigned __int64 (__cdecl *bpf_ctx_copy_t)(void *, const void *, unsigned __int64, unsigned __int64);
FFFFFFFF struct bpf_dtab_netdev;
00000028 struct bpf_event_entry
{
  perf_event *event;
  file *perf_file;
  file *map_file;
  callback_head rcu;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_event_entry.event perf_event *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_event_entry.perf_file file *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_event_entry.map_file file *;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 bpf_event_entry.rcu callback_head;
//          0028 effalign(8) sda=0 bits=0000 bpf_event_entry struct packalign=0

00000040 struct bpf_fib_lookup
{
  __u8 family;
  __u8 l4_protocol;
  __be16 sport;
  __be16 dport;
  __u16 tot_len;
  __u32 ifindex;
  union
  {
    __u8 tos;
    __be32 flowinfo;
    __u32 rt_metric;
  };
  union
  {
    __be32 ipv4_src;
    __u32 ipv6_src[4];
  };
  union
  {
    __be32 ipv4_dst;
    __u32 ipv6_dst[4];
  };
  __be16 h_vlan_proto;
  __be16 h_vlan_TCI;
  __u8 smac[6];
  __u8 dmac[6];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 bpf_fib_lookup.family __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 bpf_fib_lookup.l4_protocol __u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 bpf_fib_lookup.sport __be16;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 bpf_fib_lookup.dport __be16;
//  4. 0006 0002 effalign(2) fda=0 bits=0000 bpf_fib_lookup.tot_len __u16;
//  5. 0008 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup.ifindex __u32;
//  6. 000C 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup.bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D;
//  7. 0010 0010 effalign(4) fda=0 bits=0000 bpf_fib_lookup.bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9 bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9;
//  8. 0020 0010 effalign(4) fda=0 bits=0000 bpf_fib_lookup.bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7 bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7;
//  9. 0030 0002 effalign(2) fda=0 bits=0000 bpf_fib_lookup.h_vlan_proto __be16;
// 10. 0032 0002 effalign(2) fda=0 bits=0000 bpf_fib_lookup.h_vlan_TCI __be16;
// 11. 0034 0006 effalign(1) fda=0 bits=0000 bpf_fib_lookup.smac __u8[6];
// 12. 003A 0006 effalign(1) fda=0 bits=0000 bpf_fib_lookup.dmac __u8[6];
//          0040 effalign(4) sda=0 bits=0000 bpf_fib_lookup struct packalign=0

00000004 union bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D
{
  __u8 tos;
  __be32 flowinfo;
  __u32 rt_metric;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D.tos __u8;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D.flowinfo __be32;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D.rt_metric __u32;
//          0004 effalign(4) sda=0 bits=0000 bpf_fib_lookup::$099CEE3092F26780C1140B23137D9C0D union packalign=0

00000010 union bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9
{
  __be32 ipv4_src;
  __u32 ipv6_src[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9.ipv4_src __be32;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9.ipv6_src __u32[4];
//          0010 effalign(4) sda=0 bits=0000 bpf_fib_lookup::$46CA90F60DBA42967462C08B0CC64CA9 union packalign=0

00000010 union bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7
{
  __be32 ipv4_dst;
  __u32 ipv6_dst[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7.ipv4_dst __be32;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7.ipv6_dst __u32[4];
//          0010 effalign(4) sda=0 bits=0000 bpf_fib_lookup::$BFED621D896DD0A20B1CB8728988DCB7 union packalign=0

00000038 struct bpf_flow_keys
{
  __u16 nhoff;
  __u16 thoff;
  __u16 addr_proto;
  __u8 is_frag;
  __u8 is_first_frag;
  __u8 is_encap;
  __u8 ip_proto;
  __be16 n_proto;
  __be16 sport;
  __be16 dport;
  union
  {
    struct
    {
      __be32 ipv4_src;
      __be32 ipv4_dst;
    };
    struct
    {
      __u32 ipv6_src[4];
      __u32 ipv6_dst[4];
    };
  };
  __u32 flags;
  __be32 flow_label;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.nhoff __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.thoff __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.addr_proto __u16;
//  3. 0006 0001 effalign(1) fda=0 bits=0000 bpf_flow_keys.is_frag __u8;
//  4. 0007 0001 effalign(1) fda=0 bits=0000 bpf_flow_keys.is_first_frag __u8;
//  5. 0008 0001 effalign(1) fda=0 bits=0000 bpf_flow_keys.is_encap __u8;
//  6. 0009 0001 effalign(1) fda=0 bits=0000 bpf_flow_keys.ip_proto __u8;
//  7. 000A 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.n_proto __be16;
//  8. 000C 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.sport __be16;
//  9. 000E 0002 effalign(2) fda=0 bits=0000 bpf_flow_keys.dport __be16;
// 10. 0010 0020 effalign(4) fda=0 bits=0000 bpf_flow_keys.bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571 bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571;
// 11. 0030 0004 effalign(4) fda=0 bits=0000 bpf_flow_keys.flags __u32;
// 12. 0034 0004 effalign(4) fda=0 bits=0000 bpf_flow_keys.flow_label __be32;
//          0038 effalign(4) sda=0 bits=0000 bpf_flow_keys struct packalign=0

00000020 union bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571
{
  struct
  {
    __be32 ipv4_src;
    __be32 ipv4_dst;
  };
  struct
  {
    __u32 ipv6_src[4];
    __u32 ipv6_dst[4];
  };
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571.$84C44666FD2523EEB7381B988A0293BE $84C44666FD2523EEB7381B988A0293BE;
//  1. 0000 0020 effalign(4) fda=0 bits=0000 bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571.$D0E7BB60637F8A57EBC3B64012540D98 $D0E7BB60637F8A57EBC3B64012540D98;
//          0020 effalign(4) sda=0 bits=0000 bpf_flow_keys::$E42E480F4EBBBAF31219C626E7E65571 union packalign=0

00000004 enum bpf_func_id : unsigned __int32
{
  BPF_FUNC_unspec = 0x0,
  BPF_FUNC_map_lookup_elem = 0x1,
  BPF_FUNC_map_update_elem = 0x2,
  BPF_FUNC_map_delete_elem = 0x3,
  BPF_FUNC_probe_read = 0x4,
  BPF_FUNC_ktime_get_ns = 0x5,
  BPF_FUNC_trace_printk = 0x6,
  BPF_FUNC_get_prandom_u32 = 0x7,
  BPF_FUNC_get_smp_processor_id = 0x8,
  BPF_FUNC_skb_store_bytes = 0x9,
  BPF_FUNC_l3_csum_replace = 0xA,
  BPF_FUNC_l4_csum_replace = 0xB,
  BPF_FUNC_tail_call = 0xC,
  BPF_FUNC_clone_redirect = 0xD,
  BPF_FUNC_get_current_pid_tgid = 0xE,
  BPF_FUNC_get_current_uid_gid = 0xF,
  BPF_FUNC_get_current_comm = 0x10,
  BPF_FUNC_get_cgroup_classid = 0x11,
  BPF_FUNC_skb_vlan_push = 0x12,
  BPF_FUNC_skb_vlan_pop = 0x13,
  BPF_FUNC_skb_get_tunnel_key = 0x14,
  BPF_FUNC_skb_set_tunnel_key = 0x15,
  BPF_FUNC_perf_event_read = 0x16,
  BPF_FUNC_redirect = 0x17,
  BPF_FUNC_get_route_realm = 0x18,
  BPF_FUNC_perf_event_output = 0x19,
  BPF_FUNC_skb_load_bytes = 0x1A,
  BPF_FUNC_get_stackid = 0x1B,
  BPF_FUNC_csum_diff = 0x1C,
  BPF_FUNC_skb_get_tunnel_opt = 0x1D,
  BPF_FUNC_skb_set_tunnel_opt = 0x1E,
  BPF_FUNC_skb_change_proto = 0x1F,
  BPF_FUNC_skb_change_type = 0x20,
  BPF_FUNC_skb_under_cgroup = 0x21,
  BPF_FUNC_get_hash_recalc = 0x22,
  BPF_FUNC_get_current_task = 0x23,
  BPF_FUNC_probe_write_user = 0x24,
  BPF_FUNC_current_task_under_cgroup = 0x25,
  BPF_FUNC_skb_change_tail = 0x26,
  BPF_FUNC_skb_pull_data = 0x27,
  BPF_FUNC_csum_update = 0x28,
  BPF_FUNC_set_hash_invalid = 0x29,
  BPF_FUNC_get_numa_node_id = 0x2A,
  BPF_FUNC_skb_change_head = 0x2B,
  BPF_FUNC_xdp_adjust_head = 0x2C,
  BPF_FUNC_probe_read_str = 0x2D,
  BPF_FUNC_get_socket_cookie = 0x2E,
  BPF_FUNC_get_socket_uid = 0x2F,
  BPF_FUNC_set_hash = 0x30,
  BPF_FUNC_setsockopt = 0x31,
  BPF_FUNC_skb_adjust_room = 0x32,
  BPF_FUNC_redirect_map = 0x33,
  BPF_FUNC_sk_redirect_map = 0x34,
  BPF_FUNC_sock_map_update = 0x35,
  BPF_FUNC_xdp_adjust_meta = 0x36,
  BPF_FUNC_perf_event_read_value = 0x37,
  BPF_FUNC_perf_prog_read_value = 0x38,
  BPF_FUNC_getsockopt = 0x39,
  BPF_FUNC_override_return = 0x3A,
  BPF_FUNC_sock_ops_cb_flags_set = 0x3B,
  BPF_FUNC_msg_redirect_map = 0x3C,
  BPF_FUNC_msg_apply_bytes = 0x3D,
  BPF_FUNC_msg_cork_bytes = 0x3E,
  BPF_FUNC_msg_pull_data = 0x3F,
  BPF_FUNC_bind = 0x40,
  BPF_FUNC_xdp_adjust_tail = 0x41,
  BPF_FUNC_skb_get_xfrm_state = 0x42,
  BPF_FUNC_get_stack = 0x43,
  BPF_FUNC_skb_load_bytes_relative = 0x44,
  BPF_FUNC_fib_lookup = 0x45,
  BPF_FUNC_sock_hash_update = 0x46,
  BPF_FUNC_msg_redirect_hash = 0x47,
  BPF_FUNC_sk_redirect_hash = 0x48,
  BPF_FUNC_lwt_push_encap = 0x49,
  BPF_FUNC_lwt_seg6_store_bytes = 0x4A,
  BPF_FUNC_lwt_seg6_adjust_srh = 0x4B,
  BPF_FUNC_lwt_seg6_action = 0x4C,
  BPF_FUNC_rc_repeat = 0x4D,
  BPF_FUNC_rc_keydown = 0x4E,
  BPF_FUNC_skb_cgroup_id = 0x4F,
  BPF_FUNC_get_current_cgroup_id = 0x50,
  BPF_FUNC_get_local_storage = 0x51,
  BPF_FUNC_sk_select_reuseport = 0x52,
  BPF_FUNC_skb_ancestor_cgroup_id = 0x53,
  BPF_FUNC_sk_lookup_tcp = 0x54,
  BPF_FUNC_sk_lookup_udp = 0x55,
  BPF_FUNC_sk_release = 0x56,
  BPF_FUNC_map_push_elem = 0x57,
  BPF_FUNC_map_pop_elem = 0x58,
  BPF_FUNC_map_peek_elem = 0x59,
  BPF_FUNC_msg_push_data = 0x5A,
  BPF_FUNC_msg_pop_data = 0x5B,
  BPF_FUNC_rc_pointer_rel = 0x5C,
  BPF_FUNC_spin_lock = 0x5D,
  BPF_FUNC_spin_unlock = 0x5E,
  BPF_FUNC_sk_fullsock = 0x5F,
  BPF_FUNC_tcp_sock = 0x60,
  BPF_FUNC_skb_ecn_set_ce = 0x61,
  BPF_FUNC_get_listener_sock = 0x62,
  BPF_FUNC_skc_lookup_tcp = 0x63,
  BPF_FUNC_tcp_check_syncookie = 0x64,
  BPF_FUNC_sysctl_get_name = 0x65,
  BPF_FUNC_sysctl_get_current_value = 0x66,
  BPF_FUNC_sysctl_get_new_value = 0x67,
  BPF_FUNC_sysctl_set_new_value = 0x68,
  BPF_FUNC_strtol = 0x69,
  BPF_FUNC_strtoul = 0x6A,
  BPF_FUNC_sk_storage_get = 0x6B,
  BPF_FUNC_sk_storage_delete = 0x6C,
  BPF_FUNC_send_signal = 0x6D,
  BPF_FUNC_tcp_gen_syncookie = 0x6E,
  __BPF_FUNC_MAX_ID = 0x6F,
};
00000008 struct bpf_func_info
{
  __u32 insn_off;
  __u32 type_id;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_func_info.insn_off __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_func_info.type_id __u32;
//          0008 effalign(4) sda=0 bits=0000 bpf_func_info struct packalign=0

00000028 struct bpf_func_proto
{
  u64 (__cdecl *func)(u64, u64, u64, u64, u64);
  bool gpl_only;
  bool pkt_access;
  bpf_return_type ret_type;
  bpf_arg_type arg1_type;
  bpf_arg_type arg2_type;
  bpf_arg_type arg3_type;
  bpf_arg_type arg4_type;
  bpf_arg_type arg5_type;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_func_proto.func u64 (__cdecl *)(u64, u64, u64, u64, u64);
//  1. 0008 0001 effalign(1) fda=0 bits=0000 bpf_func_proto.gpl_only bool;
//  2. 0009 0001 effalign(1) fda=0 bits=0000 bpf_func_proto.pkt_access bool;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.ret_type bpf_return_type;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.arg1_type bpf_arg_type;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.arg2_type bpf_arg_type;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.arg3_type bpf_arg_type;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.arg4_type bpf_arg_type;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 bpf_func_proto.arg5_type bpf_arg_type;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 bpf_func_proto struct packalign=0

00000004 enum bpf_hdr_start_off : unsigned __int32
{
  BPF_HDR_START_MAC = 0x0,
  BPF_HDR_START_NET = 0x1,
};
00000008 struct bpf_insn
{
  __u8 code;
  unsigned __int8 dst_reg : 4;
  unsigned __int8 src_reg : 4;
  __s16 off;
  __s32 imm;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 bpf_insn.code __u8;
//  1. 0001. 0 4 effalign(1) fda=0 bits=0000 bpf_insn.dst_reg bi.nbytes=1 U
//  2. 0001. 4 4 effalign(1) fda=0 bits=0000 bpf_insn.src_reg bi.nbytes=1 U
//  3. 0002 0002 effalign(2) fda=0 bits=0000 bpf_insn.off __s16;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 bpf_insn.imm __s32;
//          0008 effalign(4) sda=0 bits=0000 bpf_insn struct packalign=0

00000008 struct bpf_insn_access_aux
{
  bpf_reg_type reg_type;
  int ctx_field_size;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_insn_access_aux.reg_type bpf_reg_type;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_insn_access_aux.ctx_field_size int;
//          0008 effalign(4) sda=0 bits=0000 bpf_insn_access_aux struct packalign=0

00000010 struct bpf_line_info
{
  __u32 insn_off;
  __u32 file_name_off;
  __u32 line_off;
  __u32 line_col;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_line_info.insn_off __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_line_info.file_name_off __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_line_info.line_off __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_line_info.line_col __u32;
//          0010 effalign(4) sda=0 bits=0000 bpf_line_info struct packalign=0

00000004 struct bpf_lpm_trie_key
{
  __u32 prefixlen;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_lpm_trie_key.prefixlen __u32;
//          0004 effalign(4) sda=0 bits=0000 bpf_lpm_trie_key struct packalign=0

00000004 enum bpf_lwt_encap_mode : unsigned __int32
{
  BPF_LWT_ENCAP_SEG6 = 0x0,
  BPF_LWT_ENCAP_SEG6_INLINE = 0x1,
  BPF_LWT_ENCAP_IP = 0x2,
};
000000C0 struct bpf_map
{
  __attribute__((aligned(64))) const bpf_map_ops *ops;
  bpf_map *inner_map_meta;
  void *security;
  bpf_map_type map_type;
  u32 key_size;
  u32 value_size;
  u32 max_entries;
  u32 map_flags;
  int spin_lock_off;
  u32 id;
  int numa_node;
  u32 btf_key_type_id;
  u32 btf_value_type_id;
  btf *btf;
  bpf_map_memory memory;
  bool unpriv_array;
  bool frozen;
  __attribute__((aligned(64))) atomic_t refcnt;
  atomic_t usercnt;
  work_struct work;
  char name[16];
};
//  0. 0000 0008 effalign(64) fda=7 bits=0000 bpf_map.ops const bpf_map_ops *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_map.inner_map_meta bpf_map *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_map.security void *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 bpf_map.map_type bpf_map_type;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 bpf_map.key_size u32;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 bpf_map.value_size u32;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 bpf_map.max_entries u32;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 bpf_map.map_flags u32;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 bpf_map.spin_lock_off int;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 bpf_map.id u32;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 bpf_map.numa_node int;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 bpf_map.btf_key_type_id u32;
// 12. 003C 0004 effalign(4) fda=0 bits=0000 bpf_map.btf_value_type_id u32;
// 13. 0040 0008 effalign(8) fda=0 bits=0000 bpf_map.btf btf *;
// 14. 0048 0010 effalign(8) fda=0 bits=0000 bpf_map.memory bpf_map_memory;
// 15. 0058 0001 effalign(1) fda=0 bits=0000 bpf_map.unpriv_array bool;
// 16. 0059 0001 effalign(1) fda=0 bits=0000 bpf_map.frozen bool;
// 17. 0080 0004 effalign(64) fda=7 bits=0000 bpf_map.refcnt atomic_t;
// 18. 0084 0004 effalign(4) fda=0 bits=0000 bpf_map.usercnt atomic_t;
// 19. 0088 0020 effalign(8) fda=0 bits=0000 bpf_map.work work_struct;
// 20. 00A8 0010 effalign(1) fda=0 bits=0000 bpf_map.name char[16];
//          00B8 unpadded_size
//          00C0 effalign(64) sda=0 bits=0000 bpf_map struct packalign=0

00000020 struct bpf_map_dev_ops
{
  int (__cdecl *map_get_next_key)(bpf_offloaded_map *, void *, void *);
  int (__cdecl *map_lookup_elem)(bpf_offloaded_map *, void *, void *);
  int (__cdecl *map_update_elem)(bpf_offloaded_map *, void *, void *, u64);
  int (__cdecl *map_delete_elem)(bpf_offloaded_map *, void *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_map_dev_ops.map_get_next_key int (__cdecl *)(bpf_offloaded_map *, void *, void *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_map_dev_ops.map_lookup_elem int (__cdecl *)(bpf_offloaded_map *, void *, void *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_map_dev_ops.map_update_elem int (__cdecl *)(bpf_offloaded_map *, void *, void *, u64);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_map_dev_ops.map_delete_elem int (__cdecl *)(bpf_offloaded_map *, void *);
//          0020 effalign(8) sda=0 bits=0000 bpf_map_dev_ops struct packalign=0

00000050 struct __attribute__((aligned(8))) bpf_map_info
{
  __u32 type;
  __u32 id;
  __u32 key_size;
  __u32 value_size;
  __u32 max_entries;
  __u32 map_flags;
  char name[16];
  __u32 ifindex;
  unsigned __int32 : 32;
  unsigned __int64 netns_dev;
  __u64 netns_ino;
  __u32 btf_id;
  __u32 btf_key_type_id;
  __u32 btf_value_type_id;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_map_info.type __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_map_info.id __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_map_info.key_size __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_map_info.value_size __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_map_info.max_entries __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_map_info.map_flags __u32;
//  6. 0018 0010 effalign(1) fda=0 bits=0000 bpf_map_info.name char[16];
//  7. 0028 0004 effalign(4) fda=0 bits=0000 bpf_map_info.ifindex __u32;
//  8. 002C. 0 32 effalign(4) fda=0 bits=0000 bpf_map_info.(null) bi.nbytes=4 U
//  9. 0030 0008 effalign(8) fda=0 bits=0000 bpf_map_info.netns_dev __u64;
// 10. 0038 0008 effalign(8) fda=0 bits=0000 bpf_map_info.netns_ino __u64;
// 11. 0040 0004 effalign(4) fda=0 bits=0000 bpf_map_info.btf_id __u32;
// 12. 0044 0004 effalign(4) fda=0 bits=0000 bpf_map_info.btf_key_type_id __u32;
// 13. 0048 0004 effalign(4) fda=0 bits=0000 bpf_map_info.btf_value_type_id __u32;
//          004C unpadded_size
//          0050 effalign(8) sda=4 bits=0000 bpf_map_info struct packalign=0

00000010 struct bpf_map_memory
{
  u32 pages;
  user_struct *user;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_map_memory.pages u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_map_memory.user user_struct *;
//          0010 effalign(8) sda=0 bits=0000 bpf_map_memory struct packalign=0

000000A8 struct bpf_map_ops
{
  int (__cdecl *map_alloc_check)(bpf_attr *);
  bpf_map *(__cdecl *map_alloc)(bpf_attr *);
  void (__cdecl *map_release)(bpf_map *, file *);
  void (__cdecl *map_free)(bpf_map *);
  int (__cdecl *map_get_next_key)(bpf_map *, void *, void *);
  void (__cdecl *map_release_uref)(bpf_map *);
  void *(__cdecl *map_lookup_elem_sys_only)(bpf_map *, void *);
  void *(__cdecl *map_lookup_elem)(bpf_map *, void *);
  int (__cdecl *map_update_elem)(bpf_map *, void *, void *, u64);
  int (__cdecl *map_delete_elem)(bpf_map *, void *);
  int (__cdecl *map_push_elem)(bpf_map *, void *, u64);
  int (__cdecl *map_pop_elem)(bpf_map *, void *);
  int (__cdecl *map_peek_elem)(bpf_map *, void *);
  void *(__cdecl *map_fd_get_ptr)(bpf_map *, file *, int);
  void (__cdecl *map_fd_put_ptr)(void *);
  u32 (__cdecl *map_gen_lookup)(bpf_map *, bpf_insn *);
  u32 (__cdecl *map_fd_sys_lookup_elem)(void *);
  void (__cdecl *map_seq_show_elem)(bpf_map *, void *, seq_file *);
  int (__cdecl *map_check_btf)(const bpf_map *, const btf *, const btf_type *, const btf_type *);
  int (__cdecl *map_direct_value_addr)(const bpf_map *, u64 *, u32);
  int (__cdecl *map_direct_value_meta)(const bpf_map *, u64, u32 *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_alloc_check int (__cdecl *)(bpf_attr *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_alloc bpf_map *(__cdecl *)(bpf_attr *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_release void (__cdecl *)(bpf_map *, file *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_free void (__cdecl *)(bpf_map *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_get_next_key int (__cdecl *)(bpf_map *, void *, void *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_release_uref void (__cdecl *)(bpf_map *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_lookup_elem_sys_only void *(__cdecl *)(bpf_map *, void *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_lookup_elem void *(__cdecl *)(bpf_map *, void *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_update_elem int (__cdecl *)(bpf_map *, void *, void *, u64);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_delete_elem int (__cdecl *)(bpf_map *, void *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_push_elem int (__cdecl *)(bpf_map *, void *, u64);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_pop_elem int (__cdecl *)(bpf_map *, void *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_peek_elem int (__cdecl *)(bpf_map *, void *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_fd_get_ptr void *(__cdecl *)(bpf_map *, file *, int);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_fd_put_ptr void (__cdecl *)(void *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_gen_lookup u32 (__cdecl *)(bpf_map *, bpf_insn *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_fd_sys_lookup_elem u32 (__cdecl *)(void *);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_seq_show_elem void (__cdecl *)(bpf_map *, void *, seq_file *);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_check_btf int (__cdecl *)(const bpf_map *, const btf *, const btf_type *, const btf_type *);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_direct_value_addr int (__cdecl *)(const bpf_map *, u64 *, u32);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 bpf_map_ops.map_direct_value_meta int (__cdecl *)(const bpf_map *, u64, u32 *);
//          00A8 effalign(8) sda=0 bits=0000 bpf_map_ops struct packalign=0

00000004 enum bpf_map_type : unsigned __int32
{
  BPF_MAP_TYPE_UNSPEC = 0x0,
  BPF_MAP_TYPE_HASH = 0x1,
  BPF_MAP_TYPE_ARRAY = 0x2,
  BPF_MAP_TYPE_PROG_ARRAY = 0x3,
  BPF_MAP_TYPE_PERF_EVENT_ARRAY = 0x4,
  BPF_MAP_TYPE_PERCPU_HASH = 0x5,
  BPF_MAP_TYPE_PERCPU_ARRAY = 0x6,
  BPF_MAP_TYPE_STACK_TRACE = 0x7,
  BPF_MAP_TYPE_CGROUP_ARRAY = 0x8,
  BPF_MAP_TYPE_LRU_HASH = 0x9,
  BPF_MAP_TYPE_LRU_PERCPU_HASH = 0xA,
  BPF_MAP_TYPE_LPM_TRIE = 0xB,
  BPF_MAP_TYPE_ARRAY_OF_MAPS = 0xC,
  BPF_MAP_TYPE_HASH_OF_MAPS = 0xD,
  BPF_MAP_TYPE_DEVMAP = 0xE,
  BPF_MAP_TYPE_SOCKMAP = 0xF,
  BPF_MAP_TYPE_CPUMAP = 0x10,
  BPF_MAP_TYPE_XSKMAP = 0x11,
  BPF_MAP_TYPE_SOCKHASH = 0x12,
  BPF_MAP_TYPE_CGROUP_STORAGE = 0x13,
  BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 0x14,
  BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 0x15,
  BPF_MAP_TYPE_QUEUE = 0x16,
  BPF_MAP_TYPE_STACK = 0x17,
  BPF_MAP_TYPE_SK_STORAGE = 0x18,
  BPF_MAP_TYPE_DEVMAP_HASH = 0x19,
};
FFFFFFFF struct bpf_offload_dev;
00000100 struct bpf_offloaded_map
{
  bpf_map map;
  net_device *netdev;
  const bpf_map_dev_ops *dev_ops;
  void *dev_priv;
  list_head offloads;
};
//  0. 0000 00C0 effalign(64) fda=0 bits=0000 bpf_offloaded_map.map bpf_map;
//  1. 00C0 0008 effalign(8) fda=0 bits=0000 bpf_offloaded_map.netdev net_device *;
//  2. 00C8 0008 effalign(8) fda=0 bits=0000 bpf_offloaded_map.dev_ops const bpf_map_dev_ops *;
//  3. 00D0 0008 effalign(8) fda=0 bits=0000 bpf_offloaded_map.dev_priv void *;
//  4. 00D8 0010 effalign(8) fda=0 bits=0000 bpf_offloaded_map.offloads list_head;
//          00E8 unpadded_size
//          0100 effalign(64) sda=0 bits=0000 bpf_offloaded_map struct packalign=0

00000018 struct bpf_perf_event_value
{
  __u64 counter;
  __u64 enabled;
  __u64 running;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_perf_event_value.counter __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_perf_event_value.enabled __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_perf_event_value.running __u64;
//          0018 effalign(8) sda=0 bits=0000 bpf_perf_event_value struct packalign=0

FFFFFFFF struct bpf_prog;
00000010 struct bpf_prog_array
{
  callback_head rcu;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 bpf_prog_array.rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 bpf_prog_array struct packalign=0

00000018 struct bpf_prog_array_item
{
  bpf_prog *prog;
  bpf_cgroup_storage *cgroup_storage[2];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_prog_array_item.prog bpf_prog *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 bpf_prog_array_item.cgroup_storage bpf_cgroup_storage *[2];
//          0018 effalign(8) sda=0 bits=0000 bpf_prog_array_item struct packalign=0

00000128 struct bpf_prog_aux
{
  atomic_t refcnt;
  u32 used_map_cnt;
  u32 max_ctx_offset;
  u32 max_pkt_offset;
  u32 max_tp_access;
  u32 stack_depth;
  u32 id;
  u32 func_cnt;
  u32 func_idx;
  bool verifier_zext;
  bool offload_requested;
  bpf_prog **func;
  void *jit_data;
  latch_tree_node ksym_tnode;
  list_head ksym_lnode;
  const bpf_prog_ops *ops;
  bpf_map **used_maps;
  bpf_prog *prog;
  user_struct *user;
  u64 load_time;
  bpf_map *cgroup_storage[2];
  char name[16];
  void *security;
  bpf_prog_offload *offload;
  btf *btf;
  bpf_func_info *func_info;
  bpf_line_info *linfo;
  void **jited_linfo;
  u32 func_info_cnt;
  u32 nr_linfo;
  u32 linfo_idx;
  bpf_prog_stats *stats;
  union
  {
    work_struct work;
    callback_head rcu;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.refcnt atomic_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.used_map_cnt u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.max_ctx_offset u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.max_pkt_offset u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.max_tp_access u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.stack_depth u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.id u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.func_cnt u32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.func_idx u32;
//  9. 0024 0001 effalign(1) fda=0 bits=0000 bpf_prog_aux.verifier_zext bool;
// 10. 0025 0001 effalign(1) fda=0 bits=0000 bpf_prog_aux.offload_requested bool;
// 11. 0028 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.func bpf_prog **;
// 12. 0030 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.jit_data void *;
// 13. 0038 0030 effalign(8) fda=0 bits=0000 bpf_prog_aux.ksym_tnode latch_tree_node;
// 14. 0068 0010 effalign(8) fda=0 bits=0000 bpf_prog_aux.ksym_lnode list_head;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.ops const bpf_prog_ops *;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.used_maps bpf_map **;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.prog bpf_prog *;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.user user_struct *;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.load_time u64;
// 20. 00A0 0010 effalign(8) fda=0 bits=0000 bpf_prog_aux.cgroup_storage bpf_map *[2];
// 21. 00B0 0010 effalign(1) fda=0 bits=0000 bpf_prog_aux.name char[16];
// 22. 00C0 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.security void *;
// 23. 00C8 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.offload bpf_prog_offload *;
// 24. 00D0 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.btf btf *;
// 25. 00D8 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.func_info bpf_func_info *;
// 26. 00E0 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.linfo bpf_line_info *;
// 27. 00E8 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.jited_linfo void **;
// 28. 00F0 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.func_info_cnt u32;
// 29. 00F4 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.nr_linfo u32;
// 30. 00F8 0004 effalign(4) fda=0 bits=0000 bpf_prog_aux.linfo_idx u32;
// 31. 0100 0008 effalign(8) fda=0 bits=0000 bpf_prog_aux.stats bpf_prog_stats *;
// 32. 0108 0020 effalign(8) fda=0 bits=0000 bpf_prog_aux.bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111 bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111;
//          0128 effalign(8) sda=0 bits=0000 bpf_prog_aux struct packalign=0

00000020 union bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111
{
  work_struct work;
  callback_head rcu;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111.work work_struct;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111.rcu callback_head;
//          0020 effalign(8) sda=0 bits=0000 bpf_prog_aux::$9CB9978DE051D500926A90FDD530A111 union packalign=0

000000D0 struct __attribute__((aligned(8))) bpf_prog_info
{
  __u32 type;
  __u32 id;
  __u8 tag[8];
  __u32 jited_prog_len;
  __u32 xlated_prog_len;
  __attribute__((aligned(8))) __u64 jited_prog_insns;
  __attribute__((aligned(8))) __u64 xlated_prog_insns;
  __u64 load_time;
  __u32 created_by_uid;
  __u32 nr_map_ids;
  __attribute__((aligned(8))) __u64 map_ids;
  char name[16];
  __u32 ifindex;
  unsigned __int32 gpl_compatible : 1;
  unsigned __int32 : 31;
  unsigned __int64 netns_dev;
  __u64 netns_ino;
  __u32 nr_jited_ksyms;
  __u32 nr_jited_func_lens;
  __attribute__((aligned(8))) __u64 jited_ksyms;
  __attribute__((aligned(8))) __u64 jited_func_lens;
  __u32 btf_id;
  __u32 func_info_rec_size;
  __attribute__((aligned(8))) __u64 func_info;
  __u32 nr_func_info;
  __u32 nr_line_info;
  __attribute__((aligned(8))) __u64 line_info;
  __attribute__((aligned(8))) __u64 jited_line_info;
  __u32 nr_jited_line_info;
  __u32 line_info_rec_size;
  __u32 jited_line_info_rec_size;
  __u32 nr_prog_tags;
  __attribute__((aligned(8))) __u64 prog_tags;
  __u64 run_time_ns;
  __u64 run_cnt;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.type __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.id __u32;
//  2. 0008 0008 effalign(1) fda=0 bits=0000 bpf_prog_info.tag __u8[8];
//  3. 0010 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.jited_prog_len __u32;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.xlated_prog_len __u32;
//  5. 0018 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.jited_prog_insns __u64;
//  6. 0020 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.xlated_prog_insns __u64;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 bpf_prog_info.load_time __u64;
//  8. 0030 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.created_by_uid __u32;
//  9. 0034 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_map_ids __u32;
// 10. 0038 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.map_ids __u64;
// 11. 0040 0010 effalign(1) fda=0 bits=0000 bpf_prog_info.name char[16];
// 12. 0050 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.ifindex __u32;
// 13. 0054. 0 1 effalign(1) fda=0 bits=0000 bpf_prog_info.gpl_compatible bi.nbytes=4 U
// 14. 0054. 1 31 effalign(1) fda=0 bits=0000 bpf_prog_info.(null) bi.nbytes=4 U
// 15. 0058 0008 effalign(8) fda=0 bits=0000 bpf_prog_info.netns_dev __u64;
// 16. 0060 0008 effalign(8) fda=0 bits=0000 bpf_prog_info.netns_ino __u64;
// 17. 0068 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_jited_ksyms __u32;
// 18. 006C 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_jited_func_lens __u32;
// 19. 0070 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.jited_ksyms __u64;
// 20. 0078 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.jited_func_lens __u64;
// 21. 0080 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.btf_id __u32;
// 22. 0084 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.func_info_rec_size __u32;
// 23. 0088 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.func_info __u64;
// 24. 0090 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_func_info __u32;
// 25. 0094 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_line_info __u32;
// 26. 0098 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.line_info __u64;
// 27. 00A0 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.jited_line_info __u64;
// 28. 00A8 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_jited_line_info __u32;
// 29. 00AC 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.line_info_rec_size __u32;
// 30. 00B0 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.jited_line_info_rec_size __u32;
// 31. 00B4 0004 effalign(4) fda=0 bits=0000 bpf_prog_info.nr_prog_tags __u32;
// 32. 00B8 0008 effalign(8) fda=4 bits=0000 bpf_prog_info.prog_tags __u64;
// 33. 00C0 0008 effalign(8) fda=0 bits=0000 bpf_prog_info.run_time_ns __u64;
// 34. 00C8 0008 effalign(8) fda=0 bits=0000 bpf_prog_info.run_cnt __u64;
//          00D0 effalign(8) sda=4 bits=0000 bpf_prog_info struct packalign=0

00000048 struct bpf_prog_offload
{
  bpf_prog *prog;
  net_device *netdev;
  bpf_offload_dev *offdev;
  void *dev_priv;
  list_head offloads;
  bool dev_state;
  bool opt_failed;
  void *jited_image;
  u32 jited_len;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload.prog bpf_prog *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload.netdev net_device *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload.offdev bpf_offload_dev *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload.dev_priv void *;
//  4. 0020 0010 effalign(8) fda=0 bits=0000 bpf_prog_offload.offloads list_head;
//  5. 0030 0001 effalign(1) fda=0 bits=0000 bpf_prog_offload.dev_state bool;
//  6. 0031 0001 effalign(1) fda=0 bits=0000 bpf_prog_offload.opt_failed bool;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload.jited_image void *;
//  8. 0040 0004 effalign(4) fda=0 bits=0000 bpf_prog_offload.jited_len u32;
//          0044 unpadded_size
//          0048 effalign(8) sda=0 bits=0000 bpf_prog_offload struct packalign=0

00000038 struct bpf_prog_offload_ops
{
  int (__cdecl *insn_hook)(bpf_verifier_env *, int, int);
  int (__cdecl *finalize)(bpf_verifier_env *);
  int (__cdecl *replace_insn)(bpf_verifier_env *, u32, bpf_insn *);
  int (__cdecl *remove_insns)(bpf_verifier_env *, u32, u32);
  int (__cdecl *prepare)(bpf_prog *);
  int (__cdecl *translate)(bpf_prog *);
  void (__cdecl *destroy)(bpf_prog *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.insn_hook int (__cdecl *)(bpf_verifier_env *, int, int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.finalize int (__cdecl *)(bpf_verifier_env *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.replace_insn int (__cdecl *)(bpf_verifier_env *, u32, bpf_insn *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.remove_insns int (__cdecl *)(bpf_verifier_env *, u32, u32);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.prepare int (__cdecl *)(bpf_prog *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.translate int (__cdecl *)(bpf_prog *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 bpf_prog_offload_ops.destroy void (__cdecl *)(bpf_prog *);
//          0038 effalign(8) sda=0 bits=0000 bpf_prog_offload_ops struct packalign=0

00000008 struct bpf_prog_ops
{
  int (__cdecl *test_run)(bpf_prog *, const bpf_attr *, bpf_attr *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_prog_ops.test_run int (__cdecl *)(bpf_prog *, const bpf_attr *, bpf_attr *);
//          0008 effalign(8) sda=0 bits=0000 bpf_prog_ops struct packalign=0

00000010 struct bpf_prog_stats
{
  u64 cnt;
  u64 nsecs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_prog_stats.cnt u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_prog_stats.nsecs u64;
//          0010 effalign(8) sda=0 bits=0000 bpf_prog_stats struct packalign=0

00000004 enum bpf_prog_type : unsigned __int32
{
  BPF_PROG_TYPE_UNSPEC = 0x0,
  BPF_PROG_TYPE_SOCKET_FILTER = 0x1,
  BPF_PROG_TYPE_KPROBE = 0x2,
  BPF_PROG_TYPE_SCHED_CLS = 0x3,
  BPF_PROG_TYPE_SCHED_ACT = 0x4,
  BPF_PROG_TYPE_TRACEPOINT = 0x5,
  BPF_PROG_TYPE_XDP = 0x6,
  BPF_PROG_TYPE_PERF_EVENT = 0x7,
  BPF_PROG_TYPE_CGROUP_SKB = 0x8,
  BPF_PROG_TYPE_CGROUP_SOCK = 0x9,
  BPF_PROG_TYPE_LWT_IN = 0xA,
  BPF_PROG_TYPE_LWT_OUT = 0xB,
  BPF_PROG_TYPE_LWT_XMIT = 0xC,
  BPF_PROG_TYPE_SOCK_OPS = 0xD,
  BPF_PROG_TYPE_SK_SKB = 0xE,
  BPF_PROG_TYPE_CGROUP_DEVICE = 0xF,
  BPF_PROG_TYPE_SK_MSG = 0x10,
  BPF_PROG_TYPE_RAW_TRACEPOINT = 0x11,
  BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 0x12,
  BPF_PROG_TYPE_LWT_SEG6LOCAL = 0x13,
  BPF_PROG_TYPE_LIRC_MODE2 = 0x14,
  BPF_PROG_TYPE_SK_REUSEPORT = 0x15,
  BPF_PROG_TYPE_FLOW_DISSECTOR = 0x16,
  BPF_PROG_TYPE_CGROUP_SYSCTL = 0x17,
  BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 0x18,
  BPF_PROG_TYPE_CGROUP_SOCKOPT = 0x19,
};
00000020 struct __attribute__((aligned(32))) bpf_raw_event_map
{
  tracepoint *tp;
  void *bpf_func;
  u32 num_args;
  u32 writable_size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_raw_event_map.tp tracepoint *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_raw_event_map.bpf_func void *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 bpf_raw_event_map.num_args u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 bpf_raw_event_map.writable_size u32;
//          0018 unpadded_size
//          0020 effalign(32) sda=6 bits=0000 bpf_raw_event_map struct packalign=0

00000000 struct bpf_raw_tracepoint_args
{
};
//          0000 effalign(1) sda=0 bits=0000 bpf_raw_tracepoint_args struct packalign=0

00000004 enum bpf_reg_type : unsigned __int32
{
  NOT_INIT = 0x0,
  SCALAR_VALUE = 0x1,
  PTR_TO_CTX = 0x2,
  CONST_PTR_TO_MAP = 0x3,
  PTR_TO_MAP_VALUE = 0x4,
  PTR_TO_MAP_VALUE_OR_NULL = 0x5,
  PTR_TO_STACK = 0x6,
  PTR_TO_PACKET_META = 0x7,
  PTR_TO_PACKET = 0x8,
  PTR_TO_PACKET_END = 0x9,
  PTR_TO_FLOW_KEYS = 0xA,
  PTR_TO_SOCKET = 0xB,
  PTR_TO_SOCKET_OR_NULL = 0xC,
  PTR_TO_SOCK_COMMON = 0xD,
  PTR_TO_SOCK_COMMON_OR_NULL = 0xE,
  PTR_TO_TCP_SOCK = 0xF,
  PTR_TO_TCP_SOCK_OR_NULL = 0x10,
  PTR_TO_TP_BUFFER = 0x11,
  PTR_TO_XDP_SOCK = 0x12,
};
00000004 enum bpf_ret_code : unsigned __int32
{
  BPF_OK = 0x0,
  BPF_DROP = 0x2,
  BPF_REDIRECT = 0x7,
  BPF_LWT_REROUTE = 0x80,
};
00000004 enum bpf_return_type : unsigned __int32
{
  RET_INTEGER = 0x0,
  RET_VOID = 0x1,
  RET_PTR_TO_MAP_VALUE = 0x2,
  RET_PTR_TO_MAP_VALUE_OR_NULL = 0x3,
  RET_PTR_TO_SOCKET_OR_NULL = 0x4,
  RET_PTR_TO_TCP_SOCK_OR_NULL = 0x5,
  RET_PTR_TO_SOCK_COMMON_OR_NULL = 0x6,
};
0000004C struct bpf_sock
{
  __u32 bound_dev_if;
  __u32 family;
  __u32 type;
  __u32 protocol;
  __u32 mark;
  __u32 priority;
  __u32 src_ip4;
  __u32 src_ip6[4];
  __u32 src_port;
  __be16 dst_port;
  unsigned __int16 : 16;
  unsigned int dst_ip4;
  __u32 dst_ip6[4];
  __u32 state;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_sock.bound_dev_if __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_sock.family __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_sock.type __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_sock.protocol __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_sock.mark __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_sock.priority __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 bpf_sock.src_ip4 __u32;
//  7. 001C 0010 effalign(4) fda=0 bits=0000 bpf_sock.src_ip6 __u32[4];
//  8. 002C 0004 effalign(4) fda=0 bits=0000 bpf_sock.src_port __u32;
//  9. 0030 0002 effalign(2) fda=0 bits=0000 bpf_sock.dst_port __be16;
// 10. 0032. 0 16 effalign(2) fda=0 bits=0000 bpf_sock.(null) bi.nbytes=2 U
// 11. 0034 0004 effalign(4) fda=0 bits=0000 bpf_sock.dst_ip4 __u32;
// 12. 0038 0010 effalign(4) fda=0 bits=0000 bpf_sock.dst_ip6 __u32[4];
// 13. 0048 0004 effalign(4) fda=0 bits=0000 bpf_sock.state __u32;
//          004C effalign(4) sda=0 bits=0000 bpf_sock struct packalign=0

00000048 struct bpf_sock_addr
{
  __u32 user_family;
  __u32 user_ip4;
  __u32 user_ip6[4];
  __u32 user_port;
  __u32 family;
  __u32 type;
  __u32 protocol;
  __u32 msg_src_ip4;
  __u32 msg_src_ip6[4];
  union __attribute__((aligned(8)))
  {
    bpf_sock *sk;
    unsigned __int64 : 64;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.user_family __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.user_ip4 __u32;
//  2. 0008 0010 effalign(4) fda=0 bits=0000 bpf_sock_addr.user_ip6 __u32[4];
//  3. 0018 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.user_port __u32;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.family __u32;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.type __u32;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.protocol __u32;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 bpf_sock_addr.msg_src_ip4 __u32;
//  8. 002C 0010 effalign(4) fda=0 bits=0000 bpf_sock_addr.msg_src_ip6 __u32[4];
//  9. 0040 0008 effalign(8) fda=0 bits=0000 bpf_sock_addr.bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31 bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31;
//          0048 effalign(8) sda=0 bits=0000 bpf_sock_addr struct packalign=0

00000008 union __attribute__((aligned(8))) bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31
{
  bpf_sock *sk;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31.sk bpf_sock *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 bpf_sock_addr::$000FA75B077373DB1E9F715A746A0F31 union packalign=0

000000C0 struct bpf_sock_ops
{
  __u32 op;
  union
  {
    __u32 args[4];
    __u32 reply;
    __u32 replylong[4];
  };
  __u32 family;
  __u32 remote_ip4;
  __u32 local_ip4;
  __u32 remote_ip6[4];
  __u32 local_ip6[4];
  __u32 remote_port;
  __u32 local_port;
  __u32 is_fullsock;
  __u32 snd_cwnd;
  __u32 srtt_us;
  __u32 bpf_sock_ops_cb_flags;
  __u32 state;
  __u32 rtt_min;
  __u32 snd_ssthresh;
  __u32 rcv_nxt;
  __u32 snd_nxt;
  __u32 snd_una;
  __u32 mss_cache;
  __u32 ecn_flags;
  __u32 rate_delivered;
  __u32 rate_interval_us;
  __u32 packets_out;
  __u32 retrans_out;
  __u32 total_retrans;
  __u32 segs_in;
  __u32 data_segs_in;
  __u32 segs_out;
  __u32 data_segs_out;
  __u32 lost_out;
  __u32 sacked_out;
  __u32 sk_txhash;
  __u64 bytes_received;
  __u64 bytes_acked;
  union __attribute__((aligned(8)))
  {
    bpf_sock *sk;
    unsigned __int64 : 64;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.op __u32;
//  1. 0004 0010 effalign(4) fda=0 bits=0000 bpf_sock_ops.bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933 bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.family __u32;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.remote_ip4 __u32;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.local_ip4 __u32;
//  5. 0020 0010 effalign(4) fda=0 bits=0000 bpf_sock_ops.remote_ip6 __u32[4];
//  6. 0030 0010 effalign(4) fda=0 bits=0000 bpf_sock_ops.local_ip6 __u32[4];
//  7. 0040 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.remote_port __u32;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.local_port __u32;
//  9. 0048 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.is_fullsock __u32;
// 10. 004C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.snd_cwnd __u32;
// 11. 0050 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.srtt_us __u32;
// 12. 0054 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.bpf_sock_ops_cb_flags __u32;
// 13. 0058 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.state __u32;
// 14. 005C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.rtt_min __u32;
// 15. 0060 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.snd_ssthresh __u32;
// 16. 0064 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.rcv_nxt __u32;
// 17. 0068 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.snd_nxt __u32;
// 18. 006C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.snd_una __u32;
// 19. 0070 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.mss_cache __u32;
// 20. 0074 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.ecn_flags __u32;
// 21. 0078 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.rate_delivered __u32;
// 22. 007C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.rate_interval_us __u32;
// 23. 0080 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.packets_out __u32;
// 24. 0084 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.retrans_out __u32;
// 25. 0088 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.total_retrans __u32;
// 26. 008C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.segs_in __u32;
// 27. 0090 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.data_segs_in __u32;
// 28. 0094 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.segs_out __u32;
// 29. 0098 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.data_segs_out __u32;
// 30. 009C 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.lost_out __u32;
// 31. 00A0 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.sacked_out __u32;
// 32. 00A4 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops.sk_txhash __u32;
// 33. 00A8 0008 effalign(8) fda=0 bits=0000 bpf_sock_ops.bytes_received __u64;
// 34. 00B0 0008 effalign(8) fda=0 bits=0000 bpf_sock_ops.bytes_acked __u64;
// 35. 00B8 0008 effalign(8) fda=0 bits=0000 bpf_sock_ops.bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31 bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31;
//          00C0 effalign(8) sda=0 bits=0000 bpf_sock_ops struct packalign=0

00000008 union __attribute__((aligned(8))) bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31
{
  bpf_sock *sk;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31.sk bpf_sock *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 bpf_sock_ops::$000FA75B077373DB1E9F715A746A0F31 union packalign=0

00000010 union bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933
{
  __u32 args[4];
  __u32 reply;
  __u32 replylong[4];
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933.args __u32[4];
//  1. 0000 0004 effalign(4) fda=0 bits=0000 bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933.reply __u32;
//  2. 0000 0010 effalign(4) fda=0 bits=0000 bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933.replylong __u32[4];
//          0010 effalign(4) sda=0 bits=0000 bpf_sock_ops::$1444088C892ABCE6546B5CE1B246D933 union packalign=0

00000024 struct bpf_sock_tuple
{
  union
  {
    $A9F29324AF96E616719CBC495F44E56E ipv4;
    $82BA7F6B6A9107A3E90C483C03471D56 ipv6;
  };
};
//  0. 0000 0024 effalign(4) fda=0 bits=0000 bpf_sock_tuple.bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3 bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3;
//          0024 effalign(4) sda=0 bits=0000 bpf_sock_tuple struct packalign=0

00000024 union bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3
{
  $A9F29324AF96E616719CBC495F44E56E ipv4;
  $82BA7F6B6A9107A3E90C483C03471D56 ipv6;
};
//  0. 0000 000C effalign(4) fda=0 bits=0000 bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3.ipv4 $A9F29324AF96E616719CBC495F44E56E;
//  1. 0000 0024 effalign(4) fda=0 bits=0000 bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3.ipv6 $82BA7F6B6A9107A3E90C483C03471D56;
//          0024 effalign(4) sda=0 bits=0000 bpf_sock_tuple::$F2518B9190F2355D841B1A979B03A8F3 union packalign=0

00000028 struct bpf_sockopt
{
  union __attribute__((aligned(8)))
  {
    bpf_sock *sk;
    unsigned __int64 : 64;
  };
  union __attribute__((aligned(8)))
  {
    void *optval;
    unsigned __int64 : 64;
  };
  union __attribute__((aligned(8)))
  {
    void *optval_end;
    unsigned __int64 : 64;
  };
  int level;
  __s32 optname;
  __s32 optlen;
  __s32 retval;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sockopt.bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31 bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_sockopt.bpf_sockopt::$2E6184E23841EADB581D147471D0C941 bpf_sockopt::$2E6184E23841EADB581D147471D0C941;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_sockopt.bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 bpf_sockopt.level __s32;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 bpf_sockopt.optname __s32;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 bpf_sockopt.optlen __s32;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 bpf_sockopt.retval __s32;
//          0028 effalign(8) sda=0 bits=0000 bpf_sockopt struct packalign=0

00000008 union __attribute__((aligned(8))) bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31
{
  bpf_sock *sk;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31.sk bpf_sock *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 bpf_sockopt::$000FA75B077373DB1E9F715A746A0F31 union packalign=0

00000008 union __attribute__((aligned(8))) bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B
{
  void *optval_end;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B.optval_end void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 bpf_sockopt::$19BB67B7C055818F1B5D7227B90D839B union packalign=0

00000008 union __attribute__((aligned(8))) bpf_sockopt::$2E6184E23841EADB581D147471D0C941
{
  void *optval;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_sockopt::$2E6184E23841EADB581D147471D0C941.optval void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 bpf_sockopt::$2E6184E23841EADB581D147471D0C941.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 bpf_sockopt::$2E6184E23841EADB581D147471D0C941 union packalign=0

00000004 struct bpf_spin_lock
{
  __u32 val;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_spin_lock.val __u32;
//          0004 effalign(4) sda=0 bits=0000 bpf_spin_lock struct packalign=0

00000020 struct bpf_stack_build_id
{
  __s32 status;
  unsigned __int8 build_id[20];
  union
  {
    __u64 offset;
    __u64 ip;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_stack_build_id.status __s32;
//  1. 0004 0014 effalign(1) fda=0 bits=0000 bpf_stack_build_id.build_id unsigned __int8[20];
//  2. 0018 0008 effalign(8) fda=0 bits=0000 bpf_stack_build_id.bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040 bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040;
//          0020 effalign(8) sda=0 bits=0000 bpf_stack_build_id struct packalign=0

00000008 union bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040
{
  __u64 offset;
  __u64 ip;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040.offset __u64;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040.ip __u64;
//          0008 effalign(8) sda=0 bits=0000 bpf_stack_build_id::$F2D01ED475668572A13F3053E7BA4040 union packalign=0

00000004 enum bpf_stack_build_id_status : unsigned __int32
{
  BPF_STACK_BUILD_ID_EMPTY = 0x0,
  BPF_STACK_BUILD_ID_VALID = 0x1,
  BPF_STACK_BUILD_ID_IP = 0x2,
};
00000008 struct bpf_sysctl
{
  __u32 write;
  __u32 file_pos;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_sysctl.write __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_sysctl.file_pos __u32;
//          0008 effalign(4) sda=0 bits=0000 bpf_sysctl struct packalign=0

00000004 enum bpf_task_fd_type : unsigned __int32
{
  BPF_FD_TYPE_RAW_TRACEPOINT = 0x0,
  BPF_FD_TYPE_TRACEPOINT = 0x1,
  BPF_FD_TYPE_KPROBE = 0x2,
  BPF_FD_TYPE_KRETPROBE = 0x3,
  BPF_FD_TYPE_UPROBE = 0x4,
  BPF_FD_TYPE_URETPROBE = 0x5,
};
00000070 struct bpf_tcp_sock
{
  __u32 snd_cwnd;
  __u32 srtt_us;
  __u32 rtt_min;
  __u32 snd_ssthresh;
  __u32 rcv_nxt;
  __u32 snd_nxt;
  __u32 snd_una;
  __u32 mss_cache;
  __u32 ecn_flags;
  __u32 rate_delivered;
  __u32 rate_interval_us;
  __u32 packets_out;
  __u32 retrans_out;
  __u32 total_retrans;
  __u32 segs_in;
  __u32 data_segs_in;
  __u32 segs_out;
  __u32 data_segs_out;
  __u32 lost_out;
  __u32 sacked_out;
  __u64 bytes_received;
  __u64 bytes_acked;
  __u32 dsack_dups;
  __u32 delivered;
  __u32 delivered_ce;
  __u32 icsk_retransmits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.snd_cwnd __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.srtt_us __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.rtt_min __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.snd_ssthresh __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.rcv_nxt __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.snd_nxt __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.snd_una __u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.mss_cache __u32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.ecn_flags __u32;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.rate_delivered __u32;
// 10. 0028 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.rate_interval_us __u32;
// 11. 002C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.packets_out __u32;
// 12. 0030 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.retrans_out __u32;
// 13. 0034 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.total_retrans __u32;
// 14. 0038 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.segs_in __u32;
// 15. 003C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.data_segs_in __u32;
// 16. 0040 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.segs_out __u32;
// 17. 0044 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.data_segs_out __u32;
// 18. 0048 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.lost_out __u32;
// 19. 004C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.sacked_out __u32;
// 20. 0050 0008 effalign(8) fda=0 bits=0000 bpf_tcp_sock.bytes_received __u64;
// 21. 0058 0008 effalign(8) fda=0 bits=0000 bpf_tcp_sock.bytes_acked __u64;
// 22. 0060 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.dsack_dups __u32;
// 23. 0064 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.delivered __u32;
// 24. 0068 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.delivered_ce __u32;
// 25. 006C 0004 effalign(4) fda=0 bits=0000 bpf_tcp_sock.icsk_retransmits __u32;
//          0070 effalign(8) sda=0 bits=0000 bpf_tcp_sock struct packalign=0

0000001C struct bpf_tunnel_key
{
  __u32 tunnel_id;
  union
  {
    __u32 remote_ipv4;
    __u32 remote_ipv6[4];
  };
  __u8 tunnel_tos;
  __u8 tunnel_ttl;
  __u16 tunnel_ext;
  __u32 tunnel_label;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_tunnel_key.tunnel_id __u32;
//  1. 0004 0010 effalign(4) fda=0 bits=0000 bpf_tunnel_key.bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4 bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4;
//  2. 0014 0001 effalign(1) fda=0 bits=0000 bpf_tunnel_key.tunnel_tos __u8;
//  3. 0015 0001 effalign(1) fda=0 bits=0000 bpf_tunnel_key.tunnel_ttl __u8;
//  4. 0016 0002 effalign(2) fda=0 bits=0000 bpf_tunnel_key.tunnel_ext __u16;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 bpf_tunnel_key.tunnel_label __u32;
//          001C effalign(4) sda=0 bits=0000 bpf_tunnel_key struct packalign=0

00000010 union bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4
{
  __u32 remote_ipv4;
  __u32 remote_ipv6[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4.remote_ipv4 __u32;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4.remote_ipv6 __u32[4];
//          0010 effalign(4) sda=0 bits=0000 bpf_tunnel_key::$D42CCECCBD4A7B5C055EB7EAAF8C69F4 union packalign=0

FFFFFFFF struct bpf_verifier_env;
00000028 struct bpf_verifier_ops
{
  const bpf_func_proto *(__cdecl *get_func_proto)(bpf_func_id, const bpf_prog *);
  bool (__cdecl *is_valid_access)(int, int, bpf_access_type, const bpf_prog *, bpf_insn_access_aux *);
  int (__cdecl *gen_prologue)(bpf_insn *, bool, const bpf_prog *);
  int (__cdecl *gen_ld_abs)(const bpf_insn *, bpf_insn *);
  u32 (__cdecl *convert_ctx_access)(bpf_access_type, const bpf_insn *, bpf_insn *, bpf_prog *, u32 *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bpf_verifier_ops.get_func_proto const bpf_func_proto *(__cdecl *)(bpf_func_id, const bpf_prog *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bpf_verifier_ops.is_valid_access bool (__cdecl *)(int, int, bpf_access_type, const bpf_prog *, bpf_insn_access_aux *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bpf_verifier_ops.gen_prologue int (__cdecl *)(bpf_insn *, bool, const bpf_prog *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bpf_verifier_ops.gen_ld_abs int (__cdecl *)(const bpf_insn *, bpf_insn *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 bpf_verifier_ops.convert_ctx_access u32 (__cdecl *)(bpf_access_type, const bpf_insn *, bpf_insn *, bpf_prog *, u32 *);
//          0028 effalign(8) sda=0 bits=0000 bpf_verifier_ops struct packalign=0

00000004 struct bpf_xdp_sock
{
  __u32 queue_id;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_xdp_sock.queue_id __u32;
//          0004 effalign(4) sda=0 bits=0000 bpf_xdp_sock struct packalign=0

0000001C struct bpf_xfrm_state
{
  __u32 reqid;
  __u32 spi;
  __u16 family;
  __u16 ext;
  union
  {
    __u32 remote_ipv4;
    __u32 remote_ipv6[4];
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_xfrm_state.reqid __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bpf_xfrm_state.spi __u32;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 bpf_xfrm_state.family __u16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 bpf_xfrm_state.ext __u16;
//  4. 000C 0010 effalign(4) fda=0 bits=0000 bpf_xfrm_state.bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4 bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4;
//          001C effalign(4) sda=0 bits=0000 bpf_xfrm_state struct packalign=0

00000010 union bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4
{
  __u32 remote_ipv4;
  __u32 remote_ipv6[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4.remote_ipv4 __u32;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4.remote_ipv6 __u32[4];
//          0010 effalign(4) sda=0 bits=0000 bpf_xfrm_state::$D42CCECCBD4A7B5C055EB7EAAF8C69F4 union packalign=0

00000194 struct bsd_disklabel
{
  __le32 d_magic;
  __s16 d_type;
  __s16 d_subtype;
  char d_typename[16];
  char d_packname[16];
  __u32 d_secsize;
  __u32 d_nsectors;
  __u32 d_ntracks;
  __u32 d_ncylinders;
  __u32 d_secpercyl;
  __u32 d_secperunit;
  __u16 d_sparespertrack;
  __u16 d_sparespercyl;
  __u32 d_acylinders;
  __u16 d_rpm;
  __u16 d_interleave;
  __u16 d_trackskew;
  __u16 d_cylskew;
  __u32 d_headswitch;
  __u32 d_trkseek;
  __u32 d_flags;
  __u32 d_drivedata[5];
  __u32 d_spare[5];
  __le32 d_magic2;
  __le16 d_checksum;
  __le16 d_npartitions;
  __le32 d_bbsize;
  __le32 d_sbsize;
  bsd_partition d_partitions[16];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_magic __le32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_type __s16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_subtype __s16;
//  3. 0008 0010 effalign(1) fda=0 bits=0000 bsd_disklabel.d_typename char[16];
//  4. 0018 0010 effalign(1) fda=0 bits=0000 bsd_disklabel.d_packname char[16];
//  5. 0028 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_secsize __u32;
//  6. 002C 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_nsectors __u32;
//  7. 0030 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_ntracks __u32;
//  8. 0034 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_ncylinders __u32;
//  9. 0038 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_secpercyl __u32;
// 10. 003C 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_secperunit __u32;
// 11. 0040 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_sparespertrack __u16;
// 12. 0042 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_sparespercyl __u16;
// 13. 0044 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_acylinders __u32;
// 14. 0048 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_rpm __u16;
// 15. 004A 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_interleave __u16;
// 16. 004C 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_trackskew __u16;
// 17. 004E 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_cylskew __u16;
// 18. 0050 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_headswitch __u32;
// 19. 0054 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_trkseek __u32;
// 20. 0058 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_flags __u32;
// 21. 005C 0014 effalign(4) fda=0 bits=0000 bsd_disklabel.d_drivedata __u32[5];
// 22. 0070 0014 effalign(4) fda=0 bits=0000 bsd_disklabel.d_spare __u32[5];
// 23. 0084 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_magic2 __le32;
// 24. 0088 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_checksum __le16;
// 25. 008A 0002 effalign(2) fda=0 bits=0000 bsd_disklabel.d_npartitions __le16;
// 26. 008C 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_bbsize __le32;
// 27. 0090 0004 effalign(4) fda=0 bits=0000 bsd_disklabel.d_sbsize __le32;
// 28. 0094 0100 effalign(4) fda=0 bits=0000 bsd_disklabel.d_partitions bsd_partition[16];
//          0194 effalign(4) sda=0 bits=0000 bsd_disklabel struct packalign=0

00000010 struct bsd_partition
{
  __le32 p_size;
  __le32 p_offset;
  __le32 p_fsize;
  __u8 p_fstype;
  __u8 p_frag;
  __le16 p_cpg;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bsd_partition.p_size __le32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bsd_partition.p_offset __le32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 bsd_partition.p_fsize __le32;
//  3. 000C 0001 effalign(1) fda=0 bits=0000 bsd_partition.p_fstype __u8;
//  4. 000D 0001 effalign(1) fda=0 bits=0000 bsd_partition.p_frag __u8;
//  5. 000E 0002 effalign(2) fda=0 bits=0000 bsd_partition.p_cpg __le16;
//          0010 effalign(4) sda=0 bits=0000 bsd_partition struct packalign=0

00000020 struct bsg_class_device
{
  device *class_dev;
  int minor;
  request_queue *queue;
  const bsg_ops *ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bsg_class_device.class_dev device *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bsg_class_device.minor int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bsg_class_device.queue request_queue *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bsg_class_device.ops const bsg_ops *;
//          0020 effalign(8) sda=0 bits=0000 bsg_class_device struct packalign=0

FFFFFFFF struct bsg_job;
00000020 struct bsg_ops
{
  int (__cdecl *check_proto)(sg_io_v4 *);
  int (__cdecl *fill_hdr)(request *, sg_io_v4 *, fmode_t);
  int (__cdecl *complete_rq)(request *, sg_io_v4 *);
  void (__cdecl *free_rq)(request *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bsg_ops.check_proto int (__cdecl *)(sg_io_v4 *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bsg_ops.fill_hdr int (__cdecl *)(request *, sg_io_v4 *, fmode_t);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bsg_ops.complete_rq int (__cdecl *)(request *, sg_io_v4 *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bsg_ops.free_rq void (__cdecl *)(request *);
//          0020 effalign(8) sda=0 bits=0000 bsg_ops struct packalign=0

FFFFFFFF struct btf;
FFFFFFFF struct btf_type;
FFFFFFFF struct bucket_table;
FFFFFFFF struct buffer_head;
0000000C struct bug_entry
{
  int bug_addr_disp;
  int file_disp;
  unsigned __int16 line;
  unsigned __int16 flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 bug_entry.bug_addr_disp int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 bug_entry.file_disp int;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 bug_entry.line unsigned __int16;
//  3. 000A 0002 effalign(2) fda=0 bits=0000 bug_entry.flags unsigned __int16;
//          000C effalign(4) sda=0 bits=0000 bug_entry struct packalign=0

00000004 enum bug_trap_type : unsigned __int32
{
  BUG_TRAP_TYPE_NONE = 0x0,
  BUG_TRAP_TYPE_WARN = 0x1,
  BUG_TRAP_TYPE_BUG = 0x2,
};
00000020 struct bus_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(bus_type *, char *);
  ssize_t (__cdecl *store)(bus_type *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 bus_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 bus_attribute.show ssize_t (__cdecl *)(bus_type *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 bus_attribute.store ssize_t (__cdecl *)(bus_type *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 bus_attribute struct packalign=0

000000A8 struct bus_type
{
  const char *name;
  const char *dev_name;
  device *dev_root;
  const attribute_group **bus_groups;
  const attribute_group **dev_groups;
  const attribute_group **drv_groups;
  int (__cdecl *match)(device *, device_driver *);
  int (__cdecl *uevent)(device *, kobj_uevent_env *);
  int (__cdecl *probe)(device *);
  int (__cdecl *remove)(device *);
  void (__cdecl *shutdown)(device *);
  int (__cdecl *online)(device *);
  int (__cdecl *offline)(device *);
  int (__cdecl *suspend)(device *, pm_message_t);
  int (__cdecl *resume)(device *);
  int (__cdecl *num_vf)(device *);
  int (__cdecl *dma_configure)(device *);
  const dev_pm_ops *pm;
  const iommu_ops *iommu_ops;
  subsys_private *p;
  bool need_parent_lock;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bus_type.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 bus_type.dev_name const char *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 bus_type.dev_root device *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 bus_type.bus_groups const attribute_group **;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 bus_type.dev_groups const attribute_group **;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 bus_type.drv_groups const attribute_group **;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 bus_type.match int (__cdecl *)(device *, device_driver *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 bus_type.uevent int (__cdecl *)(device *, kobj_uevent_env *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 bus_type.probe int (__cdecl *)(device *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 bus_type.remove int (__cdecl *)(device *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 bus_type.shutdown void (__cdecl *)(device *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 bus_type.online int (__cdecl *)(device *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 bus_type.offline int (__cdecl *)(device *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 bus_type.suspend int (__cdecl *)(device *, pm_message_t);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 bus_type.resume int (__cdecl *)(device *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 bus_type.num_vf int (__cdecl *)(device *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 bus_type.dma_configure int (__cdecl *)(device *);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 bus_type.pm const dev_pm_ops *;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 bus_type.iommu_ops const iommu_ops *;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 bus_type.p subsys_private *;
// 20. 00A0 0001 effalign(1) fda=0 bits=0000 bus_type.need_parent_lock bool;
//          00A1 unpadded_size
//          00A8 effalign(8) sda=0 bits=0000 bus_type struct packalign=0

00000018 struct bvec_iter
{
  sector_t bi_sector;
  unsigned int bi_size;
  unsigned int bi_idx;
  unsigned int bi_bvec_done;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 bvec_iter.bi_sector sector_t;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 bvec_iter.bi_size unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 bvec_iter.bi_idx unsigned int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 bvec_iter.bi_bvec_done unsigned int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 bvec_iter struct packalign=0

00000018 struct bvec_iter_all
{
  bio_vec bv;
  int idx;
  unsigned int done;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 bvec_iter_all.bv bio_vec;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 bvec_iter_all.idx int;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 bvec_iter_all.done unsigned int;
//          0018 effalign(8) sda=0 bits=0000 bvec_iter_all struct packalign=0

00000008 typedef __kernel_caddr_t caddr_t;
00000008 typedef void (__cdecl *call_rcu_func_t)(callback_head *, rcu_callback_t);
00000020 typedef __call_single_data call_single_data_t;
00000010 struct __attribute__((aligned(8))) callback_head
{
  callback_head *next;
  void (__cdecl *func)(callback_head *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 callback_head.next callback_head *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 callback_head.func void (__cdecl *)(callback_head *);
//          0010 effalign(8) sda=4 bits=0000 callback_head struct packalign=0

00000008 typedef __user_cap_data_struct *cap_user_data_t;
00000008 typedef __user_cap_header_struct *cap_user_header_t;
00000060 struct capsule_info
{
  efi_capsule_header_t header;
  efi_capsule_header_t *capsule;
  int reset_type;
  __int64 index;
  size_t count;
  size_t total_size;
  page **pages;
  phys_addr_t *phys;
  size_t page_bytes_remain;
};
//  0. 0000 001C effalign(4) fda=0 bits=0000 capsule_info.header efi_capsule_header_t;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 capsule_info.capsule efi_capsule_header_t *;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 capsule_info.reset_type int;
//  3. 0030 0008 effalign(8) fda=0 bits=0000 capsule_info.index __int64;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 capsule_info.count size_t;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 capsule_info.total_size size_t;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 capsule_info.pages page **;
//  7. 0050 0008 effalign(8) fda=0 bits=0000 capsule_info.phys phys_addr_t *;
//  8. 0058 0008 effalign(8) fda=0 bits=0000 capsule_info.page_bytes_remain size_t;
//          0060 effalign(8) sda=0 bits=0000 capsule_info struct packalign=0

FFFFFFFF struct capture_control;
00000010 struct ccw_device_id
{
  __u16 match_flags;
  __u16 cu_type;
  __u16 dev_type;
  __u8 cu_model;
  __u8 dev_model;
  kernel_ulong_t driver_info;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 ccw_device_id.match_flags __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 ccw_device_id.cu_type __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 ccw_device_id.dev_type __u16;
//  3. 0006 0001 effalign(1) fda=0 bits=0000 ccw_device_id.cu_model __u8;
//  4. 0007 0001 effalign(1) fda=0 bits=0000 ccw_device_id.dev_model __u8;
//  5. 0008 0008 effalign(8) fda=0 bits=0000 ccw_device_id.driver_info kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 ccw_device_id struct packalign=0

00000068 struct cdev
{
  kobject kobj;
  module *owner;
  const file_operations *ops;
  list_head list;
  dev_t dev;
  unsigned int count;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 cdev.kobj kobject;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 cdev.owner module *;
//  2. 0048 0008 effalign(8) fda=0 bits=0000 cdev.ops const file_operations *;
//  3. 0050 0010 effalign(8) fda=0 bits=0000 cdev.list list_head;
//  4. 0060 0004 effalign(4) fda=0 bits=0000 cdev.dev dev_t;
//  5. 0064 0004 effalign(4) fda=0 bits=0000 cdev.count unsigned int;
//          0068 effalign(8) sda=0 bits=0000 cdev struct packalign=0

FFFFFFFF struct cfs_rq;
FFFFFFFF struct cgroup_subsys_state;
00000078 struct class
{
  const char *name;
  module *owner;
  const attribute_group **class_groups;
  const attribute_group **dev_groups;
  kobject *dev_kobj;
  int (__cdecl *dev_uevent)(device *, kobj_uevent_env *);
  char *(__cdecl *devnode)(device *, umode_t *);
  void (__cdecl *class_release)(class *);
  void (__cdecl *dev_release)(device *);
  int (__cdecl *shutdown_pre)(device *);
  const kobj_ns_type_operations *ns_type;
  const void *(__cdecl *namespace)(device *);
  void (__cdecl *get_ownership)(device *, kuid_t *, kgid_t *);
  const dev_pm_ops *pm;
  subsys_private *p;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 class.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 class.owner module *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 class.class_groups const attribute_group **;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 class.dev_groups const attribute_group **;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 class.dev_kobj kobject *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 class.dev_uevent int (__cdecl *)(device *, kobj_uevent_env *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 class.devnode char *(__cdecl *)(device *, umode_t *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 class.class_release void (__cdecl *)(class *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 class.dev_release void (__cdecl *)(device *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 class.shutdown_pre int (__cdecl *)(device *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 class.ns_type const kobj_ns_type_operations *;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 class.namespace const void *(__cdecl *)(device *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 class.get_ownership void (__cdecl *)(device *, kuid_t *, kgid_t *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 class.pm const dev_pm_ops *;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 class.p subsys_private *;
//          0078 effalign(8) sda=0 bits=0000 class struct packalign=0

00000020 struct class_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(class *, class_attribute *, char *);
  ssize_t (__cdecl *store)(class *, class_attribute *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 class_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 class_attribute.show ssize_t (__cdecl *)(class *, class_attribute *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 class_attribute.store ssize_t (__cdecl *)(class *, class_attribute *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 class_attribute struct packalign=0

00000028 struct class_attribute_string
{
  class_attribute attr;
  char *str;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 class_attribute_string.attr class_attribute;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 class_attribute_string.str char *;
//          0028 effalign(8) sda=0 bits=0000 class_attribute_string struct packalign=0

FFFFFFFF struct class_compat;
00000018 struct class_dev_iter
{
  klist_iter ki;
  const device_type *type;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 class_dev_iter.ki klist_iter;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 class_dev_iter.type const device_type *;
//          0018 effalign(8) sda=0 bits=0000 class_dev_iter struct packalign=0

00000028 struct class_interface
{
  list_head node;
  class *class;
  int (__cdecl *add_dev)(device *, class_interface *);
  void (__cdecl *remove_dev)(device *, class_interface *);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 class_interface.node list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 class_interface.class class *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 class_interface.add_dev int (__cdecl *)(device *, class_interface *);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 class_interface.remove_dev void (__cdecl *)(device *, class_interface *);
//          0028 effalign(8) sda=0 bits=0000 class_interface struct packalign=0

FFFFFFFF struct clock_event_device;
00000008 typedef __kernel_clock_t clock_t;
00000004 typedef __kernel_clockid_t clockid_t;
FFFFFFFF struct clocksource;
00000040 struct clone_args
{
  __attribute__((aligned(8))) __u64 flags;
  __attribute__((aligned(8))) __u64 pidfd;
  __attribute__((aligned(8))) __u64 child_tid;
  __attribute__((aligned(8))) __u64 parent_tid;
  __attribute__((aligned(8))) __u64 exit_signal;
  __attribute__((aligned(8))) __u64 stack;
  __attribute__((aligned(8))) __u64 stack_size;
  __attribute__((aligned(8))) __u64 tls;
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 clone_args.flags __u64;
//  1. 0008 0008 effalign(8) fda=4 bits=0000 clone_args.pidfd __u64;
//  2. 0010 0008 effalign(8) fda=4 bits=0000 clone_args.child_tid __u64;
//  3. 0018 0008 effalign(8) fda=4 bits=0000 clone_args.parent_tid __u64;
//  4. 0020 0008 effalign(8) fda=4 bits=0000 clone_args.exit_signal __u64;
//  5. 0028 0008 effalign(8) fda=4 bits=0000 clone_args.stack __u64;
//  6. 0030 0008 effalign(8) fda=4 bits=0000 clone_args.stack_size __u64;
//  7. 0038 0008 effalign(8) fda=4 bits=0000 clone_args.tls __u64;
//          0040 effalign(8) sda=0 bits=0000 clone_args struct packalign=0

FFFFFFFF struct compat_robust_list_head;
00000020 struct completion
{
  unsigned int done;
  wait_queue_head_t wait;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 completion.done unsigned int;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 completion.wait wait_queue_head_t;
//          0020 effalign(8) sda=0 bits=0000 completion struct packalign=0

00000004 enum compound_dtor_id : unsigned __int32
{
  NULL_COMPOUND_DTOR = 0x0,
  COMPOUND_PAGE_DTOR = 0x1,
  HUGETLB_PAGE_DTOR = 0x2,
  TRANSHUGE_PAGE_DTOR = 0x3,
  NR_COMPOUND_DTORS = 0x4,
};
FFFFFFFF typedef void __cdecl compound_page_dtor(page *);
FFFFFFFF typedef int __cdecl congested_fn(void *, int);
0000000C struct context_tracking
{
  bool active;
  int recursion;
  ctx_state state;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 context_tracking.active bool;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 context_tracking.recursion int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 context_tracking.state ctx_state;
//          000C effalign(4) sda=0 bits=0000 context_tracking struct packalign=0

00000038 struct core_state
{
  atomic_t nr_threads;
  core_thread dumper;
  completion startup;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 core_state.nr_threads atomic_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 core_state.dumper core_thread;
//  2. 0018 0020 effalign(8) fda=0 bits=0000 core_state.startup completion;
//          0038 effalign(8) sda=0 bits=0000 core_state struct packalign=0

00000010 struct core_thread
{
  task_struct *task;
  core_thread *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 core_thread.task task_struct *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 core_thread.next core_thread *;
//          0010 effalign(8) sda=0 bits=0000 core_thread struct packalign=0

FFFFFFFF struct coredump_params;
00000002 struct cpu_feature
{
  __u16 feature;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 cpu_feature.feature __u16;
//          0002 effalign(2) sda=0 bits=0000 cpu_feature struct packalign=0

00000048 struct cpu_timer
{
  timerqueue_node node;
  timerqueue_head *head;
  task_struct *task;
  list_head elist;
  int firing;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 cpu_timer.node timerqueue_node;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 cpu_timer.head timerqueue_head *;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 cpu_timer.task task_struct *;
//  3. 0030 0010 effalign(8) fda=0 bits=0000 cpu_timer.elist list_head;
//  4. 0040 0004 effalign(4) fda=0 bits=0000 cpu_timer.firing int;
//          0044 unpadded_size
//          0048 effalign(8) sda=0 bits=0000 cpu_timer struct packalign=0

00000C10 struct cpu_topology
{
  int thread_id;
  int core_id;
  int package_id;
  int llc_id;
  cpumask_t thread_sibling;
  cpumask_t core_sibling;
  cpumask_t llc_sibling;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 cpu_topology.thread_id int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 cpu_topology.core_id int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 cpu_topology.package_id int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 cpu_topology.llc_id int;
//  4. 0010 0400 effalign(8) fda=0 bits=0000 cpu_topology.thread_sibling cpumask_t;
//  5. 0410 0400 effalign(8) fda=0 bits=0000 cpu_topology.core_sibling cpumask_t;
//  6. 0810 0400 effalign(8) fda=0 bits=0000 cpu_topology.llc_sibling cpumask_t;
//          0C10 effalign(8) sda=0 bits=0000 cpu_topology struct packalign=0

00000018 struct cpu_vfs_cap_data
{
  __u32 magic_etc;
  kernel_cap_t permitted;
  kernel_cap_t inheritable;
  kuid_t rootid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 cpu_vfs_cap_data.magic_etc __u32;
//  1. 0004 0008 effalign(4) fda=0 bits=0000 cpu_vfs_cap_data.permitted kernel_cap_t;
//  2. 000C 0008 effalign(4) fda=0 bits=0000 cpu_vfs_cap_data.inheritable kernel_cap_t;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 cpu_vfs_cap_data.rootid kuid_t;
//          0018 effalign(4) sda=0 bits=0000 cpu_vfs_cap_data struct packalign=0

00000004 enum cpuid_leafs : unsigned __int32
{
  CPUID_1_EDX = 0x0,
  CPUID_8000_0001_EDX = 0x1,
  CPUID_8086_0001_EDX = 0x2,
  CPUID_LNX_1 = 0x3,
  CPUID_1_ECX = 0x4,
  CPUID_C000_0001_EDX = 0x5,
  CPUID_8000_0001_ECX = 0x6,
  CPUID_LNX_2 = 0x7,
  CPUID_LNX_3 = 0x8,
  CPUID_7_0_EBX = 0x9,
  CPUID_D_1_EAX = 0xA,
  CPUID_LNX_4 = 0xB,
  CPUID_7_1_EAX = 0xC,
  CPUID_8000_0008_EBX = 0xD,
  CPUID_6_EAX = 0xE,
  CPUID_8000_000A_EDX = 0xF,
  CPUID_7_ECX = 0x10,
  CPUID_8000_0007_EBX = 0x11,
  CPUID_7_EDX = 0x12,
};
00000010 struct cpuid_regs
{
  u32 eax;
  u32 ebx;
  u32 ecx;
  u32 edx;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 cpuid_regs.eax u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 cpuid_regs.ebx u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 cpuid_regs.ecx u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 cpuid_regs.edx u32;
//          0010 effalign(4) sda=0 bits=0000 cpuid_regs struct packalign=0

00000004 enum cpuid_regs_idx : unsigned __int32
{
  CPUID_EAX = 0x0,
  CPUID_EBX = 0x1,
  CPUID_ECX = 0x2,
  CPUID_EDX = 0x3,
};
000000F0 struct cpuinfo_x86
{
  __u8 x86;
  __u8 x86_vendor;
  __u8 x86_model;
  __u8 x86_stepping;
  int x86_tlbsize;
  __u8 x86_virt_bits;
  __u8 x86_phys_bits;
  __u8 x86_coreid_bits;
  __u8 cu_id;
  __u32 extended_cpuid_level;
  int cpuid_level;
  __u32 x86_capability[20];
  char x86_vendor_id[16];
  char x86_model_id[64];
  unsigned int x86_cache_size;
  int x86_cache_alignment;
  int x86_cache_max_rmid;
  int x86_cache_occ_scale;
  int x86_power;
  unsigned __int64 loops_per_jiffy;
  u16 x86_max_cores;
  u16 apicid;
  u16 initial_apicid;
  u16 x86_clflush_size;
  u16 booted_cores;
  u16 phys_proc_id;
  u16 logical_proc_id;
  u16 cpu_core_id;
  u16 cpu_die_id;
  u16 logical_die_id;
  u16 cpu_index;
  u32 microcode;
  u8 x86_cache_bits;
  unsigned __int32 initialized : 1;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86 __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_vendor __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_model __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_stepping __u8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_tlbsize int;
//  5. 0008 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_virt_bits __u8;
//  6. 0009 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_phys_bits __u8;
//  7. 000A 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_coreid_bits __u8;
//  8. 000B 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.cu_id __u8;
//  9. 000C 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.extended_cpuid_level __u32;
// 10. 0010 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.cpuid_level int;
// 11. 0014 0050 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_capability __u32[20];
// 12. 0064 0010 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_vendor_id char[16];
// 13. 0074 0040 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_model_id char[64];
// 14. 00B4 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_cache_size unsigned int;
// 15. 00B8 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_cache_alignment int;
// 16. 00BC 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_cache_max_rmid int;
// 17. 00C0 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_cache_occ_scale int;
// 18. 00C4 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.x86_power int;
// 19. 00C8 0008 effalign(8) fda=0 bits=0000 cpuinfo_x86.loops_per_jiffy unsigned __int64;
// 20. 00D0 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.x86_max_cores u16;
// 21. 00D2 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.apicid u16;
// 22. 00D4 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.initial_apicid u16;
// 23. 00D6 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.x86_clflush_size u16;
// 24. 00D8 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.booted_cores u16;
// 25. 00DA 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.phys_proc_id u16;
// 26. 00DC 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.logical_proc_id u16;
// 27. 00DE 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.cpu_core_id u16;
// 28. 00E0 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.cpu_die_id u16;
// 29. 00E2 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.logical_die_id u16;
// 30. 00E4 0002 effalign(2) fda=0 bits=0000 cpuinfo_x86.cpu_index u16;
// 31. 00E8 0004 effalign(4) fda=0 bits=0000 cpuinfo_x86.microcode u32;
// 32. 00EC 0001 effalign(1) fda=0 bits=0000 cpuinfo_x86.x86_cache_bits u8;
// 33. 00EC. 8 1 effalign(1) fda=0 bits=0000 cpuinfo_x86.initialized bi.nbytes=4 U
//          00EE unpadded_size
//          00F0 effalign(8) sda=0 bits=0000 cpuinfo_x86 struct packalign=0

00000400 struct cpumask
{
  unsigned __int64 bits[128];
};
//  0. 0000 0400 effalign(8) fda=0 bits=0000 cpumask.bits unsigned __int64[128];
//          0400 effalign(8) sda=0 bits=0000 cpumask struct packalign=0

00000400 typedef cpumask cpumask_t;
00000008 typedef cpumask *cpumask_var_t;
000000A8 struct cred
{
  atomic_t usage;
  kuid_t uid;
  kgid_t gid;
  kuid_t suid;
  kgid_t sgid;
  kuid_t euid;
  kgid_t egid;
  kuid_t fsuid;
  kgid_t fsgid;
  unsigned int securebits;
  kernel_cap_t cap_inheritable;
  kernel_cap_t cap_permitted;
  kernel_cap_t cap_effective;
  kernel_cap_t cap_bset;
  kernel_cap_t cap_ambient;
  unsigned __int8 jit_keyring;
  key *session_keyring;
  key *process_keyring;
  key *thread_keyring;
  key *request_key_auth;
  void *security;
  user_struct *user;
  user_namespace *user_ns;
  group_info *group_info;
  union
  {
    int non_rcu;
    callback_head rcu;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 cred.usage atomic_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 cred.uid kuid_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 cred.gid kgid_t;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 cred.suid kuid_t;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 cred.sgid kgid_t;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 cred.euid kuid_t;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 cred.egid kgid_t;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 cred.fsuid kuid_t;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 cred.fsgid kgid_t;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 cred.securebits unsigned int;
// 10. 0028 0008 effalign(4) fda=0 bits=0000 cred.cap_inheritable kernel_cap_t;
// 11. 0030 0008 effalign(4) fda=0 bits=0000 cred.cap_permitted kernel_cap_t;
// 12. 0038 0008 effalign(4) fda=0 bits=0000 cred.cap_effective kernel_cap_t;
// 13. 0040 0008 effalign(4) fda=0 bits=0000 cred.cap_bset kernel_cap_t;
// 14. 0048 0008 effalign(4) fda=0 bits=0000 cred.cap_ambient kernel_cap_t;
// 15. 0050 0001 effalign(1) fda=0 bits=0000 cred.jit_keyring unsigned __int8;
// 16. 0058 0008 effalign(8) fda=0 bits=0000 cred.session_keyring key *;
// 17. 0060 0008 effalign(8) fda=0 bits=0000 cred.process_keyring key *;
// 18. 0068 0008 effalign(8) fda=0 bits=0000 cred.thread_keyring key *;
// 19. 0070 0008 effalign(8) fda=0 bits=0000 cred.request_key_auth key *;
// 20. 0078 0008 effalign(8) fda=0 bits=0000 cred.security void *;
// 21. 0080 0008 effalign(8) fda=0 bits=0000 cred.user user_struct *;
// 22. 0088 0008 effalign(8) fda=0 bits=0000 cred.user_ns user_namespace *;
// 23. 0090 0008 effalign(8) fda=0 bits=0000 cred.group_info group_info *;
// 24. 0098 0010 effalign(8) fda=0 bits=0000 cred.cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A;
//          00A8 effalign(8) sda=0 bits=0000 cred struct packalign=0

00000010 union cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A
{
  int non_rcu;
  callback_head rcu;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A.non_rcu int;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A.rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 cred::$B9E29CCDB89B01FFAA1B7FC2562C3F0A union packalign=0

00000010 struct css_device_id
{
  __u8 match_flags;
  __u8 type;
  kernel_ulong_t driver_data;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 css_device_id.match_flags __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 css_device_id.type __u8;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 css_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 css_device_id struct packalign=0

FFFFFFFF struct css_set;
00000058 struct ctl_dir
{
  ctl_table_header header;
  rb_root root;
};
//  0. 0000 0050 effalign(8) fda=0 bits=0000 ctl_dir.header ctl_table_header;
//  1. 0050 0008 effalign(8) fda=0 bits=0000 ctl_dir.root rb_root;
//          0058 effalign(8) sda=0 bits=0000 ctl_dir struct packalign=0

00000020 struct ctl_node
{
  rb_node node;
  ctl_table_header *header;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 ctl_node.node rb_node;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 ctl_node.header ctl_table_header *;
//          0020 effalign(8) sda=0 bits=0000 ctl_node struct packalign=0

00000008 struct ctl_path
{
  const char *procname;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 ctl_path.procname const char *;
//          0008 effalign(8) sda=0 bits=0000 ctl_path struct packalign=0

00000040 struct ctl_table
{
  const char *procname;
  void *data;
  int maxlen;
  umode_t mode;
  ctl_table *child;
  proc_handler *proc_handler;
  ctl_table_poll *poll;
  void *extra1;
  void *extra2;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 ctl_table.procname const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 ctl_table.data void *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 ctl_table.maxlen int;
//  3. 0014 0002 effalign(2) fda=0 bits=0000 ctl_table.mode umode_t;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 ctl_table.child ctl_table *;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 ctl_table.proc_handler proc_handler *;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 ctl_table.poll ctl_table_poll *;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 ctl_table.extra1 void *;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 ctl_table.extra2 void *;
//          0040 effalign(8) sda=0 bits=0000 ctl_table struct packalign=0

00000050 struct ctl_table_header
{
  union
  {
    struct
    {
      ctl_table *ctl_table;
      int used;
      int count;
      int nreg;
    };
    callback_head rcu;
  };
  completion *unregistering;
  ctl_table *ctl_table_arg;
  ctl_table_root *root;
  ctl_table_set *set;
  ctl_dir *parent;
  ctl_node *node;
  hlist_head inodes;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 ctl_table_header.ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1 ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 ctl_table_header.unregistering completion *;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 ctl_table_header.ctl_table_arg ctl_table *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 ctl_table_header.root ctl_table_root *;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 ctl_table_header.set ctl_table_set *;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 ctl_table_header.parent ctl_dir *;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 ctl_table_header.node ctl_node *;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 ctl_table_header.inodes hlist_head;
//          0050 effalign(8) sda=0 bits=0000 ctl_table_header struct packalign=0

00000018 union ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1
{
  struct
  {
    ctl_table *ctl_table;
    int used;
    int count;
    int nreg;
  };
  callback_head rcu;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1.$69569C1B850793C50E7B56EB6E59F135 $69569C1B850793C50E7B56EB6E59F135;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1.rcu callback_head;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 ctl_table_header::$F6608F9C284290DD0D040A9CAA4302C1 union packalign=0

00000020 struct ctl_table_poll
{
  atomic_t event;
  wait_queue_head_t wait;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ctl_table_poll.event atomic_t;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 ctl_table_poll.wait wait_queue_head_t;
//          0020 effalign(8) sda=0 bits=0000 ctl_table_poll struct packalign=0

00000078 struct ctl_table_root
{
  ctl_table_set default_set;
  ctl_table_set *(__cdecl *lookup)(ctl_table_root *);
  void (__cdecl *set_ownership)(ctl_table_header *, ctl_table *, kuid_t *, kgid_t *);
  int (__cdecl *permissions)(ctl_table_header *, ctl_table *);
};
//  0. 0000 0060 effalign(8) fda=0 bits=0000 ctl_table_root.default_set ctl_table_set;
//  1. 0060 0008 effalign(8) fda=0 bits=0000 ctl_table_root.lookup ctl_table_set *(__cdecl *)(ctl_table_root *);
//  2. 0068 0008 effalign(8) fda=0 bits=0000 ctl_table_root.set_ownership void (__cdecl *)(ctl_table_header *, ctl_table *, kuid_t *, kgid_t *);
//  3. 0070 0008 effalign(8) fda=0 bits=0000 ctl_table_root.permissions int (__cdecl *)(ctl_table_header *, ctl_table *);
//          0078 effalign(8) sda=0 bits=0000 ctl_table_root struct packalign=0

00000060 struct ctl_table_set
{
  int (__cdecl *is_seen)(ctl_table_set *);
  ctl_dir dir;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 ctl_table_set.is_seen int (__cdecl *)(ctl_table_set *);
//  1. 0008 0058 effalign(8) fda=0 bits=0000 ctl_table_set.dir ctl_dir;
//          0060 effalign(8) sda=0 bits=0000 ctl_table_set struct packalign=0

00000008 typedef void (*ctor_fn_t)(void);
00000004 enum ctx_state : __int32
{
  CONTEXT_DISABLED = 0xFFFFFFFF,
  CONTEXT_KERNEL = 0x0,
  CONTEXT_USER = 0x1,
  CONTEXT_GUEST = 0x2,
};
00000008 typedef unsigned __int64 cycles_t;
00000004 typedef __kernel_daddr_t daddr_t;
00000028 struct debug_obj
{
  hlist_node node;
  debug_obj_state state;
  unsigned int astate;
  void *object;
  debug_obj_descr *descr;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 debug_obj.node hlist_node;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 debug_obj.state debug_obj_state;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 debug_obj.astate unsigned int;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 debug_obj.object void *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 debug_obj.descr debug_obj_descr *;
//          0028 effalign(8) sda=0 bits=0000 debug_obj struct packalign=0

00000040 struct debug_obj_descr
{
  const char *name;
  void *(__cdecl *debug_hint)(void *);
  bool (__cdecl *is_static_object)(void *);
  bool (__cdecl *fixup_init)(void *, debug_obj_state);
  bool (__cdecl *fixup_activate)(void *, debug_obj_state);
  bool (__cdecl *fixup_destroy)(void *, debug_obj_state);
  bool (__cdecl *fixup_free)(void *, debug_obj_state);
  bool (__cdecl *fixup_assert_init)(void *, debug_obj_state);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.debug_hint void *(__cdecl *)(void *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.is_static_object bool (__cdecl *)(void *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.fixup_init bool (__cdecl *)(void *, debug_obj_state);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.fixup_activate bool (__cdecl *)(void *, debug_obj_state);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.fixup_destroy bool (__cdecl *)(void *, debug_obj_state);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.fixup_free bool (__cdecl *)(void *, debug_obj_state);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 debug_obj_descr.fixup_assert_init bool (__cdecl *)(void *, debug_obj_state);
//          0040 effalign(8) sda=0 bits=0000 debug_obj_descr struct packalign=0

00000004 enum debug_obj_state : unsigned __int32
{
  ODEBUG_STATE_NONE = 0x0,
  ODEBUG_STATE_INIT = 0x1,
  ODEBUG_STATE_INACTIVE = 0x2,
  ODEBUG_STATE_ACTIVE = 0x3,
  ODEBUG_STATE_DESTROYED = 0x4,
  ODEBUG_STATE_NOTAVAILABLE = 0x5,
  ODEBUG_STATE_MAX = 0x6,
};
00000020 struct deferred_split
{
  spinlock_t split_queue_lock;
  list_head split_queue;
  unsigned __int64 split_queue_len;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 deferred_split.split_queue_lock spinlock_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 deferred_split.split_queue list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 deferred_split.split_queue_len unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 deferred_split struct packalign=0

00000010 struct delayed_call
{
  void (__cdecl *fn)(void *);
  void *arg;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 delayed_call.fn void (__cdecl *)(void *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 delayed_call.arg void *;
//          0010 effalign(8) sda=0 bits=0000 delayed_call struct packalign=0

00000058 struct delayed_work
{
  work_struct work;
  timer_list timer;
  workqueue_struct *wq;
  int cpu;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 delayed_work.work work_struct;
//  1. 0020 0028 effalign(8) fda=0 bits=0000 delayed_work.timer timer_list;
//  2. 0048 0008 effalign(8) fda=0 bits=0000 delayed_work.wq workqueue_struct *;
//  3. 0050 0004 effalign(4) fda=0 bits=0000 delayed_work.cpu int;
//          0054 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 delayed_work struct packalign=0

000000C0 struct dentry
{
  unsigned int d_flags;
  seqcount_t d_seq;
  hlist_bl_node d_hash;
  dentry *d_parent;
  qstr d_name;
  inode *d_inode;
  unsigned __int8 d_iname[32];
  lockref d_lockref;
  const dentry_operations *d_op;
  super_block *d_sb;
  unsigned __int64 d_time;
  void *d_fsdata;
  union
  {
    list_head d_lru;
    wait_queue_head_t *d_wait;
  };
  list_head d_child;
  list_head d_subdirs;
  dentry::$3B49588AADC70A3FDC7C3D53565E8A90 d_u;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 dentry.d_flags unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 dentry.d_seq seqcount_t;
//  2. 0008 0010 effalign(8) fda=0 bits=0000 dentry.d_hash hlist_bl_node;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dentry.d_parent dentry *;
//  4. 0020 0010 effalign(8) fda=0 bits=0000 dentry.d_name qstr;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 dentry.d_inode inode *;
//  6. 0038 0020 effalign(1) fda=0 bits=0000 dentry.d_iname unsigned __int8[32];
//  7. 0058 0008 effalign(8) fda=0 bits=0000 dentry.d_lockref lockref;
//  8. 0060 0008 effalign(8) fda=0 bits=0000 dentry.d_op const dentry_operations *;
//  9. 0068 0008 effalign(8) fda=0 bits=0000 dentry.d_sb super_block *;
// 10. 0070 0008 effalign(8) fda=0 bits=0000 dentry.d_time unsigned __int64;
// 11. 0078 0008 effalign(8) fda=0 bits=0000 dentry.d_fsdata void *;
// 12. 0080 0010 effalign(8) fda=0 bits=0000 dentry.dentry::$F03198F59BB5B110A103CBC825C57379 dentry::$F03198F59BB5B110A103CBC825C57379;
// 13. 0090 0010 effalign(8) fda=0 bits=0000 dentry.d_child list_head;
// 14. 00A0 0010 effalign(8) fda=0 bits=0000 dentry.d_subdirs list_head;
// 15. 00B0 0010 effalign(8) fda=0 bits=0000 dentry.d_u dentry::$3B49588AADC70A3FDC7C3D53565E8A90;
//          00C0 effalign(8) sda=0 bits=0000 dentry struct packalign=0

00000010 union dentry::$3B49588AADC70A3FDC7C3D53565E8A90
{
  hlist_node d_alias;
  hlist_bl_node d_in_lookup_hash;
  callback_head d_rcu;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 dentry::$3B49588AADC70A3FDC7C3D53565E8A90.d_alias hlist_node;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 dentry::$3B49588AADC70A3FDC7C3D53565E8A90.d_in_lookup_hash hlist_bl_node;
//  2. 0000 0010 effalign(8) fda=0 bits=0000 dentry::$3B49588AADC70A3FDC7C3D53565E8A90.d_rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 dentry::$3B49588AADC70A3FDC7C3D53565E8A90 union packalign=0

00000010 union dentry::$F03198F59BB5B110A103CBC825C57379
{
  list_head d_lru;
  wait_queue_head_t *d_wait;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 dentry::$F03198F59BB5B110A103CBC825C57379.d_lru list_head;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 dentry::$F03198F59BB5B110A103CBC825C57379.d_wait wait_queue_head_t *;
//          0010 effalign(8) sda=0 bits=0000 dentry::$F03198F59BB5B110A103CBC825C57379 union packalign=0

00000004 enum dentry_d_lock_class : unsigned __int32
{
  DENTRY_D_LOCK_NORMAL = 0x0,
  DENTRY_D_LOCK_NESTED = 0x1,
};
00000080 struct __attribute__((aligned(64))) dentry_operations
{
  int (__cdecl *d_revalidate)(dentry *, unsigned int);
  int (__cdecl *d_weak_revalidate)(dentry *, unsigned int);
  int (__cdecl *d_hash)(const dentry *, qstr *);
  int (__cdecl *d_compare)(const dentry *, unsigned int, const char *, const qstr *);
  int (__cdecl *d_delete)(const dentry *);
  int (__cdecl *d_init)(dentry *);
  void (__cdecl *d_release)(dentry *);
  void (__cdecl *d_prune)(dentry *);
  void (__cdecl *d_iput)(dentry *, inode *);
  char *(__cdecl *d_dname)(dentry *, char *, int);
  vfsmount *(__cdecl *d_automount)(path *);
  int (__cdecl *d_manage)(const path *, bool);
  dentry *(__cdecl *d_real)(dentry *, const inode *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_revalidate int (__cdecl *)(dentry *, unsigned int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_weak_revalidate int (__cdecl *)(dentry *, unsigned int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_hash int (__cdecl *)(const dentry *, qstr *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_compare int (__cdecl *)(const dentry *, unsigned int, const char *, const qstr *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_delete int (__cdecl *)(const dentry *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_init int (__cdecl *)(dentry *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_release void (__cdecl *)(dentry *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_prune void (__cdecl *)(dentry *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_iput void (__cdecl *)(dentry *, inode *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_dname char *(__cdecl *)(dentry *, char *, int);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_automount vfsmount *(__cdecl *)(path *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_manage int (__cdecl *)(const path *, bool);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 dentry_operations.d_real dentry *(__cdecl *)(dentry *, const inode *);
//          0068 unpadded_size
//          0080 effalign(64) sda=7 bits=0000 dentry_operations struct packalign=0

00000030 struct dentry_stat_t
{
  __int64 nr_dentry;
  __int64 nr_unused;
  __int64 age_limit;
  __int64 want_pages;
  __int64 nr_negative;
  __int64 dummy;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.nr_dentry __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.nr_unused __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.age_limit __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.want_pages __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.nr_negative __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 dentry_stat_t.dummy __int64;
//          0030 effalign(8) sda=0 bits=0000 dentry_stat_t struct packalign=0

00000004 typedef u32 depot_stack_handle_t;
0000000A struct __attribute__((packed)) desc_ptr
{
  unsigned __int16 size;
  unsigned __int64 address;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 desc_ptr.size unsigned __int16;
//  1. 0002 0008 effalign(1) fda=0 bits=0000 desc_ptr.address unsigned __int64;
//          000A effalign(1) sda=0 bits=0040 desc_ptr struct packalign=0

00000008 struct __attribute__((packed)) desc_struct
{
  u16 limit0;
  u16 base0;
  unsigned __int16 base1 : 8;
  unsigned __int16 type : 4;
  unsigned __int16 s : 1;
  unsigned __int16 dpl : 2;
  unsigned __int16 p : 1;
  unsigned __int16 limit1 : 4;
  unsigned __int16 avl : 1;
  unsigned __int16 l : 1;
  unsigned __int16 d : 1;
  unsigned __int16 g : 1;
  unsigned __int16 base2 : 8;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 desc_struct.limit0 u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 desc_struct.base0 u16;
//  2. 0004. 0 8 effalign(1) fda=0 bits=0000 desc_struct.base1 bi.nbytes=2 U
//  3. 0004. 8 4 effalign(1) fda=0 bits=0000 desc_struct.type bi.nbytes=2 U
//  4. 0004.12 1 effalign(1) fda=0 bits=0000 desc_struct.s bi.nbytes=2 U
//  5. 0004.13 2 effalign(1) fda=0 bits=0000 desc_struct.dpl bi.nbytes=2 U
//  6. 0004.15 1 effalign(1) fda=0 bits=0000 desc_struct.p bi.nbytes=2 U
//  7. 0006. 0 4 effalign(1) fda=0 bits=0000 desc_struct.limit1 bi.nbytes=2 U
//  8. 0006. 4 1 effalign(1) fda=0 bits=0000 desc_struct.avl bi.nbytes=2 U
//  9. 0006. 5 1 effalign(1) fda=0 bits=0000 desc_struct.l bi.nbytes=2 U
// 10. 0006. 6 1 effalign(1) fda=0 bits=0000 desc_struct.d bi.nbytes=2 U
// 11. 0006. 7 1 effalign(1) fda=0 bits=0000 desc_struct.g bi.nbytes=2 U
// 12. 0006. 8 8 effalign(1) fda=0 bits=0000 desc_struct.base2 bi.nbytes=2 U
//          0008 effalign(1) sda=0 bits=0040 desc_struct struct packalign=0

00000008 struct dev_archdata
{
  void *iommu;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dev_archdata.iommu void *;
//          0008 effalign(8) sda=0 bits=0000 dev_archdata struct packalign=0

00000004 enum dev_dma_attr : unsigned __int32
{
  DEV_DMA_NOT_SUPPORTED = 0x0,
  DEV_DMA_NON_COHERENT = 0x1,
  DEV_DMA_COHERENT = 0x2,
};
00000028 struct dev_ext_attribute
{
  device_attribute attr;
  void *var;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 dev_ext_attribute.attr device_attribute;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 dev_ext_attribute.var void *;
//          0028 effalign(8) sda=0 bits=0000 dev_ext_attribute struct packalign=0

00000028 struct dev_links_info
{
  list_head suppliers;
  list_head consumers;
  dl_dev_state status;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 dev_links_info.suppliers list_head;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 dev_links_info.consumers list_head;
//  2. 0020 0004 effalign(4) fda=0 bits=0000 dev_links_info.status dl_dev_state;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 dev_links_info struct packalign=0

000000E0 struct dev_pagemap
{
  vmem_altmap altmap;
  resource res;
  percpu_ref *ref;
  percpu_ref internal_ref;
  completion done;
  memory_type type;
  unsigned int flags;
  const dev_pagemap_ops *ops;
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 dev_pagemap.altmap vmem_altmap;
//  1. 0030 0040 effalign(8) fda=0 bits=0000 dev_pagemap.res resource;
//  2. 0070 0008 effalign(8) fda=0 bits=0000 dev_pagemap.ref percpu_ref *;
//  3. 0078 0038 effalign(8) fda=0 bits=0000 dev_pagemap.internal_ref percpu_ref;
//  4. 00B0 0020 effalign(8) fda=0 bits=0000 dev_pagemap.done completion;
//  5. 00D0 0004 effalign(4) fda=0 bits=0000 dev_pagemap.type memory_type;
//  6. 00D4 0004 effalign(4) fda=0 bits=0000 dev_pagemap.flags unsigned int;
//  7. 00D8 0008 effalign(8) fda=0 bits=0000 dev_pagemap.ops const dev_pagemap_ops *;
//          00E0 effalign(8) sda=0 bits=0000 dev_pagemap struct packalign=0

00000020 struct dev_pagemap_ops
{
  void (__cdecl *page_free)(page *);
  void (__cdecl *kill)(dev_pagemap *);
  void (__cdecl *cleanup)(dev_pagemap *);
  vm_fault_t (__cdecl *migrate_to_ram)(vm_fault *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dev_pagemap_ops.page_free void (__cdecl *)(page *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dev_pagemap_ops.kill void (__cdecl *)(dev_pagemap *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 dev_pagemap_ops.cleanup void (__cdecl *)(dev_pagemap *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dev_pagemap_ops.migrate_to_ram vm_fault_t (__cdecl *)(vm_fault *);
//          0020 effalign(8) sda=0 bits=0000 dev_pagemap_ops struct packalign=0

FFFFFFFF struct dev_pin_info;
000000D8 struct dev_pm_domain
{
  dev_pm_ops ops;
  void (__cdecl *detach)(device *, bool);
  int (__cdecl *activate)(device *);
  void (__cdecl *sync)(device *);
  void (__cdecl *dismiss)(device *);
};
//  0. 0000 00B8 effalign(8) fda=0 bits=0000 dev_pm_domain.ops dev_pm_ops;
//  1. 00B8 0008 effalign(8) fda=0 bits=0000 dev_pm_domain.detach void (__cdecl *)(device *, bool);
//  2. 00C0 0008 effalign(8) fda=0 bits=0000 dev_pm_domain.activate int (__cdecl *)(device *);
//  3. 00C8 0008 effalign(8) fda=0 bits=0000 dev_pm_domain.sync void (__cdecl *)(device *);
//  4. 00D0 0008 effalign(8) fda=0 bits=0000 dev_pm_domain.dismiss void (__cdecl *)(device *);
//          00D8 effalign(8) sda=0 bits=0000 dev_pm_domain struct packalign=0

00000130 struct dev_pm_info
{
  pm_message_t power_state;
  unsigned __int32 can_wakeup : 1;
  unsigned __int32 async_suspend : 1;
  __int8 in_dpm_list : 1;
  __int8 is_prepared : 1;
  __int8 is_suspended : 1;
  __int8 is_noirq_suspended : 1;
  __int8 is_late_suspended : 1;
  __int8 no_pm : 1;
  __int8 early_init : 1;
  __int8 direct_complete : 1;
  u32 driver_flags;
  spinlock_t lock;
  list_head entry;
  completion completion;
  wakeup_source *wakeup;
  __int8 wakeup_path : 1;
  __int8 syscore : 1;
  __int8 no_pm_callbacks : 1;
  unsigned __int32 must_resume : 1;
  unsigned __int32 may_skip_resume : 1;
  hrtimer suspend_timer;
  u64 timer_expires;
  work_struct work;
  wait_queue_head_t wait_queue;
  wake_irq *wakeirq;
  atomic_t usage_count;
  atomic_t child_count;
  unsigned __int32 disable_depth : 3;
  unsigned __int32 idle_notification : 1;
  unsigned __int32 request_pending : 1;
  unsigned __int32 deferred_resume : 1;
  unsigned __int32 needs_force_resume : 1;
  unsigned __int32 runtime_auto : 1;
  __int8 ignore_children : 1;
  unsigned __int32 no_callbacks : 1;
  unsigned __int32 irq_safe : 1;
  unsigned __int32 use_autosuspend : 1;
  unsigned __int32 timer_autosuspends : 1;
  unsigned __int32 memalloc_noio : 1;
  unsigned int links_count;
  rpm_request request;
  rpm_status runtime_status;
  int runtime_error;
  int autosuspend_delay;
  u64 last_busy;
  u64 active_time;
  u64 suspended_time;
  u64 accounting_timestamp;
  pm_subsys_data *subsys_data;
  void (__cdecl *set_latency_tolerance)(device *, s32);
  dev_pm_qos *qos;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 dev_pm_info.power_state pm_message_t;
//  1. 0004. 0 1 effalign(1) fda=0 bits=0000 dev_pm_info.can_wakeup bi.nbytes=4 U
//  2. 0004. 1 1 effalign(1) fda=0 bits=0000 dev_pm_info.async_suspend bi.nbytes=4 U
//  3. 0004. 2 1 effalign(1) fda=0 bits=0000 dev_pm_info.in_dpm_list bi.nbytes=1 S
//  4. 0004. 3 1 effalign(1) fda=0 bits=0000 dev_pm_info.is_prepared bi.nbytes=1 S
//  5. 0004. 4 1 effalign(1) fda=0 bits=0000 dev_pm_info.is_suspended bi.nbytes=1 S
//  6. 0004. 5 1 effalign(1) fda=0 bits=0000 dev_pm_info.is_noirq_suspended bi.nbytes=1 S
//  7. 0004. 6 1 effalign(1) fda=0 bits=0000 dev_pm_info.is_late_suspended bi.nbytes=1 S
//  8. 0004. 7 1 effalign(1) fda=0 bits=0000 dev_pm_info.no_pm bi.nbytes=1 S
//  9. 0005. 0 1 effalign(1) fda=0 bits=0000 dev_pm_info.early_init bi.nbytes=1 S
// 10. 0005. 1 1 effalign(1) fda=0 bits=0000 dev_pm_info.direct_complete bi.nbytes=1 S
// 11. 0008 0004 effalign(4) fda=0 bits=0000 dev_pm_info.driver_flags u32;
// 12. 000C 0004 effalign(4) fda=0 bits=0000 dev_pm_info.lock spinlock_t;
// 13. 0010 0010 effalign(8) fda=0 bits=0000 dev_pm_info.entry list_head;
// 14. 0020 0020 effalign(8) fda=0 bits=0000 dev_pm_info.completion completion;
// 15. 0040 0008 effalign(8) fda=0 bits=0000 dev_pm_info.wakeup wakeup_source *;
// 16. 0048. 0 1 effalign(1) fda=0 bits=0000 dev_pm_info.wakeup_path bi.nbytes=1 S
// 17. 0048. 1 1 effalign(1) fda=0 bits=0000 dev_pm_info.syscore bi.nbytes=1 S
// 18. 0048. 2 1 effalign(1) fda=0 bits=0000 dev_pm_info.no_pm_callbacks bi.nbytes=1 S
// 19. 0048. 3 1 effalign(1) fda=0 bits=0000 dev_pm_info.must_resume bi.nbytes=4 U
// 20. 0048. 4 1 effalign(1) fda=0 bits=0000 dev_pm_info.may_skip_resume bi.nbytes=4 U
// 21. 0050 0040 effalign(8) fda=0 bits=0000 dev_pm_info.suspend_timer hrtimer;
// 22. 0090 0008 effalign(8) fda=0 bits=0000 dev_pm_info.timer_expires u64;
// 23. 0098 0020 effalign(8) fda=0 bits=0000 dev_pm_info.work work_struct;
// 24. 00B8 0018 effalign(8) fda=0 bits=0000 dev_pm_info.wait_queue wait_queue_head_t;
// 25. 00D0 0008 effalign(8) fda=0 bits=0000 dev_pm_info.wakeirq wake_irq *;
// 26. 00D8 0004 effalign(4) fda=0 bits=0000 dev_pm_info.usage_count atomic_t;
// 27. 00DC 0004 effalign(4) fda=0 bits=0000 dev_pm_info.child_count atomic_t;
// 28. 00E0. 0 3 effalign(1) fda=0 bits=0000 dev_pm_info.disable_depth bi.nbytes=4 U
// 29. 00E0. 3 1 effalign(1) fda=0 bits=0000 dev_pm_info.idle_notification bi.nbytes=4 U
// 30. 00E0. 4 1 effalign(1) fda=0 bits=0000 dev_pm_info.request_pending bi.nbytes=4 U
// 31. 00E0. 5 1 effalign(1) fda=0 bits=0000 dev_pm_info.deferred_resume bi.nbytes=4 U
// 32. 00E0. 6 1 effalign(1) fda=0 bits=0000 dev_pm_info.needs_force_resume bi.nbytes=4 U
// 33. 00E0. 7 1 effalign(1) fda=0 bits=0000 dev_pm_info.runtime_auto bi.nbytes=4 U
// 34. 00E1. 0 1 effalign(1) fda=0 bits=0000 dev_pm_info.ignore_children bi.nbytes=1 S
// 35. 00E0. 9 1 effalign(1) fda=0 bits=0000 dev_pm_info.no_callbacks bi.nbytes=4 U
// 36. 00E0.10 1 effalign(1) fda=0 bits=0000 dev_pm_info.irq_safe bi.nbytes=4 U
// 37. 00E0.11 1 effalign(1) fda=0 bits=0000 dev_pm_info.use_autosuspend bi.nbytes=4 U
// 38. 00E0.12 1 effalign(1) fda=0 bits=0000 dev_pm_info.timer_autosuspends bi.nbytes=4 U
// 39. 00E0.13 1 effalign(1) fda=0 bits=0000 dev_pm_info.memalloc_noio bi.nbytes=4 U
// 40. 00E4 0004 effalign(4) fda=0 bits=0000 dev_pm_info.links_count unsigned int;
// 41. 00E8 0004 effalign(4) fda=0 bits=0000 dev_pm_info.request rpm_request;
// 42. 00EC 0004 effalign(4) fda=0 bits=0000 dev_pm_info.runtime_status rpm_status;
// 43. 00F0 0004 effalign(4) fda=0 bits=0000 dev_pm_info.runtime_error int;
// 44. 00F4 0004 effalign(4) fda=0 bits=0000 dev_pm_info.autosuspend_delay int;
// 45. 00F8 0008 effalign(8) fda=0 bits=0000 dev_pm_info.last_busy u64;
// 46. 0100 0008 effalign(8) fda=0 bits=0000 dev_pm_info.active_time u64;
// 47. 0108 0008 effalign(8) fda=0 bits=0000 dev_pm_info.suspended_time u64;
// 48. 0110 0008 effalign(8) fda=0 bits=0000 dev_pm_info.accounting_timestamp u64;
// 49. 0118 0008 effalign(8) fda=0 bits=0000 dev_pm_info.subsys_data pm_subsys_data *;
// 50. 0120 0008 effalign(8) fda=0 bits=0000 dev_pm_info.set_latency_tolerance void (__cdecl *)(device *, s32);
// 51. 0128 0008 effalign(8) fda=0 bits=0000 dev_pm_info.qos dev_pm_qos *;
//          0130 effalign(8) sda=0 bits=0000 dev_pm_info struct packalign=0

000000B8 struct dev_pm_ops
{
  int (__cdecl *prepare)(device *);
  void (__cdecl *complete)(device *);
  int (__cdecl *suspend)(device *);
  int (__cdecl *resume)(device *);
  int (__cdecl *freeze)(device *);
  int (__cdecl *thaw)(device *);
  int (__cdecl *poweroff)(device *);
  int (__cdecl *restore)(device *);
  int (__cdecl *suspend_late)(device *);
  int (__cdecl *resume_early)(device *);
  int (__cdecl *freeze_late)(device *);
  int (__cdecl *thaw_early)(device *);
  int (__cdecl *poweroff_late)(device *);
  int (__cdecl *restore_early)(device *);
  int (__cdecl *suspend_noirq)(device *);
  int (__cdecl *resume_noirq)(device *);
  int (__cdecl *freeze_noirq)(device *);
  int (__cdecl *thaw_noirq)(device *);
  int (__cdecl *poweroff_noirq)(device *);
  int (__cdecl *restore_noirq)(device *);
  int (__cdecl *runtime_suspend)(device *);
  int (__cdecl *runtime_resume)(device *);
  int (__cdecl *runtime_idle)(device *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.prepare int (__cdecl *)(device *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.complete void (__cdecl *)(device *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.suspend int (__cdecl *)(device *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.resume int (__cdecl *)(device *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.freeze int (__cdecl *)(device *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.thaw int (__cdecl *)(device *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.poweroff int (__cdecl *)(device *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.restore int (__cdecl *)(device *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.suspend_late int (__cdecl *)(device *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.resume_early int (__cdecl *)(device *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.freeze_late int (__cdecl *)(device *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.thaw_early int (__cdecl *)(device *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.poweroff_late int (__cdecl *)(device *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.restore_early int (__cdecl *)(device *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.suspend_noirq int (__cdecl *)(device *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.resume_noirq int (__cdecl *)(device *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.freeze_noirq int (__cdecl *)(device *);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.thaw_noirq int (__cdecl *)(device *);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.poweroff_noirq int (__cdecl *)(device *);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.restore_noirq int (__cdecl *)(device *);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.runtime_suspend int (__cdecl *)(device *);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.runtime_resume int (__cdecl *)(device *);
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 dev_pm_ops.runtime_idle int (__cdecl *)(device *);
//          00B8 effalign(8) sda=0 bits=0000 dev_pm_ops struct packalign=0

FFFFFFFF struct dev_pm_qos;
00000004 enum dev_prop_type : unsigned __int32
{
  DEV_PROP_U8 = 0x0,
  DEV_PROP_U16 = 0x1,
  DEV_PROP_U32 = 0x2,
  DEV_PROP_U64 = 0x3,
  DEV_PROP_STRING = 0x4,
  DEV_PROP_MAX = 0x5,
};
00000004 typedef __kernel_dev_t dev_t;
00000008 typedef void *(__cdecl *devcon_match_fn_t)(device_connection *, int, void *);
000002D8 struct device
{
  kobject kobj;
  device *parent;
  device_private *p;
  const char *init_name;
  const device_type *type;
  bus_type *bus;
  device_driver *driver;
  void *platform_data;
  void *driver_data;
  mutex mutex;
  dev_links_info links;
  dev_pm_info power;
  dev_pm_domain *pm_domain;
  irq_domain *msi_domain;
  dev_pin_info *pins;
  raw_spinlock_t msi_lock;
  list_head msi_list;
  const dma_map_ops *dma_ops;
  u64 *dma_mask;
  u64 coherent_dma_mask;
  u64 bus_dma_mask;
  unsigned __int64 dma_pfn_offset;
  device_dma_parameters *dma_parms;
  list_head dma_pools;
  dev_archdata archdata;
  device_node *of_node;
  fwnode_handle *fwnode;
  int numa_node;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  list_head devres_head;
  class *class;
  const attribute_group **groups;
  void (__cdecl *release)(device *);
  iommu_group *iommu_group;
  iommu_fwspec *iommu_fwspec;
  iommu_param *iommu_param;
  __int8 offline_disabled : 1;
  __int8 offline : 1;
  __int8 of_node_reused : 1;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 device.kobj kobject;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 device.parent device *;
//  2. 0048 0008 effalign(8) fda=0 bits=0000 device.p device_private *;
//  3. 0050 0008 effalign(8) fda=0 bits=0000 device.init_name const char *;
//  4. 0058 0008 effalign(8) fda=0 bits=0000 device.type const device_type *;
//  5. 0060 0008 effalign(8) fda=0 bits=0000 device.bus bus_type *;
//  6. 0068 0008 effalign(8) fda=0 bits=0000 device.driver device_driver *;
//  7. 0070 0008 effalign(8) fda=0 bits=0000 device.platform_data void *;
//  8. 0078 0008 effalign(8) fda=0 bits=0000 device.driver_data void *;
//  9. 0080 0020 effalign(8) fda=0 bits=0000 device.mutex mutex;
// 10. 00A0 0028 effalign(8) fda=0 bits=0000 device.links dev_links_info;
// 11. 00C8 0130 effalign(8) fda=0 bits=0000 device.power dev_pm_info;
// 12. 01F8 0008 effalign(8) fda=0 bits=0000 device.pm_domain dev_pm_domain *;
// 13. 0200 0008 effalign(8) fda=0 bits=0000 device.msi_domain irq_domain *;
// 14. 0208 0008 effalign(8) fda=0 bits=0000 device.pins dev_pin_info *;
// 15. 0210 0004 effalign(4) fda=0 bits=0000 device.msi_lock raw_spinlock_t;
// 16. 0218 0010 effalign(8) fda=0 bits=0000 device.msi_list list_head;
// 17. 0228 0008 effalign(8) fda=0 bits=0000 device.dma_ops const dma_map_ops *;
// 18. 0230 0008 effalign(8) fda=0 bits=0000 device.dma_mask u64 *;
// 19. 0238 0008 effalign(8) fda=0 bits=0000 device.coherent_dma_mask u64;
// 20. 0240 0008 effalign(8) fda=0 bits=0000 device.bus_dma_mask u64;
// 21. 0248 0008 effalign(8) fda=0 bits=0000 device.dma_pfn_offset unsigned __int64;
// 22. 0250 0008 effalign(8) fda=0 bits=0000 device.dma_parms device_dma_parameters *;
// 23. 0258 0010 effalign(8) fda=0 bits=0000 device.dma_pools list_head;
// 24. 0268 0008 effalign(8) fda=0 bits=0000 device.archdata dev_archdata;
// 25. 0270 0008 effalign(8) fda=0 bits=0000 device.of_node device_node *;
// 26. 0278 0008 effalign(8) fda=0 bits=0000 device.fwnode fwnode_handle *;
// 27. 0280 0004 effalign(4) fda=0 bits=0000 device.numa_node int;
// 28. 0284 0004 effalign(4) fda=0 bits=0000 device.devt dev_t;
// 29. 0288 0004 effalign(4) fda=0 bits=0000 device.id u32;
// 30. 028C 0004 effalign(4) fda=0 bits=0000 device.devres_lock spinlock_t;
// 31. 0290 0010 effalign(8) fda=0 bits=0000 device.devres_head list_head;
// 32. 02A0 0008 effalign(8) fda=0 bits=0000 device.class class *;
// 33. 02A8 0008 effalign(8) fda=0 bits=0000 device.groups const attribute_group **;
// 34. 02B0 0008 effalign(8) fda=0 bits=0000 device.release void (__cdecl *)(device *);
// 35. 02B8 0008 effalign(8) fda=0 bits=0000 device.iommu_group iommu_group *;
// 36. 02C0 0008 effalign(8) fda=0 bits=0000 device.iommu_fwspec iommu_fwspec *;
// 37. 02C8 0008 effalign(8) fda=0 bits=0000 device.iommu_param iommu_param *;
// 38. 02D0. 0 1 effalign(1) fda=0 bits=0000 device.offline_disabled bi.nbytes=1 S
// 39. 02D0. 1 1 effalign(1) fda=0 bits=0000 device.offline bi.nbytes=1 S
// 40. 02D0. 2 1 effalign(1) fda=0 bits=0000 device.of_node_reused bi.nbytes=1 S
//          02D1 unpadded_size
//          02D8 effalign(8) sda=0 bits=0000 device struct packalign=0

00000020 struct device_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(device *, device_attribute *, char *);
  ssize_t (__cdecl *store)(device *, device_attribute *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 device_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 device_attribute.show ssize_t (__cdecl *)(device *, device_attribute *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 device_attribute.store ssize_t (__cdecl *)(device *, device_attribute *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 device_attribute struct packalign=0

00000030 struct device_connection
{
  fwnode_handle *fwnode;
  const char *endpoint[2];
  const char *id;
  list_head list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 device_connection.fwnode fwnode_handle *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 device_connection.endpoint const char *[2];
//  2. 0018 0008 effalign(8) fda=0 bits=0000 device_connection.id const char *;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 device_connection.list list_head;
//          0030 effalign(8) sda=0 bits=0000 device_connection struct packalign=0

00000010 struct device_dma_parameters
{
  unsigned int max_segment_size;
  unsigned __int64 segment_boundary_mask;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 device_dma_parameters.max_segment_size unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 device_dma_parameters.segment_boundary_mask unsigned __int64;
//          0010 effalign(8) sda=0 bits=0000 device_dma_parameters struct packalign=0

00000088 struct device_driver
{
  const char *name;
  bus_type *bus;
  module *owner;
  const char *mod_name;
  bool suppress_bind_attrs;
  probe_type probe_type;
  const of_device_id *of_match_table;
  const acpi_device_id *acpi_match_table;
  int (__cdecl *probe)(device *);
  int (__cdecl *remove)(device *);
  void (__cdecl *shutdown)(device *);
  int (__cdecl *suspend)(device *, pm_message_t);
  int (__cdecl *resume)(device *);
  const attribute_group **groups;
  const attribute_group **dev_groups;
  const dev_pm_ops *pm;
  void (__cdecl *coredump)(device *);
  driver_private *p;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 device_driver.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 device_driver.bus bus_type *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 device_driver.owner module *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 device_driver.mod_name const char *;
//  4. 0020 0001 effalign(1) fda=0 bits=0000 device_driver.suppress_bind_attrs bool;
//  5. 0024 0004 effalign(4) fda=0 bits=0000 device_driver.probe_type probe_type;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 device_driver.of_match_table const of_device_id *;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 device_driver.acpi_match_table const acpi_device_id *;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 device_driver.probe int (__cdecl *)(device *);
//  9. 0040 0008 effalign(8) fda=0 bits=0000 device_driver.remove int (__cdecl *)(device *);
// 10. 0048 0008 effalign(8) fda=0 bits=0000 device_driver.shutdown void (__cdecl *)(device *);
// 11. 0050 0008 effalign(8) fda=0 bits=0000 device_driver.suspend int (__cdecl *)(device *, pm_message_t);
// 12. 0058 0008 effalign(8) fda=0 bits=0000 device_driver.resume int (__cdecl *)(device *);
// 13. 0060 0008 effalign(8) fda=0 bits=0000 device_driver.groups const attribute_group **;
// 14. 0068 0008 effalign(8) fda=0 bits=0000 device_driver.dev_groups const attribute_group **;
// 15. 0070 0008 effalign(8) fda=0 bits=0000 device_driver.pm const dev_pm_ops *;
// 16. 0078 0008 effalign(8) fda=0 bits=0000 device_driver.coredump void (__cdecl *)(device *);
// 17. 0080 0008 effalign(8) fda=0 bits=0000 device_driver.p driver_private *;
//          0088 effalign(8) sda=0 bits=0000 device_driver struct packalign=0

00000058 struct device_link
{
  device *supplier;
  list_head s_node;
  device *consumer;
  list_head c_node;
  device_link_state status;
  u32 flags;
  refcount_t rpm_active;
  kref kref;
  callback_head callback_head;
  bool supplier_preactivated;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 device_link.supplier device *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 device_link.s_node list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 device_link.consumer device *;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 device_link.c_node list_head;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 device_link.status device_link_state;
//  5. 0034 0004 effalign(4) fda=0 bits=0000 device_link.flags u32;
//  6. 0038 0004 effalign(4) fda=0 bits=0000 device_link.rpm_active refcount_t;
//  7. 003C 0004 effalign(4) fda=0 bits=0000 device_link.kref kref;
//  8. 0040 0010 effalign(8) fda=0 bits=0000 device_link.callback_head callback_head;
//  9. 0050 0001 effalign(1) fda=0 bits=0000 device_link.supplier_preactivated bool;
//          0051 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 device_link struct packalign=0

00000004 enum device_link_state : __int32
{
  DL_STATE_NONE = 0xFFFFFFFF,
  DL_STATE_DORMANT = 0x0,
  DL_STATE_AVAILABLE = 0x1,
  DL_STATE_CONSUMER_PROBE = 0x2,
  DL_STATE_ACTIVE = 0x3,
  DL_STATE_SUPPLIER_UNBIND = 0x4,
};
00000060 struct device_node
{
  const char *name;
  phandle phandle;
  const char *full_name;
  fwnode_handle fwnode;
  property *properties;
  property *deadprops;
  device_node *parent;
  device_node *child;
  device_node *sibling;
  unsigned __int64 _flags;
  void *data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 device_node.name const char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 device_node.phandle phandle;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 device_node.full_name const char *;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 device_node.fwnode fwnode_handle;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 device_node.properties property *;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 device_node.deadprops property *;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 device_node.parent device_node *;
//  7. 0040 0008 effalign(8) fda=0 bits=0000 device_node.child device_node *;
//  8. 0048 0008 effalign(8) fda=0 bits=0000 device_node.sibling device_node *;
//  9. 0050 0008 effalign(8) fda=0 bits=0000 device_node._flags unsigned __int64;
// 10. 0058 0008 effalign(8) fda=0 bits=0000 device_node.data void *;
//          0060 effalign(8) sda=0 bits=0000 device_node struct packalign=0

FFFFFFFF struct device_private;
00000030 struct device_type
{
  const char *name;
  const attribute_group **groups;
  int (__cdecl *uevent)(device *, kobj_uevent_env *);
  char *(__cdecl *devnode)(device *, umode_t *, kuid_t *, kgid_t *);
  void (__cdecl *release)(device *);
  const dev_pm_ops *pm;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 device_type.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 device_type.groups const attribute_group **;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 device_type.uevent int (__cdecl *)(device *, kobj_uevent_env *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 device_type.devnode char *(__cdecl *)(device *, umode_t *, kuid_t *, kgid_t *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 device_type.release void (__cdecl *)(device *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 device_type.pm const dev_pm_ops *;
//          0030 effalign(8) sda=0 bits=0000 device_type struct packalign=0

FFFFFFFF typedef int __cdecl dio_iodone_t(kiocb *, loff_t, ssize_t, void *);
FFFFFFFF typedef void __cdecl dio_submit_t(bio *, inode *, loff_t);
00000010 struct dir_context
{
  filldir_t actor;
  loff_t pos;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dir_context.actor filldir_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dir_context.pos loff_t;
//          0010 effalign(8) sda=0 bits=0000 dir_context struct packalign=0

FFFFFFFF struct disk_events;
00000018 struct disk_part_iter
{
  gendisk *disk;
  hd_struct *part;
  int idx;
  unsigned int flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 disk_part_iter.disk gendisk *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 disk_part_iter.part hd_struct *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 disk_part_iter.idx int;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 disk_part_iter.flags unsigned int;
//          0018 effalign(8) sda=0 bits=0000 disk_part_iter struct packalign=0

00000020 struct disk_part_tbl
{
  callback_head callback_head;
  int len;
  hd_struct *last_lookup;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 disk_part_tbl.callback_head callback_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 disk_part_tbl.len int;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 disk_part_tbl.last_lookup hd_struct *;
//          0020 effalign(8) sda=0 bits=0000 disk_part_tbl struct packalign=0

00000080 struct disk_stats
{
  u64 nsecs[3];
  unsigned __int64 sectors[3];
  unsigned __int64 ios[3];
  unsigned __int64 merges[3];
  unsigned __int64 io_ticks;
  unsigned __int64 time_in_queue;
  local_t in_flight[2];
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 disk_stats.nsecs u64[3];
//  1. 0018 0018 effalign(8) fda=0 bits=0000 disk_stats.sectors unsigned __int64[3];
//  2. 0030 0018 effalign(8) fda=0 bits=0000 disk_stats.ios unsigned __int64[3];
//  3. 0048 0018 effalign(8) fda=0 bits=0000 disk_stats.merges unsigned __int64[3];
//  4. 0060 0008 effalign(8) fda=0 bits=0000 disk_stats.io_ticks unsigned __int64;
//  5. 0068 0008 effalign(8) fda=0 bits=0000 disk_stats.time_in_queue unsigned __int64;
//  6. 0070 0010 effalign(8) fda=0 bits=0000 disk_stats.in_flight local_t[2];
//          0080 effalign(8) sda=0 bits=0000 disk_stats struct packalign=0

00000004 enum dl_dev_state : unsigned __int32
{
  DL_DEV_NO_DRIVER = 0x0,
  DL_DEV_PROBING = 0x1,
  DL_DEV_DRIVER_BOUND = 0x2,
  DL_DEV_UNBINDING = 0x3,
};
00000008 typedef u64 dma_addr_t;
00000020 struct dma_domain
{
  list_head node;
  const dma_map_ops *dma_ops;
  int domain_nr;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 dma_domain.node list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 dma_domain.dma_ops const dma_map_ops *;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 dma_domain.domain_nr int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 dma_domain struct packalign=0

FFFFFFFF typedef int __cdecl dma_drain_needed_fn(request *);
FFFFFFFF struct dma_map_ops;
00000004 enum dmi_field : unsigned __int32
{
  DMI_NONE = 0x0,
  DMI_BIOS_VENDOR = 0x1,
  DMI_BIOS_VERSION = 0x2,
  DMI_BIOS_DATE = 0x3,
  DMI_SYS_VENDOR = 0x4,
  DMI_PRODUCT_NAME = 0x5,
  DMI_PRODUCT_VERSION = 0x6,
  DMI_PRODUCT_SERIAL = 0x7,
  DMI_PRODUCT_UUID = 0x8,
  DMI_PRODUCT_SKU = 0x9,
  DMI_PRODUCT_FAMILY = 0xA,
  DMI_BOARD_VENDOR = 0xB,
  DMI_BOARD_NAME = 0xC,
  DMI_BOARD_VERSION = 0xD,
  DMI_BOARD_SERIAL = 0xE,
  DMI_BOARD_ASSET_TAG = 0xF,
  DMI_CHASSIS_VENDOR = 0x10,
  DMI_CHASSIS_TYPE = 0x11,
  DMI_CHASSIS_VERSION = 0x12,
  DMI_CHASSIS_SERIAL = 0x13,
  DMI_CHASSIS_ASSET_TAG = 0x14,
  DMI_STRING_MAX = 0x15,
  DMI_OEM_STRING = 0x16,
};
00000050 struct dmi_strmatch
{
  unsigned __int8 slot : 7;
  unsigned __int8 exact_match : 1;
  char substr[79];
};
//  0. 0000. 0 7 effalign(1) fda=0 bits=0000 dmi_strmatch.slot bi.nbytes=1 U
//  1. 0000. 7 1 effalign(1) fda=0 bits=0000 dmi_strmatch.exact_match bi.nbytes=1 U
//  2. 0001 004F effalign(1) fda=0 bits=0000 dmi_strmatch.substr char[79];
//          0050 effalign(1) sda=0 bits=0000 dmi_strmatch struct packalign=0

00000158 struct dmi_system_id
{
  int (__cdecl *callback)(const dmi_system_id *);
  const char *ident;
  dmi_strmatch matches[4];
  void *driver_data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dmi_system_id.callback int (__cdecl *)(const dmi_system_id *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dmi_system_id.ident const char *;
//  2. 0010 0140 effalign(1) fda=0 bits=0000 dmi_system_id.matches dmi_strmatch[4];
//  3. 0150 0008 effalign(8) fda=0 bits=0000 dmi_system_id.driver_data void *;
//          0158 effalign(8) sda=0 bits=0000 dmi_system_id struct packalign=0

00000004 enum dpm_order : unsigned __int32
{
  DPM_ORDER_NONE = 0x0,
  DPM_ORDER_DEV_AFTER_PARENT = 0x1,
  DPM_ORDER_PARENT_BEFORE_DEV = 0x2,
  DPM_ORDER_DEV_LAST = 0x3,
};
00000180 struct dqstats
{
  unsigned __int64 stat[8];
  percpu_counter counter[8];
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 dqstats.stat unsigned __int64[8];
//  1. 0040 0140 effalign(8) fda=0 bits=0000 dqstats.counter percpu_counter[8];
//          0180 effalign(8) sda=0 bits=0000 dqstats struct packalign=0

000000D0 struct dquot
{
  hlist_node dq_hash;
  list_head dq_inuse;
  list_head dq_free;
  list_head dq_dirty;
  mutex dq_lock;
  spinlock_t dq_dqb_lock;
  atomic_t dq_count;
  super_block *dq_sb;
  kqid dq_id;
  loff_t dq_off;
  unsigned __int64 dq_flags;
  mem_dqblk dq_dqb;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 dquot.dq_hash hlist_node;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 dquot.dq_inuse list_head;
//  2. 0020 0010 effalign(8) fda=0 bits=0000 dquot.dq_free list_head;
//  3. 0030 0010 effalign(8) fda=0 bits=0000 dquot.dq_dirty list_head;
//  4. 0040 0020 effalign(8) fda=0 bits=0000 dquot.dq_lock mutex;
//  5. 0060 0004 effalign(4) fda=0 bits=0000 dquot.dq_dqb_lock spinlock_t;
//  6. 0064 0004 effalign(4) fda=0 bits=0000 dquot.dq_count atomic_t;
//  7. 0068 0008 effalign(8) fda=0 bits=0000 dquot.dq_sb super_block *;
//  8. 0070 0008 effalign(4) fda=0 bits=0000 dquot.dq_id kqid;
//  9. 0078 0008 effalign(8) fda=0 bits=0000 dquot.dq_off loff_t;
// 10. 0080 0008 effalign(8) fda=0 bits=0000 dquot.dq_flags unsigned __int64;
// 11. 0088 0048 effalign(8) fda=0 bits=0000 dquot.dq_dqb mem_dqblk;
//          00D0 effalign(8) sda=0 bits=0000 dquot struct packalign=0

00000058 struct dquot_operations
{
  int (__cdecl *write_dquot)(dquot *);
  dquot *(__cdecl *alloc_dquot)(super_block *, int);
  void (__cdecl *destroy_dquot)(dquot *);
  int (__cdecl *acquire_dquot)(dquot *);
  int (__cdecl *release_dquot)(dquot *);
  int (__cdecl *mark_dirty)(dquot *);
  int (__cdecl *write_info)(super_block *, int);
  qsize_t *(__cdecl *get_reserved_space)(inode *);
  int (__cdecl *get_projid)(inode *, kprojid_t *);
  int (__cdecl *get_inode_usage)(inode *, qsize_t *);
  int (__cdecl *get_next_id)(super_block *, kqid *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 dquot_operations.write_dquot int (__cdecl *)(dquot *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 dquot_operations.alloc_dquot dquot *(__cdecl *)(super_block *, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 dquot_operations.destroy_dquot void (__cdecl *)(dquot *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 dquot_operations.acquire_dquot int (__cdecl *)(dquot *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 dquot_operations.release_dquot int (__cdecl *)(dquot *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 dquot_operations.mark_dirty int (__cdecl *)(dquot *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 dquot_operations.write_info int (__cdecl *)(super_block *, int);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 dquot_operations.get_reserved_space qsize_t *(__cdecl *)(inode *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 dquot_operations.get_projid int (__cdecl *)(inode *, kprojid_t *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 dquot_operations.get_inode_usage int (__cdecl *)(inode *, qsize_t *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 dquot_operations.get_next_id int (__cdecl *)(super_block *, kqid *);
//          0058 effalign(8) sda=0 bits=0000 dquot_operations struct packalign=0

00000008 typedef int (__cdecl *dr_match_t)(device *, void *, void *);
00000008 typedef void (__cdecl *dr_release_t)(device *, void *);
00000020 struct driver_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(device_driver *, char *);
  ssize_t (__cdecl *store)(device_driver *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 driver_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 driver_attribute.show ssize_t (__cdecl *)(device_driver *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 driver_attribute.store ssize_t (__cdecl *)(device_driver *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 driver_attribute struct packalign=0

FFFFFFFF struct driver_private;
00000008 struct dynamic
{
  Elf32_Sword d_tag;
  dynamic::$355B7563D908D50B4B67712FB263B5CD d_un;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 dynamic.d_tag Elf32_Sword;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 dynamic.d_un dynamic::$355B7563D908D50B4B67712FB263B5CD;
//          0008 effalign(4) sda=0 bits=0000 dynamic struct packalign=0

00000004 union dynamic::$355B7563D908D50B4B67712FB263B5CD
{
  Elf32_Sword d_val;
  Elf32_Addr d_ptr;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 dynamic::$355B7563D908D50B4B67712FB263B5CD.d_val Elf32_Sword;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 dynamic::$355B7563D908D50B4B67712FB263B5CD.d_ptr Elf32_Addr;
//          0004 effalign(4) sda=0 bits=0000 dynamic::$355B7563D908D50B4B67712FB263B5CD union packalign=0

00000230 struct edd
{
  unsigned int mbr_signature[16];
  edd_info edd_info[6];
  unsigned __int8 mbr_signature_nr;
  unsigned __int8 edd_info_nr;
};
//  0. 0000 0040 effalign(4) fda=0 bits=0000 edd.mbr_signature unsigned int[16];
//  1. 0040 01EC effalign(1) fda=0 bits=0000 edd.edd_info edd_info[6];
//  2. 022C 0001 effalign(1) fda=0 bits=0000 edd.mbr_signature_nr unsigned __int8;
//  3. 022D 0001 effalign(1) fda=0 bits=0000 edd.edd_info_nr unsigned __int8;
//          022E unpadded_size
//          0230 effalign(4) sda=0 bits=0000 edd struct packalign=0

0000004A struct __attribute__((packed)) edd_device_params
{
  __u16 length;
  __u16 info_flags;
  __u32 num_default_cylinders;
  __u32 num_default_heads;
  __u32 sectors_per_track;
  __u64 number_of_sectors;
  __u16 bytes_per_sector;
  __u32 dpte_ptr;
  __u16 key;
  __u8 device_path_info_length;
  __u8 reserved2;
  __u16 reserved3;
  __u8 host_bus_type[4];
  __u8 interface_type[8];
  edd_device_params::$8071D3B9C2774723A2B601A86CD11D32 interface_path;
  edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3 device_path;
  __u8 reserved4;
  __u8 checksum;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 edd_device_params.length __u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 edd_device_params.info_flags __u16;
//  2. 0004 0004 effalign(1) fda=0 bits=0000 edd_device_params.num_default_cylinders __u32;
//  3. 0008 0004 effalign(1) fda=0 bits=0000 edd_device_params.num_default_heads __u32;
//  4. 000C 0004 effalign(1) fda=0 bits=0000 edd_device_params.sectors_per_track __u32;
//  5. 0010 0008 effalign(1) fda=0 bits=0000 edd_device_params.number_of_sectors __u64;
//  6. 0018 0002 effalign(1) fda=0 bits=0000 edd_device_params.bytes_per_sector __u16;
//  7. 001A 0004 effalign(1) fda=0 bits=0000 edd_device_params.dpte_ptr __u32;
//  8. 001E 0002 effalign(1) fda=0 bits=0000 edd_device_params.key __u16;
//  9. 0020 0001 effalign(1) fda=0 bits=0000 edd_device_params.device_path_info_length __u8;
// 10. 0021 0001 effalign(1) fda=0 bits=0000 edd_device_params.reserved2 __u8;
// 11. 0022 0002 effalign(1) fda=0 bits=0000 edd_device_params.reserved3 __u16;
// 12. 0024 0004 effalign(1) fda=0 bits=0000 edd_device_params.host_bus_type __u8[4];
// 13. 0028 0008 effalign(1) fda=0 bits=0000 edd_device_params.interface_type __u8[8];
// 14. 0030 0008 effalign(1) fda=0 bits=0000 edd_device_params.interface_path edd_device_params::$8071D3B9C2774723A2B601A86CD11D32;
// 15. 0038 0010 effalign(1) fda=0 bits=0000 edd_device_params.device_path edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3;
// 16. 0048 0001 effalign(1) fda=0 bits=0000 edd_device_params.reserved4 __u8;
// 17. 0049 0001 effalign(1) fda=0 bits=0000 edd_device_params.checksum __u8;
//          004A effalign(1) sda=0 bits=0040 edd_device_params struct packalign=0

00000010 union edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3
{
  $93C956B6D490774D97BADC09ACD6CEA4 ata;
  $6333D439F89A1B26526669C96B2EE017 atapi;
  $5E18C62100CCF68E4E5E71C179E6A3BF scsi;
  $42D5F5B662BD61DA5FC8E511DFAF9EBF usb;
  $CBD268B33DAA25A6FCA5CAD6B8CD0A90 i1394;
  $A325BF819B520A657BED1A4CCDD95F0C fibre;
  $CA92296E8AC6642454C9882B6FE5C971 i2o;
  $C230E8656B59790AE365036A1B215898 raid;
  $93C956B6D490774D97BADC09ACD6CEA4 sata;
  $5211084EA13AFCE1BC8B790544A28F9F unknown;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.ata $93C956B6D490774D97BADC09ACD6CEA4;
//  1. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.atapi $6333D439F89A1B26526669C96B2EE017;
//  2. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.scsi $5E18C62100CCF68E4E5E71C179E6A3BF;
//  3. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.usb $42D5F5B662BD61DA5FC8E511DFAF9EBF;
//  4. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.i1394 $CBD268B33DAA25A6FCA5CAD6B8CD0A90;
//  5. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.fibre $A325BF819B520A657BED1A4CCDD95F0C;
//  6. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.i2o $CA92296E8AC6642454C9882B6FE5C971;
//  7. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.raid $C230E8656B59790AE365036A1B215898;
//  8. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.sata $93C956B6D490774D97BADC09ACD6CEA4;
//  9. 0000 0010 effalign(1) fda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3.unknown $5211084EA13AFCE1BC8B790544A28F9F;
//          0010 effalign(1) sda=0 bits=0000 edd_device_params::$475B93B27E03D5E157199BDFEDF26BC3 union packalign=0

00000008 union edd_device_params::$8071D3B9C2774723A2B601A86CD11D32
{
  $A816B002F72288AE3D8ED110908EFED4 isa;
  $917BCA6048F928E1199E2CDF8EF12D5D pci;
  $29D3DFB965F453A09EC040260BDA44B8 ibnd;
  $29D3DFB965F453A09EC040260BDA44B8 xprs;
  $29D3DFB965F453A09EC040260BDA44B8 htpt;
  $29D3DFB965F453A09EC040260BDA44B8 unknown;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.isa $A816B002F72288AE3D8ED110908EFED4;
//  1. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.pci $917BCA6048F928E1199E2CDF8EF12D5D;
//  2. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.ibnd $29D3DFB965F453A09EC040260BDA44B8;
//  3. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.xprs $29D3DFB965F453A09EC040260BDA44B8;
//  4. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.htpt $29D3DFB965F453A09EC040260BDA44B8;
//  5. 0000 0008 effalign(1) fda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32.unknown $29D3DFB965F453A09EC040260BDA44B8;
//          0008 effalign(1) sda=0 bits=0000 edd_device_params::$8071D3B9C2774723A2B601A86CD11D32 union packalign=0

00000052 struct __attribute__((packed)) edd_info
{
  __u8 device;
  __u8 version;
  __u16 interface_support;
  __u16 legacy_max_cylinder;
  __u8 legacy_max_head;
  __u8 legacy_sectors_per_track;
  edd_device_params params;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 edd_info.device __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 edd_info.version __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 edd_info.interface_support __u16;
//  3. 0004 0002 effalign(1) fda=0 bits=0000 edd_info.legacy_max_cylinder __u16;
//  4. 0006 0001 effalign(1) fda=0 bits=0000 edd_info.legacy_max_head __u8;
//  5. 0007 0001 effalign(1) fda=0 bits=0000 edd_info.legacy_sectors_per_track __u8;
//  6. 0008 004A effalign(1) fda=0 bits=0000 edd_info.params edd_device_params;
//          0052 effalign(1) sda=0 bits=0040 edd_info struct packalign=0

00000080 struct edid_info
{
  unsigned __int8 dummy[128];
};
//  0. 0000 0080 effalign(1) fda=0 bits=0000 edid_info.dummy unsigned __int8[128];
//          0080 effalign(1) sda=0 bits=0000 edid_info struct packalign=0

00000160 struct efi
{
  efi_system_table_t *systab;
  unsigned int runtime_version;
  unsigned __int64 mps;
  unsigned __int64 acpi;
  unsigned __int64 acpi20;
  unsigned __int64 smbios;
  unsigned __int64 smbios3;
  unsigned __int64 boot_info;
  unsigned __int64 hcdp;
  unsigned __int64 uga;
  unsigned __int64 fw_vendor;
  unsigned __int64 runtime;
  unsigned __int64 config_table;
  unsigned __int64 esrt;
  unsigned __int64 properties_table;
  unsigned __int64 mem_attr_table;
  unsigned __int64 rng_seed;
  unsigned __int64 tpm_log;
  unsigned __int64 tpm_final_log;
  unsigned __int64 mokvar_table;
  unsigned __int64 mem_reserve;
  efi_get_time_t *get_time;
  efi_set_time_t *set_time;
  efi_get_wakeup_time_t *get_wakeup_time;
  efi_set_wakeup_time_t *set_wakeup_time;
  efi_get_variable_t *get_variable;
  efi_get_next_variable_t *get_next_variable;
  efi_set_variable_t *set_variable;
  efi_set_variable_t *set_variable_nonblocking;
  efi_query_variable_info_t *query_variable_info;
  efi_query_variable_info_t *query_variable_info_nonblocking;
  efi_update_capsule_t *update_capsule;
  efi_query_capsule_caps_t *query_capsule_caps;
  efi_get_next_high_mono_count_t *get_next_high_mono_count;
  efi_reset_system_t *reset_system;
  efi_set_virtual_address_map_t *set_virtual_address_map;
  efi_memory_map memmap;
  unsigned __int64 flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi.systab efi_system_table_t *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 efi.runtime_version unsigned int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi.mps unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi.acpi unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi.acpi20 unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi.smbios unsigned __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 efi.smbios3 unsigned __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 efi.boot_info unsigned __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 efi.hcdp unsigned __int64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 efi.uga unsigned __int64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 efi.fw_vendor unsigned __int64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 efi.runtime unsigned __int64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 efi.config_table unsigned __int64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 efi.esrt unsigned __int64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 efi.properties_table unsigned __int64;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 efi.mem_attr_table unsigned __int64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 efi.rng_seed unsigned __int64;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 efi.tpm_log unsigned __int64;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 efi.tpm_final_log unsigned __int64;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 efi.mokvar_table unsigned __int64;
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 efi.mem_reserve unsigned __int64;
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 efi.get_time efi_get_time_t *;
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 efi.set_time efi_set_time_t *;
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 efi.get_wakeup_time efi_get_wakeup_time_t *;
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 efi.set_wakeup_time efi_set_wakeup_time_t *;
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 efi.get_variable efi_get_variable_t *;
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 efi.get_next_variable efi_get_next_variable_t *;
// 27. 00D8 0008 effalign(8) fda=0 bits=0000 efi.set_variable efi_set_variable_t *;
// 28. 00E0 0008 effalign(8) fda=0 bits=0000 efi.set_variable_nonblocking efi_set_variable_t *;
// 29. 00E8 0008 effalign(8) fda=0 bits=0000 efi.query_variable_info efi_query_variable_info_t *;
// 30. 00F0 0008 effalign(8) fda=0 bits=0000 efi.query_variable_info_nonblocking efi_query_variable_info_t *;
// 31. 00F8 0008 effalign(8) fda=0 bits=0000 efi.update_capsule efi_update_capsule_t *;
// 32. 0100 0008 effalign(8) fda=0 bits=0000 efi.query_capsule_caps efi_query_capsule_caps_t *;
// 33. 0108 0008 effalign(8) fda=0 bits=0000 efi.get_next_high_mono_count efi_get_next_high_mono_count_t *;
// 34. 0110 0008 effalign(8) fda=0 bits=0000 efi.reset_system efi_reset_system_t *;
// 35. 0118 0008 effalign(8) fda=0 bits=0000 efi.set_virtual_address_map efi_set_virtual_address_map_t *;
// 36. 0120 0038 effalign(8) fda=0 bits=0000 efi.memmap efi_memory_map;
// 37. 0158 0008 effalign(8) fda=0 bits=0000 efi.flags unsigned __int64;
//          0160 effalign(8) sda=0 bits=0000 efi struct packalign=0

00000001 typedef u8 efi_bool_t;
00000030 struct efi_boot_memmap
{
  efi_memory_desc_t **map;
  unsigned __int64 *map_size;
  unsigned __int64 *desc_size;
  u32 *desc_ver;
  unsigned __int64 *key_ptr;
  unsigned __int64 *buff_size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.map efi_memory_desc_t **;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.map_size unsigned __int64 *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.desc_size unsigned __int64 *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.desc_ver u32 *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.key_ptr unsigned __int64 *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_boot_memmap.buff_size unsigned __int64 *;
//          0030 effalign(8) sda=0 bits=0000 efi_boot_memmap struct packalign=0

000000C8 struct __attribute__((packed)) efi_boot_services_32_t
{
  efi_table_hdr_t hdr;
  u32 raise_tpl;
  u32 restore_tpl;
  u32 allocate_pages;
  u32 free_pages;
  u32 get_memory_map;
  u32 allocate_pool;
  u32 free_pool;
  u32 create_event;
  u32 set_timer;
  u32 wait_for_event;
  u32 signal_event;
  u32 close_event;
  u32 check_event;
  u32 install_protocol_interface;
  u32 reinstall_protocol_interface;
  u32 uninstall_protocol_interface;
  u32 handle_protocol;
  u32 __reserved;
  u32 register_protocol_notify;
  u32 locate_handle;
  u32 locate_device_path;
  u32 install_configuration_table;
  u32 load_image;
  u32 start_image;
  u32 exit;
  u32 unload_image;
  u32 exit_boot_services;
  u32 get_next_monotonic_count;
  u32 stall;
  u32 set_watchdog_timer;
  u32 connect_controller;
  u32 disconnect_controller;
  u32 open_protocol;
  u32 close_protocol;
  u32 open_protocol_information;
  u32 protocols_per_handle;
  u32 locate_handle_buffer;
  u32 locate_protocol;
  u32 install_multiple_protocol_interfaces;
  u32 uninstall_multiple_protocol_interfaces;
  u32 calculate_crc32;
  u32 copy_mem;
  u32 set_mem;
  u32 create_event_ex;
};
//  0. 0000 0018 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.hdr efi_table_hdr_t;
//  1. 0018 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.raise_tpl u32;
//  2. 001C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.restore_tpl u32;
//  3. 0020 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.allocate_pages u32;
//  4. 0024 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.free_pages u32;
//  5. 0028 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.get_memory_map u32;
//  6. 002C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.allocate_pool u32;
//  7. 0030 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.free_pool u32;
//  8. 0034 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.create_event u32;
//  9. 0038 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.set_timer u32;
// 10. 003C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.wait_for_event u32;
// 11. 0040 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.signal_event u32;
// 12. 0044 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.close_event u32;
// 13. 0048 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.check_event u32;
// 14. 004C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.install_protocol_interface u32;
// 15. 0050 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.reinstall_protocol_interface u32;
// 16. 0054 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.uninstall_protocol_interface u32;
// 17. 0058 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.handle_protocol u32;
// 18. 005C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.__reserved u32;
// 19. 0060 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.register_protocol_notify u32;
// 20. 0064 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.locate_handle u32;
// 21. 0068 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.locate_device_path u32;
// 22. 006C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.install_configuration_table u32;
// 23. 0070 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.load_image u32;
// 24. 0074 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.start_image u32;
// 25. 0078 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.exit u32;
// 26. 007C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.unload_image u32;
// 27. 0080 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.exit_boot_services u32;
// 28. 0084 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.get_next_monotonic_count u32;
// 29. 0088 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.stall u32;
// 30. 008C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.set_watchdog_timer u32;
// 31. 0090 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.connect_controller u32;
// 32. 0094 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.disconnect_controller u32;
// 33. 0098 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.open_protocol u32;
// 34. 009C 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.close_protocol u32;
// 35. 00A0 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.open_protocol_information u32;
// 36. 00A4 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.protocols_per_handle u32;
// 37. 00A8 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.locate_handle_buffer u32;
// 38. 00AC 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.locate_protocol u32;
// 39. 00B0 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.install_multiple_protocol_interfaces u32;
// 40. 00B4 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.uninstall_multiple_protocol_interfaces u32;
// 41. 00B8 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.calculate_crc32 u32;
// 42. 00BC 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.copy_mem u32;
// 43. 00C0 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.set_mem u32;
// 44. 00C4 0004 effalign(1) fda=0 bits=0000 efi_boot_services_32_t.create_event_ex u32;
//          00C8 effalign(1) sda=0 bits=0040 efi_boot_services_32_t struct packalign=0

00000178 struct __attribute__((packed)) efi_boot_services_64_t
{
  efi_table_hdr_t hdr;
  u64 raise_tpl;
  u64 restore_tpl;
  u64 allocate_pages;
  u64 free_pages;
  u64 get_memory_map;
  u64 allocate_pool;
  u64 free_pool;
  u64 create_event;
  u64 set_timer;
  u64 wait_for_event;
  u64 signal_event;
  u64 close_event;
  u64 check_event;
  u64 install_protocol_interface;
  u64 reinstall_protocol_interface;
  u64 uninstall_protocol_interface;
  u64 handle_protocol;
  u64 __reserved;
  u64 register_protocol_notify;
  u64 locate_handle;
  u64 locate_device_path;
  u64 install_configuration_table;
  u64 load_image;
  u64 start_image;
  u64 exit;
  u64 unload_image;
  u64 exit_boot_services;
  u64 get_next_monotonic_count;
  u64 stall;
  u64 set_watchdog_timer;
  u64 connect_controller;
  u64 disconnect_controller;
  u64 open_protocol;
  u64 close_protocol;
  u64 open_protocol_information;
  u64 protocols_per_handle;
  u64 locate_handle_buffer;
  u64 locate_protocol;
  u64 install_multiple_protocol_interfaces;
  u64 uninstall_multiple_protocol_interfaces;
  u64 calculate_crc32;
  u64 copy_mem;
  u64 set_mem;
  u64 create_event_ex;
};
//  0. 0000 0018 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.raise_tpl u64;
//  2. 0020 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.restore_tpl u64;
//  3. 0028 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.allocate_pages u64;
//  4. 0030 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.free_pages u64;
//  5. 0038 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.get_memory_map u64;
//  6. 0040 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.allocate_pool u64;
//  7. 0048 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.free_pool u64;
//  8. 0050 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.create_event u64;
//  9. 0058 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.set_timer u64;
// 10. 0060 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.wait_for_event u64;
// 11. 0068 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.signal_event u64;
// 12. 0070 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.close_event u64;
// 13. 0078 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.check_event u64;
// 14. 0080 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.install_protocol_interface u64;
// 15. 0088 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.reinstall_protocol_interface u64;
// 16. 0090 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.uninstall_protocol_interface u64;
// 17. 0098 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.handle_protocol u64;
// 18. 00A0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.__reserved u64;
// 19. 00A8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.register_protocol_notify u64;
// 20. 00B0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.locate_handle u64;
// 21. 00B8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.locate_device_path u64;
// 22. 00C0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.install_configuration_table u64;
// 23. 00C8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.load_image u64;
// 24. 00D0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.start_image u64;
// 25. 00D8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.exit u64;
// 26. 00E0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.unload_image u64;
// 27. 00E8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.exit_boot_services u64;
// 28. 00F0 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.get_next_monotonic_count u64;
// 29. 00F8 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.stall u64;
// 30. 0100 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.set_watchdog_timer u64;
// 31. 0108 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.connect_controller u64;
// 32. 0110 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.disconnect_controller u64;
// 33. 0118 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.open_protocol u64;
// 34. 0120 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.close_protocol u64;
// 35. 0128 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.open_protocol_information u64;
// 36. 0130 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.protocols_per_handle u64;
// 37. 0138 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.locate_handle_buffer u64;
// 38. 0140 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.locate_protocol u64;
// 39. 0148 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.install_multiple_protocol_interfaces u64;
// 40. 0150 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.uninstall_multiple_protocol_interfaces u64;
// 41. 0158 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.calculate_crc32 u64;
// 42. 0160 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.copy_mem u64;
// 43. 0168 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.set_mem u64;
// 44. 0170 0008 effalign(1) fda=0 bits=0000 efi_boot_services_64_t.create_event_ex u64;
//          0178 effalign(1) sda=0 bits=0040 efi_boot_services_64_t struct packalign=0

00000178 struct efi_boot_services_t
{
  efi_table_hdr_t hdr;
  void *raise_tpl;
  void *restore_tpl;
  efi_status_t (__cdecl *allocate_pages)(int, int, unsigned __int64, efi_physical_addr_t *);
  efi_status_t (__cdecl *free_pages)(efi_physical_addr_t, unsigned __int64);
  efi_status_t (__cdecl *get_memory_map)(unsigned __int64 *, void *, unsigned __int64 *, unsigned __int64 *, u32 *);
  efi_status_t (__cdecl *allocate_pool)(int, unsigned __int64, void **);
  efi_status_t (__cdecl *free_pool)(void *);
  void *create_event;
  void *set_timer;
  void *wait_for_event;
  void *signal_event;
  void *close_event;
  void *check_event;
  void *install_protocol_interface;
  void *reinstall_protocol_interface;
  void *uninstall_protocol_interface;
  efi_status_t (__cdecl *handle_protocol)(efi_handle_t, efi_guid_t *, void **);
  void *__reserved;
  void *register_protocol_notify;
  efi_status_t (__cdecl *locate_handle)(int, efi_guid_t *, void *, unsigned __int64 *, efi_handle_t *);
  void *locate_device_path;
  efi_status_t (__cdecl *install_configuration_table)(efi_guid_t *, void *);
  void *load_image;
  void *start_image;
  void *exit;
  void *unload_image;
  efi_status_t (__cdecl *exit_boot_services)(efi_handle_t, unsigned __int64);
  void *get_next_monotonic_count;
  void *stall;
  void *set_watchdog_timer;
  void *connect_controller;
  void *disconnect_controller;
  void *open_protocol;
  void *close_protocol;
  void *open_protocol_information;
  void *protocols_per_handle;
  void *locate_handle_buffer;
  efi_status_t (__cdecl *locate_protocol)(efi_guid_t *, void *, void **);
  void *install_multiple_protocol_interfaces;
  void *uninstall_multiple_protocol_interfaces;
  void *calculate_crc32;
  void *copy_mem;
  void *set_mem;
  void *create_event_ex;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_boot_services_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.raise_tpl void *;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.restore_tpl void *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.allocate_pages efi_status_t (__cdecl *)(int, int, unsigned __int64, efi_physical_addr_t *);
//  4. 0030 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.free_pages efi_status_t (__cdecl *)(efi_physical_addr_t, unsigned __int64);
//  5. 0038 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.get_memory_map efi_status_t (__cdecl *)(unsigned __int64 *, void *, unsigned __int64 *, unsigned __int64 *, u32 *);
//  6. 0040 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.allocate_pool efi_status_t (__cdecl *)(int, unsigned __int64, void **);
//  7. 0048 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.free_pool efi_status_t (__cdecl *)(void *);
//  8. 0050 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.create_event void *;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.set_timer void *;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.wait_for_event void *;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.signal_event void *;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.close_event void *;
// 13. 0078 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.check_event void *;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.install_protocol_interface void *;
// 15. 0088 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.reinstall_protocol_interface void *;
// 16. 0090 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.uninstall_protocol_interface void *;
// 17. 0098 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.handle_protocol efi_status_t (__cdecl *)(efi_handle_t, efi_guid_t *, void **);
// 18. 00A0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.__reserved void *;
// 19. 00A8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.register_protocol_notify void *;
// 20. 00B0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.locate_handle efi_status_t (__cdecl *)(int, efi_guid_t *, void *, unsigned __int64 *, efi_handle_t *);
// 21. 00B8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.locate_device_path void *;
// 22. 00C0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.install_configuration_table efi_status_t (__cdecl *)(efi_guid_t *, void *);
// 23. 00C8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.load_image void *;
// 24. 00D0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.start_image void *;
// 25. 00D8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.exit void *;
// 26. 00E0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.unload_image void *;
// 27. 00E8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.exit_boot_services efi_status_t (__cdecl *)(efi_handle_t, unsigned __int64);
// 28. 00F0 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.get_next_monotonic_count void *;
// 29. 00F8 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.stall void *;
// 30. 0100 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.set_watchdog_timer void *;
// 31. 0108 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.connect_controller void *;
// 32. 0110 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.disconnect_controller void *;
// 33. 0118 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.open_protocol void *;
// 34. 0120 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.close_protocol void *;
// 35. 0128 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.open_protocol_information void *;
// 36. 0130 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.protocols_per_handle void *;
// 37. 0138 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.locate_handle_buffer void *;
// 38. 0140 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.locate_protocol efi_status_t (__cdecl *)(efi_guid_t *, void *, void **);
// 39. 0148 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.install_multiple_protocol_interfaces void *;
// 40. 0150 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.uninstall_multiple_protocol_interfaces void *;
// 41. 0158 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.calculate_crc32 void *;
// 42. 0160 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.copy_mem void *;
// 43. 0168 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.set_mem void *;
// 44. 0170 0008 effalign(8) fda=0 bits=0000 efi_boot_services_t.create_event_ex void *;
//          0178 effalign(8) sda=0 bits=0000 efi_boot_services_t struct packalign=0

0000001C struct efi_capsule_header_t
{
  efi_guid_t guid;
  u32 headersize;
  u32 flags;
  u32 imagesize;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_capsule_header_t.guid efi_guid_t;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 efi_capsule_header_t.headersize u32;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 efi_capsule_header_t.flags u32;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 efi_capsule_header_t.imagesize u32;
//          001C effalign(4) sda=0 bits=0000 efi_capsule_header_t struct packalign=0

00000030 struct efi_cert_x509_sha256_t
{
  efi_sha256_hash_t to_be_signed_hash;
  efi_time_t time_of_revocation;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 efi_cert_x509_sha256_t.to_be_signed_hash efi_sha256_hash_t;
//  1. 0020 0010 effalign(4) fda=0 bits=0000 efi_cert_x509_sha256_t.time_of_revocation efi_time_t;
//          0030 effalign(4) sda=0 bits=0000 efi_cert_x509_sha256_t struct packalign=0

00000002 typedef u16 efi_char16_t;
00000014 struct efi_config_table_32_t
{
  efi_guid_t guid;
  u32 table;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_config_table_32_t.guid efi_guid_t;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 efi_config_table_32_t.table u32;
//          0014 effalign(4) sda=0 bits=0000 efi_config_table_32_t struct packalign=0

00000018 struct efi_config_table_64_t
{
  efi_guid_t guid;
  u64 table;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_config_table_64_t.guid efi_guid_t;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 efi_config_table_64_t.table u64;
//          0018 effalign(8) sda=0 bits=0000 efi_config_table_64_t struct packalign=0

00000018 struct efi_config_table_t
{
  efi_guid_t guid;
  unsigned __int64 table;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_config_table_t.guid efi_guid_t;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 efi_config_table_t.table unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 efi_config_table_t struct packalign=0

00000020 struct efi_config_table_type_t
{
  efi_guid_t guid;
  const char *name;
  unsigned __int64 *ptr;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_config_table_type_t.guid efi_guid_t;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 efi_config_table_type_t.name const char *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 efi_config_table_type_t.ptr unsigned __int64 *;
//          0020 effalign(8) sda=0 bits=0000 efi_config_table_type_t struct packalign=0

0000000C struct __attribute__((packed)) efi_dev_path
{
  u8 type;
  u8 sub_type;
  u16 length;
  union
  {
    $792D8DB77BFDC553877F8E79F73D09AC acpi;
    $DA3C97E7A5F978318679C7D516AF6688 pci;
  };
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 efi_dev_path.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 efi_dev_path.sub_type u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 efi_dev_path.length u16;
//  3. 0004 0008 effalign(1) fda=0 bits=0000 efi_dev_path.efi_dev_path::$D95126A072C59514027B9367C9FBFF42 efi_dev_path::$D95126A072C59514027B9367C9FBFF42;
//          000C effalign(1) sda=0 bits=0040 efi_dev_path struct packalign=0

00000008 union efi_dev_path::$D95126A072C59514027B9367C9FBFF42
{
  $792D8DB77BFDC553877F8E79F73D09AC acpi;
  $DA3C97E7A5F978318679C7D516AF6688 pci;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 efi_dev_path::$D95126A072C59514027B9367C9FBFF42.acpi $792D8DB77BFDC553877F8E79F73D09AC;
//  1. 0000 0002 effalign(1) fda=0 bits=0000 efi_dev_path::$D95126A072C59514027B9367C9FBFF42.pci $DA3C97E7A5F978318679C7D516AF6688;
//          0008 effalign(4) sda=0 bits=0000 efi_dev_path::$D95126A072C59514027B9367C9FBFF42 union packalign=0

00000008 typedef void (__cdecl *efi_element_handler_t)(const char *, const void *, size_t);
00000008 typedef efi_status_t (__cdecl *efi_exit_boot_map_processing)(efi_system_table_t *, efi_boot_memmap *, void *);
00000020 struct efi_fdt_params
{
  u64 system_table;
  u64 mmap;
  u32 mmap_size;
  u32 desc_size;
  u32 desc_ver;
  u32 secure_boot;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_fdt_params.system_table u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_fdt_params.mmap u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 efi_fdt_params.mmap_size u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 efi_fdt_params.desc_size u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 efi_fdt_params.desc_ver u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 efi_fdt_params.secure_boot u32;
//          0020 effalign(8) sda=0 bits=0000 efi_fdt_params struct packalign=0

00000030 struct efi_file_handle_32_t
{
  u64 revision;
  u32 open;
  u32 close;
  u32 delete;
  u32 read;
  u32 write;
  u32 get_position;
  u32 set_position;
  u32 get_info;
  u32 set_info;
  u32 flush;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_file_handle_32_t.revision u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.open u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.close u32;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.delete u32;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.read u32;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.write u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.get_position u32;
//  7. 0020 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.set_position u32;
//  8. 0024 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.get_info u32;
//  9. 0028 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.set_info u32;
// 10. 002C 0004 effalign(4) fda=0 bits=0000 efi_file_handle_32_t.flush u32;
//          0030 effalign(8) sda=0 bits=0000 efi_file_handle_32_t struct packalign=0

00000058 struct efi_file_handle_64_t
{
  u64 revision;
  u64 open;
  u64 close;
  u64 delete;
  u64 read;
  u64 write;
  u64 get_position;
  u64 set_position;
  u64 get_info;
  u64 set_info;
  u64 flush;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.revision u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.open u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.close u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.delete u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.read u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.write u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.get_position u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.set_position u64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.get_info u64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.set_info u64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 efi_file_handle_64_t.flush u64;
//          0058 effalign(8) sda=0 bits=0000 efi_file_handle_64_t struct packalign=0

00000058 typedef _efi_file_handle efi_file_handle_t;
00000058 struct efi_file_info_t
{
  u64 size;
  u64 file_size;
  u64 phys_size;
  efi_time_t create_time;
  efi_time_t last_access_time;
  efi_time_t modification_time;
  __attribute__((aligned(8))) __u64 attribute;
  efi_char16_t filename[1];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_file_info_t.size u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_file_info_t.file_size u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_file_info_t.phys_size u64;
//  3. 0018 0010 effalign(4) fda=0 bits=0000 efi_file_info_t.create_time efi_time_t;
//  4. 0028 0010 effalign(4) fda=0 bits=0000 efi_file_info_t.last_access_time efi_time_t;
//  5. 0038 0010 effalign(4) fda=0 bits=0000 efi_file_info_t.modification_time efi_time_t;
//  6. 0048 0008 effalign(8) fda=4 bits=0000 efi_file_info_t.attribute __u64;
//  7. 0050 0002 effalign(2) fda=0 bits=0000 efi_file_info_t.filename efi_char16_t[1];
//          0052 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 efi_file_info_t struct packalign=0

00000010 struct efi_file_io_interface_32_t
{
  u64 revision;
  u32 open_volume;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_file_io_interface_32_t.revision u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 efi_file_io_interface_32_t.open_volume u32;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 efi_file_io_interface_32_t struct packalign=0

00000010 struct efi_file_io_interface_64_t
{
  u64 revision;
  u64 open_volume;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_file_io_interface_64_t.revision u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_file_io_interface_64_t.open_volume u64;
//          0010 effalign(8) sda=0 bits=0000 efi_file_io_interface_64_t struct packalign=0

00000010 typedef _efi_file_io_interface efi_file_io_interface_t;
00000008 typedef int (__cdecl *efi_freemem_callback_t)(u64, u64, void *);
00000004 struct __attribute__((packed)) efi_generic_dev_path
{
  u8 type;
  u8 sub_type;
  u16 length;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 efi_generic_dev_path.type u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 efi_generic_dev_path.sub_type u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 efi_generic_dev_path.length u16;
//          0004 effalign(1) sda=0 bits=0040 efi_generic_dev_path struct packalign=0

FFFFFFFF typedef efi_status_t __cdecl efi_get_next_high_mono_count_t(u32 *);
FFFFFFFF typedef efi_status_t __cdecl efi_get_next_variable_t(unsigned __int64 *, efi_char16_t *, efi_guid_t *);
FFFFFFFF typedef efi_status_t __cdecl efi_get_time_t(efi_time_t *, efi_time_cap_t *);
FFFFFFFF typedef efi_status_t __cdecl efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, unsigned __int64 *, void *);
FFFFFFFF typedef efi_status_t __cdecl efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);
00000024 struct __attribute__((packed)) efi_graphics_output_mode_info
{
  u32 version;
  u32 horizontal_resolution;
  u32 vertical_resolution;
  int pixel_format;
  efi_pixel_bitmask pixel_information;
  u32 pixels_per_scan_line;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.version u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.horizontal_resolution u32;
//  2. 0008 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.vertical_resolution u32;
//  3. 000C 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.pixel_format int;
//  4. 0010 0010 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.pixel_information efi_pixel_bitmask;
//  5. 0020 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_mode_info.pixels_per_scan_line u32;
//          0024 effalign(1) sda=0 bits=0040 efi_graphics_output_mode_info struct packalign=0

00000020 struct efi_graphics_output_protocol
{
  unsigned __int64 query_mode;
  unsigned __int64 set_mode;
  unsigned __int64 blt;
  efi_graphics_output_protocol_mode *mode;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol.query_mode unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol.set_mode unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol.blt unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol.mode efi_graphics_output_protocol_mode *;
//          0020 effalign(8) sda=0 bits=0000 efi_graphics_output_protocol struct packalign=0

00000010 struct efi_graphics_output_protocol_32
{
  u32 query_mode;
  u32 set_mode;
  u32 blt;
  u32 mode;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_graphics_output_protocol_32.query_mode u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_graphics_output_protocol_32.set_mode u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_graphics_output_protocol_32.blt u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_graphics_output_protocol_32.mode u32;
//          0010 effalign(4) sda=0 bits=0000 efi_graphics_output_protocol_32 struct packalign=0

00000020 struct efi_graphics_output_protocol_64
{
  u64 query_mode;
  u64 set_mode;
  u64 blt;
  u64 mode;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol_64.query_mode u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol_64.set_mode u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol_64.blt u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_graphics_output_protocol_64.mode u64;
//          0020 effalign(8) sda=0 bits=0000 efi_graphics_output_protocol_64 struct packalign=0

00000028 struct __attribute__((packed)) efi_graphics_output_protocol_mode
{
  u32 max_mode;
  u32 mode;
  unsigned __int64 info;
  unsigned __int64 size_of_info;
  u64 frame_buffer_base;
  unsigned __int64 frame_buffer_size;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.max_mode u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.mode u32;
//  2. 0008 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.info unsigned __int64;
//  3. 0010 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.size_of_info unsigned __int64;
//  4. 0018 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.frame_buffer_base u64;
//  5. 0020 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode.frame_buffer_size unsigned __int64;
//          0028 effalign(1) sda=0 bits=0040 efi_graphics_output_protocol_mode struct packalign=0

0000001C struct __attribute__((packed)) efi_graphics_output_protocol_mode_32
{
  u32 max_mode;
  u32 mode;
  u32 info;
  u32 size_of_info;
  u64 frame_buffer_base;
  u32 frame_buffer_size;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.max_mode u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.mode u32;
//  2. 0008 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.info u32;
//  3. 000C 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.size_of_info u32;
//  4. 0010 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.frame_buffer_base u64;
//  5. 0018 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_32.frame_buffer_size u32;
//          001C effalign(1) sda=0 bits=0040 efi_graphics_output_protocol_mode_32 struct packalign=0

00000028 struct __attribute__((packed)) efi_graphics_output_protocol_mode_64
{
  u32 max_mode;
  u32 mode;
  u64 info;
  u64 size_of_info;
  u64 frame_buffer_base;
  u64 frame_buffer_size;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.max_mode u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.mode u32;
//  2. 0008 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.info u64;
//  3. 0010 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.size_of_info u64;
//  4. 0018 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.frame_buffer_base u64;
//  5. 0020 0008 effalign(1) fda=0 bits=0000 efi_graphics_output_protocol_mode_64.frame_buffer_size u64;
//          0028 effalign(1) sda=0 bits=0040 efi_graphics_output_protocol_mode_64 struct packalign=0

00000008 typedef efi_status_t (__cdecl *efi_graphics_output_protocol_query_mode)(efi_graphics_output_protocol *, u32, unsigned __int64 *, efi_graphics_output_mode_info **);
00000010 typedef guid_t efi_guid_t;
00000008 typedef void *efi_handle_t;
00000020 struct efi_info
{
  __u32 efi_loader_signature;
  __u32 efi_systab;
  __u32 efi_memdesc_size;
  __u32 efi_memdesc_version;
  __u32 efi_memmap;
  __u32 efi_memmap_size;
  __u32 efi_systab_hi;
  __u32 efi_memmap_hi;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_info.efi_loader_signature __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_info.efi_systab __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_info.efi_memdesc_size __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_info.efi_memdesc_version __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 efi_info.efi_memmap __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 efi_info.efi_memmap_size __u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 efi_info.efi_systab_hi __u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 efi_info.efi_memmap_hi __u32;
//          0020 effalign(4) sda=0 bits=0000 efi_info struct packalign=0

00000040 struct efi_loaded_image_32_t
{
  u32 revision;
  u32 parent_handle;
  u32 system_table;
  u32 device_handle;
  u32 file_path;
  u32 reserved;
  u32 load_options_size;
  u32 load_options;
  u32 image_base;
  __attribute__((aligned(8))) __u64 image_size;
  unsigned int image_code_type;
  unsigned int image_data_type;
  unsigned __int64 unload;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.revision u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.parent_handle u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.system_table u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.device_handle u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.file_path u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.reserved u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.load_options_size u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.load_options u32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.image_base u32;
//  9. 0028 0008 effalign(8) fda=4 bits=0000 efi_loaded_image_32_t.image_size __u64;
// 10. 0030 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.image_code_type unsigned int;
// 11. 0034 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_32_t.image_data_type unsigned int;
// 12. 0038 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_32_t.unload unsigned __int64;
//          0040 effalign(8) sda=0 bits=0000 efi_loaded_image_32_t struct packalign=0

00000060 struct efi_loaded_image_64_t
{
  u32 revision;
  u64 parent_handle;
  u64 system_table;
  u64 device_handle;
  u64 file_path;
  u64 reserved;
  u32 load_options_size;
  u64 load_options;
  u64 image_base;
  __attribute__((aligned(8))) __u64 image_size;
  unsigned int image_code_type;
  unsigned int image_data_type;
  unsigned __int64 unload;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_64_t.revision u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.parent_handle u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.system_table u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.device_handle u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.file_path u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.reserved u64;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_64_t.load_options_size u32;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.load_options u64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.image_base u64;
//  9. 0048 0008 effalign(8) fda=4 bits=0000 efi_loaded_image_64_t.image_size __u64;
// 10. 0050 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_64_t.image_code_type unsigned int;
// 11. 0054 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_64_t.image_data_type unsigned int;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_64_t.unload unsigned __int64;
//          0060 effalign(8) sda=0 bits=0000 efi_loaded_image_64_t struct packalign=0

00000060 struct efi_loaded_image_t
{
  u32 revision;
  void *parent_handle;
  efi_system_table_t *system_table;
  void *device_handle;
  void *file_path;
  void *reserved;
  u32 load_options_size;
  void *load_options;
  void *image_base;
  __attribute__((aligned(8))) __u64 image_size;
  unsigned int image_code_type;
  unsigned int image_data_type;
  unsigned __int64 unload;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_t.revision u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.parent_handle void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.system_table efi_system_table_t *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.device_handle void *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.file_path void *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.reserved void *;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_t.load_options_size u32;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.load_options void *;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.image_base void *;
//  9. 0048 0008 effalign(8) fda=4 bits=0000 efi_loaded_image_t.image_size __u64;
// 10. 0050 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_t.image_code_type unsigned int;
// 11. 0054 0004 effalign(4) fda=0 bits=0000 efi_loaded_image_t.image_data_type unsigned int;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 efi_loaded_image_t.unload unsigned __int64;
//          0060 effalign(8) sda=0 bits=0000 efi_loaded_image_t struct packalign=0

00000018 struct efi_mem_range
{
  range range;
  u64 attribute;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 efi_mem_range.range range;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 efi_mem_range.attribute u64;
//          0018 effalign(8) sda=0 bits=0000 efi_mem_range struct packalign=0

00000008 typedef int (__cdecl *efi_memattr_perm_setter)(mm_struct *, efi_memory_desc_t *);
00000010 struct efi_memory_attributes_table_t
{
  u32 version;
  u32 num_entries;
  u32 desc_size;
  u32 reserved;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_memory_attributes_table_t.version u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_memory_attributes_table_t.num_entries u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_memory_attributes_table_t.desc_size u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_memory_attributes_table_t.reserved u32;
//          0010 effalign(4) sda=0 bits=0000 efi_memory_attributes_table_t struct packalign=0

00000028 struct efi_memory_desc_t
{
  u32 type;
  u32 pad;
  u64 phys_addr;
  u64 virt_addr;
  u64 num_pages;
  u64 attribute;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_memory_desc_t.type u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_memory_desc_t.pad u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 efi_memory_desc_t.phys_addr u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 efi_memory_desc_t.virt_addr u64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 efi_memory_desc_t.num_pages u64;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 efi_memory_desc_t.attribute u64;
//          0028 effalign(8) sda=0 bits=0000 efi_memory_desc_t struct packalign=0

00000038 struct efi_memory_map
{
  phys_addr_t phys_map;
  void *map;
  void *map_end;
  int nr_map;
  unsigned __int64 desc_version;
  unsigned __int64 desc_size;
  bool late;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_memory_map.phys_map phys_addr_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_memory_map.map void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_memory_map.map_end void *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 efi_memory_map.nr_map int;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_memory_map.desc_version unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_memory_map.desc_size unsigned __int64;
//  6. 0030 0001 effalign(1) fda=0 bits=0000 efi_memory_map.late bool;
//          0031 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 efi_memory_map struct packalign=0

00000020 struct efi_memory_map_data
{
  phys_addr_t phys_map;
  unsigned __int64 size;
  unsigned __int64 desc_version;
  unsigned __int64 desc_size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_memory_map_data.phys_map phys_addr_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_memory_map_data.size unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_memory_map_data.desc_version unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_memory_map_data.desc_size unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 efi_memory_map_data struct packalign=0

00000108 struct __attribute__((packed)) efi_mokvar_table_entry
{
  char name[256];
  u64 data_size;
};
//  0. 0000 0100 effalign(1) fda=0 bits=0000 efi_mokvar_table_entry.name char[256];
//  1. 0100 0008 effalign(1) fda=0 bits=0000 efi_mokvar_table_entry.data_size u64;
//          0108 effalign(1) sda=0 bits=0040 efi_mokvar_table_entry struct packalign=0

00000058 struct efi_pci_io_protocol_32_t
{
  u32 poll_mem;
  u32 poll_io;
  efi_pci_io_protocol_access_32_t mem;
  efi_pci_io_protocol_access_32_t io;
  efi_pci_io_protocol_access_32_t pci;
  u32 copy_mem;
  u32 map;
  u32 unmap;
  u32 allocate_buffer;
  u32 free_buffer;
  u32 flush;
  u32 get_location;
  u32 attributes;
  u32 get_bar_attributes;
  u32 set_bar_attributes;
  u64 romsize;
  u32 romimage;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.poll_mem u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.poll_io u32;
//  2. 0008 0008 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.mem efi_pci_io_protocol_access_32_t;
//  3. 0010 0008 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.io efi_pci_io_protocol_access_32_t;
//  4. 0018 0008 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.pci efi_pci_io_protocol_access_32_t;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.copy_mem u32;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.map u32;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.unmap u32;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.allocate_buffer u32;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.free_buffer u32;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.flush u32;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.get_location u32;
// 12. 003C 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.attributes u32;
// 13. 0040 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.get_bar_attributes u32;
// 14. 0044 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.set_bar_attributes u32;
// 15. 0048 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_32_t.romsize u64;
// 16. 0050 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_32_t.romimage u32;
//          0054 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 efi_pci_io_protocol_32_t struct packalign=0

000000A0 struct efi_pci_io_protocol_64_t
{
  u64 poll_mem;
  u64 poll_io;
  efi_pci_io_protocol_access_64_t mem;
  efi_pci_io_protocol_access_64_t io;
  efi_pci_io_protocol_access_64_t pci;
  u64 copy_mem;
  u64 map;
  u64 unmap;
  u64 allocate_buffer;
  u64 free_buffer;
  u64 flush;
  u64 get_location;
  u64 attributes;
  u64 get_bar_attributes;
  u64 set_bar_attributes;
  u64 romsize;
  u64 romimage;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.poll_mem u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.poll_io u64;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.mem efi_pci_io_protocol_access_64_t;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.io efi_pci_io_protocol_access_64_t;
//  4. 0030 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.pci efi_pci_io_protocol_access_64_t;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.copy_mem u64;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.map u64;
//  7. 0050 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.unmap u64;
//  8. 0058 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.allocate_buffer u64;
//  9. 0060 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.free_buffer u64;
// 10. 0068 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.flush u64;
// 11. 0070 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.get_location u64;
// 12. 0078 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.attributes u64;
// 13. 0080 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.get_bar_attributes u64;
// 14. 0088 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.set_bar_attributes u64;
// 15. 0090 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.romsize u64;
// 16. 0098 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_64_t.romimage u64;
//          00A0 effalign(8) sda=0 bits=0000 efi_pci_io_protocol_64_t struct packalign=0

00000008 struct efi_pci_io_protocol_access_32_t
{
  u32 read;
  u32 write;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_access_32_t.read u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_pci_io_protocol_access_32_t.write u32;
//          0008 effalign(4) sda=0 bits=0000 efi_pci_io_protocol_access_32_t struct packalign=0

00000010 struct efi_pci_io_protocol_access_64_t
{
  u64 read;
  u64 write;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_access_64_t.read u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_access_64_t.write u64;
//          0010 effalign(8) sda=0 bits=0000 efi_pci_io_protocol_access_64_t struct packalign=0

00000010 struct efi_pci_io_protocol_access_t
{
  void *read;
  void *write;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_access_t.read void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_access_t.write void *;
//          0010 effalign(8) sda=0 bits=0000 efi_pci_io_protocol_access_t struct packalign=0

000000A0 struct efi_pci_io_protocol_t
{
  void *poll_mem;
  void *poll_io;
  efi_pci_io_protocol_access_t mem;
  efi_pci_io_protocol_access_t io;
  efi_pci_io_protocol_access_t pci;
  void *copy_mem;
  void *map;
  void *unmap;
  void *allocate_buffer;
  void *free_buffer;
  void *flush;
  void *get_location;
  void *attributes;
  void *get_bar_attributes;
  void *set_bar_attributes;
  uint64_t romsize;
  void *romimage;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.poll_mem void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.poll_io void *;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.mem efi_pci_io_protocol_access_t;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.io efi_pci_io_protocol_access_t;
//  4. 0030 0010 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.pci efi_pci_io_protocol_access_t;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.copy_mem void *;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.map void *;
//  7. 0050 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.unmap void *;
//  8. 0058 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.allocate_buffer void *;
//  9. 0060 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.free_buffer void *;
// 10. 0068 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.flush void *;
// 11. 0070 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.get_location void *;
// 12. 0078 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.attributes void *;
// 13. 0080 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.get_bar_attributes void *;
// 14. 0088 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.set_bar_attributes void *;
// 15. 0090 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.romsize uint64_t;
// 16. 0098 0008 effalign(8) fda=0 bits=0000 efi_pci_io_protocol_t.romimage void *;
//          00A0 effalign(8) sda=0 bits=0000 efi_pci_io_protocol_t struct packalign=0

00000008 typedef u64 efi_physical_addr_t;
00000010 struct efi_pixel_bitmask
{
  u32 red_mask;
  u32 green_mask;
  u32 blue_mask;
  u32 reserved_mask;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_pixel_bitmask.red_mask u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_pixel_bitmask.green_mask u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_pixel_bitmask.blue_mask u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_pixel_bitmask.reserved_mask u32;
//          0010 effalign(4) sda=0 bits=0000 efi_pixel_bitmask struct packalign=0

00000010 struct efi_properties_table_t
{
  u32 version;
  u32 length;
  u64 memory_protection_attribute;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_properties_table_t.version u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_properties_table_t.length u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 efi_properties_table_t.memory_protection_attribute u64;
//          0010 effalign(8) sda=0 bits=0000 efi_properties_table_t struct packalign=0

FFFFFFFF typedef efi_status_t __cdecl efi_query_capsule_caps_t(efi_capsule_header_t **, unsigned __int64, u64 *, int *);
FFFFFFFF typedef efi_status_t __cdecl efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);
FFFFFFFF typedef efi_status_t __cdecl efi_query_variable_store_t(u32, unsigned __int64, bool);
FFFFFFFF typedef void __cdecl efi_reset_system_t(int, efi_status_t, unsigned __int64, efi_char16_t *);
00000004 enum efi_rts_ids : unsigned __int32
{
  EFI_NONE = 0x0,
  EFI_GET_TIME = 0x1,
  EFI_SET_TIME = 0x2,
  EFI_GET_WAKEUP_TIME = 0x3,
  EFI_SET_WAKEUP_TIME = 0x4,
  EFI_GET_VARIABLE = 0x5,
  EFI_GET_NEXT_VARIABLE = 0x6,
  EFI_SET_VARIABLE = 0x7,
  EFI_QUERY_VARIABLE_INFO = 0x8,
  EFI_GET_NEXT_HIGH_MONO_COUNT = 0x9,
  EFI_RESET_SYSTEM = 0xA,
  EFI_UPDATE_CAPSULE = 0xB,
  EFI_QUERY_CAPSULE_CAPS = 0xC,
};
00000050 struct efi_runtime_services_32_t
{
  efi_table_hdr_t hdr;
  u32 get_time;
  u32 set_time;
  u32 get_wakeup_time;
  u32 set_wakeup_time;
  u32 set_virtual_address_map;
  u32 convert_pointer;
  u32 get_variable;
  u32 get_next_variable;
  u32 set_variable;
  u32 get_next_high_mono_count;
  u32 reset_system;
  u32 update_capsule;
  u32 query_capsule_caps;
  u32 query_variable_info;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_runtime_services_32_t.hdr efi_table_hdr_t;
//  1. 0018 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.get_time u32;
//  2. 001C 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.set_time u32;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.get_wakeup_time u32;
//  4. 0024 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.set_wakeup_time u32;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.set_virtual_address_map u32;
//  6. 002C 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.convert_pointer u32;
//  7. 0030 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.get_variable u32;
//  8. 0034 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.get_next_variable u32;
//  9. 0038 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.set_variable u32;
// 10. 003C 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.get_next_high_mono_count u32;
// 11. 0040 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.reset_system u32;
// 12. 0044 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.update_capsule u32;
// 13. 0048 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.query_capsule_caps u32;
// 14. 004C 0004 effalign(4) fda=0 bits=0000 efi_runtime_services_32_t.query_variable_info u32;
//          0050 effalign(8) sda=0 bits=0000 efi_runtime_services_32_t struct packalign=0

00000088 struct efi_runtime_services_64_t
{
  efi_table_hdr_t hdr;
  u64 get_time;
  u64 set_time;
  u64 get_wakeup_time;
  u64 set_wakeup_time;
  u64 set_virtual_address_map;
  u64 convert_pointer;
  u64 get_variable;
  u64 get_next_variable;
  u64 set_variable;
  u64 get_next_high_mono_count;
  u64 reset_system;
  u64 update_capsule;
  u64 query_capsule_caps;
  u64 query_variable_info;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.get_time u64;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.set_time u64;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.get_wakeup_time u64;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.set_wakeup_time u64;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.set_virtual_address_map u64;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.convert_pointer u64;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.get_variable u64;
//  8. 0050 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.get_next_variable u64;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.set_variable u64;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.get_next_high_mono_count u64;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.reset_system u64;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.update_capsule u64;
// 13. 0078 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.query_capsule_caps u64;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_64_t.query_variable_info u64;
//          0088 effalign(8) sda=0 bits=0000 efi_runtime_services_64_t struct packalign=0

00000088 struct efi_runtime_services_t
{
  efi_table_hdr_t hdr;
  efi_get_time_t *get_time;
  efi_set_time_t *set_time;
  efi_get_wakeup_time_t *get_wakeup_time;
  efi_set_wakeup_time_t *set_wakeup_time;
  efi_set_virtual_address_map_t *set_virtual_address_map;
  void *convert_pointer;
  efi_get_variable_t *get_variable;
  efi_get_next_variable_t *get_next_variable;
  efi_set_variable_t *set_variable;
  efi_get_next_high_mono_count_t *get_next_high_mono_count;
  efi_reset_system_t *reset_system;
  efi_update_capsule_t *update_capsule;
  efi_query_capsule_caps_t *query_capsule_caps;
  efi_query_variable_info_t *query_variable_info;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_runtime_services_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.get_time efi_get_time_t *;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.set_time efi_set_time_t *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.get_wakeup_time efi_get_wakeup_time_t *;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.set_wakeup_time efi_set_wakeup_time_t *;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.set_virtual_address_map efi_set_virtual_address_map_t *;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.convert_pointer void *;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.get_variable efi_get_variable_t *;
//  8. 0050 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.get_next_variable efi_get_next_variable_t *;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.set_variable efi_set_variable_t *;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.get_next_high_mono_count efi_get_next_high_mono_count_t *;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.reset_system efi_reset_system_t *;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.update_capsule efi_update_capsule_t *;
// 13. 0078 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.query_capsule_caps efi_query_capsule_caps_t *;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 efi_runtime_services_t.query_variable_info efi_query_variable_info_t *;
//          0088 effalign(8) sda=0 bits=0000 efi_runtime_services_t struct packalign=0

00000078 struct efi_runtime_work
{
  void *arg1;
  void *arg2;
  void *arg3;
  void *arg4;
  void *arg5;
  efi_status_t status;
  work_struct work;
  efi_rts_ids efi_rts_id;
  completion efi_rts_comp;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.arg1 void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.arg2 void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.arg3 void *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.arg4 void *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.arg5 void *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_runtime_work.status efi_status_t;
//  6. 0030 0020 effalign(8) fda=0 bits=0000 efi_runtime_work.work work_struct;
//  7. 0050 0004 effalign(4) fda=0 bits=0000 efi_runtime_work.efi_rts_id efi_rts_ids;
//  8. 0058 0020 effalign(8) fda=0 bits=0000 efi_runtime_work.efi_rts_comp completion;
//          0078 effalign(8) sda=0 bits=0000 efi_runtime_work struct packalign=0

00000004 enum efi_secureboot_mode : unsigned __int32
{
  efi_secureboot_mode_unset = 0x0,
  efi_secureboot_mode_unknown = 0x1,
  efi_secureboot_mode_disabled = 0x2,
  efi_secureboot_mode_enabled = 0x3,
};
FFFFFFFF typedef efi_status_t __cdecl efi_set_time_t(efi_time_t *);
FFFFFFFF typedef efi_status_t __cdecl efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, unsigned __int64, void *);
FFFFFFFF typedef efi_status_t __cdecl efi_set_virtual_address_map_t(unsigned __int64, unsigned __int64, u32, efi_memory_desc_t *);
FFFFFFFF typedef efi_status_t __cdecl efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);
00000020 typedef u8 efi_sha256_hash_t[32];
00000010 struct efi_signature_data_t
{
  efi_guid_t signature_owner;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_signature_data_t.signature_owner efi_guid_t;
//          0010 effalign(1) sda=0 bits=0000 efi_signature_data_t struct packalign=0

0000001C struct efi_signature_list_t
{
  efi_guid_t signature_type;
  u32 signature_list_size;
  u32 signature_header_size;
  u32 signature_size;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 efi_signature_list_t.signature_type efi_guid_t;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 efi_signature_list_t.signature_list_size u32;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 efi_signature_list_t.signature_header_size u32;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 efi_signature_list_t.signature_size u32;
//          001C effalign(4) sda=0 bits=0000 efi_signature_list_t struct packalign=0

00000018 struct efi_simple_text_output_protocol
{
  void *reset;
  efi_status_t (__cdecl *output_string)(void *, void *);
  void *test_string;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol.reset void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol.output_string efi_status_t (__cdecl *)(void *, void *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol.test_string void *;
//          0018 effalign(8) sda=0 bits=0000 efi_simple_text_output_protocol struct packalign=0

0000000C struct efi_simple_text_output_protocol_32_t
{
  u32 reset;
  u32 output_string;
  u32 test_string;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_simple_text_output_protocol_32_t.reset u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_simple_text_output_protocol_32_t.output_string u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_simple_text_output_protocol_32_t.test_string u32;
//          000C effalign(4) sda=0 bits=0000 efi_simple_text_output_protocol_32_t struct packalign=0

00000018 struct efi_simple_text_output_protocol_64_t
{
  u64 reset;
  u64 output_string;
  u64 test_string;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol_64_t.reset u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol_64_t.output_string u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_simple_text_output_protocol_64_t.test_string u64;
//          0018 effalign(8) sda=0 bits=0000 efi_simple_text_output_protocol_64_t struct packalign=0

00000008 typedef unsigned __int64 efi_status_t;
00000048 struct efi_system_table_32_t
{
  efi_table_hdr_t hdr;
  u32 fw_vendor;
  u32 fw_revision;
  u32 con_in_handle;
  u32 con_in;
  u32 con_out_handle;
  u32 con_out;
  u32 stderr_handle;
  u32 stderr;
  u32 runtime;
  u32 boottime;
  u32 nr_tables;
  u32 tables;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_system_table_32_t.hdr efi_table_hdr_t;
//  1. 0018 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.fw_vendor u32;
//  2. 001C 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.fw_revision u32;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.con_in_handle u32;
//  4. 0024 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.con_in u32;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.con_out_handle u32;
//  6. 002C 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.con_out u32;
//  7. 0030 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.stderr_handle u32;
//  8. 0034 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.stderr u32;
//  9. 0038 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.runtime u32;
// 10. 003C 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.boottime u32;
// 11. 0040 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.nr_tables u32;
// 12. 0044 0004 effalign(4) fda=0 bits=0000 efi_system_table_32_t.tables u32;
//          0048 effalign(8) sda=0 bits=0000 efi_system_table_32_t struct packalign=0

00000078 struct efi_system_table_64_t
{
  efi_table_hdr_t hdr;
  u64 fw_vendor;
  u32 fw_revision;
  u32 __pad1;
  u64 con_in_handle;
  u64 con_in;
  u64 con_out_handle;
  u64 con_out;
  u64 stderr_handle;
  u64 stderr;
  u64 runtime;
  u64 boottime;
  u32 nr_tables;
  u32 __pad2;
  u64 tables;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_system_table_64_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.fw_vendor u64;
//  2. 0020 0004 effalign(4) fda=0 bits=0000 efi_system_table_64_t.fw_revision u32;
//  3. 0024 0004 effalign(4) fda=0 bits=0000 efi_system_table_64_t.__pad1 u32;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.con_in_handle u64;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.con_in u64;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.con_out_handle u64;
//  7. 0040 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.con_out u64;
//  8. 0048 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.stderr_handle u64;
//  9. 0050 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.stderr u64;
// 10. 0058 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.runtime u64;
// 11. 0060 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.boottime u64;
// 12. 0068 0004 effalign(4) fda=0 bits=0000 efi_system_table_64_t.nr_tables u32;
// 13. 006C 0004 effalign(4) fda=0 bits=0000 efi_system_table_64_t.__pad2 u32;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 efi_system_table_64_t.tables u64;
//          0078 effalign(8) sda=0 bits=0000 efi_system_table_64_t struct packalign=0

00000078 struct efi_system_table_t
{
  efi_table_hdr_t hdr;
  unsigned __int64 fw_vendor;
  u32 fw_revision;
  unsigned __int64 con_in_handle;
  unsigned __int64 con_in;
  unsigned __int64 con_out_handle;
  unsigned __int64 con_out;
  unsigned __int64 stderr_handle;
  unsigned __int64 stderr;
  efi_runtime_services_t *runtime;
  efi_boot_services_t *boottime;
  unsigned __int64 nr_tables;
  unsigned __int64 tables;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 efi_system_table_t.hdr efi_table_hdr_t;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.fw_vendor unsigned __int64;
//  2. 0020 0004 effalign(4) fda=0 bits=0000 efi_system_table_t.fw_revision u32;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.con_in_handle unsigned __int64;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.con_in unsigned __int64;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.con_out_handle unsigned __int64;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.con_out unsigned __int64;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.stderr_handle unsigned __int64;
//  8. 0050 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.stderr unsigned __int64;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.runtime efi_runtime_services_t *;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.boottime efi_boot_services_t *;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.nr_tables unsigned __int64;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 efi_system_table_t.tables unsigned __int64;
//          0078 effalign(8) sda=0 bits=0000 efi_system_table_t struct packalign=0

00000018 struct efi_table_hdr_t
{
  u64 signature;
  u32 revision;
  u32 headersize;
  u32 crc32;
  u32 reserved;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_table_hdr_t.signature u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 efi_table_hdr_t.revision u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 efi_table_hdr_t.headersize u32;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 efi_table_hdr_t.crc32 u32;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 efi_table_hdr_t.reserved u32;
//          0018 effalign(8) sda=0 bits=0000 efi_table_hdr_t struct packalign=0

00000004 typedef u32 efi_tcg2_event_log_format;
00000010 struct efi_tcg2_final_events_table
{
  u64 version;
  u64 nr_events;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_tcg2_final_events_table.version u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_tcg2_final_events_table.nr_events u64;
//          0010 effalign(8) sda=0 bits=0000 efi_tcg2_final_events_table struct packalign=0

0000001C struct efi_tcg2_protocol_32_t
{
  u32 get_capability;
  u32 get_event_log;
  u32 hash_log_extend_event;
  u32 submit_command;
  u32 get_active_pcr_banks;
  u32 set_active_pcr_banks;
  u32 get_result_of_set_active_pcr_banks;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.get_capability u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.get_event_log u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.hash_log_extend_event u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.submit_command u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.get_active_pcr_banks u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.set_active_pcr_banks u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 efi_tcg2_protocol_32_t.get_result_of_set_active_pcr_banks u32;
//          001C effalign(4) sda=0 bits=0000 efi_tcg2_protocol_32_t struct packalign=0

00000038 struct efi_tcg2_protocol_64_t
{
  u64 get_capability;
  u64 get_event_log;
  u64 hash_log_extend_event;
  u64 submit_command;
  u64 get_active_pcr_banks;
  u64 set_active_pcr_banks;
  u64 get_result_of_set_active_pcr_banks;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.get_capability u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.get_event_log u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.hash_log_extend_event u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.submit_command u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.get_active_pcr_banks u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.set_active_pcr_banks u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_64_t.get_result_of_set_active_pcr_banks u64;
//          0038 effalign(8) sda=0 bits=0000 efi_tcg2_protocol_64_t struct packalign=0

00000038 struct efi_tcg2_protocol_t
{
  void *get_capability;
  efi_status_t (__cdecl *get_event_log)(efi_handle_t, efi_tcg2_event_log_format, efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
  void *hash_log_extend_event;
  void *submit_command;
  void *get_active_pcr_banks;
  void *set_active_pcr_banks;
  void *get_result_of_set_active_pcr_banks;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.get_capability void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.get_event_log efi_status_t (__cdecl *)(efi_handle_t, efi_tcg2_event_log_format, efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.hash_log_extend_event void *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.submit_command void *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.get_active_pcr_banks void *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.set_active_pcr_banks void *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 efi_tcg2_protocol_t.get_result_of_set_active_pcr_banks void *;
//          0038 effalign(8) sda=0 bits=0000 efi_tcg2_protocol_t struct packalign=0

0000000C struct efi_time_cap_t
{
  u32 resolution;
  u32 accuracy;
  u8 sets_to_zero;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 efi_time_cap_t.resolution u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 efi_time_cap_t.accuracy u32;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 efi_time_cap_t.sets_to_zero u8;
//          0009 unpadded_size
//          000C effalign(4) sda=0 bits=0000 efi_time_cap_t struct packalign=0

00000010 struct efi_time_t
{
  u16 year;
  u8 month;
  u8 day;
  u8 hour;
  u8 minute;
  u8 second;
  u8 pad1;
  u32 nanosecond;
  s16 timezone;
  u8 daylight;
  u8 pad2;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 efi_time_t.year u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 efi_time_t.month u8;
//  2. 0003 0001 effalign(1) fda=0 bits=0000 efi_time_t.day u8;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 efi_time_t.hour u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 efi_time_t.minute u8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 efi_time_t.second u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 efi_time_t.pad1 u8;
//  7. 0008 0004 effalign(4) fda=0 bits=0000 efi_time_t.nanosecond u32;
//  8. 000C 0002 effalign(2) fda=0 bits=0000 efi_time_t.timezone s16;
//  9. 000E 0001 effalign(1) fda=0 bits=0000 efi_time_t.daylight u8;
// 10. 000F 0001 effalign(1) fda=0 bits=0000 efi_time_t.pad2 u8;
//          0010 effalign(4) sda=0 bits=0000 efi_time_t struct packalign=0

FFFFFFFF typedef efi_status_t __cdecl efi_update_capsule_t(efi_capsule_header_t **, unsigned __int64, unsigned __int64);
00000824 struct __attribute__((packed)) efi_variable
{
  efi_char16_t VariableName[512];
  efi_guid_t VendorGuid;
  unsigned __int64 DataSize;
  __u8 Data[1024];
  efi_status_t Status;
  __u32 Attributes;
};
//  0. 0000 0400 effalign(1) fda=0 bits=0000 efi_variable.VariableName efi_char16_t[512];
//  1. 0400 0010 effalign(1) fda=0 bits=0000 efi_variable.VendorGuid efi_guid_t;
//  2. 0410 0008 effalign(1) fda=0 bits=0000 efi_variable.DataSize unsigned __int64;
//  3. 0418 0400 effalign(1) fda=0 bits=0000 efi_variable.Data __u8[1024];
//  4. 0818 0008 effalign(1) fda=0 bits=0000 efi_variable.Status efi_status_t;
//  5. 0820 0004 effalign(1) fda=0 bits=0000 efi_variable.Attributes __u32;
//          0824 effalign(1) sda=0 bits=0040 efi_variable struct packalign=0

00000880 struct efivar_entry
{
  efi_variable var;
  list_head list;
  kobject kobj;
  bool scanning;
  bool deleting;
};
//  0. 0000 0824 effalign(1) fda=0 bits=0000 efivar_entry.var efi_variable;
//  1. 0828 0010 effalign(8) fda=0 bits=0000 efivar_entry.list list_head;
//  2. 0838 0040 effalign(8) fda=0 bits=0000 efivar_entry.kobj kobject;
//  3. 0878 0001 effalign(1) fda=0 bits=0000 efivar_entry.scanning bool;
//  4. 0879 0001 effalign(1) fda=0 bits=0000 efivar_entry.deleting bool;
//          087A unpadded_size
//          0880 effalign(8) sda=0 bits=0000 efivar_entry struct packalign=0

00000028 struct efivar_operations
{
  efi_get_variable_t *get_variable;
  efi_get_next_variable_t *get_next_variable;
  efi_set_variable_t *set_variable;
  efi_set_variable_t *set_variable_nonblocking;
  efi_query_variable_store_t *query_variable_store;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efivar_operations.get_variable efi_get_variable_t *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efivar_operations.get_next_variable efi_get_next_variable_t *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efivar_operations.set_variable efi_set_variable_t *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 efivar_operations.set_variable_nonblocking efi_set_variable_t *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 efivar_operations.query_variable_store efi_query_variable_store_t *;
//          0028 effalign(8) sda=0 bits=0000 efivar_operations struct packalign=0

00000018 struct efivars
{
  kset *kset;
  kobject *kobject;
  const efivar_operations *ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 efivars.kset kset *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 efivars.kobject kobject *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 efivars.ops const efivar_operations *;
//          0018 effalign(8) sda=0 bits=0000 efivars struct packalign=0

00000010 struct eisa_device_id
{
  char sig[8];
  kernel_ulong_t driver_data;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 eisa_device_id.sig char[8];
//  1. 0008 0008 effalign(8) fda=0 bits=0000 eisa_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 eisa_device_id struct packalign=0

000000B0 struct elevator_mq_ops
{
  int (__cdecl *init_sched)(request_queue *, elevator_type *);
  void (__cdecl *exit_sched)(elevator_queue *);
  int (__cdecl *init_hctx)(blk_mq_hw_ctx *, unsigned int);
  void (__cdecl *exit_hctx)(blk_mq_hw_ctx *, unsigned int);
  void (__cdecl *depth_updated)(blk_mq_hw_ctx *);
  bool (__cdecl *allow_merge)(request_queue *, request *, bio *);
  bool (__cdecl *bio_merge)(request_queue *, bio *, unsigned int);
  int (__cdecl *request_merge)(request_queue *, request **, bio *);
  void (__cdecl *request_merged)(request_queue *, request *, elv_merge);
  void (__cdecl *requests_merged)(request_queue *, request *, request *);
  void (__cdecl *limit_depth)(unsigned int, blk_mq_alloc_data *);
  void (__cdecl *prepare_request)(request *, bio *);
  void (__cdecl *finish_request)(request *);
  void (__cdecl *insert_requests)(blk_mq_hw_ctx *, list_head *, bool);
  request *(__cdecl *dispatch_request)(blk_mq_hw_ctx *);
  bool (__cdecl *has_work)(blk_mq_hw_ctx *);
  void (__cdecl *completed_request)(request *, u64);
  void (__cdecl *requeue_request)(request *);
  request *(__cdecl *former_request)(request_queue *, request *);
  request *(__cdecl *next_request)(request_queue *, request *);
  void (__cdecl *init_icq)(io_cq *);
  void (__cdecl *exit_icq)(io_cq *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.init_sched int (__cdecl *)(request_queue *, elevator_type *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.exit_sched void (__cdecl *)(elevator_queue *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.init_hctx int (__cdecl *)(blk_mq_hw_ctx *, unsigned int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.exit_hctx void (__cdecl *)(blk_mq_hw_ctx *, unsigned int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.depth_updated void (__cdecl *)(blk_mq_hw_ctx *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.allow_merge bool (__cdecl *)(request_queue *, request *, bio *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.bio_merge bool (__cdecl *)(request_queue *, bio *, unsigned int);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.request_merge int (__cdecl *)(request_queue *, request **, bio *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.request_merged void (__cdecl *)(request_queue *, request *, elv_merge);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.requests_merged void (__cdecl *)(request_queue *, request *, request *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.limit_depth void (__cdecl *)(unsigned int, blk_mq_alloc_data *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.prepare_request void (__cdecl *)(request *, bio *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.finish_request void (__cdecl *)(request *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.insert_requests void (__cdecl *)(blk_mq_hw_ctx *, list_head *, bool);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.dispatch_request request *(__cdecl *)(blk_mq_hw_ctx *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.has_work bool (__cdecl *)(blk_mq_hw_ctx *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.completed_request void (__cdecl *)(request *, u64);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.requeue_request void (__cdecl *)(request *);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.former_request request *(__cdecl *)(request_queue *, request *);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.next_request request *(__cdecl *)(request_queue *, request *);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.init_icq void (__cdecl *)(io_cq *);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 elevator_mq_ops.exit_icq void (__cdecl *)(io_cq *);
//          00B0 effalign(8) sda=0 bits=0000 elevator_mq_ops struct packalign=0

00000278 struct elevator_queue
{
  elevator_type *type;
  void *elevator_data;
  kobject kobj;
  mutex sysfs_lock;
  unsigned __int32 registered : 1;
  hlist_head hash[64];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 elevator_queue.type elevator_type *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 elevator_queue.elevator_data void *;
//  2. 0010 0040 effalign(8) fda=0 bits=0000 elevator_queue.kobj kobject;
//  3. 0050 0020 effalign(8) fda=0 bits=0000 elevator_queue.sysfs_lock mutex;
//  4. 0070. 0 1 effalign(1) fda=0 bits=0000 elevator_queue.registered bi.nbytes=4 U
//  5. 0078 0200 effalign(8) fda=0 bits=0000 elevator_queue.hash hlist_head[64];
//          0278 effalign(8) sda=0 bits=0000 elevator_queue struct packalign=0

00000128 struct elevator_type
{
  kmem_cache *icq_cache;
  elevator_mq_ops ops;
  size_t icq_size;
  size_t icq_align;
  elv_fs_entry *elevator_attrs;
  const char *elevator_name;
  const char *elevator_alias;
  const unsigned int elevator_features;
  module *elevator_owner;
  const blk_mq_debugfs_attr *queue_debugfs_attrs;
  const blk_mq_debugfs_attr *hctx_debugfs_attrs;
  char icq_cache_name[22];
  list_head list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 elevator_type.icq_cache kmem_cache *;
//  1. 0008 00B0 effalign(8) fda=0 bits=0000 elevator_type.ops elevator_mq_ops;
//  2. 00B8 0008 effalign(8) fda=0 bits=0000 elevator_type.icq_size size_t;
//  3. 00C0 0008 effalign(8) fda=0 bits=0000 elevator_type.icq_align size_t;
//  4. 00C8 0008 effalign(8) fda=0 bits=0000 elevator_type.elevator_attrs elv_fs_entry *;
//  5. 00D0 0008 effalign(8) fda=0 bits=0000 elevator_type.elevator_name const char *;
//  6. 00D8 0008 effalign(8) fda=0 bits=0000 elevator_type.elevator_alias const char *;
//  7. 00E0 0004 effalign(4) fda=0 bits=0000 elevator_type.elevator_features const unsigned int;
//  8. 00E8 0008 effalign(8) fda=0 bits=0000 elevator_type.elevator_owner module *;
//  9. 00F0 0008 effalign(8) fda=0 bits=0000 elevator_type.queue_debugfs_attrs const blk_mq_debugfs_attr *;
// 10. 00F8 0008 effalign(8) fda=0 bits=0000 elevator_type.hctx_debugfs_attrs const blk_mq_debugfs_attr *;
// 11. 0100 0016 effalign(1) fda=0 bits=0000 elevator_type.icq_cache_name char[22];
// 12. 0118 0010 effalign(8) fda=0 bits=0000 elevator_type.list list_head;
//          0128 effalign(8) sda=0 bits=0000 elevator_type struct packalign=0

00000034 struct elf32_hdr
{
  unsigned __int8 e_ident[16];
  Elf32_Half e_type;
  Elf32_Half e_machine;
  Elf32_Word e_version;
  Elf32_Addr e_entry;
  Elf32_Off e_phoff;
  Elf32_Off e_shoff;
  Elf32_Word e_flags;
  Elf32_Half e_ehsize;
  Elf32_Half e_phentsize;
  Elf32_Half e_phnum;
  Elf32_Half e_shentsize;
  Elf32_Half e_shnum;
  Elf32_Half e_shstrndx;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 elf32_hdr.e_ident unsigned __int8[16];
//  1. 0010 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_type Elf32_Half;
//  2. 0012 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_machine Elf32_Half;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 elf32_hdr.e_version Elf32_Word;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 elf32_hdr.e_entry Elf32_Addr;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 elf32_hdr.e_phoff Elf32_Off;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 elf32_hdr.e_shoff Elf32_Off;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 elf32_hdr.e_flags Elf32_Word;
//  8. 0028 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_ehsize Elf32_Half;
//  9. 002A 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_phentsize Elf32_Half;
// 10. 002C 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_phnum Elf32_Half;
// 11. 002E 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_shentsize Elf32_Half;
// 12. 0030 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_shnum Elf32_Half;
// 13. 0032 0002 effalign(2) fda=0 bits=0000 elf32_hdr.e_shstrndx Elf32_Half;
//          0034 effalign(4) sda=0 bits=0000 elf32_hdr struct packalign=0

0000000C struct elf32_note
{
  Elf32_Word n_namesz;
  Elf32_Word n_descsz;
  Elf32_Word n_type;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_note.n_namesz Elf32_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_note.n_descsz Elf32_Word;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf32_note.n_type Elf32_Word;
//          000C effalign(4) sda=0 bits=0000 elf32_note struct packalign=0

00000020 struct elf32_phdr
{
  Elf32_Word p_type;
  Elf32_Off p_offset;
  Elf32_Addr p_vaddr;
  Elf32_Addr p_paddr;
  Elf32_Word p_filesz;
  Elf32_Word p_memsz;
  Elf32_Word p_flags;
  Elf32_Word p_align;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_type Elf32_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_offset Elf32_Off;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_vaddr Elf32_Addr;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_paddr Elf32_Addr;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_filesz Elf32_Word;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_memsz Elf32_Word;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_flags Elf32_Word;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 elf32_phdr.p_align Elf32_Word;
//          0020 effalign(4) sda=0 bits=0000 elf32_phdr struct packalign=0

00000008 struct elf32_rel
{
  Elf32_Addr r_offset;
  Elf32_Word r_info;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_rel.r_offset Elf32_Addr;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_rel.r_info Elf32_Word;
//          0008 effalign(4) sda=0 bits=0000 elf32_rel struct packalign=0

0000000C struct elf32_rela
{
  Elf32_Addr r_offset;
  Elf32_Word r_info;
  Elf32_Sword r_addend;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_rela.r_offset Elf32_Addr;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_rela.r_info Elf32_Word;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf32_rela.r_addend Elf32_Sword;
//          000C effalign(4) sda=0 bits=0000 elf32_rela struct packalign=0

00000028 struct elf32_shdr
{
  Elf32_Word sh_name;
  Elf32_Word sh_type;
  Elf32_Word sh_flags;
  Elf32_Addr sh_addr;
  Elf32_Off sh_offset;
  Elf32_Word sh_size;
  Elf32_Word sh_link;
  Elf32_Word sh_info;
  Elf32_Word sh_addralign;
  Elf32_Word sh_entsize;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_name Elf32_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_type Elf32_Word;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_flags Elf32_Word;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_addr Elf32_Addr;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_offset Elf32_Off;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_size Elf32_Word;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_link Elf32_Word;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_info Elf32_Word;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_addralign Elf32_Word;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 elf32_shdr.sh_entsize Elf32_Word;
//          0028 effalign(4) sda=0 bits=0000 elf32_shdr struct packalign=0

00000010 struct elf32_sym
{
  Elf32_Word st_name;
  Elf32_Addr st_value;
  Elf32_Word st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  Elf32_Half st_shndx;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf32_sym.st_name Elf32_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf32_sym.st_value Elf32_Addr;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf32_sym.st_size Elf32_Word;
//  3. 000C 0001 effalign(1) fda=0 bits=0000 elf32_sym.st_info unsigned __int8;
//  4. 000D 0001 effalign(1) fda=0 bits=0000 elf32_sym.st_other unsigned __int8;
//  5. 000E 0002 effalign(2) fda=0 bits=0000 elf32_sym.st_shndx Elf32_Half;
//          0010 effalign(4) sda=0 bits=0000 elf32_sym struct packalign=0

00000040 struct elf64_hdr
{
  unsigned __int8 e_ident[16];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 elf64_hdr.e_ident unsigned __int8[16];
//  1. 0010 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_type Elf64_Half;
//  2. 0012 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_machine Elf64_Half;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 elf64_hdr.e_version Elf64_Word;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 elf64_hdr.e_entry Elf64_Addr;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 elf64_hdr.e_phoff Elf64_Off;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 elf64_hdr.e_shoff Elf64_Off;
//  7. 0030 0004 effalign(4) fda=0 bits=0000 elf64_hdr.e_flags Elf64_Word;
//  8. 0034 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_ehsize Elf64_Half;
//  9. 0036 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_phentsize Elf64_Half;
// 10. 0038 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_phnum Elf64_Half;
// 11. 003A 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_shentsize Elf64_Half;
// 12. 003C 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_shnum Elf64_Half;
// 13. 003E 0002 effalign(2) fda=0 bits=0000 elf64_hdr.e_shstrndx Elf64_Half;
//          0040 effalign(8) sda=0 bits=0000 elf64_hdr struct packalign=0

0000000C struct elf64_note
{
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf64_note.n_namesz Elf64_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf64_note.n_descsz Elf64_Word;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 elf64_note.n_type Elf64_Word;
//          000C effalign(4) sda=0 bits=0000 elf64_note struct packalign=0

00000038 struct elf64_phdr
{
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf64_phdr.p_type Elf64_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf64_phdr.p_flags Elf64_Word;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_offset Elf64_Off;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_vaddr Elf64_Addr;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_paddr Elf64_Addr;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_filesz Elf64_Xword;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_memsz Elf64_Xword;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 elf64_phdr.p_align Elf64_Xword;
//          0038 effalign(8) sda=0 bits=0000 elf64_phdr struct packalign=0

00000010 struct elf64_rel
{
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 elf64_rel.r_offset Elf64_Addr;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 elf64_rel.r_info Elf64_Xword;
//          0010 effalign(8) sda=0 bits=0000 elf64_rel struct packalign=0

00000018 struct elf64_rela
{
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
  Elf64_Sxword r_addend;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 elf64_rela.r_offset Elf64_Addr;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 elf64_rela.r_info Elf64_Xword;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 elf64_rela.r_addend Elf64_Sxword;
//          0018 effalign(8) sda=0 bits=0000 elf64_rela struct packalign=0

00000040 struct elf64_shdr
{
  Elf64_Word sh_name;
  Elf64_Word sh_type;
  Elf64_Xword sh_flags;
  Elf64_Addr sh_addr;
  Elf64_Off sh_offset;
  Elf64_Xword sh_size;
  Elf64_Word sh_link;
  Elf64_Word sh_info;
  Elf64_Xword sh_addralign;
  Elf64_Xword sh_entsize;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf64_shdr.sh_name Elf64_Word;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 elf64_shdr.sh_type Elf64_Word;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_flags Elf64_Xword;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_addr Elf64_Addr;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_offset Elf64_Off;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_size Elf64_Xword;
//  6. 0028 0004 effalign(4) fda=0 bits=0000 elf64_shdr.sh_link Elf64_Word;
//  7. 002C 0004 effalign(4) fda=0 bits=0000 elf64_shdr.sh_info Elf64_Word;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_addralign Elf64_Xword;
//  9. 0038 0008 effalign(8) fda=0 bits=0000 elf64_shdr.sh_entsize Elf64_Xword;
//          0040 effalign(8) sda=0 bits=0000 elf64_shdr struct packalign=0

00000018 struct elf64_sym
{
  Elf64_Word st_name;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  Elf64_Half st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 elf64_sym.st_name Elf64_Word;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 elf64_sym.st_info unsigned __int8;
//  2. 0005 0001 effalign(1) fda=0 bits=0000 elf64_sym.st_other unsigned __int8;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 elf64_sym.st_shndx Elf64_Half;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 elf64_sym.st_value Elf64_Addr;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 elf64_sym.st_size Elf64_Xword;
//          0018 effalign(8) sda=0 bits=0000 elf64_sym struct packalign=0

00000200 typedef user_i387_struct elf_fpregset_t;
00000008 typedef unsigned __int64 elf_greg_t;
000000D8 typedef elf_greg_t elf_gregset_t[27];
00000020 struct elv_fs_entry
{
  attribute attr;
  ssize_t (__cdecl *show)(elevator_queue *, char *);
  ssize_t (__cdecl *store)(elevator_queue *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 elv_fs_entry.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 elv_fs_entry.show ssize_t (__cdecl *)(elevator_queue *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 elv_fs_entry.store ssize_t (__cdecl *)(elevator_queue *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 elv_fs_entry struct packalign=0

00000004 enum elv_merge : unsigned __int32
{
  ELEVATOR_NO_MERGE = 0x0,
  ELEVATOR_FRONT_MERGE = 0x1,
  ELEVATOR_BACK_MERGE = 0x2,
  ELEVATOR_DISCARD_MERGE = 0x3,
};
00001000 struct entry_stack
{
  char stack[4096];
};
//  0. 0000 1000 effalign(1) fda=0 bits=0000 entry_stack.stack char[4096];
//          1000 effalign(1) sda=0 bits=0000 entry_stack struct packalign=0

00001000 struct __attribute__((aligned(4096))) entry_stack_page
{
  entry_stack stack;
};
//  0. 0000 1000 effalign(1) fda=0 bits=0000 entry_stack_page.stack entry_stack;
//          1000 effalign(4096) sda=13 bits=0000 entry_stack_page struct packalign=0

FFFFFFFF struct ep_device;
0000000C struct __attribute__((packed)) epoll_event
{
  __poll_t events;
  __u64 data;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 epoll_event.events __poll_t;
//  1. 0004 0008 effalign(1) fda=0 bits=0000 epoll_event.data __u64;
//          000C effalign(1) sda=0 bits=0040 epoll_event struct packalign=0

00000010 struct error_injection_entry
{
  unsigned __int64 addr;
  int etype;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 error_injection_entry.addr unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 error_injection_entry.etype int;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 error_injection_entry struct packalign=0

00000004 typedef u32 errseq_t;
0000000C struct exception_table_entry
{
  int insn;
  int fixup;
  int handler;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 exception_table_entry.insn int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 exception_table_entry.fixup int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 exception_table_entry.handler int;
//          000C effalign(4) sda=0 bits=0000 exception_table_entry struct packalign=0

00000020 struct execute_work
{
  work_struct work;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 execute_work.work work_struct;
//          0020 effalign(8) sda=0 bits=0000 execute_work struct packalign=0

00000008 typedef void (*exitcall_t)(void);
FFFFFFFF struct export_operations;
00000008 struct f_owner_ex
{
  int type;
  __kernel_pid_t pid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 f_owner_ex.type int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 f_owner_ex.pid __kernel_pid_t;
//          0008 effalign(4) sda=0 bits=0000 f_owner_ex struct packalign=0

00000030 struct fasync_struct
{
  rwlock_t fa_lock;
  int magic;
  int fa_fd;
  fasync_struct *fa_next;
  file *fa_file;
  callback_head fa_rcu;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 fasync_struct.fa_lock rwlock_t;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 fasync_struct.magic int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 fasync_struct.fa_fd int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 fasync_struct.fa_next fasync_struct *;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 fasync_struct.fa_file file *;
//  5. 0020 0010 effalign(8) fda=0 bits=0000 fasync_struct.fa_rcu callback_head;
//          0030 effalign(8) sda=0 bits=0000 fasync_struct struct packalign=0

00000010 struct fd
{
  file *file;
  unsigned int flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fd.file file *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 fd.flags unsigned int;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 fd struct packalign=0

00000080 typedef __kernel_fd_set fd_set;
00000020 struct fiemap
{
  __u64 fm_start;
  __u64 fm_length;
  __u32 fm_flags;
  __u32 fm_mapped_extents;
  __u32 fm_extent_count;
  __u32 fm_reserved;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fiemap.fm_start __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fiemap.fm_length __u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 fiemap.fm_flags __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 fiemap.fm_mapped_extents __u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 fiemap.fm_extent_count __u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 fiemap.fm_reserved __u32;
//          0020 effalign(8) sda=0 bits=0000 fiemap struct packalign=0

00000038 struct fiemap_extent
{
  __u64 fe_logical;
  __u64 fe_physical;
  __u64 fe_length;
  __u64 fe_reserved64[2];
  __u32 fe_flags;
  __u32 fe_reserved[3];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fiemap_extent.fe_logical __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fiemap_extent.fe_physical __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 fiemap_extent.fe_length __u64;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 fiemap_extent.fe_reserved64 __u64[2];
//  4. 0028 0004 effalign(4) fda=0 bits=0000 fiemap_extent.fe_flags __u32;
//  5. 002C 000C effalign(4) fda=0 bits=0000 fiemap_extent.fe_reserved __u32[3];
//          0038 effalign(8) sda=0 bits=0000 fiemap_extent struct packalign=0

00000018 struct fiemap_extent_info
{
  unsigned int fi_flags;
  unsigned int fi_extents_mapped;
  unsigned int fi_extents_max;
  fiemap_extent *fi_extents_start;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 fiemap_extent_info.fi_flags unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 fiemap_extent_info.fi_extents_mapped unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 fiemap_extent_info.fi_extents_max unsigned int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 fiemap_extent_info.fi_extents_start fiemap_extent *;
//          0018 effalign(8) sda=0 bits=0000 fiemap_extent_info struct packalign=0

00000100 struct __attribute__((aligned(8))) file
{
  file::$B5D8E076F408A137EC3C35F8032C006D f_u;
  path f_path;
  inode *f_inode;
  const file_operations *f_op;
  spinlock_t f_lock;
  rw_hint f_write_hint;
  atomic_long_t f_count;
  unsigned int f_flags;
  fmode_t f_mode;
  mutex f_pos_lock;
  loff_t f_pos;
  fown_struct f_owner;
  const cred *f_cred;
  file_ra_state f_ra;
  u64 f_version;
  void *f_security;
  void *private_data;
  list_head f_ep_links;
  list_head f_tfile_llink;
  address_space *f_mapping;
  errseq_t f_wb_err;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 file.f_u file::$B5D8E076F408A137EC3C35F8032C006D;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 file.f_path path;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 file.f_inode inode *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 file.f_op const file_operations *;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 file.f_lock spinlock_t;
//  5. 0034 0004 effalign(4) fda=0 bits=0000 file.f_write_hint rw_hint;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 file.f_count atomic_long_t;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 file.f_flags unsigned int;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 file.f_mode fmode_t;
//  9. 0048 0020 effalign(8) fda=0 bits=0000 file.f_pos_lock mutex;
// 10. 0068 0008 effalign(8) fda=0 bits=0000 file.f_pos loff_t;
// 11. 0070 0020 effalign(8) fda=0 bits=0000 file.f_owner fown_struct;
// 12. 0090 0008 effalign(8) fda=0 bits=0000 file.f_cred const cred *;
// 13. 0098 0020 effalign(8) fda=0 bits=0000 file.f_ra file_ra_state;
// 14. 00B8 0008 effalign(8) fda=0 bits=0000 file.f_version u64;
// 15. 00C0 0008 effalign(8) fda=0 bits=0000 file.f_security void *;
// 16. 00C8 0008 effalign(8) fda=0 bits=0000 file.private_data void *;
// 17. 00D0 0010 effalign(8) fda=0 bits=0000 file.f_ep_links list_head;
// 18. 00E0 0010 effalign(8) fda=0 bits=0000 file.f_tfile_llink list_head;
// 19. 00F0 0008 effalign(8) fda=0 bits=0000 file.f_mapping address_space *;
// 20. 00F8 0004 effalign(4) fda=0 bits=0000 file.f_wb_err errseq_t;
//          00FC unpadded_size
//          0100 effalign(8) sda=4 bits=0000 file struct packalign=0

00000010 union file::$B5D8E076F408A137EC3C35F8032C006D
{
  llist_node fu_llist;
  callback_head fu_rcuhead;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file::$B5D8E076F408A137EC3C35F8032C006D.fu_llist llist_node;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 file::$B5D8E076F408A137EC3C35F8032C006D.fu_rcuhead callback_head;
//          0010 effalign(8) sda=0 bits=0000 file::$B5D8E076F408A137EC3C35F8032C006D union packalign=0

00000020 struct file_clone_range
{
  __s64 src_fd;
  __u64 src_offset;
  __u64 src_length;
  __u64 dest_offset;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_clone_range.src_fd __s64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 file_clone_range.src_offset __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 file_clone_range.src_length __u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 file_clone_range.dest_offset __u64;
//          0020 effalign(8) sda=0 bits=0000 file_clone_range struct packalign=0

00000018 struct file_dedupe_range
{
  __u64 src_offset;
  __u64 src_length;
  __u16 dest_count;
  __u16 reserved1;
  __u32 reserved2;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_dedupe_range.src_offset __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 file_dedupe_range.src_length __u64;
//  2. 0010 0002 effalign(2) fda=0 bits=0000 file_dedupe_range.dest_count __u16;
//  3. 0012 0002 effalign(2) fda=0 bits=0000 file_dedupe_range.reserved1 __u16;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 file_dedupe_range.reserved2 __u32;
//          0018 effalign(8) sda=0 bits=0000 file_dedupe_range struct packalign=0

00000020 struct file_dedupe_range_info
{
  __s64 dest_fd;
  __u64 dest_offset;
  __u64 bytes_deduped;
  __s32 status;
  __u32 reserved;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_dedupe_range_info.dest_fd __s64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 file_dedupe_range_info.dest_offset __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 file_dedupe_range_info.bytes_deduped __u64;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 file_dedupe_range_info.status __s32;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 file_dedupe_range_info.reserved __u32;
//          0020 effalign(8) sda=0 bits=0000 file_dedupe_range_info struct packalign=0

00000008 struct file_handle
{
  __u32 handle_bytes;
  int handle_type;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 file_handle.handle_bytes __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 file_handle.handle_type int;
//          0008 effalign(4) sda=0 bits=0000 file_handle struct packalign=0

000000D8 struct file_lock
{
  file_lock *fl_blocker;
  list_head fl_list;
  hlist_node fl_link;
  list_head fl_blocked_requests;
  list_head fl_blocked_member;
  fl_owner_t fl_owner;
  unsigned int fl_flags;
  unsigned __int8 fl_type;
  unsigned int fl_pid;
  int fl_link_cpu;
  wait_queue_head_t fl_wait;
  file *fl_file;
  loff_t fl_start;
  loff_t fl_end;
  fasync_struct *fl_fasync;
  unsigned __int64 fl_break_time;
  unsigned __int64 fl_downgrade_time;
  const file_lock_operations *fl_ops;
  const lock_manager_operations *fl_lmops;
  file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698 fl_u;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_lock.fl_blocker file_lock *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 file_lock.fl_list list_head;
//  2. 0018 0010 effalign(8) fda=0 bits=0000 file_lock.fl_link hlist_node;
//  3. 0028 0010 effalign(8) fda=0 bits=0000 file_lock.fl_blocked_requests list_head;
//  4. 0038 0010 effalign(8) fda=0 bits=0000 file_lock.fl_blocked_member list_head;
//  5. 0048 0008 effalign(8) fda=0 bits=0000 file_lock.fl_owner fl_owner_t;
//  6. 0050 0004 effalign(4) fda=0 bits=0000 file_lock.fl_flags unsigned int;
//  7. 0054 0001 effalign(1) fda=0 bits=0000 file_lock.fl_type unsigned __int8;
//  8. 0058 0004 effalign(4) fda=0 bits=0000 file_lock.fl_pid unsigned int;
//  9. 005C 0004 effalign(4) fda=0 bits=0000 file_lock.fl_link_cpu int;
// 10. 0060 0018 effalign(8) fda=0 bits=0000 file_lock.fl_wait wait_queue_head_t;
// 11. 0078 0008 effalign(8) fda=0 bits=0000 file_lock.fl_file file *;
// 12. 0080 0008 effalign(8) fda=0 bits=0000 file_lock.fl_start loff_t;
// 13. 0088 0008 effalign(8) fda=0 bits=0000 file_lock.fl_end loff_t;
// 14. 0090 0008 effalign(8) fda=0 bits=0000 file_lock.fl_fasync fasync_struct *;
// 15. 0098 0008 effalign(8) fda=0 bits=0000 file_lock.fl_break_time unsigned __int64;
// 16. 00A0 0008 effalign(8) fda=0 bits=0000 file_lock.fl_downgrade_time unsigned __int64;
// 17. 00A8 0008 effalign(8) fda=0 bits=0000 file_lock.fl_ops const file_lock_operations *;
// 18. 00B0 0008 effalign(8) fda=0 bits=0000 file_lock.fl_lmops const lock_manager_operations *;
// 19. 00B8 0020 effalign(8) fda=0 bits=0000 file_lock.fl_u file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698;
//          00D8 effalign(8) sda=0 bits=0000 file_lock struct packalign=0

00000020 union file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698
{
  nfs_lock_info nfs_fl;
  nfs4_lock_info nfs4_fl;
  $EB3075E152535FBC682ED73518D5C19B afs;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698.nfs_fl nfs_lock_info;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698.nfs4_fl nfs4_lock_info;
//  2. 0000 0018 effalign(8) fda=0 bits=0000 file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698.afs $EB3075E152535FBC682ED73518D5C19B;
//          0020 effalign(8) sda=0 bits=0000 file_lock::$AB9D867A1A8BEF98EF40F3341AEA3698 union packalign=0

00000038 struct file_lock_context
{
  spinlock_t flc_lock;
  list_head flc_flock;
  list_head flc_posix;
  list_head flc_lease;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 file_lock_context.flc_lock spinlock_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 file_lock_context.flc_flock list_head;
//  2. 0018 0010 effalign(8) fda=0 bits=0000 file_lock_context.flc_posix list_head;
//  3. 0028 0010 effalign(8) fda=0 bits=0000 file_lock_context.flc_lease list_head;
//          0038 effalign(8) sda=0 bits=0000 file_lock_context struct packalign=0

00000010 struct file_lock_operations
{
  void (__cdecl *fl_copy_lock)(file_lock *, file_lock *);
  void (__cdecl *fl_release_private)(file_lock *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_lock_operations.fl_copy_lock void (__cdecl *)(file_lock *, file_lock *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 file_lock_operations.fl_release_private void (__cdecl *)(file_lock *);
//          0010 effalign(8) sda=0 bits=0000 file_lock_operations struct packalign=0

00000110 struct file_operations
{
  module *owner;
  loff_t (__cdecl *llseek)(file *, loff_t, int);
  ssize_t (__cdecl *read)(file *, char *, size_t, loff_t *);
  ssize_t (__cdecl *write)(file *, const char *, size_t, loff_t *);
  ssize_t (__cdecl *read_iter)(kiocb *, iov_iter *);
  ssize_t (__cdecl *write_iter)(kiocb *, iov_iter *);
  int (__cdecl *iopoll)(kiocb *, bool);
  int (__cdecl *iterate)(file *, dir_context *);
  int (__cdecl *iterate_shared)(file *, dir_context *);
  __poll_t (__cdecl *poll)(file *, poll_table_struct *);
  __int64 (__cdecl *unlocked_ioctl)(file *, unsigned int, unsigned __int64);
  __int64 (__cdecl *compat_ioctl)(file *, unsigned int, unsigned __int64);
  int (__cdecl *mmap)(file *, vm_area_struct *);
  unsigned __int64 mmap_supported_flags;
  int (__cdecl *open)(inode *, file *);
  int (__cdecl *flush)(file *, fl_owner_t);
  int (__cdecl *release)(inode *, file *);
  int (__cdecl *fsync)(file *, loff_t, loff_t, int);
  int (__cdecl *fasync)(int, file *, int);
  int (__cdecl *lock)(file *, int, file_lock *);
  ssize_t (__cdecl *sendpage)(file *, page *, int, size_t, loff_t *, int);
  unsigned __int64 (__cdecl *get_unmapped_area)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
  int (__cdecl *check_flags)(int);
  int (__cdecl *setfl)(file *, unsigned __int64);
  int (__cdecl *flock)(file *, int, file_lock *);
  ssize_t (__cdecl *splice_write)(pipe_inode_info *, file *, loff_t *, size_t, unsigned int);
  ssize_t (__cdecl *splice_read)(file *, loff_t *, pipe_inode_info *, size_t, unsigned int);
  int (__cdecl *setlease)(file *, __int64, file_lock **, void **);
  __int64 (__cdecl *fallocate)(file *, int, loff_t, loff_t);
  void (__cdecl *show_fdinfo)(seq_file *, file *);
  ssize_t (__cdecl *copy_file_range)(file *, loff_t, file *, loff_t, size_t, unsigned int);
  loff_t (__cdecl *remap_file_range)(file *, loff_t, file *, loff_t, loff_t, unsigned int);
  int (__cdecl *fadvise)(file *, loff_t, loff_t, int);
  bool may_pollfree;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_operations.owner module *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 file_operations.llseek loff_t (__cdecl *)(file *, loff_t, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 file_operations.read ssize_t (__cdecl *)(file *, char *, size_t, loff_t *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 file_operations.write ssize_t (__cdecl *)(file *, const char *, size_t, loff_t *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 file_operations.read_iter ssize_t (__cdecl *)(kiocb *, iov_iter *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 file_operations.write_iter ssize_t (__cdecl *)(kiocb *, iov_iter *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 file_operations.iopoll int (__cdecl *)(kiocb *, bool);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 file_operations.iterate int (__cdecl *)(file *, dir_context *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 file_operations.iterate_shared int (__cdecl *)(file *, dir_context *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 file_operations.poll __poll_t (__cdecl *)(file *, poll_table_struct *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 file_operations.unlocked_ioctl __int64 (__cdecl *)(file *, unsigned int, unsigned __int64);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 file_operations.compat_ioctl __int64 (__cdecl *)(file *, unsigned int, unsigned __int64);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 file_operations.mmap int (__cdecl *)(file *, vm_area_struct *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 file_operations.mmap_supported_flags unsigned __int64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 file_operations.open int (__cdecl *)(inode *, file *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 file_operations.flush int (__cdecl *)(file *, fl_owner_t);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 file_operations.release int (__cdecl *)(inode *, file *);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 file_operations.fsync int (__cdecl *)(file *, loff_t, loff_t, int);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 file_operations.fasync int (__cdecl *)(int, file *, int);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 file_operations.lock int (__cdecl *)(file *, int, file_lock *);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 file_operations.sendpage ssize_t (__cdecl *)(file *, page *, int, size_t, loff_t *, int);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 file_operations.get_unmapped_area unsigned __int64 (__cdecl *)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 file_operations.check_flags int (__cdecl *)(int);
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 file_operations.setfl int (__cdecl *)(file *, unsigned __int64);
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 file_operations.flock int (__cdecl *)(file *, int, file_lock *);
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 file_operations.splice_write ssize_t (__cdecl *)(pipe_inode_info *, file *, loff_t *, size_t, unsigned int);
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 file_operations.splice_read ssize_t (__cdecl *)(file *, loff_t *, pipe_inode_info *, size_t, unsigned int);
// 27. 00D8 0008 effalign(8) fda=0 bits=0000 file_operations.setlease int (__cdecl *)(file *, __int64, file_lock **, void **);
// 28. 00E0 0008 effalign(8) fda=0 bits=0000 file_operations.fallocate __int64 (__cdecl *)(file *, int, loff_t, loff_t);
// 29. 00E8 0008 effalign(8) fda=0 bits=0000 file_operations.show_fdinfo void (__cdecl *)(seq_file *, file *);
// 30. 00F0 0008 effalign(8) fda=0 bits=0000 file_operations.copy_file_range ssize_t (__cdecl *)(file *, loff_t, file *, loff_t, size_t, unsigned int);
// 31. 00F8 0008 effalign(8) fda=0 bits=0000 file_operations.remap_file_range loff_t (__cdecl *)(file *, loff_t, file *, loff_t, loff_t, unsigned int);
// 32. 0100 0008 effalign(8) fda=0 bits=0000 file_operations.fadvise int (__cdecl *)(file *, loff_t, loff_t, int);
// 33. 0108 0001 effalign(1) fda=0 bits=0000 file_operations.may_pollfree bool;
//          0109 unpadded_size
//          0110 effalign(8) sda=0 bits=0000 file_operations struct packalign=0

00000020 struct file_ra_state
{
  unsigned __int64 start;
  unsigned int size;
  unsigned int async_size;
  unsigned int ra_pages;
  unsigned int mmap_miss;
  loff_t prev_pos;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_ra_state.start unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 file_ra_state.size unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 file_ra_state.async_size unsigned int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 file_ra_state.ra_pages unsigned int;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 file_ra_state.mmap_miss unsigned int;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 file_ra_state.prev_pos loff_t;
//          0020 effalign(8) sda=0 bits=0000 file_ra_state struct packalign=0

00000048 struct file_system_type
{
  const char *name;
  int fs_flags;
  int (__cdecl *init_fs_context)(fs_context *);
  const fs_parameter_description *parameters;
  dentry *(__cdecl *mount)(file_system_type *, int, const char *, void *);
  void (__cdecl *kill_sb)(super_block *);
  module *owner;
  file_system_type *next;
  hlist_head fs_supers;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 file_system_type.name const char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 file_system_type.fs_flags int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 file_system_type.init_fs_context int (__cdecl *)(fs_context *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 file_system_type.parameters const fs_parameter_description *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 file_system_type.mount dentry *(__cdecl *)(file_system_type *, int, const char *, void *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 file_system_type.kill_sb void (__cdecl *)(super_block *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 file_system_type.owner module *;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 file_system_type.next file_system_type *;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 file_system_type.fs_supers hlist_head;
//          0048 effalign(8) sda=0 bits=0000 file_system_type struct packalign=0

00000004 enum file_time_flags : unsigned __int32
{
  S_ATIME = 0x1,
  S_MTIME = 0x2,
  S_CTIME = 0x4,
  S_VERSION = 0x8,
};
00000020 struct filename
{
  const char *name;
  const char *uptr;
  int refcnt;
  audit_names *aname;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 filename.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 filename.uptr const char *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 filename.refcnt int;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 filename.aname audit_names *;
//          0020 effalign(8) sda=0 bits=0000 filename struct packalign=0

00000018 struct files_stat_struct
{
  unsigned __int64 nr_files;
  unsigned __int64 nr_free_files;
  unsigned __int64 max_files;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 files_stat_struct.nr_files unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 files_stat_struct.nr_free_files unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 files_stat_struct.max_files unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 files_stat_struct struct packalign=0

FFFFFFFF struct files_struct;
00000008 typedef int (__cdecl *filldir_t)(dir_context *, const char *, int, loff_t, u64, unsigned int);
FFFFFFFF typedef int __cdecl filler_t(void *, page *);
00000004 enum fixed_addresses : unsigned __int32
{
  VSYSCALL_PAGE = 0x1FF,
  FIX_DBGP_BASE = 0x200,
  FIX_EARLYCON_MEM_BASE = 0x201,
  FIX_APIC_BASE = 0x202,
  FIX_IO_APIC_BASE_0 = 0x203,
  FIX_IO_APIC_BASE_END = 0x282,
  FIX_PARAVIRT_BOOTMAP = 0x283,
  FIX_APEI_GHES_IRQ = 0x284,
  FIX_APEI_GHES_NMI = 0x285,
  __end_of_permanent_fixed_addresses = 0x286,
  FIX_BTMAP_END = 0x400,
  FIX_BTMAP_BEGIN = 0x5FF,
  FIX_TBOOT_BASE = 0x600,
  __end_of_fixed_addresses = 0x601,
};
00000030 struct fixed_percpu_data
{
  char gs_base[40];
  unsigned __int64 stack_canary;
};
//  0. 0000 0028 effalign(1) fda=0 bits=0000 fixed_percpu_data.gs_base char[40];
//  1. 0028 0008 effalign(8) fda=0 bits=0000 fixed_percpu_data.stack_canary unsigned __int64;
//          0030 effalign(8) sda=0 bits=0000 fixed_percpu_data struct packalign=0

00000008 typedef void *fl_owner_t;
00000020 struct flock
{
  __int16 l_type;
  __int16 l_whence;
  __kernel_off_t l_start;
  __kernel_off_t l_len;
  __kernel_pid_t l_pid;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 flock.l_type __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 flock.l_whence __int16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 flock.l_start __kernel_off_t;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 flock.l_len __kernel_off_t;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 flock.l_pid __kernel_pid_t;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 flock struct packalign=0

00000020 struct flock64
{
  __int16 l_type;
  __int16 l_whence;
  __kernel_loff_t l_start;
  __kernel_loff_t l_len;
  __kernel_pid_t l_pid;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 flock64.l_type __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 flock64.l_whence __int16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 flock64.l_start __kernel_loff_t;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 flock64.l_len __kernel_loff_t;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 flock64.l_pid __kernel_pid_t;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 flock64 struct packalign=0

FFFFFFFF struct flush_tlb_info;
00000004 typedef unsigned int fmode_t;
00000020 struct fown_struct
{
  rwlock_t lock;
  pid *pid;
  pid_type pid_type;
  kuid_t uid;
  kuid_t euid;
  int signum;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 fown_struct.lock rwlock_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fown_struct.pid pid *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 fown_struct.pid_type pid_type;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 fown_struct.uid kuid_t;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 fown_struct.euid kuid_t;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 fown_struct.signum int;
//          0020 effalign(8) sda=0 bits=0000 fown_struct struct packalign=0

00001000 union fpregs_state
{
  fregs_state fsave;
  fxregs_state fxsave;
  swregs_state soft;
  xregs_state xsave;
  u8 __padding[4096];
};
//  0. 0000 0070 effalign(4) fda=0 bits=0000 fpregs_state.fsave fregs_state;
//  1. 0000 0200 effalign(16) fda=0 bits=0000 fpregs_state.fxsave fxregs_state;
//  2. 0000 0088 effalign(8) fda=0 bits=0000 fpregs_state.soft swregs_state;
//  3. 0000 0240 effalign(64) fda=0 bits=0000 fpregs_state.xsave xregs_state;
//  4. 0000 1000 effalign(1) fda=0 bits=0000 fpregs_state.__padding u8[4096];
//          1000 effalign(64) sda=0 bits=0000 fpregs_state union packalign=0

00000030 struct fprop_global
{
  percpu_counter events;
  unsigned int period;
  seqcount_t sequence;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 fprop_global.events percpu_counter;
//  1. 0028 0004 effalign(4) fda=0 bits=0000 fprop_global.period unsigned int;
//  2. 002C 0004 effalign(4) fda=0 bits=0000 fprop_global.sequence seqcount_t;
//          0030 effalign(8) sda=0 bits=0000 fprop_global struct packalign=0

00000030 struct fprop_local_percpu
{
  percpu_counter events;
  unsigned int period;
  raw_spinlock_t lock;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 fprop_local_percpu.events percpu_counter;
//  1. 0028 0004 effalign(4) fda=0 bits=0000 fprop_local_percpu.period unsigned int;
//  2. 002C 0004 effalign(4) fda=0 bits=0000 fprop_local_percpu.lock raw_spinlock_t;
//          0030 effalign(8) sda=0 bits=0000 fprop_local_percpu struct packalign=0

00000010 struct fprop_local_single
{
  unsigned __int64 events;
  unsigned int period;
  raw_spinlock_t lock;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fprop_local_single.events unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 fprop_local_single.period unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 fprop_local_single.lock raw_spinlock_t;
//          0010 effalign(8) sda=0 bits=0000 fprop_local_single struct packalign=0

00001040 struct fpu
{
  unsigned int last_cpu;
  unsigned __int64 avx512_timestamp;
  fpregs_state state;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 fpu.last_cpu unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fpu.avx512_timestamp unsigned __int64;
//  2. 0040 1000 effalign(64) fda=0 bits=0000 fpu.state fpregs_state;
//          1040 effalign(64) sda=0 bits=0000 fpu struct packalign=0

0000000C struct frame_vector
{
  unsigned int nr_allocated;
  unsigned int nr_frames;
  bool got_ref;
  bool is_pfns;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 frame_vector.nr_allocated unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 frame_vector.nr_frames unsigned int;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 frame_vector.got_ref bool;
//  3. 0009 0001 effalign(1) fda=0 bits=0000 frame_vector.is_pfns bool;
//          000A unpadded_size
//          000C effalign(4) sda=0 bits=0000 frame_vector struct packalign=0

00000068 struct free_area
{
  list_head free_list[6];
  unsigned __int64 nr_free;
};
//  0. 0000 0060 effalign(8) fda=0 bits=0000 free_area.free_list list_head[6];
//  1. 0060 0008 effalign(8) fda=0 bits=0000 free_area.nr_free unsigned __int64;
//          0068 effalign(8) sda=0 bits=0000 free_area struct packalign=0

00000070 struct fregs_state
{
  u32 cwd;
  u32 swd;
  u32 twd;
  u32 fip;
  u32 fcs;
  u32 foo;
  u32 fos;
  u32 st_space[20];
  u32 status;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 fregs_state.cwd u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 fregs_state.swd u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 fregs_state.twd u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 fregs_state.fip u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 fregs_state.fcs u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 fregs_state.foo u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 fregs_state.fos u32;
//  7. 001C 0050 effalign(4) fda=0 bits=0000 fregs_state.st_space u32[20];
//  8. 006C 0004 effalign(4) fda=0 bits=0000 fregs_state.status u32;
//          0070 effalign(4) sda=0 bits=0000 fregs_state struct packalign=0

FFFFFFFF struct fs_context;
00000070 struct fs_disk_quota
{
  __s8 d_version;
  __s8 d_flags;
  __u16 d_fieldmask;
  __u32 d_id;
  __u64 d_blk_hardlimit;
  __u64 d_blk_softlimit;
  __u64 d_ino_hardlimit;
  __u64 d_ino_softlimit;
  __u64 d_bcount;
  __u64 d_icount;
  __s32 d_itimer;
  __s32 d_btimer;
  __u16 d_iwarns;
  __u16 d_bwarns;
  __s32 d_padding2;
  __u64 d_rtb_hardlimit;
  __u64 d_rtb_softlimit;
  __u64 d_rtbcount;
  __s32 d_rtbtimer;
  __u16 d_rtbwarns;
  __s16 d_padding3;
  char d_padding4[8];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 fs_disk_quota.d_version __s8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 fs_disk_quota.d_flags __s8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 fs_disk_quota.d_fieldmask __u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 fs_disk_quota.d_id __u32;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_blk_hardlimit __u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_blk_softlimit __u64;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_ino_hardlimit __u64;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_ino_softlimit __u64;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_bcount __u64;
//  9. 0030 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_icount __u64;
// 10. 0038 0004 effalign(4) fda=0 bits=0000 fs_disk_quota.d_itimer __s32;
// 11. 003C 0004 effalign(4) fda=0 bits=0000 fs_disk_quota.d_btimer __s32;
// 12. 0040 0002 effalign(2) fda=0 bits=0000 fs_disk_quota.d_iwarns __u16;
// 13. 0042 0002 effalign(2) fda=0 bits=0000 fs_disk_quota.d_bwarns __u16;
// 14. 0044 0004 effalign(4) fda=0 bits=0000 fs_disk_quota.d_padding2 __s32;
// 15. 0048 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_rtb_hardlimit __u64;
// 16. 0050 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_rtb_softlimit __u64;
// 17. 0058 0008 effalign(8) fda=0 bits=0000 fs_disk_quota.d_rtbcount __u64;
// 18. 0060 0004 effalign(4) fda=0 bits=0000 fs_disk_quota.d_rtbtimer __s32;
// 19. 0064 0002 effalign(2) fda=0 bits=0000 fs_disk_quota.d_rtbwarns __u16;
// 20. 0066 0002 effalign(2) fda=0 bits=0000 fs_disk_quota.d_padding3 __s16;
// 21. 0068 0008 effalign(1) fda=0 bits=0000 fs_disk_quota.d_padding4 char[8];
//          0070 effalign(8) sda=0 bits=0000 fs_disk_quota struct packalign=0

00000070 typedef fs_disk_quota fs_disk_quota_t;
FFFFFFFF struct fs_parameter_description;
00000018 struct fs_qfilestat
{
  __u64 qfs_ino;
  __u64 qfs_nblks;
  __u32 qfs_nextents;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fs_qfilestat.qfs_ino __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fs_qfilestat.qfs_nblks __u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 fs_qfilestat.qfs_nextents __u32;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 fs_qfilestat struct packalign=0

00000018 typedef fs_qfilestat fs_qfilestat_t;
00000018 struct fs_qfilestatv
{
  __u64 qfs_ino;
  __u64 qfs_nblks;
  __u32 qfs_nextents;
  __u32 qfs_pad;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fs_qfilestatv.qfs_ino __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fs_qfilestatv.qfs_nblks __u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 fs_qfilestatv.qfs_nextents __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 fs_qfilestatv.qfs_pad __u32;
//          0018 effalign(8) sda=0 bits=0000 fs_qfilestatv struct packalign=0

00000050 struct fs_quota_stat
{
  __s8 qs_version;
  __u16 qs_flags;
  __s8 qs_pad;
  fs_qfilestat_t qs_uquota;
  fs_qfilestat_t qs_gquota;
  __u32 qs_incoredqs;
  __s32 qs_btimelimit;
  __s32 qs_itimelimit;
  __s32 qs_rtbtimelimit;
  __u16 qs_bwarnlimit;
  __u16 qs_iwarnlimit;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 fs_quota_stat.qs_version __s8;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 fs_quota_stat.qs_flags __u16;
//  2. 0004 0001 effalign(1) fda=0 bits=0000 fs_quota_stat.qs_pad __s8;
//  3. 0008 0018 effalign(8) fda=0 bits=0000 fs_quota_stat.qs_uquota fs_qfilestat_t;
//  4. 0020 0018 effalign(8) fda=0 bits=0000 fs_quota_stat.qs_gquota fs_qfilestat_t;
//  5. 0038 0004 effalign(4) fda=0 bits=0000 fs_quota_stat.qs_incoredqs __u32;
//  6. 003C 0004 effalign(4) fda=0 bits=0000 fs_quota_stat.qs_btimelimit __s32;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 fs_quota_stat.qs_itimelimit __s32;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 fs_quota_stat.qs_rtbtimelimit __s32;
//  9. 0048 0002 effalign(2) fda=0 bits=0000 fs_quota_stat.qs_bwarnlimit __u16;
// 10. 004A 0002 effalign(2) fda=0 bits=0000 fs_quota_stat.qs_iwarnlimit __u16;
//          004C unpadded_size
//          0050 effalign(8) sda=0 bits=0000 fs_quota_stat struct packalign=0

00000050 typedef fs_quota_stat fs_quota_stat_t;
000000A0 struct fs_quota_statv
{
  __s8 qs_version;
  __u8 qs_pad1;
  __u16 qs_flags;
  __u32 qs_incoredqs;
  fs_qfilestatv qs_uquota;
  fs_qfilestatv qs_gquota;
  fs_qfilestatv qs_pquota;
  __s32 qs_btimelimit;
  __s32 qs_itimelimit;
  __s32 qs_rtbtimelimit;
  __u16 qs_bwarnlimit;
  __u16 qs_iwarnlimit;
  __u64 qs_pad2[8];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 fs_quota_statv.qs_version __s8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 fs_quota_statv.qs_pad1 __u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 fs_quota_statv.qs_flags __u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 fs_quota_statv.qs_incoredqs __u32;
//  4. 0008 0018 effalign(8) fda=0 bits=0000 fs_quota_statv.qs_uquota fs_qfilestatv;
//  5. 0020 0018 effalign(8) fda=0 bits=0000 fs_quota_statv.qs_gquota fs_qfilestatv;
//  6. 0038 0018 effalign(8) fda=0 bits=0000 fs_quota_statv.qs_pquota fs_qfilestatv;
//  7. 0050 0004 effalign(4) fda=0 bits=0000 fs_quota_statv.qs_btimelimit __s32;
//  8. 0054 0004 effalign(4) fda=0 bits=0000 fs_quota_statv.qs_itimelimit __s32;
//  9. 0058 0004 effalign(4) fda=0 bits=0000 fs_quota_statv.qs_rtbtimelimit __s32;
// 10. 005C 0002 effalign(2) fda=0 bits=0000 fs_quota_statv.qs_bwarnlimit __u16;
// 11. 005E 0002 effalign(2) fda=0 bits=0000 fs_quota_statv.qs_iwarnlimit __u16;
// 12. 0060 0040 effalign(8) fda=0 bits=0000 fs_quota_statv.qs_pad2 __u64[8];
//          00A0 effalign(8) sda=0 bits=0000 fs_quota_statv struct packalign=0

FFFFFFFF struct fs_struct;
FFFFFFFF struct fscrypt_info;
FFFFFFFF struct fscrypt_operations;
00000012 struct fsl_mc_device_id
{
  __u16 vendor;
  const char obj_type[16];
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 fsl_mc_device_id.vendor __u16;
//  1. 0002 0010 effalign(1) fda=0 bits=0000 fsl_mc_device_id.obj_type const char[16];
//          0012 effalign(2) sda=0 bits=0000 fsl_mc_device_id struct packalign=0

FFFFFFFF struct fsnotify_mark_connector;
00000018 struct fstrim_range
{
  __u64 start;
  __u64 len;
  __u64 minlen;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fstrim_range.start __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fstrim_range.len __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 fstrim_range.minlen __u64;
//          0018 effalign(8) sda=0 bits=0000 fstrim_range struct packalign=0

FFFFFFFF struct fsverity_info;
FFFFFFFF struct fsverity_operations;
0000001C struct fsxattr
{
  __u32 fsx_xflags;
  __u32 fsx_extsize;
  __u32 fsx_nextents;
  __u32 fsx_projid;
  __u32 fsx_cowextsize;
  unsigned __int8 fsx_pad[8];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 fsxattr.fsx_xflags __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 fsxattr.fsx_extsize __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 fsxattr.fsx_nextents __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 fsxattr.fsx_projid __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 fsxattr.fsx_cowextsize __u32;
//  5. 0014 0008 effalign(1) fda=0 bits=0000 fsxattr.fsx_pad unsigned __int8[8];
//          001C effalign(4) sda=0 bits=0000 fsxattr struct packalign=0

00000028 struct ftrace_branch_data
{
  const char *func;
  const char *file;
  unsigned int line;
  union
  {
    struct
    {
      unsigned __int64 correct;
      unsigned __int64 incorrect;
    };
    struct
    {
      unsigned __int64 miss;
      unsigned __int64 hit;
    };
    unsigned __int64 miss_hit[2];
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 ftrace_branch_data.func const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 ftrace_branch_data.file const char *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 ftrace_branch_data.line unsigned int;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 ftrace_branch_data.ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8 ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8;
//          0028 effalign(8) sda=0 bits=0000 ftrace_branch_data struct packalign=0

00000010 union ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8
{
  struct
  {
    unsigned __int64 correct;
    unsigned __int64 incorrect;
  };
  struct
  {
    unsigned __int64 miss;
    unsigned __int64 hit;
  };
  unsigned __int64 miss_hit[2];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8.$7A2D00F1EDED085A322EED81EE9DDD1F $7A2D00F1EDED085A322EED81EE9DDD1F;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8.$5D69F5B72CCA61C8CE3CD8BAA8412A47 $5D69F5B72CCA61C8CE3CD8BAA8412A47;
//  2. 0000 0010 effalign(8) fda=0 bits=0000 ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8.miss_hit unsigned __int64[2];
//          0010 effalign(8) sda=0 bits=0000 ftrace_branch_data::$948234AF45808A433D7675D4258FB0B8 union packalign=0

00000004 enum ftrace_dump_mode : unsigned __int32
{
  DUMP_NONE = 0x0,
  DUMP_ALL = 0x1,
  DUMP_ORIG = 0x2,
};
00000030 struct ftrace_likely_data
{
  ftrace_branch_data data;
  unsigned __int64 constant;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 ftrace_likely_data.data ftrace_branch_data;
//  1. 0028 0008 effalign(8) fda=0 bits=0000 ftrace_likely_data.constant unsigned __int64;
//          0030 effalign(8) sda=0 bits=0000 ftrace_likely_data struct packalign=0

FFFFFFFF struct ftrace_ret_stack;
FFFFFFFF struct futex_pi_state;
00000010 struct fwnode_endpoint
{
  unsigned int port;
  unsigned int id;
  const fwnode_handle *local_fwnode;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 fwnode_endpoint.port unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 fwnode_endpoint.id unsigned int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 fwnode_endpoint.local_fwnode const fwnode_handle *;
//          0010 effalign(8) sda=0 bits=0000 fwnode_endpoint struct packalign=0

00000010 struct fwnode_handle
{
  fwnode_handle *secondary;
  const fwnode_operations *ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fwnode_handle.secondary fwnode_handle *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fwnode_handle.ops const fwnode_operations *;
//          0010 effalign(8) sda=0 bits=0000 fwnode_handle struct packalign=0

00000078 struct fwnode_operations
{
  fwnode_handle *(__cdecl *get)(fwnode_handle *);
  void (__cdecl *put)(fwnode_handle *);
  bool (__cdecl *device_is_available)(const fwnode_handle *);
  const void *(__cdecl *device_get_match_data)(const fwnode_handle *, const device *);
  bool (__cdecl *property_present)(const fwnode_handle *, const char *);
  int (__cdecl *property_read_int_array)(const fwnode_handle *, const char *, unsigned int, void *, size_t);
  int (__cdecl *property_read_string_array)(const fwnode_handle *, const char *, const char **, size_t);
  fwnode_handle *(__cdecl *get_parent)(const fwnode_handle *);
  fwnode_handle *(__cdecl *get_next_child_node)(const fwnode_handle *, fwnode_handle *);
  fwnode_handle *(__cdecl *get_named_child_node)(const fwnode_handle *, const char *);
  int (__cdecl *get_reference_args)(const fwnode_handle *, const char *, const char *, unsigned int, unsigned int, fwnode_reference_args *);
  fwnode_handle *(__cdecl *graph_get_next_endpoint)(const fwnode_handle *, fwnode_handle *);
  fwnode_handle *(__cdecl *graph_get_remote_endpoint)(const fwnode_handle *);
  fwnode_handle *(__cdecl *graph_get_port_parent)(fwnode_handle *);
  int (__cdecl *graph_parse_endpoint)(const fwnode_handle *, fwnode_endpoint *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fwnode_operations.get fwnode_handle *(__cdecl *)(fwnode_handle *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 fwnode_operations.put void (__cdecl *)(fwnode_handle *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 fwnode_operations.device_is_available bool (__cdecl *)(const fwnode_handle *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 fwnode_operations.device_get_match_data const void *(__cdecl *)(const fwnode_handle *, const device *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 fwnode_operations.property_present bool (__cdecl *)(const fwnode_handle *, const char *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 fwnode_operations.property_read_int_array int (__cdecl *)(const fwnode_handle *, const char *, unsigned int, void *, size_t);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 fwnode_operations.property_read_string_array int (__cdecl *)(const fwnode_handle *, const char *, const char **, size_t);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 fwnode_operations.get_parent fwnode_handle *(__cdecl *)(const fwnode_handle *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 fwnode_operations.get_next_child_node fwnode_handle *(__cdecl *)(const fwnode_handle *, fwnode_handle *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 fwnode_operations.get_named_child_node fwnode_handle *(__cdecl *)(const fwnode_handle *, const char *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 fwnode_operations.get_reference_args int (__cdecl *)(const fwnode_handle *, const char *, const char *, unsigned int, unsigned int, fwnode_reference_args *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 fwnode_operations.graph_get_next_endpoint fwnode_handle *(__cdecl *)(const fwnode_handle *, fwnode_handle *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 fwnode_operations.graph_get_remote_endpoint fwnode_handle *(__cdecl *)(const fwnode_handle *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 fwnode_operations.graph_get_port_parent fwnode_handle *(__cdecl *)(fwnode_handle *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 fwnode_operations.graph_parse_endpoint int (__cdecl *)(const fwnode_handle *, fwnode_endpoint *);
//          0078 effalign(8) sda=0 bits=0000 fwnode_operations struct packalign=0

00000050 struct fwnode_reference_args
{
  fwnode_handle *fwnode;
  unsigned int nargs;
  u64 args[8];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 fwnode_reference_args.fwnode fwnode_handle *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 fwnode_reference_args.nargs unsigned int;
//  2. 0010 0040 effalign(8) fda=0 bits=0000 fwnode_reference_args.args u64[8];
//          0050 effalign(8) sda=0 bits=0000 fwnode_reference_args struct packalign=0

00000200 struct __attribute__((aligned(16))) fxregs_state
{
  u16 cwd;
  u16 swd;
  u16 twd;
  u16 fop;
  union
  {
    struct
    {
      u64 rip;
      u64 rdp;
    };
    struct
    {
      u32 fip;
      u32 fcs;
      u32 foo;
      u32 fos;
    };
  };
  u32 mxcsr;
  u32 mxcsr_mask;
  u32 st_space[32];
  u32 xmm_space[64];
  u32 padding[12];
  union
  {
    u32 padding1[12];
    u32 sw_reserved[12];
  };
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 fxregs_state.cwd u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 fxregs_state.swd u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 fxregs_state.twd u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 fxregs_state.fop u16;
//  4. 0008 0010 effalign(8) fda=0 bits=0000 fxregs_state.fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705 fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 fxregs_state.mxcsr u32;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 fxregs_state.mxcsr_mask u32;
//  7. 0020 0080 effalign(4) fda=0 bits=0000 fxregs_state.st_space u32[32];
//  8. 00A0 0100 effalign(4) fda=0 bits=0000 fxregs_state.xmm_space u32[64];
//  9. 01A0 0030 effalign(4) fda=0 bits=0000 fxregs_state.padding u32[12];
// 10. 01D0 0030 effalign(4) fda=0 bits=0000 fxregs_state.fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA;
//          0200 effalign(16) sda=5 bits=0000 fxregs_state struct packalign=0

00000030 union fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA
{
  u32 padding1[12];
  u32 sw_reserved[12];
};
//  0. 0000 0030 effalign(4) fda=0 bits=0000 fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA.padding1 u32[12];
//  1. 0000 0030 effalign(4) fda=0 bits=0000 fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA.sw_reserved u32[12];
//          0030 effalign(4) sda=0 bits=0000 fxregs_state::$4A20CD17BF8247A49962096C5B16F4AA union packalign=0

00000010 union fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705
{
  struct
  {
    u64 rip;
    u64 rdp;
  };
  struct
  {
    u32 fip;
    u32 fcs;
    u32 foo;
    u32 fos;
  };
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705.$01BDD16C1AA177C5585F7FD1924C3EAA $01BDD16C1AA177C5585F7FD1924C3EAA;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705.$C27BEB34D2E5F24B2A42044AEB0EB8C3 $C27BEB34D2E5F24B2A42044AEB0EB8C3;
//          0010 effalign(8) sda=0 bits=0000 fxregs_state::$AAD6466AC28B6CCA1F6CCE27BDDE1705 union packalign=0

00000010 typedef gate_struct gate_desc;
00000010 struct __attribute__((packed)) gate_struct
{
  u16 offset_low;
  u16 segment;
  idt_bits bits;
  u16 offset_middle;
  u32 offset_high;
  u32 reserved;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 gate_struct.offset_low u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 gate_struct.segment u16;
//  2. 0004 0002 effalign(1) fda=0 bits=0000 gate_struct.bits idt_bits;
//  3. 0006 0002 effalign(1) fda=0 bits=0000 gate_struct.offset_middle u16;
//  4. 0008 0004 effalign(1) fda=0 bits=0000 gate_struct.offset_high u32;
//  5. 000C 0004 effalign(1) fda=0 bits=0000 gate_struct.reserved u32;
//          0010 effalign(1) sda=0 bits=0040 gate_struct struct packalign=0

00000498 struct gendisk
{
  int major;
  int first_minor;
  int minors;
  char disk_name[32];
  char *(__cdecl *devnode)(gendisk *, umode_t *);
  unsigned __int16 events;
  unsigned __int16 event_flags;
  disk_part_tbl *part_tbl;
  hd_struct part0;
  const block_device_operations *fops;
  request_queue *queue;
  void *private_data;
  int flags;
  rw_semaphore lookup_sem;
  kobject *slave_dir;
  timer_rand_state *random;
  atomic_t sync_io;
  disk_events *ev;
  kobject integrity_kobj;
  int node_id;
  badblocks *bb;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 gendisk.major int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 gendisk.first_minor int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 gendisk.minors int;
//  3. 000C 0020 effalign(1) fda=0 bits=0000 gendisk.disk_name char[32];
//  4. 0030 0008 effalign(8) fda=0 bits=0000 gendisk.devnode char *(__cdecl *)(gendisk *, umode_t *);
//  5. 0038 0002 effalign(2) fda=0 bits=0000 gendisk.events unsigned __int16;
//  6. 003A 0002 effalign(2) fda=0 bits=0000 gendisk.event_flags unsigned __int16;
//  7. 0040 0008 effalign(8) fda=0 bits=0000 gendisk.part_tbl disk_part_tbl *;
//  8. 0048 0398 effalign(8) fda=0 bits=0000 gendisk.part0 hd_struct;
//  9. 03E0 0008 effalign(8) fda=0 bits=0000 gendisk.fops const block_device_operations *;
// 10. 03E8 0008 effalign(8) fda=0 bits=0000 gendisk.queue request_queue *;
// 11. 03F0 0008 effalign(8) fda=0 bits=0000 gendisk.private_data void *;
// 12. 03F8 0004 effalign(4) fda=0 bits=0000 gendisk.flags int;
// 13. 0400 0028 effalign(8) fda=0 bits=0000 gendisk.lookup_sem rw_semaphore;
// 14. 0428 0008 effalign(8) fda=0 bits=0000 gendisk.slave_dir kobject *;
// 15. 0430 0008 effalign(8) fda=0 bits=0000 gendisk.random timer_rand_state *;
// 16. 0438 0004 effalign(4) fda=0 bits=0000 gendisk.sync_io atomic_t;
// 17. 0440 0008 effalign(8) fda=0 bits=0000 gendisk.ev disk_events *;
// 18. 0448 0040 effalign(8) fda=0 bits=0000 gendisk.integrity_kobj kobject;
// 19. 0488 0004 effalign(4) fda=0 bits=0000 gendisk.node_id int;
// 20. 0490 0008 effalign(8) fda=0 bits=0000 gendisk.bb badblocks *;
//          0498 effalign(8) sda=0 bits=0000 gendisk struct packalign=0

FFFFFFFF typedef int __cdecl get_block_t(inode *, sector_t, buffer_head *, int);
00000004 typedef unsigned int gfp_t;
00000002 typedef __kernel_gid16_t gid16_t;
00000004 typedef __kernel_gid32_t gid_t;
00000008 struct group_info
{
  atomic_t usage;
  int ngroups;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 group_info.usage atomic_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 group_info.ngroups int;
//          0008 effalign(4) sda=0 bits=0000 group_info struct packalign=0

00000010 struct guid_t
{
  __u8 b[16];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 guid_t.b __u8[16];
//          0010 effalign(1) sda=0 bits=0000 guid_t struct packalign=0

FFFFFFFF struct hd_geometry;
00000398 struct hd_struct
{
  sector_t start_sect;
  sector_t nr_sects;
  seqcount_t nr_sects_seq;
  sector_t alignment_offset;
  unsigned int discard_alignment;
  device __dev;
  kobject *holder_dir;
  int policy;
  int partno;
  partition_meta_info *info;
  unsigned __int64 stamp;
  disk_stats *dkstats;
  percpu_ref ref;
  rcu_work rcu_work;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hd_struct.start_sect sector_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 hd_struct.nr_sects sector_t;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 hd_struct.nr_sects_seq seqcount_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 hd_struct.alignment_offset sector_t;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 hd_struct.discard_alignment unsigned int;
//  5. 0028 02D8 effalign(8) fda=0 bits=0000 hd_struct.__dev device;
//  6. 0300 0008 effalign(8) fda=0 bits=0000 hd_struct.holder_dir kobject *;
//  7. 0308 0004 effalign(4) fda=0 bits=0000 hd_struct.policy int;
//  8. 030C 0004 effalign(4) fda=0 bits=0000 hd_struct.partno int;
//  9. 0310 0008 effalign(8) fda=0 bits=0000 hd_struct.info partition_meta_info *;
// 10. 0318 0008 effalign(8) fda=0 bits=0000 hd_struct.stamp unsigned __int64;
// 11. 0320 0008 effalign(8) fda=0 bits=0000 hd_struct.dkstats disk_stats *;
// 12. 0328 0038 effalign(8) fda=0 bits=0000 hd_struct.ref percpu_ref;
// 13. 0360 0038 effalign(8) fda=0 bits=0000 hd_struct.rcu_work rcu_work;
//          0398 effalign(8) sda=0 bits=0000 hd_struct struct packalign=0

00000020 struct hda_device_id
{
  __u32 vendor_id;
  __u32 rev_id;
  __u8 api_version;
  const char *name;
  unsigned __int64 driver_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 hda_device_id.vendor_id __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 hda_device_id.rev_id __u32;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 hda_device_id.api_version __u8;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 hda_device_id.name const char *;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 hda_device_id.driver_data unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 hda_device_id struct packalign=0

00000018 struct hid_device_id
{
  __u16 bus;
  __u16 group;
  __u32 vendor;
  __u32 product;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 hid_device_id.bus __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 hid_device_id.group __u16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 hid_device_id.vendor __u32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 hid_device_id.product __u32;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 hid_device_id.driver_data kernel_ulong_t;
//          0018 effalign(8) sda=0 bits=0000 hid_device_id struct packalign=0

00000008 struct hlist_bl_head
{
  hlist_bl_node *first;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hlist_bl_head.first hlist_bl_node *;
//          0008 effalign(8) sda=0 bits=0000 hlist_bl_head struct packalign=0

00000010 struct hlist_bl_node
{
  hlist_bl_node *next;
  hlist_bl_node **pprev;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hlist_bl_node.next hlist_bl_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 hlist_bl_node.pprev hlist_bl_node **;
//          0010 effalign(8) sda=0 bits=0000 hlist_bl_node struct packalign=0

00000008 struct hlist_head
{
  hlist_node *first;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hlist_head.first hlist_node *;
//          0008 effalign(8) sda=0 bits=0000 hlist_head struct packalign=0

00000010 struct hlist_node
{
  hlist_node *next;
  hlist_node **pprev;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hlist_node.next hlist_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 hlist_node.pprev hlist_node **;
//          0010 effalign(8) sda=0 bits=0000 hlist_node struct packalign=0

00000040 struct hrtimer
{
  timerqueue_node node;
  ktime_t _softexpires;
  hrtimer_restart (__cdecl *function)(hrtimer *);
  hrtimer_clock_base *base;
  u8 state;
  u8 is_rel;
  u8 is_soft;
  u8 is_hard;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 hrtimer.node timerqueue_node;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 hrtimer._softexpires ktime_t;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 hrtimer.function hrtimer_restart (__cdecl *)(hrtimer *);
//  3. 0030 0008 effalign(8) fda=0 bits=0000 hrtimer.base hrtimer_clock_base *;
//  4. 0038 0001 effalign(1) fda=0 bits=0000 hrtimer.state u8;
//  5. 0039 0001 effalign(1) fda=0 bits=0000 hrtimer.is_rel u8;
//  6. 003A 0001 effalign(1) fda=0 bits=0000 hrtimer.is_soft u8;
//  7. 003B 0001 effalign(1) fda=0 bits=0000 hrtimer.is_hard u8;
//          003C unpadded_size
//          0040 effalign(8) sda=0 bits=0000 hrtimer struct packalign=0

00000004 enum hrtimer_base_type : unsigned __int32
{
  HRTIMER_BASE_MONOTONIC = 0x0,
  HRTIMER_BASE_REALTIME = 0x1,
  HRTIMER_BASE_BOOTTIME = 0x2,
  HRTIMER_BASE_TAI = 0x3,
  HRTIMER_BASE_MONOTONIC_SOFT = 0x4,
  HRTIMER_BASE_REALTIME_SOFT = 0x5,
  HRTIMER_BASE_BOOTTIME_SOFT = 0x6,
  HRTIMER_BASE_TAI_SOFT = 0x7,
  HRTIMER_MAX_CLOCK_BASES = 0x8,
};
00000040 struct __attribute__((aligned(64))) hrtimer_clock_base
{
  hrtimer_cpu_base *cpu_base;
  unsigned int index;
  clockid_t clockid;
  seqcount_t seq;
  hrtimer *running;
  timerqueue_head active;
  ktime_t (*get_time)(void);
  ktime_t offset;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 hrtimer_clock_base.cpu_base hrtimer_cpu_base *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 hrtimer_clock_base.index unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 hrtimer_clock_base.clockid clockid_t;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 hrtimer_clock_base.seq seqcount_t;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 hrtimer_clock_base.running hrtimer *;
//  5. 0020 0010 effalign(8) fda=0 bits=0000 hrtimer_clock_base.active timerqueue_head;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 hrtimer_clock_base.get_time ktime_t (*)(void);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 hrtimer_clock_base.offset ktime_t;
//          0040 effalign(64) sda=7 bits=0000 hrtimer_clock_base struct packalign=0

00000240 struct __attribute__((aligned(64))) hrtimer_cpu_base
{
  raw_spinlock_t lock;
  unsigned int cpu;
  unsigned int active_bases;
  unsigned int clock_was_set_seq;
  unsigned __int32 hres_active : 1;
  unsigned __int32 in_hrtirq : 1;
  unsigned __int32 hang_detected : 1;
  unsigned __int32 softirq_activated : 1;
  unsigned int nr_events;
  unsigned __int16 nr_retries;
  unsigned __int16 nr_hangs;
  unsigned int max_hang_time;
  ktime_t expires_next;
  hrtimer *next_timer;
  ktime_t softirq_expires_next;
  hrtimer *softirq_next_timer;
  hrtimer_clock_base clock_base[8];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.lock raw_spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.cpu unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.active_bases unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.clock_was_set_seq unsigned int;
//  4. 0010. 0 1 effalign(1) fda=0 bits=0000 hrtimer_cpu_base.hres_active bi.nbytes=4 U
//  5. 0010. 1 1 effalign(1) fda=0 bits=0000 hrtimer_cpu_base.in_hrtirq bi.nbytes=4 U
//  6. 0010. 2 1 effalign(1) fda=0 bits=0000 hrtimer_cpu_base.hang_detected bi.nbytes=4 U
//  7. 0010. 3 1 effalign(1) fda=0 bits=0000 hrtimer_cpu_base.softirq_activated bi.nbytes=4 U
//  8. 0014 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.nr_events unsigned int;
//  9. 0018 0002 effalign(2) fda=0 bits=0000 hrtimer_cpu_base.nr_retries unsigned __int16;
// 10. 001A 0002 effalign(2) fda=0 bits=0000 hrtimer_cpu_base.nr_hangs unsigned __int16;
// 11. 001C 0004 effalign(4) fda=0 bits=0000 hrtimer_cpu_base.max_hang_time unsigned int;
// 12. 0020 0008 effalign(8) fda=0 bits=0000 hrtimer_cpu_base.expires_next ktime_t;
// 13. 0028 0008 effalign(8) fda=0 bits=0000 hrtimer_cpu_base.next_timer hrtimer *;
// 14. 0030 0008 effalign(8) fda=0 bits=0000 hrtimer_cpu_base.softirq_expires_next ktime_t;
// 15. 0038 0008 effalign(8) fda=0 bits=0000 hrtimer_cpu_base.softirq_next_timer hrtimer *;
// 16. 0040 0200 effalign(64) fda=0 bits=0000 hrtimer_cpu_base.clock_base hrtimer_clock_base[8];
//          0240 effalign(64) sda=7 bits=0000 hrtimer_cpu_base struct packalign=0

00000004 enum hrtimer_mode : unsigned __int32
{
  HRTIMER_MODE_ABS = 0x0,
  HRTIMER_MODE_REL = 0x1,
  HRTIMER_MODE_PINNED = 0x2,
  HRTIMER_MODE_SOFT = 0x4,
  HRTIMER_MODE_HARD = 0x8,
  HRTIMER_MODE_ABS_PINNED = 0x2,
  HRTIMER_MODE_REL_PINNED = 0x3,
  HRTIMER_MODE_ABS_SOFT = 0x4,
  HRTIMER_MODE_REL_SOFT = 0x5,
  HRTIMER_MODE_ABS_PINNED_SOFT = 0x6,
  HRTIMER_MODE_REL_PINNED_SOFT = 0x7,
  HRTIMER_MODE_ABS_HARD = 0x8,
  HRTIMER_MODE_REL_HARD = 0x9,
  HRTIMER_MODE_ABS_PINNED_HARD = 0xA,
  HRTIMER_MODE_REL_PINNED_HARD = 0xB,
};
00000004 enum hrtimer_restart : unsigned __int32
{
  HRTIMER_NORESTART = 0x0,
  HRTIMER_RESTART = 0x1,
};
00000048 struct hrtimer_sleeper
{
  hrtimer timer;
  task_struct *task;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 hrtimer_sleeper.timer hrtimer;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 hrtimer_sleeper.task task_struct *;
//          0048 effalign(8) sda=0 bits=0000 hrtimer_sleeper struct packalign=0

00000018 struct hv_vmbus_device_id
{
  uuid_le guid;
  kernel_ulong_t driver_data;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 hv_vmbus_device_id.guid uuid_le;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 hv_vmbus_device_id.driver_data kernel_ulong_t;
//          0018 effalign(8) sda=0 bits=0000 hv_vmbus_device_id struct packalign=0

00000004 enum hwparam_type : unsigned __int32
{
  hwparam_ioport = 0x0,
  hwparam_iomem = 0x1,
  hwparam_ioport_or_iomem = 0x2,
  hwparam_irq = 0x3,
  hwparam_dma = 0x4,
  hwparam_dma_addr = 0x5,
  hwparam_other = 0x6,
};
00000020 struct i2c_device_id
{
  char name[20];
  kernel_ulong_t driver_data;
};
//  0. 0000 0014 effalign(1) fda=0 bits=0000 i2c_device_id.name char[20];
//  1. 0018 0008 effalign(8) fda=0 bits=0000 i2c_device_id.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 i2c_device_id struct packalign=0

00000010 struct i3c_device_id
{
  __u8 match_flags;
  __u8 dcr;
  __u16 manuf_id;
  __u16 part_id;
  __u16 extra_info;
  const void *data;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 i3c_device_id.match_flags __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 i3c_device_id.dcr __u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 i3c_device_id.manuf_id __u16;
//  3. 0004 0002 effalign(2) fda=0 bits=0000 i3c_device_id.part_id __u16;
//  4. 0006 0002 effalign(2) fda=0 bits=0000 i3c_device_id.extra_info __u16;
//  5. 0008 0008 effalign(8) fda=0 bits=0000 i3c_device_id.data const void *;
//          0010 effalign(8) sda=0 bits=0000 i3c_device_id struct packalign=0

00000050 struct iattr
{
  unsigned int ia_valid;
  umode_t ia_mode;
  kuid_t ia_uid;
  kgid_t ia_gid;
  loff_t ia_size;
  timespec64 ia_atime;
  timespec64 ia_mtime;
  timespec64 ia_ctime;
  file *ia_file;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 iattr.ia_valid unsigned int;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 iattr.ia_mode umode_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 iattr.ia_uid kuid_t;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 iattr.ia_gid kgid_t;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 iattr.ia_size loff_t;
//  5. 0018 0010 effalign(8) fda=0 bits=0000 iattr.ia_atime timespec64;
//  6. 0028 0010 effalign(8) fda=0 bits=0000 iattr.ia_mtime timespec64;
//  7. 0038 0010 effalign(8) fda=0 bits=0000 iattr.ia_ctime timespec64;
//  8. 0048 0008 effalign(8) fda=0 bits=0000 iattr.ia_file file *;
//          0050 effalign(8) sda=0 bits=0000 iattr struct packalign=0

FFFFFFFF struct ib_device;
00000010 struct ida
{
  xarray xa;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 ida.xa xarray;
//          0010 effalign(8) sda=0 bits=0000 ida struct packalign=0

00000080 struct ida_bitmap
{
  unsigned __int64 bitmap[16];
};
//  0. 0000 0080 effalign(8) fda=0 bits=0000 ida_bitmap.bitmap unsigned __int64[16];
//          0080 effalign(8) sda=0 bits=0000 ida_bitmap struct packalign=0

00000004 enum idle_boot_override : unsigned __int32
{
  IDLE_NO_OVERRIDE = 0x0,
  IDLE_HALT = 0x1,
  IDLE_NOMWAIT = 0x2,
  IDLE_POLL = 0x3,
};
00000018 struct idr
{
  xarray idr_rt;
  unsigned int idr_base;
  unsigned int idr_next;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 idr.idr_rt xarray;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 idr.idr_base unsigned int;
//  2. 0014 0004 effalign(4) fda=0 bits=0000 idr.idr_next unsigned int;
//          0018 effalign(8) sda=0 bits=0000 idr struct packalign=0

00000002 struct __attribute__((packed)) idt_bits
{
  unsigned __int16 ist : 3;
  unsigned __int16 zero : 5;
  unsigned __int16 type : 5;
  unsigned __int16 dpl : 2;
  unsigned __int16 p : 1;
};
//  0. 0000. 0 3 effalign(1) fda=0 bits=0000 idt_bits.ist bi.nbytes=2 U
//  1. 0000. 3 5 effalign(1) fda=0 bits=0000 idt_bits.zero bi.nbytes=2 U
//  2. 0000. 8 5 effalign(1) fda=0 bits=0000 idt_bits.type bi.nbytes=2 U
//  3. 0000.13 2 effalign(1) fda=0 bits=0000 idt_bits.dpl bi.nbytes=2 U
//  4. 0000.15 1 effalign(1) fda=0 bits=0000 idt_bits.p bi.nbytes=2 U
//          0002 effalign(1) sda=0 bits=0040 idt_bits struct packalign=0

00000020 struct ieee1394_device_id
{
  __u32 match_flags;
  __u32 vendor_id;
  __u32 model_id;
  __u32 specifier_id;
  __u32 version;
  kernel_ulong_t driver_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ieee1394_device_id.match_flags __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ieee1394_device_id.vendor_id __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ieee1394_device_id.model_id __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 ieee1394_device_id.specifier_id __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 ieee1394_device_id.version __u32;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 ieee1394_device_id.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 ieee1394_device_id struct packalign=0

00000048 struct if_dqblk
{
  __u64 dqb_bhardlimit;
  __u64 dqb_bsoftlimit;
  __u64 dqb_curspace;
  __u64 dqb_ihardlimit;
  __u64 dqb_isoftlimit;
  __u64 dqb_curinodes;
  __u64 dqb_btime;
  __u64 dqb_itime;
  __u32 dqb_valid;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_bhardlimit __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_bsoftlimit __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_curspace __u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_ihardlimit __u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_isoftlimit __u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_curinodes __u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_btime __u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 if_dqblk.dqb_itime __u64;
//  8. 0040 0004 effalign(4) fda=0 bits=0000 if_dqblk.dqb_valid __u32;
//          0044 unpadded_size
//          0048 effalign(8) sda=0 bits=0000 if_dqblk struct packalign=0

00000018 struct if_dqinfo
{
  __u64 dqi_bgrace;
  __u64 dqi_igrace;
  __u32 dqi_flags;
  __u32 dqi_valid;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 if_dqinfo.dqi_bgrace __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 if_dqinfo.dqi_igrace __u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 if_dqinfo.dqi_flags __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 if_dqinfo.dqi_valid __u32;
//          0018 effalign(8) sda=0 bits=0000 if_dqinfo struct packalign=0

00000048 struct if_nextdqblk
{
  __u64 dqb_bhardlimit;
  __u64 dqb_bsoftlimit;
  __u64 dqb_curspace;
  __u64 dqb_ihardlimit;
  __u64 dqb_isoftlimit;
  __u64 dqb_curinodes;
  __u64 dqb_btime;
  __u64 dqb_itime;
  __u32 dqb_valid;
  __u32 dqb_id;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_bhardlimit __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_bsoftlimit __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_curspace __u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_ihardlimit __u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_isoftlimit __u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_curinodes __u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_btime __u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 if_nextdqblk.dqb_itime __u64;
//  8. 0040 0004 effalign(4) fda=0 bits=0000 if_nextdqblk.dqb_valid __u32;
//  9. 0044 0004 effalign(4) fda=0 bits=0000 if_nextdqblk.dqb_id __u32;
//          0048 effalign(8) sda=0 bits=0000 if_nextdqblk struct packalign=0

00000004 typedef u32 ihandle;
00000004 typedef int initcall_entry_t;
00000008 typedef int (*initcall_t)(void);
00000008 typedef __kernel_ino_t ino_t;
00000258 struct inode
{
  umode_t i_mode;
  unsigned __int16 i_opflags;
  kuid_t i_uid;
  kgid_t i_gid;
  unsigned int i_flags;
  posix_acl *i_acl;
  posix_acl *i_default_acl;
  const inode_operations *i_op;
  super_block *i_sb;
  address_space *i_mapping;
  void *i_security;
  unsigned __int64 i_ino;
  union
  {
    const unsigned int i_nlink;
    unsigned int __i_nlink;
  };
  dev_t i_rdev;
  loff_t i_size;
  timespec64 i_atime;
  timespec64 i_mtime;
  timespec64 i_ctime;
  spinlock_t i_lock;
  unsigned __int16 i_bytes;
  u8 i_blkbits;
  u8 i_write_hint;
  blkcnt_t i_blocks;
  unsigned __int64 i_state;
  rw_semaphore i_rwsem;
  unsigned __int64 dirtied_when;
  unsigned __int64 dirtied_time_when;
  hlist_node i_hash;
  list_head i_io_list;
  bdi_writeback *i_wb;
  int i_wb_frn_winner;
  u16 i_wb_frn_avg_time;
  u16 i_wb_frn_history;
  list_head i_lru;
  list_head i_sb_list;
  list_head i_wb_list;
  union
  {
    hlist_head i_dentry;
    callback_head i_rcu;
  };
  atomic64_t i_version;
  atomic64_t i_sequence;
  atomic_t i_count;
  atomic_t i_dio_count;
  atomic_t i_writecount;
  atomic_t i_readcount;
  union
  {
    const file_operations *i_fop;
    void (__cdecl *free_inode)(inode *);
  };
  file_lock_context *i_flctx;
  address_space i_data;
  list_head i_devices;
  union
  {
    pipe_inode_info *i_pipe;
    block_device *i_bdev;
    cdev *i_cdev;
    char *i_link;
    unsigned int i_dir_seq;
  };
  __u32 i_generation;
  __u32 i_fsnotify_mask;
  fsnotify_mark_connector *i_fsnotify_marks;
  fscrypt_info *i_crypt_info;
  fsverity_info *i_verity_info;
  void *i_private;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 inode.i_mode umode_t;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 inode.i_opflags unsigned __int16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 inode.i_uid kuid_t;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 inode.i_gid kgid_t;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 inode.i_flags unsigned int;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 inode.i_acl posix_acl *;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 inode.i_default_acl posix_acl *;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 inode.i_op const inode_operations *;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 inode.i_sb super_block *;
//  9. 0030 0008 effalign(8) fda=0 bits=0000 inode.i_mapping address_space *;
// 10. 0038 0008 effalign(8) fda=0 bits=0000 inode.i_security void *;
// 11. 0040 0008 effalign(8) fda=0 bits=0000 inode.i_ino unsigned __int64;
// 12. 0048 0004 effalign(4) fda=0 bits=0000 inode.inode::$4FAF459BA209DB8A26ECB5403EE4E15D inode::$4FAF459BA209DB8A26ECB5403EE4E15D;
// 13. 004C 0004 effalign(4) fda=0 bits=0000 inode.i_rdev dev_t;
// 14. 0050 0008 effalign(8) fda=0 bits=0000 inode.i_size loff_t;
// 15. 0058 0010 effalign(8) fda=0 bits=0000 inode.i_atime timespec64;
// 16. 0068 0010 effalign(8) fda=0 bits=0000 inode.i_mtime timespec64;
// 17. 0078 0010 effalign(8) fda=0 bits=0000 inode.i_ctime timespec64;
// 18. 0088 0004 effalign(4) fda=0 bits=0000 inode.i_lock spinlock_t;
// 19. 008C 0002 effalign(2) fda=0 bits=0000 inode.i_bytes unsigned __int16;
// 20. 008E 0001 effalign(1) fda=0 bits=0000 inode.i_blkbits u8;
// 21. 008F 0001 effalign(1) fda=0 bits=0000 inode.i_write_hint u8;
// 22. 0090 0008 effalign(8) fda=0 bits=0000 inode.i_blocks blkcnt_t;
// 23. 0098 0008 effalign(8) fda=0 bits=0000 inode.i_state unsigned __int64;
// 24. 00A0 0028 effalign(8) fda=0 bits=0000 inode.i_rwsem rw_semaphore;
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 inode.dirtied_when unsigned __int64;
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 inode.dirtied_time_when unsigned __int64;
// 27. 00D8 0010 effalign(8) fda=0 bits=0000 inode.i_hash hlist_node;
// 28. 00E8 0010 effalign(8) fda=0 bits=0000 inode.i_io_list list_head;
// 29. 00F8 0008 effalign(8) fda=0 bits=0000 inode.i_wb bdi_writeback *;
// 30. 0100 0004 effalign(4) fda=0 bits=0000 inode.i_wb_frn_winner int;
// 31. 0104 0002 effalign(2) fda=0 bits=0000 inode.i_wb_frn_avg_time u16;
// 32. 0106 0002 effalign(2) fda=0 bits=0000 inode.i_wb_frn_history u16;
// 33. 0108 0010 effalign(8) fda=0 bits=0000 inode.i_lru list_head;
// 34. 0118 0010 effalign(8) fda=0 bits=0000 inode.i_sb_list list_head;
// 35. 0128 0010 effalign(8) fda=0 bits=0000 inode.i_wb_list list_head;
// 36. 0138 0010 effalign(8) fda=0 bits=0000 inode.inode::$7B2567D70A0237F3EBB83C38CE08E764 inode::$7B2567D70A0237F3EBB83C38CE08E764;
// 37. 0148 0008 effalign(8) fda=0 bits=0000 inode.i_version atomic64_t;
// 38. 0150 0008 effalign(8) fda=0 bits=0000 inode.i_sequence atomic64_t;
// 39. 0158 0004 effalign(4) fda=0 bits=0000 inode.i_count atomic_t;
// 40. 015C 0004 effalign(4) fda=0 bits=0000 inode.i_dio_count atomic_t;
// 41. 0160 0004 effalign(4) fda=0 bits=0000 inode.i_writecount atomic_t;
// 42. 0164 0004 effalign(4) fda=0 bits=0000 inode.i_readcount atomic_t;
// 43. 0168 0008 effalign(8) fda=0 bits=0000 inode.inode::$3BEFEF0557BF696ECFADDA689E32F72C inode::$3BEFEF0557BF696ECFADDA689E32F72C;
// 44. 0170 0008 effalign(8) fda=0 bits=0000 inode.i_flctx file_lock_context *;
// 45. 0178 00A0 effalign(8) fda=0 bits=0000 inode.i_data address_space;
// 46. 0218 0010 effalign(8) fda=0 bits=0000 inode.i_devices list_head;
// 47. 0228 0008 effalign(8) fda=0 bits=0000 inode.inode::$8073E762935E536BF05FF9D7402CEB32 inode::$8073E762935E536BF05FF9D7402CEB32;
// 48. 0230 0004 effalign(4) fda=0 bits=0000 inode.i_generation __u32;
// 49. 0234 0004 effalign(4) fda=0 bits=0000 inode.i_fsnotify_mask __u32;
// 50. 0238 0008 effalign(8) fda=0 bits=0000 inode.i_fsnotify_marks fsnotify_mark_connector *;
// 51. 0240 0008 effalign(8) fda=0 bits=0000 inode.i_crypt_info fscrypt_info *;
// 52. 0248 0008 effalign(8) fda=0 bits=0000 inode.i_verity_info fsverity_info *;
// 53. 0250 0008 effalign(8) fda=0 bits=0000 inode.i_private void *;
//          0258 effalign(8) sda=0 bits=0000 inode struct packalign=0

00000008 union inode::$3BEFEF0557BF696ECFADDA689E32F72C
{
  const file_operations *i_fop;
  void (__cdecl *free_inode)(inode *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 inode::$3BEFEF0557BF696ECFADDA689E32F72C.i_fop const file_operations *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 inode::$3BEFEF0557BF696ECFADDA689E32F72C.free_inode void (__cdecl *)(inode *);
//          0008 effalign(8) sda=0 bits=0000 inode::$3BEFEF0557BF696ECFADDA689E32F72C union packalign=0

00000004 union inode::$4FAF459BA209DB8A26ECB5403EE4E15D
{
  const unsigned int i_nlink;
  unsigned int __i_nlink;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 inode::$4FAF459BA209DB8A26ECB5403EE4E15D.i_nlink const unsigned int;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 inode::$4FAF459BA209DB8A26ECB5403EE4E15D.__i_nlink unsigned int;
//          0004 effalign(4) sda=0 bits=0000 inode::$4FAF459BA209DB8A26ECB5403EE4E15D union packalign=0

00000010 union inode::$7B2567D70A0237F3EBB83C38CE08E764
{
  hlist_head i_dentry;
  callback_head i_rcu;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 inode::$7B2567D70A0237F3EBB83C38CE08E764.i_dentry hlist_head;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 inode::$7B2567D70A0237F3EBB83C38CE08E764.i_rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 inode::$7B2567D70A0237F3EBB83C38CE08E764 union packalign=0

00000008 union inode::$8073E762935E536BF05FF9D7402CEB32
{
  pipe_inode_info *i_pipe;
  block_device *i_bdev;
  cdev *i_cdev;
  char *i_link;
  unsigned int i_dir_seq;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32.i_pipe pipe_inode_info *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32.i_bdev block_device *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32.i_cdev cdev *;
//  3. 0000 0008 effalign(8) fda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32.i_link char *;
//  4. 0000 0004 effalign(4) fda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32.i_dir_seq unsigned int;
//          0008 effalign(8) sda=0 bits=0000 inode::$8073E762935E536BF05FF9D7402CEB32 union packalign=0

00000004 enum inode_i_mutex_lock_class : unsigned __int32
{
  I_MUTEX_NORMAL = 0x0,
  I_MUTEX_PARENT = 0x1,
  I_MUTEX_CHILD = 0x2,
  I_MUTEX_XATTR = 0x3,
  I_MUTEX_NONDIR2 = 0x4,
  I_MUTEX_PARENT2 = 0x5,
};
000000C0 struct __attribute__((aligned(64))) inode_operations
{
  dentry *(__cdecl *lookup)(inode *, dentry *, unsigned int);
  const char *(__cdecl *get_link)(dentry *, inode *, delayed_call *);
  int (__cdecl *permission)(inode *, int);
  posix_acl *(__cdecl *get_acl)(inode *, int);
  int (__cdecl *readlink)(dentry *, char *, int);
  int (__cdecl *create)(inode *, dentry *, umode_t, bool);
  int (__cdecl *link)(dentry *, inode *, dentry *);
  int (__cdecl *unlink)(inode *, dentry *);
  int (__cdecl *symlink)(inode *, dentry *, const char *);
  int (__cdecl *mkdir)(inode *, dentry *, umode_t);
  int (__cdecl *rmdir)(inode *, dentry *);
  int (__cdecl *mknod)(inode *, dentry *, umode_t, dev_t);
  int (__cdecl *rename)(inode *, dentry *, inode *, dentry *, unsigned int);
  int (__cdecl *setattr)(dentry *, iattr *);
  int (__cdecl *getattr)(const path *, kstat *, u32, unsigned int);
  ssize_t (__cdecl *listxattr)(dentry *, char *, size_t);
  int (__cdecl *fiemap)(inode *, fiemap_extent_info *, u64, u64);
  int (__cdecl *update_time)(inode *, timespec64 *, int);
  int (__cdecl *atomic_open)(inode *, dentry *, file *, unsigned int, umode_t);
  int (__cdecl *tmpfile)(inode *, dentry *, umode_t);
  int (__cdecl *set_acl)(inode *, posix_acl *, int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 inode_operations.lookup dentry *(__cdecl *)(inode *, dentry *, unsigned int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 inode_operations.get_link const char *(__cdecl *)(dentry *, inode *, delayed_call *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 inode_operations.permission int (__cdecl *)(inode *, int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 inode_operations.get_acl posix_acl *(__cdecl *)(inode *, int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 inode_operations.readlink int (__cdecl *)(dentry *, char *, int);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 inode_operations.create int (__cdecl *)(inode *, dentry *, umode_t, bool);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 inode_operations.link int (__cdecl *)(dentry *, inode *, dentry *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 inode_operations.unlink int (__cdecl *)(inode *, dentry *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 inode_operations.symlink int (__cdecl *)(inode *, dentry *, const char *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 inode_operations.mkdir int (__cdecl *)(inode *, dentry *, umode_t);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 inode_operations.rmdir int (__cdecl *)(inode *, dentry *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 inode_operations.mknod int (__cdecl *)(inode *, dentry *, umode_t, dev_t);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 inode_operations.rename int (__cdecl *)(inode *, dentry *, inode *, dentry *, unsigned int);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 inode_operations.setattr int (__cdecl *)(dentry *, iattr *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 inode_operations.getattr int (__cdecl *)(const path *, kstat *, u32, unsigned int);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 inode_operations.listxattr ssize_t (__cdecl *)(dentry *, char *, size_t);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 inode_operations.fiemap int (__cdecl *)(inode *, fiemap_extent_info *, u64, u64);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 inode_operations.update_time int (__cdecl *)(inode *, timespec64 *, int);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 inode_operations.atomic_open int (__cdecl *)(inode *, dentry *, file *, unsigned int, umode_t);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 inode_operations.tmpfile int (__cdecl *)(inode *, dentry *, umode_t);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 inode_operations.set_acl int (__cdecl *)(inode *, posix_acl *, int);
//          00A8 unpadded_size
//          00C0 effalign(64) sda=7 bits=0000 inode_operations struct packalign=0

00000038 struct inodes_stat_t
{
  __int64 nr_inodes;
  __int64 nr_unused;
  __int64 dummy[5];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 inodes_stat_t.nr_inodes __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 inodes_stat_t.nr_unused __int64;
//  2. 0010 0028 effalign(8) fda=0 bits=0000 inodes_stat_t.dummy __int64[5];
//          0038 effalign(8) sda=0 bits=0000 inodes_stat_t struct packalign=0

000000C8 struct input_device_id
{
  kernel_ulong_t flags;
  __u16 bustype;
  __u16 vendor;
  __u16 product;
  __u16 version;
  kernel_ulong_t evbit[1];
  kernel_ulong_t keybit[12];
  kernel_ulong_t relbit[1];
  kernel_ulong_t absbit[1];
  kernel_ulong_t mscbit[1];
  kernel_ulong_t ledbit[1];
  kernel_ulong_t sndbit[1];
  kernel_ulong_t ffbit[2];
  kernel_ulong_t swbit[1];
  kernel_ulong_t propbit[1];
  kernel_ulong_t driver_info;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 input_device_id.flags kernel_ulong_t;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 input_device_id.bustype __u16;
//  2. 000A 0002 effalign(2) fda=0 bits=0000 input_device_id.vendor __u16;
//  3. 000C 0002 effalign(2) fda=0 bits=0000 input_device_id.product __u16;
//  4. 000E 0002 effalign(2) fda=0 bits=0000 input_device_id.version __u16;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 input_device_id.evbit kernel_ulong_t[1];
//  6. 0018 0060 effalign(8) fda=0 bits=0000 input_device_id.keybit kernel_ulong_t[12];
//  7. 0078 0008 effalign(8) fda=0 bits=0000 input_device_id.relbit kernel_ulong_t[1];
//  8. 0080 0008 effalign(8) fda=0 bits=0000 input_device_id.absbit kernel_ulong_t[1];
//  9. 0088 0008 effalign(8) fda=0 bits=0000 input_device_id.mscbit kernel_ulong_t[1];
// 10. 0090 0008 effalign(8) fda=0 bits=0000 input_device_id.ledbit kernel_ulong_t[1];
// 11. 0098 0008 effalign(8) fda=0 bits=0000 input_device_id.sndbit kernel_ulong_t[1];
// 12. 00A0 0010 effalign(8) fda=0 bits=0000 input_device_id.ffbit kernel_ulong_t[2];
// 13. 00B0 0008 effalign(8) fda=0 bits=0000 input_device_id.swbit kernel_ulong_t[1];
// 14. 00B8 0008 effalign(8) fda=0 bits=0000 input_device_id.propbit kernel_ulong_t[1];
// 15. 00C0 0008 effalign(8) fda=0 bits=0000 input_device_id.driver_info kernel_ulong_t;
//          00C8 effalign(8) sda=0 bits=0000 input_device_id struct packalign=0

00000002 typedef s16 int16_t;
00000004 typedef s32 int32_t;
00000008 typedef s64 int64_t;
00000001 typedef s8 int8_t;
FFFFFFFF typedef void __cdecl integrity_complete_fn(request *, unsigned int);
FFFFFFFF typedef void __cdecl integrity_prepare_fn(request *);
FFFFFFFF typedef blk_status_t __cdecl integrity_processing_fn(blk_integrity_iter *);
00000068 struct io_context
{
  atomic_long_t refcount;
  atomic_t active_ref;
  atomic_t nr_tasks;
  spinlock_t lock;
  unsigned __int16 ioprio;
  int nr_batch_requests;
  unsigned __int64 last_waited;
  xarray icq_tree;
  io_cq *icq_hint;
  hlist_head icq_list;
  work_struct release_work;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 io_context.refcount atomic_long_t;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 io_context.active_ref atomic_t;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 io_context.nr_tasks atomic_t;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 io_context.lock spinlock_t;
//  4. 0014 0002 effalign(2) fda=0 bits=0000 io_context.ioprio unsigned __int16;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 io_context.nr_batch_requests int;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 io_context.last_waited unsigned __int64;
//  7. 0028 0010 effalign(8) fda=0 bits=0000 io_context.icq_tree xarray;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 io_context.icq_hint io_cq *;
//  9. 0040 0008 effalign(8) fda=0 bits=0000 io_context.icq_list hlist_head;
// 10. 0048 0020 effalign(8) fda=0 bits=0000 io_context.release_work work_struct;
//          0068 effalign(8) sda=0 bits=0000 io_context struct packalign=0

00000038 struct io_cq
{
  request_queue *q;
  io_context *ioc;
  union
  {
    list_head q_node;
    kmem_cache *__rcu_icq_cache;
  };
  union
  {
    hlist_node ioc_node;
    callback_head __rcu_head;
  };
  unsigned int flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 io_cq.q request_queue *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 io_cq.ioc io_context *;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 io_cq.io_cq::$574A1729B4EDC6A76400EA726B899B10 io_cq::$574A1729B4EDC6A76400EA726B899B10;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 io_cq.io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63 io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 io_cq.flags unsigned int;
//          0034 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 io_cq struct packalign=0

00000010 union io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63
{
  hlist_node ioc_node;
  callback_head __rcu_head;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63.ioc_node hlist_node;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63.__rcu_head callback_head;
//          0010 effalign(8) sda=0 bits=0000 io_cq::$2DA34CC0EC0AEB771E829315D4CE7E63 union packalign=0

00000010 union io_cq::$574A1729B4EDC6A76400EA726B899B10
{
  list_head q_node;
  kmem_cache *__rcu_icq_cache;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 io_cq::$574A1729B4EDC6A76400EA726B899B10.q_node list_head;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 io_cq::$574A1729B4EDC6A76400EA726B899B10.__rcu_icq_cache kmem_cache *;
//          0010 effalign(8) sda=0 bits=0000 io_cq::$574A1729B4EDC6A76400EA726B899B10 union packalign=0

FFFFFFFF struct ioapic_domain_cfg;
00000004 enum ioapic_irq_destination_types : unsigned __int32
{
  dest_Fixed = 0x0,
  dest_LowestPrio = 0x1,
  dest_SMI = 0x2,
  dest__reserved_1 = 0x3,
  dest_NMI = 0x4,
  dest_INIT = 0x5,
  dest__reserved_2 = 0x6,
  dest_ExtINT = 0x7,
};
FFFFFFFF struct iommu_fwspec;
FFFFFFFF struct iommu_group;
FFFFFFFF struct iommu_ops;
FFFFFFFF struct iommu_param;
FFFFFFFF struct iov_iter;
FFFFFFFF struct iovec;
0000000C struct ipack_device_id
{
  __u8 format;
  __u32 vendor;
  __u32 device;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 ipack_device_id.format __u8;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ipack_device_id.vendor __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ipack_device_id.device __u32;
//          000C effalign(4) sda=0 bits=0000 ipack_device_id struct packalign=0

00000030 struct ipc64_perm
{
  __kernel_key_t key;
  __kernel_uid32_t uid;
  __kernel_gid32_t gid;
  __kernel_uid32_t cuid;
  __kernel_gid32_t cgid;
  __kernel_mode_t mode;
  unsigned __int16 seq;
  unsigned __int16 __pad2;
  __kernel_ulong_t __unused1;
  __kernel_ulong_t __unused2;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ipc64_perm.key __kernel_key_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ipc64_perm.uid __kernel_uid32_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ipc64_perm.gid __kernel_gid32_t;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 ipc64_perm.cuid __kernel_uid32_t;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 ipc64_perm.cgid __kernel_gid32_t;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 ipc64_perm.mode __kernel_mode_t;
//  6. 0018 0002 effalign(2) fda=0 bits=0000 ipc64_perm.seq unsigned __int16;
//  7. 001A 0002 effalign(2) fda=0 bits=0000 ipc64_perm.__pad2 unsigned __int16;
//  8. 0020 0008 effalign(8) fda=0 bits=0000 ipc64_perm.__unused1 __kernel_ulong_t;
//  9. 0028 0008 effalign(8) fda=0 bits=0000 ipc64_perm.__unused2 __kernel_ulong_t;
//          0030 effalign(8) sda=0 bits=0000 ipc64_perm struct packalign=0

00000010 struct ipc_kludge
{
  msgbuf *msgp;
  __int64 msgtyp;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 ipc_kludge.msgp msgbuf *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 ipc_kludge.msgtyp __int64;
//          0010 effalign(8) sda=0 bits=0000 ipc_kludge struct packalign=0

0000001C struct ipc_perm
{
  __kernel_key_t key;
  __kernel_uid_t uid;
  __kernel_gid_t gid;
  __kernel_uid_t cuid;
  __kernel_gid_t cgid;
  __kernel_mode_t mode;
  unsigned __int16 seq;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ipc_perm.key __kernel_key_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ipc_perm.uid __kernel_uid_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ipc_perm.gid __kernel_gid_t;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 ipc_perm.cuid __kernel_uid_t;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 ipc_perm.cgid __kernel_gid_t;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 ipc_perm.mode __kernel_mode_t;
//  6. 0018 0002 effalign(2) fda=0 bits=0000 ipc_perm.seq unsigned __int16;
//          001A unpadded_size
//          001C effalign(4) sda=0 bits=0000 ipc_perm struct packalign=0

00000030 struct irq_affinity
{
  unsigned int pre_vectors;
  unsigned int post_vectors;
  unsigned int nr_sets;
  unsigned int set_size[4];
  void (__cdecl *calc_sets)(irq_affinity *, unsigned int);
  void *priv;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 irq_affinity.pre_vectors unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 irq_affinity.post_vectors unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 irq_affinity.nr_sets unsigned int;
//  3. 000C 0010 effalign(4) fda=0 bits=0000 irq_affinity.set_size unsigned int[4];
//  4. 0020 0008 effalign(8) fda=0 bits=0000 irq_affinity.calc_sets void (__cdecl *)(irq_affinity *, unsigned int);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 irq_affinity.priv void *;
//          0030 effalign(8) sda=0 bits=0000 irq_affinity struct packalign=0

00000408 struct irq_affinity_desc
{
  cpumask mask;
  unsigned __int32 is_managed : 1;
};
//  0. 0000 0400 effalign(8) fda=0 bits=0000 irq_affinity_desc.mask cpumask;
//  1. 0400. 0 1 effalign(1) fda=0 bits=0000 irq_affinity_desc.is_managed bi.nbytes=4 U
//          0401 unpadded_size
//          0408 effalign(8) sda=0 bits=0000 irq_affinity_desc struct packalign=0

00000038 struct irq_affinity_notify
{
  unsigned int irq;
  kref kref;
  work_struct work;
  void (__cdecl *notify)(irq_affinity_notify *, const cpumask_t *);
  void (__cdecl *release)(kref *);
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 irq_affinity_notify.irq unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 irq_affinity_notify.kref kref;
//  2. 0008 0020 effalign(8) fda=0 bits=0000 irq_affinity_notify.work work_struct;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 irq_affinity_notify.notify void (__cdecl *)(irq_affinity_notify *, const cpumask_t *);
//  4. 0030 0008 effalign(8) fda=0 bits=0000 irq_affinity_notify.release void (__cdecl *)(kref *);
//          0038 effalign(8) sda=0 bits=0000 irq_affinity_notify struct packalign=0

FFFFFFFF struct irq_alloc_info;
FFFFFFFF struct irq_cfg;
FFFFFFFF struct irq_chip;
00000080 struct __attribute__((aligned(64))) irq_cpustat_t
{
  u16 __softirq_pending;
  u8 kvm_cpu_l1tf_flush_l1d;
  unsigned int __nmi_count;
  unsigned int apic_timer_irqs;
  unsigned int irq_spurious_count;
  unsigned int icr_read_retry_count;
  unsigned int kvm_posted_intr_ipis;
  unsigned int kvm_posted_intr_wakeup_ipis;
  unsigned int kvm_posted_intr_nested_ipis;
  unsigned int x86_platform_ipis;
  unsigned int apic_perf_irqs;
  unsigned int apic_irq_work_irqs;
  unsigned int irq_resched_count;
  unsigned int irq_call_count;
  unsigned int irq_tlb_count;
  unsigned int irq_thermal_count;
  unsigned int irq_threshold_count;
  unsigned int irq_deferred_error_count;
  unsigned int irq_hv_callback_count;
  unsigned int irq_hv_reenlightenment_count;
  unsigned int hyperv_stimer0_count;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 irq_cpustat_t.__softirq_pending u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 irq_cpustat_t.kvm_cpu_l1tf_flush_l1d u8;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.__nmi_count unsigned int;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.apic_timer_irqs unsigned int;
//  4. 000C 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_spurious_count unsigned int;
//  5. 0010 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.icr_read_retry_count unsigned int;
//  6. 0014 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.kvm_posted_intr_ipis unsigned int;
//  7. 0018 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.kvm_posted_intr_wakeup_ipis unsigned int;
//  8. 001C 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.kvm_posted_intr_nested_ipis unsigned int;
//  9. 0020 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.x86_platform_ipis unsigned int;
// 10. 0024 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.apic_perf_irqs unsigned int;
// 11. 0028 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.apic_irq_work_irqs unsigned int;
// 12. 002C 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_resched_count unsigned int;
// 13. 0030 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_call_count unsigned int;
// 14. 0034 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_tlb_count unsigned int;
// 15. 0038 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_thermal_count unsigned int;
// 16. 003C 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_threshold_count unsigned int;
// 17. 0040 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_deferred_error_count unsigned int;
// 18. 0044 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_hv_callback_count unsigned int;
// 19. 0048 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.irq_hv_reenlightenment_count unsigned int;
// 20. 004C 0004 effalign(4) fda=0 bits=0000 irq_cpustat_t.hyperv_stimer0_count unsigned int;
//          0050 unpadded_size
//          0080 effalign(64) sda=7 bits=0000 irq_cpustat_t struct packalign=0

FFFFFFFF struct irq_data;
FFFFFFFF struct irq_desc;
00000090 struct irq_domain
{
  list_head link;
  const char *name;
  const irq_domain_ops *ops;
  void *host_data;
  unsigned int flags;
  unsigned int mapcount;
  fwnode_handle *fwnode;
  irq_domain_bus_token bus_token;
  irq_domain_chip_generic *gc;
  irq_domain *parent;
  irq_hw_number_t hwirq_max;
  unsigned int revmap_direct_max_irq;
  unsigned int revmap_size;
  xarray revmap_tree;
  mutex revmap_tree_mutex;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 irq_domain.link list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 irq_domain.name const char *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 irq_domain.ops const irq_domain_ops *;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 irq_domain.host_data void *;
//  4. 0028 0004 effalign(4) fda=0 bits=0000 irq_domain.flags unsigned int;
//  5. 002C 0004 effalign(4) fda=0 bits=0000 irq_domain.mapcount unsigned int;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 irq_domain.fwnode fwnode_handle *;
//  7. 0038 0004 effalign(4) fda=0 bits=0000 irq_domain.bus_token irq_domain_bus_token;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 irq_domain.gc irq_domain_chip_generic *;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 irq_domain.parent irq_domain *;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 irq_domain.hwirq_max irq_hw_number_t;
// 11. 0058 0004 effalign(4) fda=0 bits=0000 irq_domain.revmap_direct_max_irq unsigned int;
// 12. 005C 0004 effalign(4) fda=0 bits=0000 irq_domain.revmap_size unsigned int;
// 13. 0060 0010 effalign(8) fda=0 bits=0000 irq_domain.revmap_tree xarray;
// 14. 0070 0020 effalign(8) fda=0 bits=0000 irq_domain.revmap_tree_mutex mutex;
//          0090 effalign(8) sda=0 bits=0000 irq_domain struct packalign=0

00000004 enum irq_domain_bus_token : unsigned __int32
{
  DOMAIN_BUS_ANY = 0x0,
  DOMAIN_BUS_WIRED = 0x1,
  DOMAIN_BUS_GENERIC_MSI = 0x2,
  DOMAIN_BUS_PCI_MSI = 0x3,
  DOMAIN_BUS_PLATFORM_MSI = 0x4,
  DOMAIN_BUS_NEXUS = 0x5,
  DOMAIN_BUS_IPI = 0x6,
  DOMAIN_BUS_FSL_MC_MSI = 0x7,
  DOMAIN_BUS_TI_SCI_INTA_MSI = 0x8,
};
FFFFFFFF struct irq_domain_chip_generic;
00000050 struct irq_domain_ops
{
  int (__cdecl *match)(irq_domain *, device_node *, irq_domain_bus_token);
  int (__cdecl *select)(irq_domain *, irq_fwspec *, irq_domain_bus_token);
  int (__cdecl *map)(irq_domain *, unsigned int, irq_hw_number_t);
  void (__cdecl *unmap)(irq_domain *, unsigned int);
  int (__cdecl *xlate)(irq_domain *, device_node *, const u32 *, unsigned int, unsigned __int64 *, unsigned int *);
  int (__cdecl *alloc)(irq_domain *, unsigned int, unsigned int, void *);
  void (__cdecl *free)(irq_domain *, unsigned int, unsigned int);
  int (__cdecl *activate)(irq_domain *, irq_data *, bool);
  void (__cdecl *deactivate)(irq_domain *, irq_data *);
  int (__cdecl *translate)(irq_domain *, irq_fwspec *, unsigned __int64 *, unsigned int *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.match int (__cdecl *)(irq_domain *, device_node *, irq_domain_bus_token);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.select int (__cdecl *)(irq_domain *, irq_fwspec *, irq_domain_bus_token);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.map int (__cdecl *)(irq_domain *, unsigned int, irq_hw_number_t);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.unmap void (__cdecl *)(irq_domain *, unsigned int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.xlate int (__cdecl *)(irq_domain *, device_node *, const u32 *, unsigned int, unsigned __int64 *, unsigned int *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.alloc int (__cdecl *)(irq_domain *, unsigned int, unsigned int, void *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.free void (__cdecl *)(irq_domain *, unsigned int, unsigned int);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.activate int (__cdecl *)(irq_domain *, irq_data *, bool);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.deactivate void (__cdecl *)(irq_domain *, irq_data *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 irq_domain_ops.translate int (__cdecl *)(irq_domain *, irq_fwspec *, unsigned __int64 *, unsigned int *);
//          0050 effalign(8) sda=0 bits=0000 irq_domain_ops struct packalign=0

00000008 typedef void (__cdecl *irq_flow_handler_t)(irq_desc *);
00000050 struct irq_fwspec
{
  fwnode_handle *fwnode;
  int param_count;
  u32 param[16];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 irq_fwspec.fwnode fwnode_handle *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 irq_fwspec.param_count int;
//  2. 000C 0040 effalign(4) fda=0 bits=0000 irq_fwspec.param u32[16];
//          004C unpadded_size
//          0050 effalign(8) sda=0 bits=0000 irq_fwspec struct packalign=0

00000008 typedef irqreturn_t (__cdecl *irq_handler_t)(int, void *);
00000008 typedef unsigned __int64 irq_hw_number_t;
00000008 typedef void (__cdecl *irq_preflow_handler_t)(irq_data *);
00004000 struct __attribute__((aligned(16384))) irq_stack
{
  char stack[16384];
};
//  0. 0000 4000 effalign(1) fda=0 bits=0000 irq_stack.stack char[16384];
//          4000 effalign(16384) sda=15 bits=0000 irq_stack struct packalign=0

00000080 struct __attribute__((aligned(64))) irqaction
{
  irq_handler_t handler;
  void *dev_id;
  void *percpu_dev_id;
  irqaction *next;
  irq_handler_t thread_fn;
  task_struct *thread;
  irqaction *secondary;
  unsigned int irq;
  unsigned int flags;
  unsigned __int64 thread_flags;
  unsigned __int64 thread_mask;
  const char *name;
  proc_dir_entry *dir;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 irqaction.handler irq_handler_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 irqaction.dev_id void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 irqaction.percpu_dev_id void *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 irqaction.next irqaction *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 irqaction.thread_fn irq_handler_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 irqaction.thread task_struct *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 irqaction.secondary irqaction *;
//  7. 0038 0004 effalign(4) fda=0 bits=0000 irqaction.irq unsigned int;
//  8. 003C 0004 effalign(4) fda=0 bits=0000 irqaction.flags unsigned int;
//  9. 0040 0008 effalign(8) fda=0 bits=0000 irqaction.thread_flags unsigned __int64;
// 10. 0048 0008 effalign(8) fda=0 bits=0000 irqaction.thread_mask unsigned __int64;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 irqaction.name const char *;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 irqaction.dir proc_dir_entry *;
//          0060 unpadded_size
//          0080 effalign(64) sda=7 bits=0000 irqaction struct packalign=0

00000004 enum irqchip_irq_state : unsigned __int32
{
  IRQCHIP_STATE_PENDING = 0x0,
  IRQCHIP_STATE_ACTIVE = 0x1,
  IRQCHIP_STATE_MASKED = 0x2,
  IRQCHIP_STATE_LINE_LEVEL = 0x3,
};
00000004 enum irqreturn : unsigned __int32
{
  IRQ_NONE = 0x0,
  IRQ_HANDLED = 0x1,
  IRQ_WAKE_THREAD = 0x2,
};
00000004 typedef irqreturn irqreturn_t;
00000010 struct isapnp_device_id
{
  unsigned __int16 card_vendor;
  unsigned __int16 card_device;
  unsigned __int16 vendor;
  unsigned __int16 function;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 isapnp_device_id.card_vendor unsigned __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 isapnp_device_id.card_device unsigned __int16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 isapnp_device_id.vendor unsigned __int16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 isapnp_device_id.function unsigned __int16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 isapnp_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 isapnp_device_id struct packalign=0

00000004 typedef unsigned int isolate_mode_t;
00000010 struct ist_info
{
  __u32 signature;
  __u32 command;
  __u32 event;
  __u32 perf_level;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ist_info.signature __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ist_info.command __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ist_info.event __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 ist_info.perf_level __u32;
//          0010 effalign(4) sda=0 bits=0000 ist_info struct packalign=0

00000020 struct itimerspec
{
  timespec it_interval;
  timespec it_value;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 itimerspec.it_interval timespec;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 itimerspec.it_value timespec;
//          0020 effalign(8) sda=0 bits=0000 itimerspec struct packalign=0

00000020 struct itimerspec64
{
  timespec64 it_interval;
  timespec64 it_value;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 itimerspec64.it_interval timespec64;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 itimerspec64.it_value timespec64;
//          0020 effalign(8) sda=0 bits=0000 itimerspec64 struct packalign=0

00000020 struct itimerval
{
  timeval it_interval;
  timeval it_value;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 itimerval.it_interval timeval;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 itimerval.it_value timeval;
//          0020 effalign(8) sda=0 bits=0000 itimerval struct packalign=0

00000118 struct __attribute__((packed)) jailhouse_setup_data
{
  __u16 version;
  __u16 compatible_version;
  __u16 pm_timer_address;
  __u16 num_cpus;
  __u64 pci_mmconfig_base;
  __u32 tsc_khz;
  __u32 apic_khz;
  __u8 standard_ioapic;
  __u8 cpu_ids[255];
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 jailhouse_setup_data.version __u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 jailhouse_setup_data.compatible_version __u16;
//  2. 0004 0002 effalign(1) fda=0 bits=0000 jailhouse_setup_data.pm_timer_address __u16;
//  3. 0006 0002 effalign(1) fda=0 bits=0000 jailhouse_setup_data.num_cpus __u16;
//  4. 0008 0008 effalign(1) fda=0 bits=0000 jailhouse_setup_data.pci_mmconfig_base __u64;
//  5. 0010 0004 effalign(1) fda=0 bits=0000 jailhouse_setup_data.tsc_khz __u32;
//  6. 0014 0004 effalign(1) fda=0 bits=0000 jailhouse_setup_data.apic_khz __u32;
//  7. 0018 0001 effalign(1) fda=0 bits=0000 jailhouse_setup_data.standard_ioapic __u8;
//  8. 0019 00FF effalign(1) fda=0 bits=0000 jailhouse_setup_data.cpu_ids __u8[255];
//          0118 effalign(1) sda=0 bits=0040 jailhouse_setup_data struct packalign=0

00000010 struct jump_entry
{
  s32 code;
  s32 target;
  __int64 key;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 jump_entry.code s32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 jump_entry.target s32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 jump_entry.key __int64;
//          0010 effalign(8) sda=0 bits=0000 jump_entry struct packalign=0

00000004 enum jump_label_type : unsigned __int32
{
  JUMP_LABEL_NOP = 0x0,
  JUMP_LABEL_JMP = 0x1,
};
FFFFFFFF struct k_clock;
00000100 struct k_itimer
{
  list_head list;
  hlist_node t_hash;
  spinlock_t it_lock;
  const k_clock *kclock;
  clockid_t it_clock;
  timer_t it_id;
  int it_active;
  s64 it_overrun;
  s64 it_overrun_last;
  int it_requeue_pending;
  int it_sigev_notify;
  ktime_t it_interval;
  signal_struct *it_signal;
  union
  {
    pid *it_pid;
    task_struct *it_process;
  };
  sigqueue *sigq;
  k_itimer::$81CA09A3250EB5499BC293F71D83D440 it;
  callback_head rcu;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 k_itimer.list list_head;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 k_itimer.t_hash hlist_node;
//  2. 0020 0004 effalign(4) fda=0 bits=0000 k_itimer.it_lock spinlock_t;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 k_itimer.kclock const k_clock *;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 k_itimer.it_clock clockid_t;
//  5. 0034 0004 effalign(4) fda=0 bits=0000 k_itimer.it_id timer_t;
//  6. 0038 0004 effalign(4) fda=0 bits=0000 k_itimer.it_active int;
//  7. 0040 0008 effalign(8) fda=0 bits=0000 k_itimer.it_overrun s64;
//  8. 0048 0008 effalign(8) fda=0 bits=0000 k_itimer.it_overrun_last s64;
//  9. 0050 0004 effalign(4) fda=0 bits=0000 k_itimer.it_requeue_pending int;
// 10. 0054 0004 effalign(4) fda=0 bits=0000 k_itimer.it_sigev_notify int;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 k_itimer.it_interval ktime_t;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 k_itimer.it_signal signal_struct *;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 k_itimer.k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 k_itimer.sigq sigqueue *;
// 15. 0078 0078 effalign(8) fda=0 bits=0000 k_itimer.it k_itimer::$81CA09A3250EB5499BC293F71D83D440;
// 16. 00F0 0010 effalign(8) fda=0 bits=0000 k_itimer.rcu callback_head;
//          0100 effalign(8) sda=0 bits=0000 k_itimer struct packalign=0

00000078 union k_itimer::$81CA09A3250EB5499BC293F71D83D440
{
  $AE78027FB145D3BF34A38FAC5A6C0061 real;
  cpu_timer cpu;
  $90254D87D549C40300494CBC395EE945 alarm;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 k_itimer::$81CA09A3250EB5499BC293F71D83D440.real $AE78027FB145D3BF34A38FAC5A6C0061;
//  1. 0000 0048 effalign(8) fda=0 bits=0000 k_itimer::$81CA09A3250EB5499BC293F71D83D440.cpu cpu_timer;
//  2. 0000 0078 effalign(8) fda=0 bits=0000 k_itimer::$81CA09A3250EB5499BC293F71D83D440.alarm $90254D87D549C40300494CBC395EE945;
//          0078 effalign(8) sda=0 bits=0000 k_itimer::$81CA09A3250EB5499BC293F71D83D440 union packalign=0

00000008 union k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B
{
  pid *it_pid;
  task_struct *it_process;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B.it_pid pid *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B.it_process task_struct *;
//          0008 effalign(8) sda=0 bits=0000 k_itimer::$B613E5ACEDE0EA6610EF97BE878BD65B union packalign=0

00000020 struct k_sigaction
{
  sigaction sa;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 k_sigaction.sa sigaction;
//          0020 effalign(8) sda=0 bits=0000 k_sigaction struct packalign=0

00000080 struct __attribute__((aligned(64))) kern_ipc_perm
{
  spinlock_t lock;
  bool deleted;
  int id;
  key_t key;
  kuid_t uid;
  kgid_t gid;
  kuid_t cuid;
  kgid_t cgid;
  umode_t mode;
  unsigned __int64 seq;
  void *security;
  rhash_head khtnode;
  callback_head rcu;
  refcount_t refcount;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.lock spinlock_t;
//  1. 0004 0001 effalign(1) fda=0 bits=0000 kern_ipc_perm.deleted bool;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.id int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.key key_t;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.uid kuid_t;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.gid kgid_t;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.cuid kuid_t;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.cgid kgid_t;
//  8. 0020 0002 effalign(2) fda=0 bits=0000 kern_ipc_perm.mode umode_t;
//  9. 0028 0008 effalign(8) fda=0 bits=0000 kern_ipc_perm.seq unsigned __int64;
// 10. 0030 0008 effalign(8) fda=0 bits=0000 kern_ipc_perm.security void *;
// 11. 0038 0008 effalign(8) fda=0 bits=0000 kern_ipc_perm.khtnode rhash_head;
// 12. 0040 0010 effalign(8) fda=0 bits=0000 kern_ipc_perm.rcu callback_head;
// 13. 0050 0004 effalign(4) fda=0 bits=0000 kern_ipc_perm.refcount refcount_t;
//          0054 unpadded_size
//          0080 effalign(64) sda=7 bits=0000 kern_ipc_perm struct packalign=0

00000008 struct kernel_cap_struct
{
  __u32 cap[2];
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 kernel_cap_struct.cap __u32[2];
//          0008 effalign(4) sda=0 bits=0000 kernel_cap_struct struct packalign=0

00000008 typedef kernel_cap_struct kernel_cap_t;
00000028 struct kernel_param
{
  const char *name;
  module *mod;
  const kernel_param_ops *ops;
  const u16 perm;
  s8 level;
  u8 flags;
  union
  {
    void *arg;
    const kparam_string *str;
    const kparam_array *arr;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernel_param.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernel_param.mod module *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernel_param.ops const kernel_param_ops *;
//  3. 0018 0002 effalign(2) fda=0 bits=0000 kernel_param.perm const u16;
//  4. 001A 0001 effalign(1) fda=0 bits=0000 kernel_param.level s8;
//  5. 001B 0001 effalign(1) fda=0 bits=0000 kernel_param.flags u8;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 kernel_param.kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81 kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81;
//          0028 effalign(8) sda=0 bits=0000 kernel_param struct packalign=0

00000008 union kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81
{
  void *arg;
  const kparam_string *str;
  const kparam_array *arr;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81.arg void *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81.str const kparam_string *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81.arr const kparam_array *;
//          0008 effalign(8) sda=0 bits=0000 kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81 union packalign=0

00000020 struct kernel_param_ops
{
  unsigned int flags;
  int (__cdecl *set)(const char *, const kernel_param *);
  int (__cdecl *get)(char *, const kernel_param *);
  void (__cdecl *free)(void *);
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kernel_param_ops.flags unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernel_param_ops.set int (__cdecl *)(const char *, const kernel_param *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernel_param_ops.get int (__cdecl *)(char *, const kernel_param *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kernel_param_ops.free void (__cdecl *)(void *);
//          0020 effalign(8) sda=0 bits=0000 kernel_param_ops struct packalign=0

00000004 enum kernel_read_file_id : unsigned __int32
{
  READING_UNKNOWN = 0x0,
  READING_FIRMWARE = 0x1,
  READING_FIRMWARE_PREALLOC_BUFFER = 0x2,
  READING_MODULE = 0x3,
  READING_KEXEC_IMAGE = 0x4,
  READING_KEXEC_INITRAMFS = 0x5,
  READING_POLICY = 0x6,
  READING_X509_CERTIFICATE = 0x7,
  READING_MAX_ID = 0x8,
};
00000030 struct kernel_siginfo
{
  struct
  {
    int si_signo;
    int si_errno;
    int si_code;
    __sifields _sifields;
  };
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 kernel_siginfo.kernel_siginfo::$EEA86D27551D0E98B064575E41986325 kernel_siginfo::$EEA86D27551D0E98B064575E41986325;
//          0030 effalign(8) sda=0 bits=0000 kernel_siginfo struct packalign=0

00000030 struct kernel_siginfo::$EEA86D27551D0E98B064575E41986325
{
  int si_signo;
  int si_errno;
  int si_code;
  __sifields _sifields;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kernel_siginfo::$EEA86D27551D0E98B064575E41986325.si_signo int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kernel_siginfo::$EEA86D27551D0E98B064575E41986325.si_errno int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 kernel_siginfo::$EEA86D27551D0E98B064575E41986325.si_code int;
//  3. 0010 0020 effalign(8) fda=0 bits=0000 kernel_siginfo::$EEA86D27551D0E98B064575E41986325._sifields __sifields;
//          0030 effalign(8) sda=0 bits=0000 kernel_siginfo::$EEA86D27551D0E98B064575E41986325 struct packalign=0

00000030 typedef kernel_siginfo kernel_siginfo_t;
0000000C struct kernel_symbol
{
  int value_offset;
  int name_offset;
  int namespace_offset;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kernel_symbol.value_offset int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kernel_symbol.name_offset int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 kernel_symbol.namespace_offset int;
//          000C effalign(4) sda=0 bits=0000 kernel_symbol struct packalign=0

00000008 typedef unsigned __int64 kernel_ulong_t;
00000020 struct kernfs_elem_attr
{
  const kernfs_ops *ops;
  kernfs_open_node *open;
  loff_t size;
  kernfs_node *notify_next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_elem_attr.ops const kernfs_ops *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_elem_attr.open kernfs_open_node *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_elem_attr.size loff_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kernfs_elem_attr.notify_next kernfs_node *;
//          0020 effalign(8) sda=0 bits=0000 kernfs_elem_attr struct packalign=0

00000018 struct kernfs_elem_dir
{
  unsigned __int64 subdirs;
  rb_root children;
  kernfs_root *root;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_elem_dir.subdirs unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_elem_dir.children rb_root;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_elem_dir.root kernfs_root *;
//          0018 effalign(8) sda=0 bits=0000 kernfs_elem_dir struct packalign=0

00000008 struct kernfs_elem_symlink
{
  kernfs_node *target_kn;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_elem_symlink.target_kn kernfs_node *;
//          0008 effalign(8) sda=0 bits=0000 kernfs_elem_symlink struct packalign=0

00000020 struct kernfs_fs_context
{
  kernfs_root *root;
  void *ns_tag;
  unsigned __int64 magic;
  bool new_sb_created;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_fs_context.root kernfs_root *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_fs_context.ns_tag void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_fs_context.magic unsigned __int64;
//  3. 0018 0001 effalign(1) fda=0 bits=0000 kernfs_fs_context.new_sb_created bool;
//          0019 unpadded_size
//          0020 effalign(8) sda=0 bits=0000 kernfs_fs_context struct packalign=0

FFFFFFFF struct kernfs_iattrs;
00000080 struct kernfs_node
{
  atomic_t count;
  atomic_t active;
  kernfs_node *parent;
  const char *name;
  rb_node rb;
  const void *ns;
  unsigned int hash;
  union
  {
    kernfs_elem_dir dir;
    kernfs_elem_symlink symlink;
    kernfs_elem_attr attr;
  };
  void *priv;
  kernfs_node_id id;
  unsigned __int16 flags;
  umode_t mode;
  kernfs_iattrs *iattr;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kernfs_node.count atomic_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kernfs_node.active atomic_t;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_node.parent kernfs_node *;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_node.name const char *;
//  4. 0018 0018 effalign(8) fda=0 bits=0000 kernfs_node.rb rb_node;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 kernfs_node.ns const void *;
//  6. 0038 0004 effalign(4) fda=0 bits=0000 kernfs_node.hash unsigned int;
//  7. 0040 0020 effalign(8) fda=0 bits=0000 kernfs_node.kernfs_node::$8652C698344606644B46A9E29BF98190 kernfs_node::$8652C698344606644B46A9E29BF98190;
//  8. 0060 0008 effalign(8) fda=0 bits=0000 kernfs_node.priv void *;
//  9. 0068 0008 effalign(8) fda=0 bits=0000 kernfs_node.id kernfs_node_id;
// 10. 0070 0002 effalign(2) fda=0 bits=0000 kernfs_node.flags unsigned __int16;
// 11. 0072 0002 effalign(2) fda=0 bits=0000 kernfs_node.mode umode_t;
// 12. 0078 0008 effalign(8) fda=0 bits=0000 kernfs_node.iattr kernfs_iattrs *;
//          0080 effalign(8) sda=0 bits=0000 kernfs_node struct packalign=0

00000020 union kernfs_node::$8652C698344606644B46A9E29BF98190
{
  kernfs_elem_dir dir;
  kernfs_elem_symlink symlink;
  kernfs_elem_attr attr;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 kernfs_node::$8652C698344606644B46A9E29BF98190.dir kernfs_elem_dir;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_node::$8652C698344606644B46A9E29BF98190.symlink kernfs_elem_symlink;
//  2. 0000 0020 effalign(8) fda=0 bits=0000 kernfs_node::$8652C698344606644B46A9E29BF98190.attr kernfs_elem_attr;
//          0020 effalign(8) sda=0 bits=0000 kernfs_node::$8652C698344606644B46A9E29BF98190 union packalign=0

00000004 enum kernfs_node_flag : unsigned __int32
{
  KERNFS_ACTIVATED = 0x10,
  KERNFS_NS = 0x20,
  KERNFS_HAS_SEQ_SHOW = 0x40,
  KERNFS_HAS_MMAP = 0x80,
  KERNFS_LOCKDEP = 0x100,
  KERNFS_SUICIDAL = 0x400,
  KERNFS_SUICIDED = 0x800,
  KERNFS_EMPTY_DIR = 0x1000,
  KERNFS_HAS_RELEASE = 0x2000,
};
00000008 union kernfs_node_id
{
  struct
  {
    u32 ino;
    u32 generation;
  };
  u64 id;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 kernfs_node_id.kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87 kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_node_id.id u64;
//          0008 effalign(8) sda=0 bits=0000 kernfs_node_id union packalign=0

00000008 struct kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87
{
  u32 ino;
  u32 generation;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87.ino u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87.generation u32;
//          0008 effalign(4) sda=0 bits=0000 kernfs_node_id::$EC06E33EB0007DDDFC1C3EA07F339B87 struct packalign=0

00000004 enum kernfs_node_type : unsigned __int32
{
  KERNFS_DIR = 0x1,
  KERNFS_FILE = 0x2,
  KERNFS_LINK = 0x4,
};
00000098 struct kernfs_open_file
{
  kernfs_node *kn;
  file *file;
  seq_file *seq_file;
  void *priv;
  mutex mutex;
  mutex prealloc_mutex;
  int event;
  list_head list;
  char *prealloc_buf;
  size_t atomic_write_len;
  __int8 mmapped : 1;
  __int8 released : 1;
  const vm_operations_struct *vm_ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.kn kernfs_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.file file *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.seq_file seq_file *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.priv void *;
//  4. 0020 0020 effalign(8) fda=0 bits=0000 kernfs_open_file.mutex mutex;
//  5. 0040 0020 effalign(8) fda=0 bits=0000 kernfs_open_file.prealloc_mutex mutex;
//  6. 0060 0004 effalign(4) fda=0 bits=0000 kernfs_open_file.event int;
//  7. 0068 0010 effalign(8) fda=0 bits=0000 kernfs_open_file.list list_head;
//  8. 0078 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.prealloc_buf char *;
//  9. 0080 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.atomic_write_len size_t;
// 10. 0088. 0 1 effalign(1) fda=0 bits=0000 kernfs_open_file.mmapped bi.nbytes=1 S
// 11. 0088. 1 1 effalign(1) fda=0 bits=0000 kernfs_open_file.released bi.nbytes=1 S
// 12. 0090 0008 effalign(8) fda=0 bits=0000 kernfs_open_file.vm_ops const vm_operations_struct *;
//          0098 effalign(8) sda=0 bits=0000 kernfs_open_file struct packalign=0

FFFFFFFF struct kernfs_open_node;
00000060 struct kernfs_ops
{
  int (__cdecl *open)(kernfs_open_file *);
  void (__cdecl *release)(kernfs_open_file *);
  int (__cdecl *seq_show)(seq_file *, void *);
  void *(__cdecl *seq_start)(seq_file *, loff_t *);
  void *(__cdecl *seq_next)(seq_file *, void *, loff_t *);
  void (__cdecl *seq_stop)(seq_file *, void *);
  ssize_t (__cdecl *read)(kernfs_open_file *, char *, size_t, loff_t);
  size_t atomic_write_len;
  bool prealloc;
  ssize_t (__cdecl *write)(kernfs_open_file *, char *, size_t, loff_t);
  __poll_t (__cdecl *poll)(kernfs_open_file *, poll_table_struct *);
  int (__cdecl *mmap)(kernfs_open_file *, vm_area_struct *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_ops.open int (__cdecl *)(kernfs_open_file *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_ops.release void (__cdecl *)(kernfs_open_file *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_ops.seq_show int (__cdecl *)(seq_file *, void *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kernfs_ops.seq_start void *(__cdecl *)(seq_file *, loff_t *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 kernfs_ops.seq_next void *(__cdecl *)(seq_file *, void *, loff_t *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 kernfs_ops.seq_stop void (__cdecl *)(seq_file *, void *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 kernfs_ops.read ssize_t (__cdecl *)(kernfs_open_file *, char *, size_t, loff_t);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 kernfs_ops.atomic_write_len size_t;
//  8. 0040 0001 effalign(1) fda=0 bits=0000 kernfs_ops.prealloc bool;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 kernfs_ops.write ssize_t (__cdecl *)(kernfs_open_file *, char *, size_t, loff_t);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 kernfs_ops.poll __poll_t (__cdecl *)(kernfs_open_file *, poll_table_struct *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 kernfs_ops.mmap int (__cdecl *)(kernfs_open_file *, vm_area_struct *);
//          0060 effalign(8) sda=0 bits=0000 kernfs_ops struct packalign=0

00000060 struct kernfs_root
{
  kernfs_node *kn;
  unsigned int flags;
  idr ino_idr;
  u32 last_ino;
  u32 next_generation;
  kernfs_syscall_ops *syscall_ops;
  list_head supers;
  wait_queue_head_t deactivate_waitq;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_root.kn kernfs_node *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 kernfs_root.flags unsigned int;
//  2. 0010 0018 effalign(8) fda=0 bits=0000 kernfs_root.ino_idr idr;
//  3. 0028 0004 effalign(4) fda=0 bits=0000 kernfs_root.last_ino u32;
//  4. 002C 0004 effalign(4) fda=0 bits=0000 kernfs_root.next_generation u32;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 kernfs_root.syscall_ops kernfs_syscall_ops *;
//  6. 0038 0010 effalign(8) fda=0 bits=0000 kernfs_root.supers list_head;
//  7. 0048 0018 effalign(8) fda=0 bits=0000 kernfs_root.deactivate_waitq wait_queue_head_t;
//          0060 effalign(8) sda=0 bits=0000 kernfs_root struct packalign=0

00000004 enum kernfs_root_flag : unsigned __int32
{
  KERNFS_ROOT_CREATE_DEACTIVATED = 0x1,
  KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 0x2,
  KERNFS_ROOT_SUPPORT_EXPORTOP = 0x4,
};
00000028 struct kernfs_syscall_ops
{
  int (__cdecl *show_options)(seq_file *, kernfs_root *);
  int (__cdecl *mkdir)(kernfs_node *, const char *, umode_t);
  int (__cdecl *rmdir)(kernfs_node *);
  int (__cdecl *rename)(kernfs_node *, kernfs_node *, const char *);
  int (__cdecl *show_path)(seq_file *, kernfs_node *, kernfs_root *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kernfs_syscall_ops.show_options int (__cdecl *)(seq_file *, kernfs_root *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kernfs_syscall_ops.mkdir int (__cdecl *)(kernfs_node *, const char *, umode_t);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kernfs_syscall_ops.rmdir int (__cdecl *)(kernfs_node *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kernfs_syscall_ops.rename int (__cdecl *)(kernfs_node *, kernfs_node *, const char *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 kernfs_syscall_ops.show_path int (__cdecl *)(seq_file *, kernfs_node *, kernfs_root *);
//          0028 effalign(8) sda=0 bits=0000 kernfs_syscall_ops struct packalign=0

000000D8 struct key
{
  refcount_t usage;
  key_serial_t serial;
  union
  {
    list_head graveyard_link;
    rb_node serial_node;
  };
  rw_semaphore sem;
  key_user *user;
  void *security;
  union
  {
    time64_t expiry;
    time64_t revoked_at;
  };
  time64_t last_used_at;
  kuid_t uid;
  kgid_t gid;
  key_perm_t perm;
  unsigned __int16 quotalen;
  unsigned __int16 datalen;
  __int16 state;
  unsigned __int64 flags;
  union
  {
    keyring_index_key index_key;
    struct
    {
      unsigned __int64 hash;
      unsigned __int64 len_desc;
      key_type *type;
      key_tag *domain_tag;
      char *description;
    };
  };
  union
  {
    key_payload payload;
    struct
    {
      list_head name_link;
      assoc_array keys;
    };
  };
  key_restriction *restrict_link;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 key.usage refcount_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 key.serial key_serial_t;
//  2. 0008 0018 effalign(8) fda=0 bits=0000 key.key::$8F7DEF0814BC0067EA29EA16A4BB90EB key::$8F7DEF0814BC0067EA29EA16A4BB90EB;
//  3. 0020 0028 effalign(8) fda=0 bits=0000 key.sem rw_semaphore;
//  4. 0048 0008 effalign(8) fda=0 bits=0000 key.user key_user *;
//  5. 0050 0008 effalign(8) fda=0 bits=0000 key.security void *;
//  6. 0058 0008 effalign(8) fda=0 bits=0000 key.key::$CB8326B98FDB687CEA85A91DCC1D2AE3 key::$CB8326B98FDB687CEA85A91DCC1D2AE3;
//  7. 0060 0008 effalign(8) fda=0 bits=0000 key.last_used_at time64_t;
//  8. 0068 0004 effalign(4) fda=0 bits=0000 key.uid kuid_t;
//  9. 006C 0004 effalign(4) fda=0 bits=0000 key.gid kgid_t;
// 10. 0070 0004 effalign(4) fda=0 bits=0000 key.perm key_perm_t;
// 11. 0074 0002 effalign(2) fda=0 bits=0000 key.quotalen unsigned __int16;
// 12. 0076 0002 effalign(2) fda=0 bits=0000 key.datalen unsigned __int16;
// 13. 0078 0002 effalign(2) fda=0 bits=0000 key.state __int16;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 key.flags unsigned __int64;
// 15. 0088 0028 effalign(8) fda=0 bits=0000 key.key::$8E5EA9613D2826F39E0CEA02CC0FB02A key::$8E5EA9613D2826F39E0CEA02CC0FB02A;
// 16. 00B0 0020 effalign(8) fda=0 bits=0000 key.key::$2CAB72B9F0B627252D8A6A5C2B7259E2 key::$2CAB72B9F0B627252D8A6A5C2B7259E2;
// 17. 00D0 0008 effalign(8) fda=0 bits=0000 key.restrict_link key_restriction *;
//          00D8 effalign(8) sda=0 bits=0000 key struct packalign=0

00000020 union key::$2CAB72B9F0B627252D8A6A5C2B7259E2
{
  key_payload payload;
  struct
  {
    list_head name_link;
    assoc_array keys;
  };
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 key::$2CAB72B9F0B627252D8A6A5C2B7259E2.payload key_payload;
//  1. 0000 0020 effalign(8) fda=0 bits=0000 key::$2CAB72B9F0B627252D8A6A5C2B7259E2.$FA1F96C4209A82444F7F77101C731C3B $FA1F96C4209A82444F7F77101C731C3B;
//          0020 effalign(8) sda=0 bits=0000 key::$2CAB72B9F0B627252D8A6A5C2B7259E2 union packalign=0

00000028 union key::$8E5EA9613D2826F39E0CEA02CC0FB02A
{
  keyring_index_key index_key;
  struct
  {
    unsigned __int64 hash;
    unsigned __int64 len_desc;
    key_type *type;
    key_tag *domain_tag;
    char *description;
  };
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 key::$8E5EA9613D2826F39E0CEA02CC0FB02A.index_key keyring_index_key;
//  1. 0000 0028 effalign(8) fda=0 bits=0000 key::$8E5EA9613D2826F39E0CEA02CC0FB02A.$E3857CE99C57F8B5022B9A513C27E905 $E3857CE99C57F8B5022B9A513C27E905;
//          0028 effalign(8) sda=0 bits=0000 key::$8E5EA9613D2826F39E0CEA02CC0FB02A union packalign=0

00000018 union key::$8F7DEF0814BC0067EA29EA16A4BB90EB
{
  list_head graveyard_link;
  rb_node serial_node;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 key::$8F7DEF0814BC0067EA29EA16A4BB90EB.graveyard_link list_head;
//  1. 0000 0018 effalign(8) fda=0 bits=0000 key::$8F7DEF0814BC0067EA29EA16A4BB90EB.serial_node rb_node;
//          0018 effalign(8) sda=0 bits=0000 key::$8F7DEF0814BC0067EA29EA16A4BB90EB union packalign=0

00000008 union key::$CB8326B98FDB687CEA85A91DCC1D2AE3
{
  time64_t expiry;
  time64_t revoked_at;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 key::$CB8326B98FDB687CEA85A91DCC1D2AE3.expiry time64_t;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 key::$CB8326B98FDB687CEA85A91DCC1D2AE3.revoked_at time64_t;
//          0008 effalign(8) sda=0 bits=0000 key::$CB8326B98FDB687CEA85A91DCC1D2AE3 union packalign=0

FFFFFFFF struct key_owner;
00000020 union key_payload
{
  void *rcu_data0;
  void *data[4];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 key_payload.rcu_data0 void *;
//  1. 0000 0020 effalign(8) fda=0 bits=0000 key_payload.data void *[4];
//          0020 effalign(8) sda=0 bits=0000 key_payload union packalign=0

00000004 typedef uint32_t key_perm_t;
00000008 typedef __key_reference_with_attributes *key_ref_t;
00000008 typedef int (__cdecl *key_restrict_link_func_t)(key *, const key_type *, const key_payload *, key *);
00000018 struct key_restriction
{
  key_restrict_link_func_t check;
  key *key;
  key_type *keytype;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 key_restriction.check key_restrict_link_func_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 key_restriction.key key *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 key_restriction.keytype key_type *;
//          0018 effalign(8) sda=0 bits=0000 key_restriction struct packalign=0

00000004 typedef int32_t key_serial_t;
00000004 enum key_state : unsigned __int32
{
  KEY_IS_UNINSTANTIATED = 0x0,
  KEY_IS_POSITIVE = 0x1,
};
00000004 typedef __kernel_key_t key_t;
00000018 struct key_tag
{
  callback_head rcu;
  refcount_t usage;
  bool removed;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 key_tag.rcu callback_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 key_tag.usage refcount_t;
//  2. 0014 0001 effalign(1) fda=0 bits=0000 key_tag.removed bool;
//          0015 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 key_tag struct packalign=0

FFFFFFFF struct key_type;
FFFFFFFF struct key_user;
00000028 struct keyring_index_key
{
  unsigned __int64 hash;
  union
  {
    struct
    {
      u16 desc_len;
      char desc[6];
    };
    unsigned __int64 x;
  };
  key_type *type;
  key_tag *domain_tag;
  const char *description;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 keyring_index_key.hash unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 keyring_index_key.keyring_index_key::$0F9699168777590BB5C2575CB56628B5 keyring_index_key::$0F9699168777590BB5C2575CB56628B5;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 keyring_index_key.type key_type *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 keyring_index_key.domain_tag key_tag *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 keyring_index_key.description const char *;
//          0028 effalign(8) sda=0 bits=0000 keyring_index_key struct packalign=0

00000008 union keyring_index_key::$0F9699168777590BB5C2575CB56628B5
{
  struct
  {
    u16 desc_len;
    char desc[6];
  };
  unsigned __int64 x;
};
//  0. 0000 0008 effalign(2) fda=0 bits=0000 keyring_index_key::$0F9699168777590BB5C2575CB56628B5.$99E1C31D7C026F6F12847AB310A0B651 $99E1C31D7C026F6F12847AB310A0B651;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 keyring_index_key::$0F9699168777590BB5C2575CB56628B5.x unsigned __int64;
//          0008 effalign(8) sda=0 bits=0000 keyring_index_key::$0F9699168777590BB5C2575CB56628B5 union packalign=0

FFFFFFFF struct keyring_list;
FFFFFFFF struct keyring_name;
00000004 struct kgid_t
{
  gid_t val;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kgid_t.val gid_t;
//          0004 effalign(4) sda=0 bits=0000 kgid_t struct packalign=0

00000030 struct kiocb
{
  file *ki_filp;
  loff_t ki_pos;
  void (__cdecl *ki_complete)(kiocb *, __int64, __int64);
  void *private;
  int ki_flags;
  u16 ki_hint;
  u16 ki_ioprio;
  unsigned int ki_cookie;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kiocb.ki_filp file *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kiocb.ki_pos loff_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kiocb.ki_complete void (__cdecl *)(kiocb *, __int64, __int64);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kiocb.private void *;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 kiocb.ki_flags int;
//  5. 0024 0002 effalign(2) fda=0 bits=0000 kiocb.ki_hint u16;
//  6. 0026 0002 effalign(2) fda=0 bits=0000 kiocb.ki_ioprio u16;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 kiocb.ki_cookie unsigned int;
//          002C unpadded_size
//          0030 effalign(8) sda=0 bits=0000 kiocb struct packalign=0

FFFFFFFF struct kioctx_table;
00000028 struct __attribute__((aligned(8))) klist
{
  spinlock_t k_lock;
  list_head k_list;
  void (__cdecl *get)(klist_node *);
  void (__cdecl *put)(klist_node *);
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 klist.k_lock spinlock_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 klist.k_list list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 klist.get void (__cdecl *)(klist_node *);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 klist.put void (__cdecl *)(klist_node *);
//          0028 effalign(8) sda=4 bits=0000 klist struct packalign=0

00000010 struct klist_iter
{
  klist *i_klist;
  klist_node *i_cur;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 klist_iter.i_klist klist *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 klist_iter.i_cur klist_node *;
//          0010 effalign(8) sda=0 bits=0000 klist_iter struct packalign=0

00000020 struct klist_node
{
  void *n_klist;
  list_head n_node;
  kref n_ref;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 klist_node.n_klist void *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 klist_node.n_node list_head;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 klist_node.n_ref kref;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 klist_node struct packalign=0

00000058 struct klp_modinfo
{
  Elf64_Ehdr hdr;
  Elf64_Shdr *sechdrs;
  char *secstrings;
  unsigned int symndx;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 klp_modinfo.hdr Elf64_Ehdr;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 klp_modinfo.sechdrs Elf64_Shdr *;
//  2. 0048 0008 effalign(8) fda=0 bits=0000 klp_modinfo.secstrings char *;
//  3. 0050 0004 effalign(4) fda=0 bits=0000 klp_modinfo.symndx unsigned int;
//          0054 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 klp_modinfo struct packalign=0

00000004 enum kmalloc_cache_type : unsigned __int32
{
  KMALLOC_NORMAL = 0x0,
  KMALLOC_RECLAIM = 0x1,
  KMALLOC_DMA = 0x2,
  NR_KMALLOC_TYPES = 0x3,
};
FFFFFFFF struct kmem_cache;
00000004 enum kmsg_dump_reason : unsigned __int32
{
  KMSG_DUMP_UNDEF = 0x0,
  KMSG_DUMP_PANIC = 0x1,
  KMSG_DUMP_OOPS = 0x2,
  KMSG_DUMP_EMERG = 0x3,
  KMSG_DUMP_RESTART = 0x4,
  KMSG_DUMP_HALT = 0x5,
  KMSG_DUMP_POWEROFF = 0x6,
};
00000038 struct kmsg_dumper
{
  list_head list;
  void (__cdecl *dump)(kmsg_dumper *, kmsg_dump_reason);
  kmsg_dump_reason max_reason;
  bool active;
  bool registered;
  u32 cur_idx;
  u32 next_idx;
  u64 cur_seq;
  u64 next_seq;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 kmsg_dumper.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 kmsg_dumper.dump void (__cdecl *)(kmsg_dumper *, kmsg_dump_reason);
//  2. 0018 0004 effalign(4) fda=0 bits=0000 kmsg_dumper.max_reason kmsg_dump_reason;
//  3. 001C 0001 effalign(1) fda=0 bits=0000 kmsg_dumper.active bool;
//  4. 001D 0001 effalign(1) fda=0 bits=0000 kmsg_dumper.registered bool;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 kmsg_dumper.cur_idx u32;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 kmsg_dumper.next_idx u32;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 kmsg_dumper.cur_seq u64;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 kmsg_dumper.next_seq u64;
//          0038 effalign(8) sda=0 bits=0000 kmsg_dumper struct packalign=0

00000020 struct kobj_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(kobject *, kobj_attribute *, char *);
  ssize_t (__cdecl *store)(kobject *, kobj_attribute *, const char *, size_t);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 kobj_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 kobj_attribute.show ssize_t (__cdecl *)(kobject *, kobj_attribute *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 kobj_attribute.store ssize_t (__cdecl *)(kobject *, kobj_attribute *, const char *, size_t);
//          0020 effalign(8) sda=0 bits=0000 kobj_attribute struct packalign=0

00000004 enum kobj_ns_type : unsigned __int32
{
  KOBJ_NS_TYPE_NONE = 0x0,
  KOBJ_NS_TYPE_NET = 0x1,
  KOBJ_NS_TYPES = 0x2,
};
00000030 struct kobj_ns_type_operations
{
  kobj_ns_type type;
  bool (*current_may_mount)(void);
  void *(*grab_current_ns)(void);
  const void *(__cdecl *netlink_ns)(sock *);
  const void *(*initial_ns)(void);
  void (__cdecl *drop_ns)(void *);
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kobj_ns_type_operations.type kobj_ns_type;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kobj_ns_type_operations.current_may_mount bool (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kobj_ns_type_operations.grab_current_ns void *(*)(void);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kobj_ns_type_operations.netlink_ns const void *(__cdecl *)(sock *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 kobj_ns_type_operations.initial_ns const void *(*)(void);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 kobj_ns_type_operations.drop_ns void (__cdecl *)(void *);
//          0030 effalign(8) sda=0 bits=0000 kobj_ns_type_operations struct packalign=0

00000038 struct kobj_type
{
  void (__cdecl *release)(kobject *);
  const sysfs_ops *sysfs_ops;
  attribute **default_attrs;
  const attribute_group **default_groups;
  const kobj_ns_type_operations *(__cdecl *child_ns_type)(kobject *);
  const void *(__cdecl *namespace)(kobject *);
  void (__cdecl *get_ownership)(kobject *, kuid_t *, kgid_t *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kobj_type.release void (__cdecl *)(kobject *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kobj_type.sysfs_ops const sysfs_ops *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kobj_type.default_attrs attribute **;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 kobj_type.default_groups const attribute_group **;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 kobj_type.child_ns_type const kobj_ns_type_operations *(__cdecl *)(kobject *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 kobj_type.namespace const void *(__cdecl *)(kobject *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 kobj_type.get_ownership void (__cdecl *)(kobject *, kuid_t *, kgid_t *);
//          0038 effalign(8) sda=0 bits=0000 kobj_type struct packalign=0

00000920 struct kobj_uevent_env
{
  char *argv[3];
  char *envp[32];
  int envp_idx;
  char buf[2048];
  int buflen;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 kobj_uevent_env.argv char *[3];
//  1. 0018 0100 effalign(8) fda=0 bits=0000 kobj_uevent_env.envp char *[32];
//  2. 0118 0004 effalign(4) fda=0 bits=0000 kobj_uevent_env.envp_idx int;
//  3. 011C 0800 effalign(1) fda=0 bits=0000 kobj_uevent_env.buf char[2048];
//  4. 091C 0004 effalign(4) fda=0 bits=0000 kobj_uevent_env.buflen int;
//          0920 effalign(8) sda=0 bits=0000 kobj_uevent_env struct packalign=0

00000040 struct kobject
{
  const char *name;
  list_head entry;
  kobject *parent;
  kset *kset;
  kobj_type *ktype;
  kernfs_node *sd;
  kref kref;
  unsigned __int32 state_initialized : 1;
  unsigned __int32 state_in_sysfs : 1;
  unsigned __int32 state_add_uevent_sent : 1;
  unsigned __int32 state_remove_uevent_sent : 1;
  unsigned __int32 uevent_suppress : 1;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kobject.name const char *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 kobject.entry list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 kobject.parent kobject *;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 kobject.kset kset *;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 kobject.ktype kobj_type *;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 kobject.sd kernfs_node *;
//  6. 0038 0004 effalign(4) fda=0 bits=0000 kobject.kref kref;
//  7. 003C. 0 1 effalign(1) fda=0 bits=0000 kobject.state_initialized bi.nbytes=4 U
//  8. 003C. 1 1 effalign(1) fda=0 bits=0000 kobject.state_in_sysfs bi.nbytes=4 U
//  9. 003C. 2 1 effalign(1) fda=0 bits=0000 kobject.state_add_uevent_sent bi.nbytes=4 U
// 10. 003C. 3 1 effalign(1) fda=0 bits=0000 kobject.state_remove_uevent_sent bi.nbytes=4 U
// 11. 003C. 4 1 effalign(1) fda=0 bits=0000 kobject.uevent_suppress bi.nbytes=4 U
//          003D unpadded_size
//          0040 effalign(8) sda=0 bits=0000 kobject struct packalign=0

00000004 enum kobject_action : unsigned __int32
{
  KOBJ_ADD = 0x0,
  KOBJ_REMOVE = 0x1,
  KOBJ_CHANGE = 0x2,
  KOBJ_MOVE = 0x3,
  KOBJ_ONLINE = 0x4,
  KOBJ_OFFLINE = 0x5,
  KOBJ_BIND = 0x6,
  KOBJ_UNBIND = 0x7,
  KOBJ_MAX = 0x8,
};
00000020 struct kparam_array
{
  unsigned int max;
  unsigned int elemsize;
  unsigned int *num;
  const kernel_param_ops *ops;
  void *elem;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kparam_array.max unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kparam_array.elemsize unsigned int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 kparam_array.num unsigned int *;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 kparam_array.ops const kernel_param_ops *;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 kparam_array.elem void *;
//          0020 effalign(8) sda=0 bits=0000 kparam_array struct packalign=0

00000010 struct kparam_string
{
  unsigned int maxlen;
  char *string;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kparam_string.maxlen unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kparam_string.string char *;
//          0010 effalign(8) sda=0 bits=0000 kparam_string struct packalign=0

00000004 struct kprojid_t
{
  projid_t val;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kprojid_t.val projid_t;
//          0004 effalign(4) sda=0 bits=0000 kprojid_t struct packalign=0

00000008 struct kqid
{
  union
  {
    kuid_t uid;
    kgid_t gid;
    kprojid_t projid;
  };
  quota_type type;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kqid.kqid::$8A7A73CA27554BDDE75B0D5A35B43C30 kqid::$8A7A73CA27554BDDE75B0D5A35B43C30;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 kqid.type quota_type;
//          0008 effalign(4) sda=0 bits=0000 kqid struct packalign=0

00000004 union kqid::$8A7A73CA27554BDDE75B0D5A35B43C30
{
  kuid_t uid;
  kgid_t gid;
  kprojid_t projid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kqid::$8A7A73CA27554BDDE75B0D5A35B43C30.uid kuid_t;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 kqid::$8A7A73CA27554BDDE75B0D5A35B43C30.gid kgid_t;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 kqid::$8A7A73CA27554BDDE75B0D5A35B43C30.projid kprojid_t;
//          0004 effalign(4) sda=0 bits=0000 kqid::$8A7A73CA27554BDDE75B0D5A35B43C30 union packalign=0

00000004 struct kref
{
  refcount_t refcount;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kref.refcount refcount_t;
//          0004 effalign(4) sda=0 bits=0000 kref struct packalign=0

00000060 struct kset
{
  list_head list;
  spinlock_t list_lock;
  kobject kobj;
  const kset_uevent_ops *uevent_ops;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 kset.list list_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 kset.list_lock spinlock_t;
//  2. 0018 0040 effalign(8) fda=0 bits=0000 kset.kobj kobject;
//  3. 0058 0008 effalign(8) fda=0 bits=0000 kset.uevent_ops const kset_uevent_ops *;
//          0060 effalign(8) sda=0 bits=0000 kset struct packalign=0

00000018 struct kset_uevent_ops
{
  int (__cdecl *const filter)(kset *, kobject *);
  const char *(__cdecl *const name)(kset *, kobject *);
  int (__cdecl *const uevent)(kset *, kobject *, kobj_uevent_env *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 kset_uevent_ops.filter int (__cdecl *const)(kset *, kobject *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 kset_uevent_ops.name const char *(__cdecl *const)(kset *, kobject *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 kset_uevent_ops.uevent int (__cdecl *const)(kset *, kobject *, kobj_uevent_env *);
//          0018 effalign(8) sda=0 bits=0000 kset_uevent_ops struct packalign=0

00000058 struct ksignal
{
  k_sigaction ka;
  kernel_siginfo_t info;
  int sig;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 ksignal.ka k_sigaction;
//  1. 0020 0030 effalign(8) fda=0 bits=0000 ksignal.info kernel_siginfo_t;
//  2. 0050 0004 effalign(4) fda=0 bits=0000 ksignal.sig int;
//          0054 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 ksignal struct packalign=0

00000088 struct kstat
{
  u32 result_mask;
  umode_t mode;
  unsigned int nlink;
  uint32_t blksize;
  u64 attributes;
  u64 attributes_mask;
  u64 ino;
  dev_t dev;
  dev_t rdev;
  kuid_t uid;
  kgid_t gid;
  loff_t size;
  timespec64 atime;
  timespec64 mtime;
  timespec64 ctime;
  timespec64 btime;
  u64 blocks;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kstat.result_mask u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 kstat.mode umode_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 kstat.nlink unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 kstat.blksize uint32_t;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 kstat.attributes u64;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 kstat.attributes_mask u64;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 kstat.ino u64;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 kstat.dev dev_t;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 kstat.rdev dev_t;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 kstat.uid kuid_t;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 kstat.gid kgid_t;
// 11. 0038 0008 effalign(8) fda=0 bits=0000 kstat.size loff_t;
// 12. 0040 0010 effalign(8) fda=0 bits=0000 kstat.atime timespec64;
// 13. 0050 0010 effalign(8) fda=0 bits=0000 kstat.mtime timespec64;
// 14. 0060 0010 effalign(8) fda=0 bits=0000 kstat.ctime timespec64;
// 15. 0070 0010 effalign(8) fda=0 bits=0000 kstat.btime timespec64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 kstat.blocks u64;
//          0088 effalign(8) sda=0 bits=0000 kstat struct packalign=0

FFFFFFFF struct kstatfs;
00000008 typedef s64 ktime_t;
00000004 struct kuid_t
{
  uid_t val;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 kuid_t.val uid_t;
//          0004 effalign(4) sda=0 bits=0000 kuid_t struct packalign=0

FFFFFFFF struct kvec;
00000004 enum l1tf_mitigations : unsigned __int32
{
  L1TF_MITIGATION_OFF = 0x0,
  L1TF_MITIGATION_FLUSH_NOWARN = 0x1,
  L1TF_MITIGATION_FLUSH = 0x2,
  L1TF_MITIGATION_FLUSH_NOSMT = 0x3,
  L1TF_MITIGATION_FULL = 0x4,
  L1TF_MITIGATION_FULL_FORCE = 0x5,
};
00000030 struct latch_tree_node
{
  rb_node node[2];
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 latch_tree_node.node rb_node[2];
//          0030 effalign(8) sda=0 bits=0000 latch_tree_node struct packalign=0

00000010 struct latch_tree_ops
{
  bool (__cdecl *less)(latch_tree_node *, latch_tree_node *);
  int (__cdecl *comp)(void *, latch_tree_node *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 latch_tree_ops.less bool (__cdecl *)(latch_tree_node *, latch_tree_node *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 latch_tree_ops.comp int (__cdecl *)(void *, latch_tree_node *);
//          0010 effalign(8) sda=0 bits=0000 latch_tree_ops struct packalign=0

00000018 struct latch_tree_root
{
  seqcount_t seq;
  rb_root tree[2];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 latch_tree_root.seq seqcount_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 latch_tree_root.tree rb_root[2];
//          0018 effalign(8) sda=0 bits=0000 latch_tree_root struct packalign=0

00000010 typedef ldttss_desc ldt_desc;
FFFFFFFF struct ldt_struct;
00000010 struct __attribute__((packed)) ldttss_desc
{
  u16 limit0;
  u16 base0;
  unsigned __int16 base1 : 8;
  unsigned __int16 type : 5;
  unsigned __int16 dpl : 2;
  unsigned __int16 p : 1;
  unsigned __int16 limit1 : 4;
  unsigned __int16 zero0 : 3;
  unsigned __int16 g : 1;
  unsigned __int16 base2 : 8;
  u32 base3;
  u32 zero1;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 ldttss_desc.limit0 u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 ldttss_desc.base0 u16;
//  2. 0004. 0 8 effalign(1) fda=0 bits=0000 ldttss_desc.base1 bi.nbytes=2 U
//  3. 0004. 8 5 effalign(1) fda=0 bits=0000 ldttss_desc.type bi.nbytes=2 U
//  4. 0004.13 2 effalign(1) fda=0 bits=0000 ldttss_desc.dpl bi.nbytes=2 U
//  5. 0004.15 1 effalign(1) fda=0 bits=0000 ldttss_desc.p bi.nbytes=2 U
//  6. 0006. 0 4 effalign(1) fda=0 bits=0000 ldttss_desc.limit1 bi.nbytes=2 U
//  7. 0006. 4 3 effalign(1) fda=0 bits=0000 ldttss_desc.zero0 bi.nbytes=2 U
//  8. 0006. 7 1 effalign(1) fda=0 bits=0000 ldttss_desc.g bi.nbytes=2 U
//  9. 0006. 8 8 effalign(1) fda=0 bits=0000 ldttss_desc.base2 bi.nbytes=2 U
// 10. 0008 0004 effalign(1) fda=0 bits=0000 ldttss_desc.base3 u32;
// 11. 000C 0004 effalign(1) fda=0 bits=0000 ldttss_desc.zero1 u32;
//          0010 effalign(1) sda=0 bits=0040 ldttss_desc struct packalign=0

FFFFFFFF struct linux_binfmt;
FFFFFFFF struct linux_binprm;
00000010 struct linux_efi_memreserve
{
  int size;
  atomic_t count;
  phys_addr_t next;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 linux_efi_memreserve.size int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 linux_efi_memreserve.count atomic_t;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 linux_efi_memreserve.next phys_addr_t;
//          0010 effalign(8) sda=0 bits=0000 linux_efi_memreserve struct packalign=0

00000004 struct linux_efi_random_seed
{
  u32 size;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 linux_efi_random_seed.size u32;
//          0004 effalign(4) sda=0 bits=0000 linux_efi_random_seed struct packalign=0

0000000C struct linux_efi_tpm_eventlog
{
  u32 size;
  u32 final_events_preboot_size;
  u8 version;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 linux_efi_tpm_eventlog.size u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 linux_efi_tpm_eventlog.final_events_preboot_size u32;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 linux_efi_tpm_eventlog.version u8;
//          0009 unpadded_size
//          000C effalign(4) sda=0 bits=0000 linux_efi_tpm_eventlog struct packalign=0

00000010 struct list_head
{
  list_head *next;
  list_head *prev;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 list_head.next list_head *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 list_head.prev list_head *;
//          0010 effalign(8) sda=0 bits=0000 list_head struct packalign=0

00000020 struct list_lru
{
  list_lru_node *node;
  list_head list;
  int shrinker_id;
  bool memcg_aware;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 list_lru.node list_lru_node *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 list_lru.list list_head;
//  2. 0018 0004 effalign(4) fda=0 bits=0000 list_lru.shrinker_id int;
//  3. 001C 0001 effalign(1) fda=0 bits=0000 list_lru.memcg_aware bool;
//          001D unpadded_size
//          0020 effalign(8) sda=0 bits=0000 list_lru struct packalign=0

00000010 struct list_lru_memcg
{
  callback_head rcu;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 list_lru_memcg.rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 list_lru_memcg struct packalign=0

00000040 struct __attribute__((aligned(64))) list_lru_node
{
  spinlock_t lock;
  list_lru_one lru;
  list_lru_memcg *memcg_lrus;
  __int64 nr_items;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 list_lru_node.lock spinlock_t;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 list_lru_node.lru list_lru_one;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 list_lru_node.memcg_lrus list_lru_memcg *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 list_lru_node.nr_items __int64;
//          0030 unpadded_size
//          0040 effalign(64) sda=7 bits=0000 list_lru_node struct packalign=0

00000018 struct list_lru_one
{
  list_head list;
  __int64 nr_items;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 list_lru_one.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 list_lru_one.nr_items __int64;
//          0018 effalign(8) sda=0 bits=0000 list_lru_one struct packalign=0

00000008 typedef lru_status (__cdecl *list_lru_walk_cb)(list_head *, list_lru_one *, spinlock_t *, void *);
00000008 struct llist_head
{
  llist_node *first;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 llist_head.first llist_node *;
//          0008 effalign(8) sda=0 bits=0000 llist_head struct packalign=0

00000008 struct llist_node
{
  llist_node *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 llist_node.next llist_node *;
//          0008 effalign(8) sda=0 bits=0000 llist_node struct packalign=0

00000010 struct load_weight
{
  unsigned __int64 weight;
  u32 inv_weight;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 load_weight.weight unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 load_weight.inv_weight u32;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 load_weight struct packalign=0

00000400 struct __attribute__((packed)) local_apic
{
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_01;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_02;
  local_apic::$EDA24887A0DF77AA41A6B912C496289A id;
  const local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621 version;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_03;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_04;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_05;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_06;
  local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA tpr;
  const local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA apr;
  const local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA ppr;
  local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A eoi;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_07;
  local_apic::$897DE8D11BB2631B3B00B00548D4CF5D ldr;
  local_apic::$29934A6B2E92861F495CEBE0696E1BBC dfr;
  local_apic::$077D929E5E4293C60A781F5DD0C29CCD svr;
  local_apic::$4649F766394E1B5E1F77BDFC2DE86307 isr[8];
  local_apic::$4649F766394E1B5E1F77BDFC2DE86307 tmr[8];
  local_apic::$4649F766394E1B5E1F77BDFC2DE86307 irr[8];
  local_apic::$AE3AE65A153ADE7924DE2A8661E629BF esr;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_08;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_09;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_10;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_11;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_12;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_13;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_14;
  local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF icr1;
  local_apic::$DD7A426F03DF46114F75DEA1D384BF57 icr2;
  local_apic::$237711FDBFDCD36CD7CD8565B97F59A5 lvt_timer;
  local_apic::$3FB4519274FB635E28016307EBCDF087 lvt_thermal;
  local_apic::$3FB4519274FB635E28016307EBCDF087 lvt_pc;
  local_apic::$54E7D9C9118EA7C6BCFB657E433517AA lvt_lint0;
  local_apic::$54E7D9C9118EA7C6BCFB657E433517AA lvt_lint1;
  local_apic::$30BE5C14BBF840CE56CFDB9604D466E2 lvt_error;
  local_apic::$0308F1A5221887187BAC405D4A6C56A7 timer_icr;
  const local_apic::$9049B34A9DDBF1867B175091C435BED8 timer_ccr;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_16;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_17;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_18;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_19;
  local_apic::$3D0E5B57180747F8F65B3369211A9315 timer_dcr;
  local_apic::$A53F371A9244043C4970755026866F90 __reserved_20;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_01 local_apic::$A53F371A9244043C4970755026866F90;
//  1. 0010 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_02 local_apic::$A53F371A9244043C4970755026866F90;
//  2. 0020 0010 effalign(1) fda=0 bits=0000 local_apic.id local_apic::$EDA24887A0DF77AA41A6B912C496289A;
//  3. 0030 0010 effalign(1) fda=0 bits=0000 local_apic.version const local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621;
//  4. 0040 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_03 local_apic::$A53F371A9244043C4970755026866F90;
//  5. 0050 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_04 local_apic::$A53F371A9244043C4970755026866F90;
//  6. 0060 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_05 local_apic::$A53F371A9244043C4970755026866F90;
//  7. 0070 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_06 local_apic::$A53F371A9244043C4970755026866F90;
//  8. 0080 0010 effalign(1) fda=0 bits=0000 local_apic.tpr local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA;
//  9. 0090 0010 effalign(1) fda=0 bits=0000 local_apic.apr const local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA;
// 10. 00A0 0010 effalign(1) fda=0 bits=0000 local_apic.ppr const local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA;
// 11. 00B0 0010 effalign(1) fda=0 bits=0000 local_apic.eoi local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A;
// 12. 00C0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_07 local_apic::$A53F371A9244043C4970755026866F90;
// 13. 00D0 0010 effalign(1) fda=0 bits=0000 local_apic.ldr local_apic::$897DE8D11BB2631B3B00B00548D4CF5D;
// 14. 00E0 0010 effalign(1) fda=0 bits=0000 local_apic.dfr local_apic::$29934A6B2E92861F495CEBE0696E1BBC;
// 15. 00F0 0010 effalign(1) fda=0 bits=0000 local_apic.svr local_apic::$077D929E5E4293C60A781F5DD0C29CCD;
// 16. 0100 0080 effalign(1) fda=0 bits=0000 local_apic.isr local_apic::$4649F766394E1B5E1F77BDFC2DE86307[8];
// 17. 0180 0080 effalign(1) fda=0 bits=0000 local_apic.tmr local_apic::$4649F766394E1B5E1F77BDFC2DE86307[8];
// 18. 0200 0080 effalign(1) fda=0 bits=0000 local_apic.irr local_apic::$4649F766394E1B5E1F77BDFC2DE86307[8];
// 19. 0280 0010 effalign(1) fda=0 bits=0000 local_apic.esr local_apic::$AE3AE65A153ADE7924DE2A8661E629BF;
// 20. 0290 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_08 local_apic::$A53F371A9244043C4970755026866F90;
// 21. 02A0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_09 local_apic::$A53F371A9244043C4970755026866F90;
// 22. 02B0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_10 local_apic::$A53F371A9244043C4970755026866F90;
// 23. 02C0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_11 local_apic::$A53F371A9244043C4970755026866F90;
// 24. 02D0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_12 local_apic::$A53F371A9244043C4970755026866F90;
// 25. 02E0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_13 local_apic::$A53F371A9244043C4970755026866F90;
// 26. 02F0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_14 local_apic::$A53F371A9244043C4970755026866F90;
// 27. 0300 0010 effalign(1) fda=0 bits=0000 local_apic.icr1 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF;
// 28. 0310 0010 effalign(1) fda=0 bits=0000 local_apic.icr2 local_apic::$DD7A426F03DF46114F75DEA1D384BF57;
// 29. 0320 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_timer local_apic::$237711FDBFDCD36CD7CD8565B97F59A5;
// 30. 0330 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_thermal local_apic::$3FB4519274FB635E28016307EBCDF087;
// 31. 0340 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_pc local_apic::$3FB4519274FB635E28016307EBCDF087;
// 32. 0350 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_lint0 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA;
// 33. 0360 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_lint1 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA;
// 34. 0370 0010 effalign(1) fda=0 bits=0000 local_apic.lvt_error local_apic::$30BE5C14BBF840CE56CFDB9604D466E2;
// 35. 0380 0010 effalign(1) fda=0 bits=0000 local_apic.timer_icr local_apic::$0308F1A5221887187BAC405D4A6C56A7;
// 36. 0390 0010 effalign(1) fda=0 bits=0000 local_apic.timer_ccr const local_apic::$9049B34A9DDBF1867B175091C435BED8;
// 37. 03A0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_16 local_apic::$A53F371A9244043C4970755026866F90;
// 38. 03B0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_17 local_apic::$A53F371A9244043C4970755026866F90;
// 39. 03C0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_18 local_apic::$A53F371A9244043C4970755026866F90;
// 40. 03D0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_19 local_apic::$A53F371A9244043C4970755026866F90;
// 41. 03E0 0010 effalign(1) fda=0 bits=0000 local_apic.timer_dcr local_apic::$3D0E5B57180747F8F65B3369211A9315;
// 42. 03F0 0010 effalign(1) fda=0 bits=0000 local_apic.__reserved_20 local_apic::$A53F371A9244043C4970755026866F90;
//          0400 effalign(1) sda=0 bits=0040 local_apic struct packalign=0

00000010 struct local_apic::$0308F1A5221887187BAC405D4A6C56A7
{
  unsigned int initial_count;
  unsigned int __reserved_2[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 local_apic::$0308F1A5221887187BAC405D4A6C56A7.initial_count unsigned int;
//  1. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$0308F1A5221887187BAC405D4A6C56A7.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$0308F1A5221887187BAC405D4A6C56A7 struct packalign=0

00000010 struct local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A
{
  unsigned int eoi;
  unsigned int __reserved[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A.eoi unsigned int;
//  1. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A.__reserved unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$068E57DE6F52FAF84EC6AD7226FF9C5A struct packalign=0

00000010 struct local_apic::$077D929E5E4293C60A781F5DD0C29CCD
{
  unsigned __int32 spurious_vector : 8;
  unsigned __int32 apic_enabled : 1;
  unsigned __int32 focus_cpu : 1;
  unsigned __int32 __reserved_2 : 22;
  unsigned int __reserved_3[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD.spurious_vector bi.nbytes=4 U
//  1. 0000. 8 1 effalign(1) fda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD.apic_enabled bi.nbytes=4 U
//  2. 0000. 9 1 effalign(1) fda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD.focus_cpu bi.nbytes=4 U
//  3. 0000.10 22 effalign(1) fda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD.__reserved_2 bi.nbytes=4 U
//  4. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD.__reserved_3 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$077D929E5E4293C60A781F5DD0C29CCD struct packalign=0

00000010 struct local_apic::$237711FDBFDCD36CD7CD8565B97F59A5
{
  unsigned __int32 vector : 8;
  unsigned __int32 __reserved_1 : 4;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 __reserved_2 : 3;
  unsigned __int32 mask : 1;
  unsigned __int32 timer_mode : 1;
  unsigned __int32 __reserved_3 : 14;
  unsigned int __reserved_4[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.vector bi.nbytes=4 U
//  1. 0000. 8 4 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.__reserved_1 bi.nbytes=4 U
//  2. 0000.12 1 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.delivery_status bi.nbytes=4 U
//  3. 0000.13 3 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.__reserved_2 bi.nbytes=4 U
//  4. 0000.16 1 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.mask bi.nbytes=4 U
//  5. 0000.17 1 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.timer_mode bi.nbytes=4 U
//  6. 0000.18 14 effalign(1) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.__reserved_3 bi.nbytes=4 U
//  7. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5.__reserved_4 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$237711FDBFDCD36CD7CD8565B97F59A5 struct packalign=0

00000010 struct local_apic::$29934A6B2E92861F495CEBE0696E1BBC
{
  unsigned __int32 __reserved_1 : 28;
  unsigned __int32 model : 4;
  unsigned int __reserved_2[3];
};
//  0. 0000. 0 28 effalign(4) fda=0 bits=0000 local_apic::$29934A6B2E92861F495CEBE0696E1BBC.__reserved_1 bi.nbytes=4 U
//  1. 0000.28 4 effalign(4) fda=0 bits=0000 local_apic::$29934A6B2E92861F495CEBE0696E1BBC.model bi.nbytes=4 U
//  2. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$29934A6B2E92861F495CEBE0696E1BBC.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$29934A6B2E92861F495CEBE0696E1BBC struct packalign=0

00000010 struct local_apic::$30BE5C14BBF840CE56CFDB9604D466E2
{
  unsigned __int32 vector : 8;
  unsigned __int32 __reserved_1 : 4;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 __reserved_2 : 3;
  unsigned __int32 mask : 1;
  unsigned __int32 __reserved_3 : 15;
  unsigned int __reserved_4[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.vector bi.nbytes=4 U
//  1. 0000. 8 4 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.__reserved_1 bi.nbytes=4 U
//  2. 0000.12 1 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.delivery_status bi.nbytes=4 U
//  3. 0000.13 3 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.__reserved_2 bi.nbytes=4 U
//  4. 0000.16 1 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.mask bi.nbytes=4 U
//  5. 0000.17 15 effalign(1) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.__reserved_3 bi.nbytes=4 U
//  6. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2.__reserved_4 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$30BE5C14BBF840CE56CFDB9604D466E2 struct packalign=0

00000010 struct local_apic::$3D0E5B57180747F8F65B3369211A9315
{
  unsigned __int32 divisor : 4;
  unsigned __int32 __reserved_1 : 28;
  unsigned int __reserved_2[3];
};
//  0. 0000. 0 4 effalign(1) fda=0 bits=0000 local_apic::$3D0E5B57180747F8F65B3369211A9315.divisor bi.nbytes=4 U
//  1. 0000. 4 28 effalign(1) fda=0 bits=0000 local_apic::$3D0E5B57180747F8F65B3369211A9315.__reserved_1 bi.nbytes=4 U
//  2. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$3D0E5B57180747F8F65B3369211A9315.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$3D0E5B57180747F8F65B3369211A9315 struct packalign=0

00000010 struct local_apic::$3FB4519274FB635E28016307EBCDF087
{
  unsigned __int32 vector : 8;
  unsigned __int32 delivery_mode : 3;
  unsigned __int32 __reserved_1 : 1;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 __reserved_2 : 3;
  unsigned __int32 mask : 1;
  unsigned __int32 __reserved_3 : 15;
  unsigned int __reserved_4[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.vector bi.nbytes=4 U
//  1. 0000. 8 3 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.delivery_mode bi.nbytes=4 U
//  2. 0000.11 1 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.__reserved_1 bi.nbytes=4 U
//  3. 0000.12 1 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.delivery_status bi.nbytes=4 U
//  4. 0000.13 3 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.__reserved_2 bi.nbytes=4 U
//  5. 0000.16 1 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.mask bi.nbytes=4 U
//  6. 0000.17 15 effalign(1) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.__reserved_3 bi.nbytes=4 U
//  7. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087.__reserved_4 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$3FB4519274FB635E28016307EBCDF087 struct packalign=0

00000010 struct local_apic::$4649F766394E1B5E1F77BDFC2DE86307
{
  unsigned int bitfield;
  unsigned int __reserved[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 local_apic::$4649F766394E1B5E1F77BDFC2DE86307.bitfield unsigned int;
//  1. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$4649F766394E1B5E1F77BDFC2DE86307.__reserved unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$4649F766394E1B5E1F77BDFC2DE86307 struct packalign=0

00000010 struct local_apic::$54E7D9C9118EA7C6BCFB657E433517AA
{
  unsigned __int32 vector : 8;
  unsigned __int32 delivery_mode : 3;
  unsigned __int32 __reserved_1 : 1;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 polarity : 1;
  unsigned __int32 remote_irr : 1;
  unsigned __int32 trigger : 1;
  unsigned __int32 mask : 1;
  unsigned __int32 __reserved_2 : 15;
  unsigned int __reserved_3[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.vector bi.nbytes=4 U
//  1. 0000. 8 3 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.delivery_mode bi.nbytes=4 U
//  2. 0000.11 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.__reserved_1 bi.nbytes=4 U
//  3. 0000.12 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.delivery_status bi.nbytes=4 U
//  4. 0000.13 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.polarity bi.nbytes=4 U
//  5. 0000.14 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.remote_irr bi.nbytes=4 U
//  6. 0000.15 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.trigger bi.nbytes=4 U
//  7. 0000.16 1 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.mask bi.nbytes=4 U
//  8. 0000.17 15 effalign(1) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.__reserved_2 bi.nbytes=4 U
//  9. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA.__reserved_3 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$54E7D9C9118EA7C6BCFB657E433517AA struct packalign=0

00000010 struct local_apic::$897DE8D11BB2631B3B00B00548D4CF5D
{
  unsigned __int32 __reserved_1 : 24;
  unsigned __int32 logical_dest : 8;
  unsigned int __reserved_2[3];
};
//  0. 0000. 0 24 effalign(4) fda=0 bits=0000 local_apic::$897DE8D11BB2631B3B00B00548D4CF5D.__reserved_1 bi.nbytes=4 U
//  1. 0000.24 8 effalign(4) fda=0 bits=0000 local_apic::$897DE8D11BB2631B3B00B00548D4CF5D.logical_dest bi.nbytes=4 U
//  2. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$897DE8D11BB2631B3B00B00548D4CF5D.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$897DE8D11BB2631B3B00B00548D4CF5D struct packalign=0

00000010 struct local_apic::$9049B34A9DDBF1867B175091C435BED8
{
  unsigned int curr_count;
  unsigned int __reserved_2[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 local_apic::$9049B34A9DDBF1867B175091C435BED8.curr_count unsigned int;
//  1. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$9049B34A9DDBF1867B175091C435BED8.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$9049B34A9DDBF1867B175091C435BED8 struct packalign=0

00000010 struct local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA
{
  unsigned __int32 priority : 8;
  unsigned __int32 __reserved_1 : 24;
  unsigned int __reserved_2[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA.priority bi.nbytes=4 U
//  1. 0000. 8 24 effalign(1) fda=0 bits=0000 local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA.__reserved_1 bi.nbytes=4 U
//  2. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA.__reserved_2 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$9A57F9AD1A7D89EA93C9BC4DA9DAFCEA struct packalign=0

00000010 struct local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF
{
  unsigned __int32 vector : 8;
  unsigned __int32 delivery_mode : 3;
  unsigned __int32 destination_mode : 1;
  unsigned __int32 delivery_status : 1;
  unsigned __int32 __reserved_1 : 1;
  unsigned __int32 level : 1;
  unsigned __int32 trigger : 1;
  unsigned __int32 __reserved_2 : 2;
  unsigned __int32 shorthand : 2;
  unsigned __int32 __reserved_3 : 12;
  unsigned int __reserved_4[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.vector bi.nbytes=4 U
//  1. 0000. 8 3 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.delivery_mode bi.nbytes=4 U
//  2. 0000.11 1 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.destination_mode bi.nbytes=4 U
//  3. 0000.12 1 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.delivery_status bi.nbytes=4 U
//  4. 0000.13 1 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.__reserved_1 bi.nbytes=4 U
//  5. 0000.14 1 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.level bi.nbytes=4 U
//  6. 0000.15 1 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.trigger bi.nbytes=4 U
//  7. 0000.16 2 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.__reserved_2 bi.nbytes=4 U
//  8. 0000.18 2 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.shorthand bi.nbytes=4 U
//  9. 0000.20 12 effalign(1) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.__reserved_3 bi.nbytes=4 U
// 10. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF.__reserved_4 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$9DD3BCF7F9CE458F6A8B24B5C1650DBF struct packalign=0

00000010 struct local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621
{
  unsigned __int32 version : 8;
  unsigned __int32 __reserved_1 : 8;
  unsigned __int32 max_lvt : 8;
  unsigned __int32 __reserved_2 : 8;
  unsigned int __reserved[3];
};
//  0. 0000. 0 8 effalign(1) fda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621.version bi.nbytes=4 U
//  1. 0000. 8 8 effalign(1) fda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621.__reserved_1 bi.nbytes=4 U
//  2. 0000.16 8 effalign(1) fda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621.max_lvt bi.nbytes=4 U
//  3. 0000.24 8 effalign(1) fda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621.__reserved_2 bi.nbytes=4 U
//  4. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621.__reserved unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$A096BFDCFC8E93D85AB7AF27FCDCC621 struct packalign=0

00000010 struct local_apic::$A53F371A9244043C4970755026866F90
{
  unsigned int __reserved[4];
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 local_apic::$A53F371A9244043C4970755026866F90.__reserved unsigned int[4];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$A53F371A9244043C4970755026866F90 struct packalign=0

00000010 union local_apic::$AE3AE65A153ADE7924DE2A8661E629BF
{
  $FE522FAF5CB4CC13731D513BC018CDE7 error_bits;
  $B0040E8A9BB1B2883A6D5C53D1E7371A all_errors;
};
//  0. 0000 0010 effalign(4) fda=0 bits=0000 local_apic::$AE3AE65A153ADE7924DE2A8661E629BF.error_bits $FE522FAF5CB4CC13731D513BC018CDE7;
//  1. 0000 0010 effalign(4) fda=0 bits=0000 local_apic::$AE3AE65A153ADE7924DE2A8661E629BF.all_errors $B0040E8A9BB1B2883A6D5C53D1E7371A;
//          0010 effalign(4) sda=0 bits=0000 local_apic::$AE3AE65A153ADE7924DE2A8661E629BF union packalign=0

00000010 struct local_apic::$DD7A426F03DF46114F75DEA1D384BF57
{
  $0AB7F792334A5D00E72DC46855D66EE8 dest;
  unsigned int __reserved_4[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 local_apic::$DD7A426F03DF46114F75DEA1D384BF57.dest $0AB7F792334A5D00E72DC46855D66EE8;
//  1. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$DD7A426F03DF46114F75DEA1D384BF57.__reserved_4 unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$DD7A426F03DF46114F75DEA1D384BF57 struct packalign=0

00000010 struct local_apic::$EDA24887A0DF77AA41A6B912C496289A
{
  unsigned __int32 __reserved_1 : 24;
  unsigned __int32 phys_apic_id : 4;
  unsigned __int32 __reserved_2 : 4;
  unsigned int __reserved[3];
};
//  0. 0000. 0 24 effalign(4) fda=0 bits=0000 local_apic::$EDA24887A0DF77AA41A6B912C496289A.__reserved_1 bi.nbytes=4 U
//  1. 0000.24 4 effalign(4) fda=0 bits=0000 local_apic::$EDA24887A0DF77AA41A6B912C496289A.phys_apic_id bi.nbytes=4 U
//  2. 0000.28 4 effalign(4) fda=0 bits=0000 local_apic::$EDA24887A0DF77AA41A6B912C496289A.__reserved_2 bi.nbytes=4 U
//  3. 0004 000C effalign(4) fda=0 bits=0000 local_apic::$EDA24887A0DF77AA41A6B912C496289A.__reserved unsigned int[3];
//          0010 effalign(4) sda=0 bits=0000 local_apic::$EDA24887A0DF77AA41A6B912C496289A struct packalign=0

00000008 struct local_t
{
  atomic_long_t a;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 local_t.a atomic_long_t;
//          0008 effalign(8) sda=0 bits=0000 local_t struct packalign=0

00000000 struct lock_class_key
{
};
//          0000 effalign(1) sda=0 bits=0000 lock_class_key struct packalign=0

00000018 struct lock_manager
{
  list_head list;
  bool block_opens;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 lock_manager.list list_head;
//  1. 0010 0001 effalign(1) fda=0 bits=0000 lock_manager.block_opens bool;
//          0011 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 lock_manager struct packalign=0

00000038 struct lock_manager_operations
{
  fl_owner_t (__cdecl *lm_get_owner)(fl_owner_t);
  void (__cdecl *lm_put_owner)(fl_owner_t);
  void (__cdecl *lm_notify)(file_lock *);
  int (__cdecl *lm_grant)(file_lock *, int);
  bool (__cdecl *lm_break)(file_lock *);
  int (__cdecl *lm_change)(file_lock *, int, list_head *);
  void (__cdecl *lm_setup)(file_lock *, void **);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_get_owner fl_owner_t (__cdecl *)(fl_owner_t);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_put_owner void (__cdecl *)(fl_owner_t);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_notify void (__cdecl *)(file_lock *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_grant int (__cdecl *)(file_lock *, int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_break bool (__cdecl *)(file_lock *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_change int (__cdecl *)(file_lock *, int, list_head *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 lock_manager_operations.lm_setup void (__cdecl *)(file_lock *, void **);
//          0038 effalign(8) sda=0 bits=0000 lock_manager_operations struct packalign=0

00000000 struct lockdep_map
{
};
//          0000 effalign(1) sda=0 bits=0000 lockdep_map struct packalign=0

00000004 enum lockdep_ok : unsigned __int32
{
  LOCKDEP_STILL_OK = 0x0,
  LOCKDEP_NOW_UNRELIABLE = 0x1,
};
00000008 struct lockref
{
  union
  {
    __attribute__((aligned(8))) __u64 lock_count;
    struct
    {
      spinlock_t lock;
      int count;
    };
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 lockref.lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C;
//          0008 effalign(8) sda=0 bits=0000 lockref struct packalign=0

00000008 union lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C
{
  __attribute__((aligned(8))) __u64 lock_count;
  struct
  {
    spinlock_t lock;
    int count;
  };
};
//  0. 0000 0008 effalign(8) fda=4 bits=0000 lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C.lock_count __u64;
//  1. 0000 0008 effalign(4) fda=0 bits=0000 lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C.$AEEEF0908C303B51493A2C30B2CD252A $AEEEF0908C303B51493A2C30B2CD252A;
//          0008 effalign(8) sda=0 bits=0000 lockref::$4FD2FD6CD2BEAF15A27FC62B7E0F0C5C union packalign=0

00000008 typedef __kernel_loff_t loff_t;
00000020 struct logic_pio_host_ops
{
  u32 (__cdecl *in)(void *, unsigned __int64, size_t);
  void (__cdecl *out)(void *, unsigned __int64, u32, size_t);
  u32 (__cdecl *ins)(void *, unsigned __int64, void *, size_t, unsigned int);
  void (__cdecl *outs)(void *, unsigned __int64, const void *, size_t, unsigned int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 logic_pio_host_ops.in u32 (__cdecl *)(void *, unsigned __int64, size_t);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 logic_pio_host_ops.out void (__cdecl *)(void *, unsigned __int64, u32, size_t);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 logic_pio_host_ops.ins u32 (__cdecl *)(void *, unsigned __int64, void *, size_t, unsigned int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 logic_pio_host_ops.outs void (__cdecl *)(void *, unsigned __int64, const void *, size_t, unsigned int);
//          0020 effalign(8) sda=0 bits=0000 logic_pio_host_ops struct packalign=0

00000048 struct logic_pio_hwaddr
{
  list_head list;
  fwnode_handle *fwnode;
  resource_size_t hw_start;
  resource_size_t io_start;
  resource_size_t size;
  unsigned __int64 flags;
  void *hostdata;
  const logic_pio_host_ops *ops;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.fwnode fwnode_handle *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.hw_start resource_size_t;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.io_start resource_size_t;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.size resource_size_t;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.flags unsigned __int64;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.hostdata void *;
//  7. 0040 0008 effalign(8) fda=0 bits=0000 logic_pio_hwaddr.ops const logic_pio_host_ops *;
//          0048 effalign(8) sda=0 bits=0000 logic_pio_hwaddr struct packalign=0

00000004 enum lru_list : unsigned __int32
{
  LRU_INACTIVE_ANON = 0x0,
  LRU_ACTIVE_ANON = 0x1,
  LRU_INACTIVE_FILE = 0x2,
  LRU_ACTIVE_FILE = 0x3,
  LRU_UNEVICTABLE = 0x4,
  NR_LRU_LISTS = 0x5,
};
00000004 enum lru_status : unsigned __int32
{
  LRU_REMOVED = 0x0,
  LRU_REMOVED_RETRY = 0x1,
  LRU_ROTATE = 0x2,
  LRU_SKIP = 0x3,
  LRU_RETRY = 0x4,
};
00000088 struct lruvec
{
  list_head lists[5];
  zone_reclaim_stat reclaim_stat;
  atomic_long_t inactive_age;
  unsigned __int64 refaults;
  pglist_data *pgdat;
};
//  0. 0000 0050 effalign(8) fda=0 bits=0000 lruvec.lists list_head[5];
//  1. 0050 0020 effalign(8) fda=0 bits=0000 lruvec.reclaim_stat zone_reclaim_stat;
//  2. 0070 0008 effalign(8) fda=0 bits=0000 lruvec.inactive_age atomic_long_t;
//  3. 0078 0008 effalign(8) fda=0 bits=0000 lruvec.refaults unsigned __int64;
//  4. 0080 0008 effalign(8) fda=0 bits=0000 lruvec.pgdat pglist_data *;
//          0088 effalign(8) sda=0 bits=0000 lruvec struct packalign=0

FFFFFFFF typedef blk_qc_t __cdecl make_request_fn(request_queue *, bio *);
00000004 enum mapping_flags : unsigned __int32
{
  AS_EIO = 0x0,
  AS_ENOSPC = 0x1,
  AS_MM_ALL_LOCKS = 0x2,
  AS_UNEVICTABLE = 0x3,
  AS_EXITING = 0x4,
  AS_NO_WRITEBACK_TAGS = 0x5,
};
00000010 struct math_emu_info
{
  __int64 ___orig_eip;
  pt_regs *regs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 math_emu_info.___orig_eip __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 math_emu_info.regs pt_regs *;
//          0010 effalign(8) sda=0 bits=0000 math_emu_info struct packalign=0

00000010 struct mcb_device_id
{
  __u16 device;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 mcb_device_id.device __u16;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mcb_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 mcb_device_id struct packalign=0

00000008 struct mdio_device_id
{
  __u32 phy_id;
  __u32 phy_id_mask;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 mdio_device_id.phy_id __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 mdio_device_id.phy_id_mask __u32;
//          0008 effalign(4) sda=0 bits=0000 mdio_device_id struct packalign=0

00000004 enum mds_mitigations : unsigned __int32
{
  MDS_MITIGATION_OFF = 0x0,
  MDS_MITIGATION_FULL = 0x1,
  MDS_MITIGATION_VMWERV = 0x2,
};
00000040 struct mei_cl_device_id
{
  char name[32];
  uuid_le uuid;
  __u8 version;
  kernel_ulong_t driver_info;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 mei_cl_device_id.name char[32];
//  1. 0020 0010 effalign(1) fda=0 bits=0000 mei_cl_device_id.uuid uuid_le;
//  2. 0030 0001 effalign(1) fda=0 bits=0000 mei_cl_device_id.version __u8;
//  3. 0038 0008 effalign(8) fda=0 bits=0000 mei_cl_device_id.driver_info kernel_ulong_t;
//          0040 effalign(8) sda=0 bits=0000 mei_cl_device_id struct packalign=0

FFFFFFFF struct mem_cgroup;
00000048 struct mem_dqblk
{
  qsize_t dqb_bhardlimit;
  qsize_t dqb_bsoftlimit;
  qsize_t dqb_curspace;
  qsize_t dqb_rsvspace;
  qsize_t dqb_ihardlimit;
  qsize_t dqb_isoftlimit;
  qsize_t dqb_curinodes;
  time64_t dqb_btime;
  time64_t dqb_itime;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_bhardlimit qsize_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_bsoftlimit qsize_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_curspace qsize_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_rsvspace qsize_t;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_ihardlimit qsize_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_isoftlimit qsize_t;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_curinodes qsize_t;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_btime time64_t;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 mem_dqblk.dqb_itime time64_t;
//          0048 effalign(8) sda=0 bits=0000 mem_dqblk struct packalign=0

00000048 struct mem_dqinfo
{
  quota_format_type *dqi_format;
  int dqi_fmt_id;
  list_head dqi_dirty_list;
  unsigned __int64 dqi_flags;
  unsigned int dqi_bgrace;
  unsigned int dqi_igrace;
  qsize_t dqi_max_spc_limit;
  qsize_t dqi_max_ino_limit;
  void *dqi_priv;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_format quota_format_type *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 mem_dqinfo.dqi_fmt_id int;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_dirty_list list_head;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_flags unsigned __int64;
//  4. 0028 0004 effalign(4) fda=0 bits=0000 mem_dqinfo.dqi_bgrace unsigned int;
//  5. 002C 0004 effalign(4) fda=0 bits=0000 mem_dqinfo.dqi_igrace unsigned int;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_max_spc_limit qsize_t;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_max_ino_limit qsize_t;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 mem_dqinfo.dqi_priv void *;
//          0048 effalign(8) sda=0 bits=0000 mem_dqinfo struct packalign=0

00000010 struct mem_section
{
  unsigned __int64 section_mem_map;
  mem_section_usage *usage;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mem_section.section_mem_map unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mem_section.usage mem_section_usage *;
//          0010 effalign(8) sda=0 bits=0000 mem_section struct packalign=0

00000008 struct mem_section_usage
{
  unsigned __int64 subsection_map[1];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mem_section_usage.subsection_map unsigned __int64[1];
//          0008 effalign(8) sda=0 bits=0000 mem_section_usage struct packalign=0

00000004 enum meminit_context : unsigned __int32
{
  MEMINIT_EARLY = 0x0,
  MEMINIT_HOTPLUG = 0x1,
};
FFFFFFFF struct memory_block;
00000004 enum memory_type : unsigned __int32
{
  MEMORY_DEVICE_PRIVATE = 0x1,
  MEMORY_DEVICE_FS_DAX = 0x2,
  MEMORY_DEVICE_DEVDAX = 0x3,
  MEMORY_DEVICE_PCI_P2PDMA = 0x4,
};
FFFFFFFF struct mempolicy;
FFFFFFFF typedef void *__cdecl mempool_alloc_t(gfp_t, void *);
FFFFFFFF typedef void __cdecl mempool_free_t(void *, void *);
00000048 struct mempool_s
{
  spinlock_t lock;
  int min_nr;
  int curr_nr;
  void **elements;
  void *pool_data;
  mempool_alloc_t *alloc;
  mempool_free_t *free;
  wait_queue_head_t wait;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 mempool_s.lock spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 mempool_s.min_nr int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 mempool_s.curr_nr int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 mempool_s.elements void **;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 mempool_s.pool_data void *;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 mempool_s.alloc mempool_alloc_t *;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 mempool_s.free mempool_free_t *;
//  7. 0030 0018 effalign(8) fda=0 bits=0000 mempool_s.wait wait_queue_head_t;
//          0048 effalign(8) sda=0 bits=0000 mempool_s struct packalign=0

00000048 typedef mempool_s mempool_t;
00000004 enum mf_action_page_type : unsigned __int32
{
  MF_MSG_KERNEL = 0x0,
  MF_MSG_KERNEL_HIGH_ORDER = 0x1,
  MF_MSG_SLAB = 0x2,
  MF_MSG_DIFFERENT_COMPOUND = 0x3,
  MF_MSG_POISONED_HUGE = 0x4,
  MF_MSG_HUGE = 0x5,
  MF_MSG_FREE_HUGE = 0x6,
  MF_MSG_NON_PMD_HUGE = 0x7,
  MF_MSG_UNMAP_FAILED = 0x8,
  MF_MSG_DIRTY_SWAPCACHE = 0x9,
  MF_MSG_CLEAN_SWAPCACHE = 0xA,
  MF_MSG_DIRTY_MLOCKED_LRU = 0xB,
  MF_MSG_CLEAN_MLOCKED_LRU = 0xC,
  MF_MSG_DIRTY_UNEVICTABLE_LRU = 0xD,
  MF_MSG_CLEAN_UNEVICTABLE_LRU = 0xE,
  MF_MSG_DIRTY_LRU = 0xF,
  MF_MSG_CLEAN_LRU = 0x10,
  MF_MSG_TRUNCATED_LRU = 0x11,
  MF_MSG_BUDDY = 0x12,
  MF_MSG_BUDDY_2ND = 0x13,
  MF_MSG_DAX = 0x14,
  MF_MSG_UNKNOWN = 0x15,
};
00000004 enum mf_flags : unsigned __int32
{
  MF_COUNT_INCREASED = 0x1,
  MF_ACTION_REQUIRED = 0x2,
  MF_MUST_KILL = 0x4,
  MF_SOFT_OFFLINE = 0x8,
};
00000004 enum mf_result : unsigned __int32
{
  MF_IGNORED = 0x0,
  MF_FAILED = 0x1,
  MF_DELAYED = 0x2,
  MF_RECOVERED = 0x3,
};
00000010 struct mhp_restrictions
{
  unsigned __int64 flags;
  vmem_altmap *altmap;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mhp_restrictions.flags unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mhp_restrictions.altmap vmem_altmap *;
//          0010 effalign(8) sda=0 bits=0000 mhp_restrictions struct packalign=0

00000004 enum migrate_mode : unsigned __int32
{
  MIGRATE_ASYNC = 0x0,
  MIGRATE_SYNC_LIGHT = 0x1,
  MIGRATE_SYNC = 0x2,
  MIGRATE_SYNC_NO_COPY = 0x3,
};
00000004 enum migratetype : unsigned __int32
{
  MIGRATE_UNMOVABLE = 0x0,
  MIGRATE_MOVABLE = 0x1,
  MIGRATE_RECLAIMABLE = 0x2,
  MIGRATE_PCPTYPES = 0x3,
  MIGRATE_HIGHATOMIC = 0x3,
  MIGRATE_CMA = 0x4,
  MIGRATE_ISOLATE = 0x5,
  MIGRATE_TYPES = 0x6,
};
00000001 struct mips_cdmm_device_id
{
  __u8 type;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mips_cdmm_device_id.type __u8;
//          0001 effalign(1) sda=0 bits=0000 mips_cdmm_device_id struct packalign=0

00000088 struct mm_context_t
{
  u64 ctx_id;
  atomic64_t tlb_gen;
  rw_semaphore ldt_usr_sem;
  ldt_struct *ldt;
  unsigned __int16 ia32_compat;
  mutex lock;
  void *vdso;
  const vdso_image *vdso_image;
  atomic_t perf_rdpmc_allowed;
  u16 pkey_allocation_map;
  s16 execute_only_pkey;
  void *bd_addr;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mm_context_t.ctx_id u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mm_context_t.tlb_gen atomic64_t;
//  2. 0010 0028 effalign(8) fda=0 bits=0000 mm_context_t.ldt_usr_sem rw_semaphore;
//  3. 0038 0008 effalign(8) fda=0 bits=0000 mm_context_t.ldt ldt_struct *;
//  4. 0040 0002 effalign(2) fda=0 bits=0000 mm_context_t.ia32_compat unsigned __int16;
//  5. 0048 0020 effalign(8) fda=0 bits=0000 mm_context_t.lock mutex;
//  6. 0068 0008 effalign(8) fda=0 bits=0000 mm_context_t.vdso void *;
//  7. 0070 0008 effalign(8) fda=0 bits=0000 mm_context_t.vdso_image const vdso_image *;
//  8. 0078 0004 effalign(4) fda=0 bits=0000 mm_context_t.perf_rdpmc_allowed atomic_t;
//  9. 007C 0002 effalign(2) fda=0 bits=0000 mm_context_t.pkey_allocation_map u16;
// 10. 007E 0002 effalign(2) fda=0 bits=0000 mm_context_t.execute_only_pkey s16;
// 11. 0080 0008 effalign(8) fda=0 bits=0000 mm_context_t.bd_addr void *;
//          0088 effalign(8) sda=0 bits=0000 mm_context_t struct packalign=0

00000020 struct mm_rss_stat
{
  atomic_long_t count[4];
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 mm_rss_stat.count atomic_long_t[4];
//          0020 effalign(8) sda=0 bits=0000 mm_rss_stat struct packalign=0

00000008 struct mm_segment_t
{
  unsigned __int64 seg;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mm_segment_t.seg unsigned __int64;
//          0008 effalign(8) sda=0 bits=0000 mm_segment_t struct packalign=0

00000408 struct mm_struct
{
  struct
  {
    vm_area_struct *mmap;
    rb_root mm_rb;
    u64 vmacache_seqnum;
    unsigned __int64 (__cdecl *get_unmapped_area)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
    unsigned __int64 mmap_base;
    unsigned __int64 mmap_legacy_base;
    unsigned __int64 mmap_compat_base;
    unsigned __int64 mmap_compat_legacy_base;
    unsigned __int64 task_size;
    unsigned __int64 highest_vm_end;
    pgd_t *pgd;
    atomic_t membarrier_state;
    atomic_t mm_users;
    atomic_t mm_count;
    atomic_long_t pgtables_bytes;
    int map_count;
    spinlock_t page_table_lock;
    rw_semaphore mmap_sem;
    list_head mmlist;
    unsigned __int64 hiwater_rss;
    unsigned __int64 hiwater_vm;
    unsigned __int64 total_vm;
    unsigned __int64 locked_vm;
    atomic64_t pinned_vm;
    unsigned __int64 data_vm;
    unsigned __int64 exec_vm;
    unsigned __int64 stack_vm;
    unsigned __int64 def_flags;
    spinlock_t arg_lock;
    unsigned __int64 start_code;
    unsigned __int64 end_code;
    unsigned __int64 start_data;
    unsigned __int64 end_data;
    unsigned __int64 start_brk;
    unsigned __int64 brk;
    unsigned __int64 start_stack;
    unsigned __int64 arg_start;
    unsigned __int64 arg_end;
    unsigned __int64 env_start;
    unsigned __int64 env_end;
    unsigned __int64 saved_auxv[46];
    mm_rss_stat rss_stat;
    linux_binfmt *binfmt;
    mm_context_t context;
    unsigned __int64 flags;
    core_state *core_state;
    spinlock_t ioctx_lock;
    kioctx_table *ioctx_table;
    task_struct *owner;
    user_namespace *user_ns;
    file *exe_file;
    mmu_notifier_mm *mmu_notifier_mm;
    unsigned __int64 numa_next_scan;
    unsigned __int64 numa_scan_offset;
    int numa_scan_seq;
    atomic_t tlb_flush_pending;
    bool tlb_flush_batched;
    uprobes_state uprobes_state;
    atomic_long_t hugetlb_usage;
    work_struct async_put_work;
  };
};
//  0. 0000 0408 effalign(8) fda=0 bits=0000 mm_struct.mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE;
//          0408 effalign(8) sda=0 bits=0000 mm_struct struct packalign=0

00000408 struct mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE
{
  vm_area_struct *mmap;
  rb_root mm_rb;
  u64 vmacache_seqnum;
  unsigned __int64 (__cdecl *get_unmapped_area)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
  unsigned __int64 mmap_base;
  unsigned __int64 mmap_legacy_base;
  unsigned __int64 mmap_compat_base;
  unsigned __int64 mmap_compat_legacy_base;
  unsigned __int64 task_size;
  unsigned __int64 highest_vm_end;
  pgd_t *pgd;
  atomic_t membarrier_state;
  atomic_t mm_users;
  atomic_t mm_count;
  atomic_long_t pgtables_bytes;
  int map_count;
  spinlock_t page_table_lock;
  rw_semaphore mmap_sem;
  list_head mmlist;
  unsigned __int64 hiwater_rss;
  unsigned __int64 hiwater_vm;
  unsigned __int64 total_vm;
  unsigned __int64 locked_vm;
  atomic64_t pinned_vm;
  unsigned __int64 data_vm;
  unsigned __int64 exec_vm;
  unsigned __int64 stack_vm;
  unsigned __int64 def_flags;
  spinlock_t arg_lock;
  unsigned __int64 start_code;
  unsigned __int64 end_code;
  unsigned __int64 start_data;
  unsigned __int64 end_data;
  unsigned __int64 start_brk;
  unsigned __int64 brk;
  unsigned __int64 start_stack;
  unsigned __int64 arg_start;
  unsigned __int64 arg_end;
  unsigned __int64 env_start;
  unsigned __int64 env_end;
  unsigned __int64 saved_auxv[46];
  mm_rss_stat rss_stat;
  linux_binfmt *binfmt;
  mm_context_t context;
  unsigned __int64 flags;
  core_state *core_state;
  spinlock_t ioctx_lock;
  kioctx_table *ioctx_table;
  task_struct *owner;
  user_namespace *user_ns;
  file *exe_file;
  mmu_notifier_mm *mmu_notifier_mm;
  unsigned __int64 numa_next_scan;
  unsigned __int64 numa_scan_offset;
  int numa_scan_seq;
  atomic_t tlb_flush_pending;
  bool tlb_flush_batched;
  uprobes_state uprobes_state;
  atomic_long_t hugetlb_usage;
  work_struct async_put_work;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap vm_area_struct *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mm_rb rb_root;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.vmacache_seqnum u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.get_unmapped_area unsigned __int64 (__cdecl *)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap_base unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap_legacy_base unsigned __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap_compat_base unsigned __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap_compat_legacy_base unsigned __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.task_size unsigned __int64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.highest_vm_end unsigned __int64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.pgd pgd_t *;
// 11. 0058 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.membarrier_state atomic_t;
// 12. 005C 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mm_users atomic_t;
// 13. 0060 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mm_count atomic_t;
// 14. 0068 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.pgtables_bytes atomic_long_t;
// 15. 0070 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.map_count int;
// 16. 0074 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.page_table_lock spinlock_t;
// 17. 0078 0028 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmap_sem rw_semaphore;
// 18. 00A0 0010 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmlist list_head;
// 19. 00B0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.hiwater_rss unsigned __int64;
// 20. 00B8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.hiwater_vm unsigned __int64;
// 21. 00C0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.total_vm unsigned __int64;
// 22. 00C8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.locked_vm unsigned __int64;
// 23. 00D0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.pinned_vm atomic64_t;
// 24. 00D8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.data_vm unsigned __int64;
// 25. 00E0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.exec_vm unsigned __int64;
// 26. 00E8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.stack_vm unsigned __int64;
// 27. 00F0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.def_flags unsigned __int64;
// 28. 00F8 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.arg_lock spinlock_t;
// 29. 0100 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.start_code unsigned __int64;
// 30. 0108 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.end_code unsigned __int64;
// 31. 0110 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.start_data unsigned __int64;
// 32. 0118 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.end_data unsigned __int64;
// 33. 0120 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.start_brk unsigned __int64;
// 34. 0128 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.brk unsigned __int64;
// 35. 0130 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.start_stack unsigned __int64;
// 36. 0138 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.arg_start unsigned __int64;
// 37. 0140 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.arg_end unsigned __int64;
// 38. 0148 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.env_start unsigned __int64;
// 39. 0150 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.env_end unsigned __int64;
// 40. 0158 0170 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.saved_auxv unsigned __int64[46];
// 41. 02C8 0020 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.rss_stat mm_rss_stat;
// 42. 02E8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.binfmt linux_binfmt *;
// 43. 02F0 0088 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.context mm_context_t;
// 44. 0378 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.flags unsigned __int64;
// 45. 0380 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.core_state core_state *;
// 46. 0388 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.ioctx_lock spinlock_t;
// 47. 0390 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.ioctx_table kioctx_table *;
// 48. 0398 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.owner task_struct *;
// 49. 03A0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.user_ns user_namespace *;
// 50. 03A8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.exe_file file *;
// 51. 03B0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.mmu_notifier_mm mmu_notifier_mm *;
// 52. 03B8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.numa_next_scan unsigned __int64;
// 53. 03C0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.numa_scan_offset unsigned __int64;
// 54. 03C8 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.numa_scan_seq int;
// 55. 03CC 0004 effalign(4) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.tlb_flush_pending atomic_t;
// 56. 03D0 0001 effalign(1) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.tlb_flush_batched bool;
// 57. 03D8 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.uprobes_state uprobes_state;
// 58. 03E0 0008 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.hugetlb_usage atomic_long_t;
// 59. 03E8 0020 effalign(8) fda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE.async_put_work work_struct;
//          0408 effalign(8) sda=0 bits=0000 mm_struct::$A1FE72D8F15AD09F2661A49A8869E9FE struct packalign=0

00000018 struct mminit_pfnnid_cache
{
  unsigned __int64 last_start;
  unsigned __int64 last_end;
  int last_nid;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mminit_pfnnid_cache.last_start unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 mminit_pfnnid_cache.last_end unsigned __int64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 mminit_pfnnid_cache.last_nid int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 mminit_pfnnid_cache struct packalign=0

FFFFFFFF struct mmu_gather;
FFFFFFFF struct mmu_notifier_mm;
FFFFFFFF struct mmu_notifier_range;
00000000 struct mod_arch_specific
{
};
//          0000 effalign(1) sda=0 bits=0000 mod_arch_specific struct packalign=0

00000020 struct mod_kallsyms
{
  Elf64_Sym *symtab;
  unsigned int num_symtab;
  char *strtab;
  char *typetab;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mod_kallsyms.symtab Elf64_Sym *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 mod_kallsyms.num_symtab unsigned int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 mod_kallsyms.strtab char *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 mod_kallsyms.typetab char *;
//          0020 effalign(8) sda=0 bits=0000 mod_kallsyms struct packalign=0

00000038 struct mod_tree_node
{
  module *mod;
  latch_tree_node node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mod_tree_node.mod module *;
//  1. 0008 0030 effalign(8) fda=0 bits=0000 mod_tree_node.node latch_tree_node;
//          0038 effalign(8) sda=0 bits=0000 mod_tree_node struct packalign=0

00000004 typedef __kernel_mode_t mode_t;
00000380 struct __attribute__((aligned(64))) module
{
  module_state state;
  list_head list;
  char name[56];
  module_kobject mkobj;
  module_attribute *modinfo_attrs;
  const char *version;
  const char *srcversion;
  kobject *holders_dir;
  const kernel_symbol *syms;
  const s32 *crcs;
  unsigned int num_syms;
  mutex param_lock;
  kernel_param *kp;
  unsigned int num_kp;
  unsigned int num_gpl_syms;
  const kernel_symbol *gpl_syms;
  const s32 *gpl_crcs;
  const kernel_symbol *unused_syms;
  const s32 *unused_crcs;
  unsigned int num_unused_syms;
  unsigned int num_unused_gpl_syms;
  const kernel_symbol *unused_gpl_syms;
  const s32 *unused_gpl_crcs;
  bool sig_ok;
  bool async_probe_requested;
  const kernel_symbol *gpl_future_syms;
  const s32 *gpl_future_crcs;
  unsigned int num_gpl_future_syms;
  unsigned int num_exentries;
  exception_table_entry *extable;
  int (*init)(void);
  __attribute__((aligned(64))) module_layout core_layout;
  module_layout init_layout;
  unsigned __int64 taints;
  unsigned int num_bugs;
  list_head bug_list;
  bug_entry *bug_table;
  mod_kallsyms *kallsyms;
  mod_kallsyms core_kallsyms;
  module_sect_attrs *sect_attrs;
  module_notes_attrs *notes_attrs;
  char *args;
  void *percpu;
  unsigned int percpu_size;
  unsigned int num_tracepoints;
  tracepoint_ptr_t *tracepoints_ptrs;
  unsigned int num_srcu_structs;
  srcu_struct **srcu_struct_ptrs;
  unsigned int num_bpf_raw_events;
  bpf_raw_event_map *bpf_raw_events;
  jump_entry *jump_entries;
  unsigned int num_jump_entries;
  unsigned int num_trace_bprintk_fmt;
  const char **trace_bprintk_fmt_start;
  trace_event_call **trace_events;
  unsigned int num_trace_events;
  trace_eval_map **trace_evals;
  unsigned int num_trace_evals;
  unsigned int num_ftrace_callsites;
  unsigned __int64 *ftrace_callsites;
  bool klp;
  bool klp_alive;
  klp_modinfo *klp_info;
  list_head source_list;
  list_head target_list;
  void (*exit)(void);
  atomic_t refcnt;
  error_injection_entry *ei_funcs;
  unsigned int num_ei_funcs;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 module.state module_state;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 module.list list_head;
//  2. 0018 0038 effalign(1) fda=0 bits=0000 module.name char[56];
//  3. 0050 0060 effalign(8) fda=0 bits=0000 module.mkobj module_kobject;
//  4. 00B0 0008 effalign(8) fda=0 bits=0000 module.modinfo_attrs module_attribute *;
//  5. 00B8 0008 effalign(8) fda=0 bits=0000 module.version const char *;
//  6. 00C0 0008 effalign(8) fda=0 bits=0000 module.srcversion const char *;
//  7. 00C8 0008 effalign(8) fda=0 bits=0000 module.holders_dir kobject *;
//  8. 00D0 0008 effalign(8) fda=0 bits=0000 module.syms const kernel_symbol *;
//  9. 00D8 0008 effalign(8) fda=0 bits=0000 module.crcs const s32 *;
// 10. 00E0 0004 effalign(4) fda=0 bits=0000 module.num_syms unsigned int;
// 11. 00E8 0020 effalign(8) fda=0 bits=0000 module.param_lock mutex;
// 12. 0108 0008 effalign(8) fda=0 bits=0000 module.kp kernel_param *;
// 13. 0110 0004 effalign(4) fda=0 bits=0000 module.num_kp unsigned int;
// 14. 0114 0004 effalign(4) fda=0 bits=0000 module.num_gpl_syms unsigned int;
// 15. 0118 0008 effalign(8) fda=0 bits=0000 module.gpl_syms const kernel_symbol *;
// 16. 0120 0008 effalign(8) fda=0 bits=0000 module.gpl_crcs const s32 *;
// 17. 0128 0008 effalign(8) fda=0 bits=0000 module.unused_syms const kernel_symbol *;
// 18. 0130 0008 effalign(8) fda=0 bits=0000 module.unused_crcs const s32 *;
// 19. 0138 0004 effalign(4) fda=0 bits=0000 module.num_unused_syms unsigned int;
// 20. 013C 0004 effalign(4) fda=0 bits=0000 module.num_unused_gpl_syms unsigned int;
// 21. 0140 0008 effalign(8) fda=0 bits=0000 module.unused_gpl_syms const kernel_symbol *;
// 22. 0148 0008 effalign(8) fda=0 bits=0000 module.unused_gpl_crcs const s32 *;
// 23. 0150 0001 effalign(1) fda=0 bits=0000 module.sig_ok bool;
// 24. 0151 0001 effalign(1) fda=0 bits=0000 module.async_probe_requested bool;
// 25. 0158 0008 effalign(8) fda=0 bits=0000 module.gpl_future_syms const kernel_symbol *;
// 26. 0160 0008 effalign(8) fda=0 bits=0000 module.gpl_future_crcs const s32 *;
// 27. 0168 0004 effalign(4) fda=0 bits=0000 module.num_gpl_future_syms unsigned int;
// 28. 016C 0004 effalign(4) fda=0 bits=0000 module.num_exentries unsigned int;
// 29. 0170 0008 effalign(8) fda=0 bits=0000 module.extable exception_table_entry *;
// 30. 0178 0008 effalign(8) fda=0 bits=0000 module.init int (*)(void);
// 31. 0180 0050 effalign(64) fda=7 bits=0000 module.core_layout module_layout;
// 32. 01D0 0050 effalign(8) fda=0 bits=0000 module.init_layout module_layout;
// 33. 0220 0008 effalign(8) fda=0 bits=0000 module.taints unsigned __int64;
// 34. 0228 0004 effalign(4) fda=0 bits=0000 module.num_bugs unsigned int;
// 35. 0230 0010 effalign(8) fda=0 bits=0000 module.bug_list list_head;
// 36. 0240 0008 effalign(8) fda=0 bits=0000 module.bug_table bug_entry *;
// 37. 0248 0008 effalign(8) fda=0 bits=0000 module.kallsyms mod_kallsyms *;
// 38. 0250 0020 effalign(8) fda=0 bits=0000 module.core_kallsyms mod_kallsyms;
// 39. 0270 0008 effalign(8) fda=0 bits=0000 module.sect_attrs module_sect_attrs *;
// 40. 0278 0008 effalign(8) fda=0 bits=0000 module.notes_attrs module_notes_attrs *;
// 41. 0280 0008 effalign(8) fda=0 bits=0000 module.args char *;
// 42. 0288 0008 effalign(8) fda=0 bits=0000 module.percpu void *;
// 43. 0290 0004 effalign(4) fda=0 bits=0000 module.percpu_size unsigned int;
// 44. 0294 0004 effalign(4) fda=0 bits=0000 module.num_tracepoints unsigned int;
// 45. 0298 0008 effalign(8) fda=0 bits=0000 module.tracepoints_ptrs tracepoint_ptr_t *;
// 46. 02A0 0004 effalign(4) fda=0 bits=0000 module.num_srcu_structs unsigned int;
// 47. 02A8 0008 effalign(8) fda=0 bits=0000 module.srcu_struct_ptrs srcu_struct **;
// 48. 02B0 0004 effalign(4) fda=0 bits=0000 module.num_bpf_raw_events unsigned int;
// 49. 02B8 0008 effalign(8) fda=0 bits=0000 module.bpf_raw_events bpf_raw_event_map *;
// 50. 02C0 0008 effalign(8) fda=0 bits=0000 module.jump_entries jump_entry *;
// 51. 02C8 0004 effalign(4) fda=0 bits=0000 module.num_jump_entries unsigned int;
// 52. 02CC 0004 effalign(4) fda=0 bits=0000 module.num_trace_bprintk_fmt unsigned int;
// 53. 02D0 0008 effalign(8) fda=0 bits=0000 module.trace_bprintk_fmt_start const char **;
// 54. 02D8 0008 effalign(8) fda=0 bits=0000 module.trace_events trace_event_call **;
// 55. 02E0 0004 effalign(4) fda=0 bits=0000 module.num_trace_events unsigned int;
// 56. 02E8 0008 effalign(8) fda=0 bits=0000 module.trace_evals trace_eval_map **;
// 57. 02F0 0004 effalign(4) fda=0 bits=0000 module.num_trace_evals unsigned int;
// 58. 02F4 0004 effalign(4) fda=0 bits=0000 module.num_ftrace_callsites unsigned int;
// 59. 02F8 0008 effalign(8) fda=0 bits=0000 module.ftrace_callsites unsigned __int64 *;
// 60. 0300 0001 effalign(1) fda=0 bits=0000 module.klp bool;
// 61. 0301 0001 effalign(1) fda=0 bits=0000 module.klp_alive bool;
// 62. 0308 0008 effalign(8) fda=0 bits=0000 module.klp_info klp_modinfo *;
// 63. 0310 0010 effalign(8) fda=0 bits=0000 module.source_list list_head;
// 64. 0320 0010 effalign(8) fda=0 bits=0000 module.target_list list_head;
// 65. 0330 0008 effalign(8) fda=0 bits=0000 module.exit void (*)(void);
// 66. 0338 0004 effalign(4) fda=0 bits=0000 module.refcnt atomic_t;
// 67. 0340 0008 effalign(8) fda=0 bits=0000 module.ei_funcs error_injection_entry *;
// 68. 0348 0004 effalign(4) fda=0 bits=0000 module.num_ei_funcs unsigned int;
//          034C unpadded_size
//          0380 effalign(64) sda=7 bits=0000 module struct packalign=0

00000038 struct module_attribute
{
  attribute attr;
  ssize_t (__cdecl *show)(module_attribute *, module_kobject *, char *);
  ssize_t (__cdecl *store)(module_attribute *, module_kobject *, const char *, size_t);
  void (__cdecl *setup)(module *, const char *);
  int (__cdecl *test)(module *);
  void (__cdecl *free)(module *);
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 module_attribute.attr attribute;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 module_attribute.show ssize_t (__cdecl *)(module_attribute *, module_kobject *, char *);
//  2. 0018 0008 effalign(8) fda=0 bits=0000 module_attribute.store ssize_t (__cdecl *)(module_attribute *, module_kobject *, const char *, size_t);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 module_attribute.setup void (__cdecl *)(module *, const char *);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 module_attribute.test int (__cdecl *)(module *);
//  5. 0030 0008 effalign(8) fda=0 bits=0000 module_attribute.free void (__cdecl *)(module *);
//          0038 effalign(8) sda=0 bits=0000 module_attribute struct packalign=0

00000060 struct module_kobject
{
  kobject kobj;
  module *mod;
  kobject *drivers_dir;
  module_param_attrs *mp;
  completion *kobj_completion;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 module_kobject.kobj kobject;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 module_kobject.mod module *;
//  2. 0048 0008 effalign(8) fda=0 bits=0000 module_kobject.drivers_dir kobject *;
//  3. 0050 0008 effalign(8) fda=0 bits=0000 module_kobject.mp module_param_attrs *;
//  4. 0058 0008 effalign(8) fda=0 bits=0000 module_kobject.kobj_completion completion *;
//          0060 effalign(8) sda=0 bits=0000 module_kobject struct packalign=0

00000050 struct module_layout
{
  void *base;
  unsigned int size;
  unsigned int text_size;
  unsigned int ro_size;
  unsigned int ro_after_init_size;
  mod_tree_node mtn;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 module_layout.base void *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 module_layout.size unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 module_layout.text_size unsigned int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 module_layout.ro_size unsigned int;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 module_layout.ro_after_init_size unsigned int;
//  5. 0018 0038 effalign(8) fda=0 bits=0000 module_layout.mtn mod_tree_node;
//          0050 effalign(8) sda=0 bits=0000 module_layout struct packalign=0

FFFFFFFF struct module_notes_attrs;
FFFFFFFF struct module_param_attrs;
FFFFFFFF struct module_sect_attrs;
00000004 enum module_state : unsigned __int32
{
  MODULE_STATE_LIVE = 0x0,
  MODULE_STATE_COMING = 0x1,
  MODULE_STATE_GOING = 0x2,
  MODULE_STATE_UNFORMED = 0x3,
};
00000030 struct module_use
{
  list_head source_list;
  list_head target_list;
  module *source;
  module *target;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 module_use.source_list list_head;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 module_use.target_list list_head;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 module_use.source module *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 module_use.target module *;
//          0030 effalign(8) sda=0 bits=0000 module_use struct packalign=0

00000048 struct __attribute__((aligned(8))) module_version_attribute
{
  module_attribute mattr;
  const char *module_name;
  const char *version;
};
//  0. 0000 0038 effalign(8) fda=0 bits=0000 module_version_attribute.mattr module_attribute;
//  1. 0038 0008 effalign(8) fda=0 bits=0000 module_version_attribute.module_name const char *;
//  2. 0040 0008 effalign(8) fda=0 bits=0000 module_version_attribute.version const char *;
//          0048 effalign(8) sda=4 bits=0000 module_version_attribute struct packalign=0

00000040 struct modversion_info
{
  unsigned __int64 crc;
  char name[56];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 modversion_info.crc unsigned __int64;
//  1. 0008 0038 effalign(1) fda=0 bits=0000 modversion_info.name char[56];
//          0040 effalign(8) sda=0 bits=0000 modversion_info struct packalign=0

FFFFFFFF struct mon_bus;
00000004 enum mp_bustype : unsigned __int32
{
  MP_BUS_ISA = 0x1,
  MP_BUS_EISA = 0x2,
  MP_BUS_PCI = 0x3,
};
00000004 enum mp_irq_source_types : unsigned __int32
{
  mp_INT = 0x0,
  mp_NMI = 0x1,
  mp_SMI = 0x2,
  mp_ExtINT = 0x3,
};
00000008 struct mpc_bus
{
  unsigned __int8 type;
  unsigned __int8 busid;
  unsigned __int8 bustype[6];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mpc_bus.type unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 mpc_bus.busid unsigned __int8;
//  2. 0002 0006 effalign(1) fda=0 bits=0000 mpc_bus.bustype unsigned __int8[6];
//          0008 effalign(1) sda=0 bits=0000 mpc_bus struct packalign=0

00000014 struct mpc_cpu
{
  unsigned __int8 type;
  unsigned __int8 apicid;
  unsigned __int8 apicver;
  unsigned __int8 cpuflag;
  unsigned int cpufeature;
  unsigned int featureflag;
  unsigned int reserved[2];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mpc_cpu.type unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 mpc_cpu.apicid unsigned __int8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 mpc_cpu.apicver unsigned __int8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 mpc_cpu.cpuflag unsigned __int8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 mpc_cpu.cpufeature unsigned int;
//  5. 0008 0004 effalign(4) fda=0 bits=0000 mpc_cpu.featureflag unsigned int;
//  6. 000C 0008 effalign(4) fda=0 bits=0000 mpc_cpu.reserved unsigned int[2];
//          0014 effalign(4) sda=0 bits=0000 mpc_cpu struct packalign=0

00000008 struct mpc_intsrc
{
  unsigned __int8 type;
  unsigned __int8 irqtype;
  unsigned __int16 irqflag;
  unsigned __int8 srcbus;
  unsigned __int8 srcbusirq;
  unsigned __int8 dstapic;
  unsigned __int8 dstirq;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.type unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.irqtype unsigned __int8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 mpc_intsrc.irqflag unsigned __int16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.srcbus unsigned __int8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.srcbusirq unsigned __int8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.dstapic unsigned __int8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 mpc_intsrc.dstirq unsigned __int8;
//          0008 effalign(2) sda=0 bits=0000 mpc_intsrc struct packalign=0

00000008 struct mpc_ioapic
{
  unsigned __int8 type;
  unsigned __int8 apicid;
  unsigned __int8 apicver;
  unsigned __int8 flags;
  unsigned int apicaddr;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mpc_ioapic.type unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 mpc_ioapic.apicid unsigned __int8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 mpc_ioapic.apicver unsigned __int8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 mpc_ioapic.flags unsigned __int8;
//  4. 0004 0004 effalign(4) fda=0 bits=0000 mpc_ioapic.apicaddr unsigned int;
//          0008 effalign(4) sda=0 bits=0000 mpc_ioapic struct packalign=0

00000008 struct mpc_lintsrc
{
  unsigned __int8 type;
  unsigned __int8 irqtype;
  unsigned __int16 irqflag;
  unsigned __int8 srcbusid;
  unsigned __int8 srcbusirq;
  unsigned __int8 destapic;
  unsigned __int8 destapiclint;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.type unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.irqtype unsigned __int8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 mpc_lintsrc.irqflag unsigned __int16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.srcbusid unsigned __int8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.srcbusirq unsigned __int8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.destapic unsigned __int8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 mpc_lintsrc.destapiclint unsigned __int8;
//          0008 effalign(2) sda=0 bits=0000 mpc_lintsrc struct packalign=0

00000010 struct mpc_oemtable
{
  char signature[4];
  unsigned __int16 length;
  char rev;
  char checksum;
  char mpc[8];
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 mpc_oemtable.signature char[4];
//  1. 0004 0002 effalign(2) fda=0 bits=0000 mpc_oemtable.length unsigned __int16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 mpc_oemtable.rev char;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 mpc_oemtable.checksum char;
//  4. 0008 0008 effalign(1) fda=0 bits=0000 mpc_oemtable.mpc char[8];
//          0010 effalign(2) sda=0 bits=0000 mpc_oemtable struct packalign=0

0000002C struct mpc_table
{
  char signature[4];
  unsigned __int16 length;
  char spec;
  char checksum;
  char oem[8];
  char productid[12];
  unsigned int oemptr;
  unsigned __int16 oemsize;
  unsigned __int16 oemcount;
  unsigned int lapic;
  unsigned int reserved;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 mpc_table.signature char[4];
//  1. 0004 0002 effalign(2) fda=0 bits=0000 mpc_table.length unsigned __int16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 mpc_table.spec char;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 mpc_table.checksum char;
//  4. 0008 0008 effalign(1) fda=0 bits=0000 mpc_table.oem char[8];
//  5. 0010 000C effalign(1) fda=0 bits=0000 mpc_table.productid char[12];
//  6. 001C 0004 effalign(4) fda=0 bits=0000 mpc_table.oemptr unsigned int;
//  7. 0020 0002 effalign(2) fda=0 bits=0000 mpc_table.oemsize unsigned __int16;
//  8. 0022 0002 effalign(2) fda=0 bits=0000 mpc_table.oemcount unsigned __int16;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 mpc_table.lapic unsigned int;
// 10. 0028 0004 effalign(4) fda=0 bits=0000 mpc_table.reserved unsigned int;
//          002C effalign(4) sda=0 bits=0000 mpc_table struct packalign=0

00000010 struct mpf_intel
{
  char signature[4];
  unsigned int physptr;
  unsigned __int8 length;
  unsigned __int8 specification;
  unsigned __int8 checksum;
  unsigned __int8 feature1;
  unsigned __int8 feature2;
  unsigned __int8 feature3;
  unsigned __int8 feature4;
  unsigned __int8 feature5;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 mpf_intel.signature char[4];
//  1. 0004 0004 effalign(4) fda=0 bits=0000 mpf_intel.physptr unsigned int;
//  2. 0008 0001 effalign(1) fda=0 bits=0000 mpf_intel.length unsigned __int8;
//  3. 0009 0001 effalign(1) fda=0 bits=0000 mpf_intel.specification unsigned __int8;
//  4. 000A 0001 effalign(1) fda=0 bits=0000 mpf_intel.checksum unsigned __int8;
//  5. 000B 0001 effalign(1) fda=0 bits=0000 mpf_intel.feature1 unsigned __int8;
//  6. 000C 0001 effalign(1) fda=0 bits=0000 mpf_intel.feature2 unsigned __int8;
//  7. 000D 0001 effalign(1) fda=0 bits=0000 mpf_intel.feature3 unsigned __int8;
//  8. 000E 0001 effalign(1) fda=0 bits=0000 mpf_intel.feature4 unsigned __int8;
//  9. 000F 0001 effalign(1) fda=0 bits=0000 mpf_intel.feature5 unsigned __int8;
//          0010 effalign(4) sda=0 bits=0000 mpf_intel struct packalign=0

00000010 struct __attribute__((packed)) mpx_bndcsr
{
  u64 bndcfgu;
  u64 bndstatus;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 mpx_bndcsr.bndcfgu u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 mpx_bndcsr.bndstatus u64;
//          0010 effalign(1) sda=0 bits=0040 mpx_bndcsr struct packalign=0

00000040 struct __attribute__((packed)) mpx_bndcsr_state
{
  union
  {
    mpx_bndcsr bndcsr;
    u8 pad_to_64_bytes[64];
  };
};
//  0. 0000 0040 effalign(1) fda=0 bits=0000 mpx_bndcsr_state.mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8 mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8;
//          0040 effalign(1) sda=0 bits=0040 mpx_bndcsr_state struct packalign=0

00000040 union mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8
{
  mpx_bndcsr bndcsr;
  u8 pad_to_64_bytes[64];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8.bndcsr mpx_bndcsr;
//  1. 0000 0040 effalign(1) fda=0 bits=0000 mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8.pad_to_64_bytes u8[64];
//          0040 effalign(1) sda=0 bits=0000 mpx_bndcsr_state::$EC512B889D28F38D834B55DB693625D8 union packalign=0

00000010 struct __attribute__((packed)) mpx_bndreg
{
  u64 lower_bound;
  u64 upper_bound;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 mpx_bndreg.lower_bound u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 mpx_bndreg.upper_bound u64;
//          0010 effalign(1) sda=0 bits=0040 mpx_bndreg struct packalign=0

00000040 struct __attribute__((packed)) mpx_bndreg_state
{
  mpx_bndreg bndreg[4];
};
//  0. 0000 0040 effalign(1) fda=0 bits=0000 mpx_bndreg_state.bndreg mpx_bndreg[4];
//          0040 effalign(1) sda=0 bits=0040 mpx_bndreg_state struct packalign=0

00000004 enum mq_rq_state : unsigned __int32
{
  MQ_RQ_IDLE = 0x0,
  MQ_RQ_IN_FLIGHT = 0x1,
  MQ_RQ_COMPLETE = 0x2,
};
00000004 typedef __kernel_mqd_t mqd_t;
FFFFFFFF struct msgbuf;
00000008 struct msr
{
  union
  {
    struct
    {
      u32 l;
      u32 h;
    };
    u64 q;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 msr.msr::$F1659EA95BB6A80F9D3C192E4AC36A6C msr::$F1659EA95BB6A80F9D3C192E4AC36A6C;
//          0008 effalign(8) sda=0 bits=0000 msr struct packalign=0

00000008 union msr::$F1659EA95BB6A80F9D3C192E4AC36A6C
{
  struct
  {
    u32 l;
    u32 h;
  };
  u64 q;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 msr::$F1659EA95BB6A80F9D3C192E4AC36A6C.$0C00FA23BDE0A874E23F9019515AD89A $0C00FA23BDE0A874E23F9019515AD89A;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 msr::$F1659EA95BB6A80F9D3C192E4AC36A6C.q u64;
//          0008 effalign(8) sda=0 bits=0000 msr::$F1659EA95BB6A80F9D3C192E4AC36A6C union packalign=0

00000020 struct msr_info
{
  u32 msr_no;
  msr reg;
  msr *msrs;
  int err;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 msr_info.msr_no u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 msr_info.reg msr;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 msr_info.msrs msr *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 msr_info.err int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 msr_info struct packalign=0

00000010 struct msr_regs_info
{
  u32 *regs;
  int err;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 msr_regs_info.regs u32 *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 msr_regs_info.err int;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 msr_regs_info struct packalign=0

FFFFFFFF struct mtd_info;
00000020 struct mutex
{
  atomic_long_t owner;
  spinlock_t wait_lock;
  optimistic_spin_queue osq;
  list_head wait_list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 mutex.owner atomic_long_t;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 mutex.wait_lock spinlock_t;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 mutex.osq optimistic_spin_queue;
//  3. 0010 0010 effalign(8) fda=0 bits=0000 mutex.wait_list list_head;
//          0020 effalign(8) sda=0 bits=0000 mutex struct packalign=0

00000004 enum mutex_trylock_recursive_enum : unsigned __int32
{
  MUTEX_TRYLOCK_FAILED = 0x0,
  MUTEX_TRYLOCK_SUCCESS = 0x1,
  MUTEX_TRYLOCK_RECURSIVE = 0x2,
};
00000020 struct mutex_waiter
{
  list_head list;
  task_struct *task;
  ww_acquire_ctx *ww_ctx;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 mutex_waiter.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 mutex_waiter.task task_struct *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 mutex_waiter.ww_ctx ww_acquire_ctx *;
//          0020 effalign(8) sda=0 bits=0000 mutex_waiter struct packalign=0

00000030 struct name_snapshot
{
  qstr name;
  unsigned __int8 inline_name[32];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 name_snapshot.name qstr;
//  1. 0010 0020 effalign(1) fda=0 bits=0000 name_snapshot.inline_name unsigned __int8[32];
//          0030 effalign(8) sda=0 bits=0000 name_snapshot struct packalign=0

FFFFFFFF struct nameidata;
FFFFFFFF struct net;
FFFFFFFF struct net_device;
00000004 #pragma pack(push, 1)
struct nfit_device_handle
{
  u32 handle;
};
#pragma pack(pop)
//  0. 0000 0004 effalign(4) fda=0 bits=0000 nfit_device_handle.handle u32;
//          0004 effalign(1) sda=0 bits=0000 nfit_device_handle struct packalign=1

00000008 struct nfs4_lock_info
{
  nfs4_lock_state *owner;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 nfs4_lock_info.owner nfs4_lock_state *;
//          0008 effalign(8) sda=0 bits=0000 nfs4_lock_info struct packalign=0

FFFFFFFF struct nfs4_lock_state;
00000020 struct nfs_lock_info
{
  u32 state;
  nlm_lockowner *owner;
  list_head list;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 nfs_lock_info.state u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 nfs_lock_info.owner nlm_lockowner *;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 nfs_lock_info.list list_head;
//          0020 effalign(8) sda=0 bits=0000 nfs_lock_info struct packalign=0

00000004 typedef u32 nlink_t;
FFFFFFFF struct nlm_lockowner;
00000004 enum node_stat_item : unsigned __int32
{
  NR_LRU_BASE = 0x0,
  NR_INACTIVE_ANON = 0x0,
  NR_ACTIVE_ANON = 0x1,
  NR_INACTIVE_FILE = 0x2,
  NR_ACTIVE_FILE = 0x3,
  NR_UNEVICTABLE = 0x4,
  NR_SLAB_RECLAIMABLE = 0x5,
  NR_SLAB_UNRECLAIMABLE = 0x6,
  NR_ISOLATED_ANON = 0x7,
  NR_ISOLATED_FILE = 0x8,
  WORKINGSET_NODES = 0x9,
  WORKINGSET_REFAULT = 0xA,
  WORKINGSET_ACTIVATE = 0xB,
  WORKINGSET_RESTORE = 0xC,
  WORKINGSET_NODERECLAIM = 0xD,
  NR_ANON_MAPPED = 0xE,
  NR_FILE_MAPPED = 0xF,
  NR_FILE_PAGES = 0x10,
  NR_FILE_DIRTY = 0x11,
  NR_WRITEBACK = 0x12,
  NR_WRITEBACK_TEMP = 0x13,
  NR_SHMEM = 0x14,
  NR_SHMEM_THPS = 0x15,
  NR_SHMEM_PMDMAPPED = 0x16,
  NR_FILE_THPS = 0x17,
  NR_FILE_PMDMAPPED = 0x18,
  NR_ANON_THPS = 0x19,
  NR_UNSTABLE_NFS = 0x1A,
  NR_VMSCAN_WRITE = 0x1B,
  NR_VMSCAN_IMMEDIATE = 0x1C,
  NR_DIRTIED = 0x1D,
  NR_WRITTEN = 0x1E,
  NR_KERNEL_MISC_RECLAIMABLE = 0x1F,
  NR_VM_NODE_STAT_ITEMS = 0x20,
};
00000004 enum node_states : unsigned __int32
{
  N_POSSIBLE = 0x0,
  N_ONLINE = 0x1,
  N_NORMAL_MEMORY = 0x2,
  N_HIGH_MEMORY = 0x2,
  N_MEMORY = 0x3,
  N_CPU = 0x4,
  NR_NODE_STATES = 0x5,
};
00000100 struct nodemask_scratch
{
  nodemask_t mask1;
  nodemask_t mask2;
};
//  0. 0000 0080 effalign(8) fda=0 bits=0000 nodemask_scratch.mask1 nodemask_t;
//  1. 0080 0080 effalign(8) fda=0 bits=0000 nodemask_scratch.mask2 nodemask_t;
//          0100 effalign(8) sda=0 bits=0000 nodemask_scratch struct packalign=0

00000080 struct nodemask_t
{
  unsigned __int64 bits[16];
};
//  0. 0000 0080 effalign(8) fda=0 bits=0000 nodemask_t.bits unsigned __int64[16];
//          0080 effalign(8) sda=0 bits=0000 nodemask_t struct packalign=0

00000018 struct notifier_block
{
  notifier_fn_t notifier_call;
  notifier_block *next;
  int priority;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 notifier_block.notifier_call notifier_fn_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 notifier_block.next notifier_block *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 notifier_block.priority int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 notifier_block struct packalign=0

00000008 typedef int (__cdecl *notifier_fn_t)(notifier_block *, unsigned __int64, void *);
FFFFFFFF struct ns_common;
FFFFFFFF struct nsproxy;
FFFFFFFF struct numa_group;
00000004 enum numa_stat_item : unsigned __int32
{
  NUMA_HIT = 0x0,
  NUMA_MISS = 0x1,
  NUMA_FOREIGN = 0x2,
  NUMA_INTERLEAVE_HIT = 0x3,
  NUMA_LOCAL = 0x4,
  NUMA_OTHER = 0x5,
  NR_VM_NUMA_STAT_ITEMS = 0x6,
};
FFFFFFFF struct nvmem_cell_info;
00000028 struct nvmem_cell_table
{
  const char *nvmem_name;
  const nvmem_cell_info *cells;
  size_t ncells;
  list_head node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 nvmem_cell_table.nvmem_name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 nvmem_cell_table.cells const nvmem_cell_info *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 nvmem_cell_table.ncells size_t;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 nvmem_cell_table.node list_head;
//          0028 effalign(8) sda=0 bits=0000 nvmem_cell_table struct packalign=0

00000070 struct nvmem_config
{
  device *dev;
  const char *name;
  int id;
  module *owner;
  const nvmem_cell_info *cells;
  int ncells;
  nvmem_type type;
  bool read_only;
  bool root_only;
  bool no_of_node;
  nvmem_reg_read_t reg_read;
  nvmem_reg_write_t reg_write;
  int size;
  int word_size;
  int stride;
  void *priv;
  bool compat;
  device *base_dev;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 nvmem_config.dev device *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 nvmem_config.name const char *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 nvmem_config.id int;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 nvmem_config.owner module *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 nvmem_config.cells const nvmem_cell_info *;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 nvmem_config.ncells int;
//  6. 002C 0004 effalign(4) fda=0 bits=0000 nvmem_config.type nvmem_type;
//  7. 0030 0001 effalign(1) fda=0 bits=0000 nvmem_config.read_only bool;
//  8. 0031 0001 effalign(1) fda=0 bits=0000 nvmem_config.root_only bool;
//  9. 0032 0001 effalign(1) fda=0 bits=0000 nvmem_config.no_of_node bool;
// 10. 0038 0008 effalign(8) fda=0 bits=0000 nvmem_config.reg_read nvmem_reg_read_t;
// 11. 0040 0008 effalign(8) fda=0 bits=0000 nvmem_config.reg_write nvmem_reg_write_t;
// 12. 0048 0004 effalign(4) fda=0 bits=0000 nvmem_config.size int;
// 13. 004C 0004 effalign(4) fda=0 bits=0000 nvmem_config.word_size int;
// 14. 0050 0004 effalign(4) fda=0 bits=0000 nvmem_config.stride int;
// 15. 0058 0008 effalign(8) fda=0 bits=0000 nvmem_config.priv void *;
// 16. 0060 0001 effalign(1) fda=0 bits=0000 nvmem_config.compat bool;
// 17. 0068 0008 effalign(8) fda=0 bits=0000 nvmem_config.base_dev device *;
//          0070 effalign(8) sda=0 bits=0000 nvmem_config struct packalign=0

FFFFFFFF struct nvmem_device;
00000008 typedef int (__cdecl *nvmem_reg_read_t)(void *, unsigned int, void *, size_t);
00000008 typedef int (__cdecl *nvmem_reg_write_t)(void *, unsigned int, void *, size_t);
00000004 enum nvmem_type : unsigned __int32
{
  NVMEM_TYPE_UNKNOWN = 0x0,
  NVMEM_TYPE_EEPROM = 0x1,
  NVMEM_TYPE_OTP = 0x2,
  NVMEM_TYPE_BATTERY_BACKED = 0x3,
};
00000018 struct obs_kernel_param
{
  const char *str;
  int (__cdecl *setup_func)(char *);
  int early;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 obs_kernel_param.str const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 obs_kernel_param.setup_func int (__cdecl *)(char *);
//  2. 0010 0004 effalign(4) fda=0 bits=0000 obs_kernel_param.early int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 obs_kernel_param struct packalign=0

00000010 struct of_changeset
{
  list_head entries;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 of_changeset.entries list_head;
//          0010 effalign(8) sda=0 bits=0000 of_changeset struct packalign=0

00000030 struct of_changeset_entry
{
  list_head node;
  unsigned __int64 action;
  device_node *np;
  property *prop;
  property *old_prop;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 of_changeset_entry.node list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 of_changeset_entry.action unsigned __int64;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 of_changeset_entry.np device_node *;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 of_changeset_entry.prop property *;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 of_changeset_entry.old_prop property *;
//          0030 effalign(8) sda=0 bits=0000 of_changeset_entry struct packalign=0

000000C8 struct of_device_id
{
  char name[32];
  char type[32];
  char compatible[128];
  const void *data;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 of_device_id.name char[32];
//  1. 0020 0020 effalign(1) fda=0 bits=0000 of_device_id.type char[32];
//  2. 0040 0080 effalign(1) fda=0 bits=0000 of_device_id.compatible char[128];
//  3. 00C0 0008 effalign(8) fda=0 bits=0000 of_device_id.data const void *;
//          00C8 effalign(8) sda=0 bits=0000 of_device_id struct packalign=0

00000008 typedef void (__cdecl *of_init_fn_1)(device_node *);
00000008 typedef int (__cdecl *of_init_fn_1_ret)(device_node *);
00000008 typedef int (__cdecl *of_init_fn_2)(device_node *, device_node *);
00000004 enum of_overlay_notify_action : unsigned __int32
{
  OF_OVERLAY_PRE_APPLY = 0x0,
  OF_OVERLAY_POST_APPLY = 0x1,
  OF_OVERLAY_PRE_REMOVE = 0x2,
  OF_OVERLAY_POST_REMOVE = 0x3,
};
00000010 struct of_overlay_notify_data
{
  device_node *overlay;
  device_node *target;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 of_overlay_notify_data.overlay device_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 of_overlay_notify_data.target device_node *;
//          0010 effalign(8) sda=0 bits=0000 of_overlay_notify_data struct packalign=0

00000050 struct of_phandle_args
{
  device_node *np;
  int args_count;
  uint32_t args[16];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 of_phandle_args.np device_node *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 of_phandle_args.args_count int;
//  2. 000C 0040 effalign(4) fda=0 bits=0000 of_phandle_args.args uint32_t[16];
//          004C unpadded_size
//          0050 effalign(8) sda=0 bits=0000 of_phandle_args struct packalign=0

00000040 struct of_phandle_iterator
{
  const char *cells_name;
  int cell_count;
  const device_node *parent;
  const __be32 *list_end;
  const __be32 *phandle_end;
  const __be32 *cur;
  uint32_t cur_count;
  phandle phandle;
  device_node *node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.cells_name const char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 of_phandle_iterator.cell_count int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.parent const device_node *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.list_end const __be32 *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.phandle_end const __be32 *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.cur const __be32 *;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 of_phandle_iterator.cur_count uint32_t;
//  7. 0034 0004 effalign(4) fda=0 bits=0000 of_phandle_iterator.phandle phandle;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 of_phandle_iterator.node device_node *;
//          0040 effalign(8) sda=0 bits=0000 of_phandle_iterator struct packalign=0

00000004 enum of_reconfig_change : unsigned __int32
{
  OF_RECONFIG_NO_CHANGE = 0x0,
  OF_RECONFIG_CHANGE_ADD = 0x1,
  OF_RECONFIG_CHANGE_REMOVE = 0x2,
};
00000018 struct of_reconfig_data
{
  device_node *dn;
  property *prop;
  property *old_prop;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 of_reconfig_data.dn device_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 of_reconfig_data.prop property *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 of_reconfig_data.old_prop property *;
//          0018 effalign(8) sda=0 bits=0000 of_reconfig_data struct packalign=0

00000008 typedef __kernel_off_t off_t;
00000002 typedef __kernel_old_gid_t old_gid_t;
00000010 struct old_itimerspec32
{
  old_timespec32 it_interval;
  old_timespec32 it_value;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 old_itimerspec32.it_interval old_timespec32;
//  1. 0008 0008 effalign(4) fda=0 bits=0000 old_itimerspec32.it_value old_timespec32;
//          0010 effalign(4) sda=0 bits=0000 old_itimerspec32 struct packalign=0

00000008 typedef unsigned __int64 old_sigset_t;
00000004 typedef s32 old_time32_t;
00000008 struct old_timespec32
{
  old_time32_t tv_sec;
  s32 tv_nsec;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 old_timespec32.tv_sec old_time32_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 old_timespec32.tv_nsec s32;
//          0008 effalign(4) sda=0 bits=0000 old_timespec32 struct packalign=0

00000008 struct old_timeval32
{
  old_time32_t tv_sec;
  s32 tv_usec;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 old_timeval32.tv_sec old_time32_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 old_timeval32.tv_usec s32;
//          0008 effalign(4) sda=0 bits=0000 old_timeval32 struct packalign=0

00000080 struct old_timex32
{
  u32 modes;
  s32 offset;
  s32 freq;
  s32 maxerror;
  s32 esterror;
  s32 status;
  s32 constant;
  s32 precision;
  s32 tolerance;
  old_timeval32 time;
  s32 tick;
  s32 ppsfreq;
  s32 jitter;
  s32 shift;
  s32 stabil;
  s32 jitcnt;
  s32 calcnt;
  s32 errcnt;
  s32 stbcnt;
  s32 tai;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 old_timex32.modes u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 old_timex32.offset s32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 old_timex32.freq s32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 old_timex32.maxerror s32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 old_timex32.esterror s32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 old_timex32.status s32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 old_timex32.constant s32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 old_timex32.precision s32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 old_timex32.tolerance s32;
//  9. 0024 0008 effalign(4) fda=0 bits=0000 old_timex32.time old_timeval32;
// 10. 002C 0004 effalign(4) fda=0 bits=0000 old_timex32.tick s32;
// 11. 0030 0004 effalign(4) fda=0 bits=0000 old_timex32.ppsfreq s32;
// 12. 0034 0004 effalign(4) fda=0 bits=0000 old_timex32.jitter s32;
// 13. 0038 0004 effalign(4) fda=0 bits=0000 old_timex32.shift s32;
// 14. 003C 0004 effalign(4) fda=0 bits=0000 old_timex32.stabil s32;
// 15. 0040 0004 effalign(4) fda=0 bits=0000 old_timex32.jitcnt s32;
// 16. 0044 0004 effalign(4) fda=0 bits=0000 old_timex32.calcnt s32;
// 17. 0048 0004 effalign(4) fda=0 bits=0000 old_timex32.errcnt s32;
// 18. 004C 0004 effalign(4) fda=0 bits=0000 old_timex32.stbcnt s32;
// 19. 0050 0004 effalign(4) fda=0 bits=0000 old_timex32.tai s32;
// 20. 0054. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 21. 0058. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 22. 005C. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 23. 0060. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 24. 0064. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 25. 0068. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 26. 006C. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 27. 0070. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 28. 0074. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 29. 0078. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
// 30. 007C. 0 32 effalign(4) fda=0 bits=0000 old_timex32.(null) bi.nbytes=4 S
//          0080 effalign(4) sda=0 bits=0000 old_timex32 struct packalign=0

00000002 typedef __kernel_old_uid_t old_uid_t;
00000008 struct old_utimbuf32
{
  old_time32_t actime;
  old_time32_t modtime;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 old_utimbuf32.actime old_time32_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 old_utimbuf32.modtime old_time32_t;
//          0008 effalign(4) sda=0 bits=0000 old_utimbuf32 struct packalign=0

00000010 struct __attribute__((packed)) olpc_ofw_header
{
  __u32 ofw_magic;
  __u32 ofw_version;
  __u32 cif_handler;
  __u32 irq_desc_table;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 olpc_ofw_header.ofw_magic __u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 olpc_ofw_header.ofw_version __u32;
//  2. 0008 0004 effalign(1) fda=0 bits=0000 olpc_ofw_header.cif_handler __u32;
//  3. 000C 0004 effalign(1) fda=0 bits=0000 olpc_ofw_header.irq_desc_table __u32;
//          0010 effalign(1) sda=0 bits=0040 olpc_ofw_header struct packalign=0

00000008 typedef void (__cdecl *online_page_callback_t)(page *, unsigned int);
00000018 struct optimistic_spin_node
{
  optimistic_spin_node *next;
  optimistic_spin_node *prev;
  int locked;
  int cpu;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 optimistic_spin_node.next optimistic_spin_node *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 optimistic_spin_node.prev optimistic_spin_node *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 optimistic_spin_node.locked int;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 optimistic_spin_node.cpu int;
//          0018 effalign(8) sda=0 bits=0000 optimistic_spin_node struct packalign=0

00000004 struct optimistic_spin_queue
{
  atomic_t tail;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 optimistic_spin_queue.tail atomic_t;
//          0004 effalign(4) sda=0 bits=0000 optimistic_spin_queue struct packalign=0

00000006 struct __attribute__((packed)) orc_entry
{
  s16 sp_offset;
  s16 bp_offset;
  unsigned __int32 sp_reg : 4;
  unsigned __int32 bp_reg : 4;
  unsigned __int32 type : 2;
  unsigned __int32 end : 1;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 orc_entry.sp_offset s16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 orc_entry.bp_offset s16;
//  2. 0004. 0 4 effalign(1) fda=0 bits=0000 orc_entry.sp_reg bi.nbytes=4 U
//  3. 0004. 4 4 effalign(1) fda=0 bits=0000 orc_entry.bp_reg bi.nbytes=4 U
//  4. 0004. 8 2 effalign(1) fda=0 bits=0000 orc_entry.type bi.nbytes=4 U
//  5. 0004.10 1 effalign(1) fda=0 bits=0000 orc_entry.end bi.nbytes=4 U
//          0006 effalign(1) sda=0 bits=0040 orc_entry struct packalign=0

00000008 struct p4d_t
{
  pgd_t pgd;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 p4d_t.pgd pgd_t;
//          0008 effalign(8) sda=0 bits=0000 p4d_t struct packalign=0

00000008 typedef unsigned __int64 p4dval_t;
00000040 struct __attribute__((aligned(16))) page
{
  unsigned __int64 flags;
  union
  {
    struct
    {
      list_head lru;
      address_space *mapping;
      unsigned __int64 index;
      unsigned __int64 private;
    };
    struct
    {
      unsigned __int64 dma_addr[2];
    };
    struct
    {
      union
      {
        list_head slab_list;
        struct
        {
          page *next;
          int pages;
          int pobjects;
        };
      };
      kmem_cache *slab_cache;
      void *freelist;
      union
      {
        void *s_mem;
        unsigned __int64 counters;
        struct
        {
          unsigned __int32 inuse : 16;
          unsigned __int32 objects : 15;
          unsigned __int32 frozen : 1;
        };
      };
    };
    struct
    {
      unsigned __int64 compound_head;
      unsigned __int8 compound_dtor;
      unsigned __int8 compound_order;
      atomic_t compound_mapcount;
    };
    struct
    {
      unsigned __int64 _compound_pad_1;
      unsigned __int64 _compound_pad_2;
      list_head deferred_list;
    };
    struct
    {
      unsigned __int64 _pt_pad_1;
      pgtable_t pmd_huge_pte;
      unsigned __int64 _pt_pad_2;
      union
      {
        mm_struct *pt_mm;
        atomic_t pt_frag_refcount;
      };
      spinlock_t ptl;
    };
    struct
    {
      dev_pagemap *pgmap;
      void *zone_device_data;
    };
    callback_head callback_head;
  };
  union
  {
    atomic_t _mapcount;
    unsigned int page_type;
    unsigned int active;
    int units;
  };
  atomic_t _refcount;
  mem_cgroup *mem_cgroup;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 page.flags unsigned __int64;
//  1. 0008 0028 effalign(8) fda=0 bits=0000 page.page::$5F50E26EF261E7A7334650E9FF3A0F5A page::$5F50E26EF261E7A7334650E9FF3A0F5A;
//  2. 0030 0004 effalign(4) fda=0 bits=0000 page.page::$CA3393BBC68898D27296263250742803 page::$CA3393BBC68898D27296263250742803;
//  3. 0034 0004 effalign(4) fda=0 bits=0000 page._refcount atomic_t;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 page.mem_cgroup mem_cgroup *;
//          0040 effalign(16) sda=5 bits=0000 page struct packalign=0

00000028 union page::$5F50E26EF261E7A7334650E9FF3A0F5A
{
  struct
  {
    list_head lru;
    address_space *mapping;
    unsigned __int64 index;
    unsigned __int64 private;
  };
  struct
  {
    unsigned __int64 dma_addr[2];
  };
  struct
  {
    union
    {
      list_head slab_list;
      struct
      {
        page *next;
        int pages;
        int pobjects;
      };
    };
    kmem_cache *slab_cache;
    void *freelist;
    union
    {
      void *s_mem;
      unsigned __int64 counters;
      struct
      {
        unsigned __int32 inuse : 16;
        unsigned __int32 objects : 15;
        unsigned __int32 frozen : 1;
      };
    };
  };
  struct
  {
    unsigned __int64 compound_head;
    unsigned __int8 compound_dtor;
    unsigned __int8 compound_order;
    atomic_t compound_mapcount;
  };
  struct
  {
    unsigned __int64 _compound_pad_1;
    unsigned __int64 _compound_pad_2;
    list_head deferred_list;
  };
  struct
  {
    unsigned __int64 _pt_pad_1;
    pgtable_t pmd_huge_pte;
    unsigned __int64 _pt_pad_2;
    union
    {
      mm_struct *pt_mm;
      atomic_t pt_frag_refcount;
    };
    spinlock_t ptl;
  };
  struct
  {
    dev_pagemap *pgmap;
    void *zone_device_data;
  };
  callback_head callback_head;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$34672576DAEADB9A5B053A678A7DD49F $34672576DAEADB9A5B053A678A7DD49F;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$6F3630504A23BCE969F37C5A473E0AD7 $6F3630504A23BCE969F37C5A473E0AD7;
//  2. 0000 0028 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$51362CFB81AC1A39C0D7F8CCE9E59377 $51362CFB81AC1A39C0D7F8CCE9E59377;
//  3. 0000 0010 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$D137D31AB4BF200B069527E143652062 $D137D31AB4BF200B069527E143652062;
//  4. 0000 0020 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$A871915AF794C75F2AAD498C00BC3826 $A871915AF794C75F2AAD498C00BC3826;
//  5. 0000 0028 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$B909293F6C414207B8940B35813701F8 $B909293F6C414207B8940B35813701F8;
//  6. 0000 0010 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.$D2A5E924C2C4CF1CF51E8DE55C3CCAA5 $D2A5E924C2C4CF1CF51E8DE55C3CCAA5;
//  7. 0000 0010 effalign(8) fda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A.callback_head callback_head;
//          0028 effalign(8) sda=0 bits=0000 page::$5F50E26EF261E7A7334650E9FF3A0F5A union packalign=0

00000004 union page::$CA3393BBC68898D27296263250742803
{
  atomic_t _mapcount;
  unsigned int page_type;
  unsigned int active;
  int units;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 page::$CA3393BBC68898D27296263250742803._mapcount atomic_t;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 page::$CA3393BBC68898D27296263250742803.page_type unsigned int;
//  2. 0000 0004 effalign(4) fda=0 bits=0000 page::$CA3393BBC68898D27296263250742803.active unsigned int;
//  3. 0000 0004 effalign(4) fda=0 bits=0000 page::$CA3393BBC68898D27296263250742803.units int;
//          0004 effalign(4) sda=0 bits=0000 page::$CA3393BBC68898D27296263250742803 union packalign=0

00000004 enum page_cache_mode : unsigned __int32
{
  _PAGE_CACHE_MODE_WB = 0x0,
  _PAGE_CACHE_MODE_WC = 0x1,
  _PAGE_CACHE_MODE_UC_MINUS = 0x2,
  _PAGE_CACHE_MODE_UC = 0x3,
  _PAGE_CACHE_MODE_WT = 0x4,
  _PAGE_CACHE_MODE_WP = 0x5,
  _PAGE_CACHE_MODE_NUM = 0x8,
};
00000004 enum page_entry_size : unsigned __int32
{
  PE_SIZE_PTE = 0x0,
  PE_SIZE_PMD = 0x1,
  PE_SIZE_PUD = 0x2,
};
FFFFFFFF struct page_ext;
00000020 struct page_ext_operations
{
  size_t offset;
  size_t size;
  bool (*need)(void);
  void (*init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 page_ext_operations.offset size_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 page_ext_operations.size size_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 page_ext_operations.need bool (*)(void);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 page_ext_operations.init void (*)(void);
//          0020 effalign(8) sda=0 bits=0000 page_ext_operations struct packalign=0

00000010 struct page_frag
{
  page *page;
  __u32 offset;
  __u32 size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 page_frag.page page *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 page_frag.offset __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 page_frag.size __u32;
//          0010 effalign(8) sda=0 bits=0000 page_frag struct packalign=0

00000018 struct page_frag_cache
{
  void *va;
  __u16 offset;
  __u16 size;
  unsigned int pagecnt_bias;
  bool pfmemalloc;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 page_frag_cache.va void *;
//  1. 0008 0002 effalign(2) fda=0 bits=0000 page_frag_cache.offset __u16;
//  2. 000A 0002 effalign(2) fda=0 bits=0000 page_frag_cache.size __u16;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 page_frag_cache.pagecnt_bias unsigned int;
//  4. 0010 0001 effalign(1) fda=0 bits=0000 page_frag_cache.pfmemalloc bool;
//          0011 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 page_frag_cache struct packalign=0

00000004 enum pageblock_bits : unsigned __int32
{
  PB_migrate = 0x0,
  PB_migrate_end = 0x2,
  PB_migrate_skip = 0x3,
  NR_PAGEBLOCK_BITS = 0x4,
};
00000004 enum pageflags : unsigned __int32
{
  PG_locked = 0x0,
  PG_referenced = 0x1,
  PG_uptodate = 0x2,
  PG_dirty = 0x3,
  PG_lru = 0x4,
  PG_active = 0x5,
  PG_workingset = 0x6,
  PG_waiters = 0x7,
  PG_error = 0x8,
  PG_slab = 0x9,
  PG_owner_priv_1 = 0xA,
  PG_arch_1 = 0xB,
  PG_reserved = 0xC,
  PG_private = 0xD,
  PG_private_2 = 0xE,
  PG_writeback = 0xF,
  PG_head = 0x10,
  PG_mappedtodisk = 0x11,
  PG_reclaim = 0x12,
  PG_swapbacked = 0x13,
  PG_unevictable = 0x14,
  PG_mlocked = 0x15,
  PG_uncached = 0x16,
  PG_hwpoison = 0x17,
  PG_young = 0x18,
  PG_idle = 0x19,
  __NR_PAGEFLAGS = 0x1A,
  PG_checked = 0xA,
  PG_swapcache = 0xA,
  PG_fscache = 0xE,
  PG_pinned = 0xA,
  PG_savepinned = 0x3,
  PG_foreign = 0xA,
  PG_xen_remapped = 0xA,
  PG_slob_free = 0xD,
  PG_double_map = 0xE,
  PG_isolated = 0x12,
};
FFFFFFFF struct pagevec;
00000008 struct paravirt_callee_save
{
  void *func;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 paravirt_callee_save.func void *;
//          0008 effalign(8) sda=0 bits=0000 paravirt_callee_save struct packalign=0

00000004 enum paravirt_lazy_mode : unsigned __int32
{
  PARAVIRT_LAZY_NONE = 0x0,
  PARAVIRT_LAZY_MMU = 0x1,
  PARAVIRT_LAZY_CPU = 0x2,
};
00000010 struct paravirt_patch_site
{
  u8 *instr;
  u8 type;
  u8 len;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 paravirt_patch_site.instr u8 *;
//  1. 0008 0001 effalign(1) fda=0 bits=0000 paravirt_patch_site.type u8;
//  2. 0009 0001 effalign(1) fda=0 bits=0000 paravirt_patch_site.len u8;
//          000A unpadded_size
//          0010 effalign(8) sda=0 bits=0000 paravirt_patch_site struct packalign=0

000002B8 struct paravirt_patch_template
{
  pv_init_ops init;
  pv_time_ops time;
  pv_cpu_ops cpu;
  pv_irq_ops irq;
  pv_mmu_ops mmu;
  pv_lock_ops lock;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 paravirt_patch_template.init pv_init_ops;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 paravirt_patch_template.time pv_time_ops;
//  2. 0018 0100 effalign(8) fda=0 bits=0000 paravirt_patch_template.cpu pv_cpu_ops;
//  3. 0118 0030 effalign(8) fda=0 bits=0000 paravirt_patch_template.irq pv_irq_ops;
//  4. 0148 0148 effalign(8) fda=0 bits=0000 paravirt_patch_template.mmu pv_mmu_ops;
//  5. 0290 0028 effalign(8) fda=0 bits=0000 paravirt_patch_template.lock pv_lock_ops;
//          02B8 effalign(8) sda=0 bits=0000 paravirt_patch_template struct packalign=0

00000008 struct parisc_device_id
{
  __u8 hw_type;
  __u8 hversion_rev;
  __u16 hversion;
  __u32 sversion;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 parisc_device_id.hw_type __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 parisc_device_id.hversion_rev __u8;
//  2. 0002 0002 effalign(2) fda=0 bits=0000 parisc_device_id.hversion __u16;
//  3. 0004 0004 effalign(4) fda=0 bits=0000 parisc_device_id.sversion __u32;
//          0008 effalign(4) sda=0 bits=0000 parisc_device_id struct packalign=0

00000010 struct __attribute__((packed)) partition
{
  unsigned __int8 boot_ind;
  unsigned __int8 head;
  unsigned __int8 sector;
  unsigned __int8 cyl;
  unsigned __int8 sys_ind;
  unsigned __int8 end_head;
  unsigned __int8 end_sector;
  unsigned __int8 end_cyl;
  __le32 start_sect;
  __le32 nr_sects;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 partition.boot_ind unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 partition.head unsigned __int8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 partition.sector unsigned __int8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 partition.cyl unsigned __int8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 partition.sys_ind unsigned __int8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 partition.end_head unsigned __int8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 partition.end_sector unsigned __int8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 partition.end_cyl unsigned __int8;
//  8. 0008 0004 effalign(1) fda=0 bits=0000 partition.start_sect __le32;
//  9. 000C 0004 effalign(1) fda=0 bits=0000 partition.nr_sects __le32;
//          0010 effalign(1) sda=0 bits=0040 partition struct packalign=0

00000065 struct partition_meta_info
{
  char uuid[37];
  u8 volname[64];
};
//  0. 0000 0025 effalign(1) fda=0 bits=0000 partition_meta_info.uuid char[37];
//  1. 0025 0040 effalign(1) fda=0 bits=0000 partition_meta_info.volname u8[64];
//          0065 effalign(1) sda=0 bits=0000 partition_meta_info struct packalign=0

00000010 struct path
{
  vfsmount *mnt;
  dentry *dentry;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 path.mnt vfsmount *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 path.dentry dentry *;
//          0010 effalign(8) sda=0 bits=0000 path struct packalign=0

FFFFFFFF struct pci_bus;
FFFFFFFF struct pci_dev;
00000020 struct pci_device_id
{
  __u32 vendor;
  __u32 device;
  __u32 subvendor;
  __u32 subdevice;
  __u32 class;
  __u32 class_mask;
  kernel_ulong_t driver_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pci_device_id.vendor __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 pci_device_id.device __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 pci_device_id.subvendor __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 pci_device_id.subdevice __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 pci_device_id.class __u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 pci_device_id.class_mask __u32;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 pci_device_id.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 pci_device_id struct packalign=0

00000020 struct pci_epf_device_id
{
  char name[20];
  kernel_ulong_t driver_data;
};
//  0. 0000 0014 effalign(1) fda=0 bits=0000 pci_epf_device_id.name char[20];
//  1. 0018 0008 effalign(8) fda=0 bits=0000 pci_epf_device_id.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 pci_epf_device_id struct packalign=0

00000050 struct pcmcia_device_id
{
  __u16 match_flags;
  __u16 manf_id;
  __u16 card_id;
  __u8 func_id;
  __u8 function;
  __u8 device_no;
  __u32 prod_id_hash[4];
  const char *prod_id[4];
  kernel_ulong_t driver_info;
  char *cisfile;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 pcmcia_device_id.match_flags __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 pcmcia_device_id.manf_id __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 pcmcia_device_id.card_id __u16;
//  3. 0006 0001 effalign(1) fda=0 bits=0000 pcmcia_device_id.func_id __u8;
//  4. 0007 0001 effalign(1) fda=0 bits=0000 pcmcia_device_id.function __u8;
//  5. 0008 0001 effalign(1) fda=0 bits=0000 pcmcia_device_id.device_no __u8;
//  6. 000C 0010 effalign(4) fda=0 bits=0000 pcmcia_device_id.prod_id_hash __u32[4];
//  7. 0020 0020 effalign(8) fda=0 bits=0000 pcmcia_device_id.prod_id const char *[4];
//  8. 0040 0008 effalign(8) fda=0 bits=0000 pcmcia_device_id.driver_info kernel_ulong_t;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 pcmcia_device_id.cisfile char *;
//          0050 effalign(8) sda=0 bits=0000 pcmcia_device_id struct packalign=0

00000040 struct pcpu_alloc_info
{
  size_t static_size;
  size_t reserved_size;
  size_t dyn_size;
  size_t unit_size;
  size_t atom_size;
  size_t alloc_size;
  size_t __ai_size;
  int nr_groups;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.static_size size_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.reserved_size size_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.dyn_size size_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.unit_size size_t;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.atom_size size_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.alloc_size size_t;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 pcpu_alloc_info.__ai_size size_t;
//  7. 0038 0004 effalign(4) fda=0 bits=0000 pcpu_alloc_info.nr_groups int;
//          003C unpadded_size
//          0040 effalign(8) sda=0 bits=0000 pcpu_alloc_info struct packalign=0

00000004 enum pcpu_fc : unsigned __int32
{
  PCPU_FC_AUTO = 0x0,
  PCPU_FC_EMBED = 0x1,
  PCPU_FC_PAGE = 0x2,
  PCPU_FC_NR = 0x3,
};
00000008 typedef void *(__cdecl *pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);
FFFFFFFF typedef int __cdecl pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);
00000008 typedef void (__cdecl *pcpu_fc_free_fn_t)(void *, size_t);
00000008 typedef void (__cdecl *pcpu_fc_populate_pte_fn_t)(unsigned __int64);
00000018 struct pcpu_group_info
{
  int nr_units;
  unsigned __int64 base_offset;
  unsigned int *cpu_map;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pcpu_group_info.nr_units int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pcpu_group_info.base_offset unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pcpu_group_info.cpu_map unsigned int *;
//          0018 effalign(8) sda=0 bits=0000 pcpu_group_info struct packalign=0

00000000 struct pdev_archdata
{
};
//          0000 effalign(1) sda=0 bits=0000 pdev_archdata struct packalign=0

00000021 struct per_cpu_nodestat
{
  s8 stat_threshold;
  s8 vm_node_stat_diff[32];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 per_cpu_nodestat.stat_threshold s8;
//  1. 0001 0020 effalign(1) fda=0 bits=0000 per_cpu_nodestat.vm_node_stat_diff s8[32];
//          0021 effalign(1) sda=0 bits=0000 per_cpu_nodestat struct packalign=0

00000040 struct per_cpu_pages
{
  int count;
  int high;
  int batch;
  list_head lists[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 per_cpu_pages.count int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 per_cpu_pages.high int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 per_cpu_pages.batch int;
//  3. 0010 0030 effalign(8) fda=0 bits=0000 per_cpu_pages.lists list_head[3];
//          0040 effalign(8) sda=0 bits=0000 per_cpu_pages struct packalign=0

00000060 struct per_cpu_pageset
{
  per_cpu_pages pcp;
  s8 expire;
  u16 vm_numa_stat_diff[6];
  s8 stat_threshold;
  s8 vm_stat_diff[13];
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 per_cpu_pageset.pcp per_cpu_pages;
//  1. 0040 0001 effalign(1) fda=0 bits=0000 per_cpu_pageset.expire s8;
//  2. 0042 000C effalign(2) fda=0 bits=0000 per_cpu_pageset.vm_numa_stat_diff u16[6];
//  3. 004E 0001 effalign(1) fda=0 bits=0000 per_cpu_pageset.stat_threshold s8;
//  4. 004F 000D effalign(1) fda=0 bits=0000 per_cpu_pageset.vm_stat_diff s8[13];
//          005C unpadded_size
//          0060 effalign(8) sda=0 bits=0000 per_cpu_pageset struct packalign=0

00000028 struct percpu_counter
{
  raw_spinlock_t lock;
  s64 count;
  list_head list;
  s32 *counters;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 percpu_counter.lock raw_spinlock_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 percpu_counter.count s64;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 percpu_counter.list list_head;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 percpu_counter.counters s32 *;
//          0028 effalign(8) sda=0 bits=0000 percpu_counter struct packalign=0

00000038 struct percpu_ref
{
  atomic_long_t count;
  unsigned __int64 percpu_count_ptr;
  percpu_ref_func_t *release;
  percpu_ref_func_t *confirm_switch;
  __int8 force_atomic : 1;
  __int8 allow_reinit : 1;
  callback_head rcu;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 percpu_ref.count atomic_long_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 percpu_ref.percpu_count_ptr unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 percpu_ref.release percpu_ref_func_t *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 percpu_ref.confirm_switch percpu_ref_func_t *;
//  4. 0020. 0 1 effalign(1) fda=0 bits=0000 percpu_ref.force_atomic bi.nbytes=1 S
//  5. 0020. 1 1 effalign(1) fda=0 bits=0000 percpu_ref.allow_reinit bi.nbytes=1 S
//  6. 0028 0010 effalign(8) fda=0 bits=0000 percpu_ref.rcu callback_head;
//          0038 effalign(8) sda=0 bits=0000 percpu_ref struct packalign=0

FFFFFFFF typedef void __cdecl percpu_ref_func_t(percpu_ref *);
00000070 struct percpu_rw_semaphore
{
  rcu_sync rss;
  unsigned int *read_count;
  rw_semaphore rw_sem;
  rcuwait writer;
  int readers_block;
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 percpu_rw_semaphore.rss rcu_sync;
//  1. 0030 0008 effalign(8) fda=0 bits=0000 percpu_rw_semaphore.read_count unsigned int *;
//  2. 0038 0028 effalign(8) fda=0 bits=0000 percpu_rw_semaphore.rw_sem rw_semaphore;
//  3. 0060 0008 effalign(8) fda=0 bits=0000 percpu_rw_semaphore.writer rcuwait;
//  4. 0068 0004 effalign(4) fda=0 bits=0000 percpu_rw_semaphore.readers_block int;
//          006C unpadded_size
//          0070 effalign(8) sda=0 bits=0000 percpu_rw_semaphore struct packalign=0

FFFFFFFF struct perf_event;
FFFFFFFF struct perf_event_context;
00000004 enum perf_event_task_context : __int32
{
  perf_invalid_context = 0xFFFFFFFF,
  perf_hw_context = 0x0,
  perf_sw_context = 0x1,
  perf_nr_task_contexts = 0x2,
};
00000008 struct pfn_t
{
  u64 val;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pfn_t.val u64;
//          0008 effalign(8) sda=0 bits=0000 pfn_t struct packalign=0

0002A200 typedef pglist_data pg_data_t;
00000004 enum pg_level : unsigned __int32
{
  PG_LEVEL_NONE = 0x0,
  PG_LEVEL_4K = 0x1,
  PG_LEVEL_2M = 0x2,
  PG_LEVEL_1G = 0x3,
  PG_LEVEL_512G = 0x4,
  PG_LEVEL_NUM = 0x5,
};
00000008 struct pgd_t
{
  pgdval_t pgd;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pgd_t.pgd pgdval_t;
//          0008 effalign(8) sda=0 bits=0000 pgd_t struct packalign=0

00000004 enum pgdat_flags : unsigned __int32
{
  PGDAT_CONGESTED = 0x0,
  PGDAT_DIRTY = 0x1,
  PGDAT_WRITEBACK = 0x2,
  PGDAT_RECLAIM_LOCKED = 0x3,
};
00000008 typedef unsigned __int64 pgdval_t;
0002A200 struct pglist_data
{
  zone node_zones[5];
  zonelist node_zonelists[2];
  int nr_zones;
  spinlock_t node_size_lock;
  unsigned __int64 node_start_pfn;
  unsigned __int64 node_present_pages;
  unsigned __int64 node_spanned_pages;
  int node_id;
  wait_queue_head_t kswapd_wait;
  wait_queue_head_t pfmemalloc_wait;
  task_struct *kswapd;
  int kswapd_order;
  zone_type kswapd_classzone_idx;
  int kswapd_failures;
  int kcompactd_max_order;
  zone_type kcompactd_classzone_idx;
  wait_queue_head_t kcompactd_wait;
  task_struct *kcompactd;
  unsigned __int64 totalreserve_pages;
  unsigned __int64 min_unmapped_pages;
  unsigned __int64 min_slab_pages;
  spinlock_t lru_lock;
  deferred_split deferred_split_queue;
  lruvec lruvec;
  unsigned __int64 flags;
  per_cpu_nodestat *per_cpu_nodestats;
  atomic_long_t vm_stat[32];
};
//  0. 0000 1F40 effalign(64) fda=0 bits=0000 pglist_data.node_zones zone[5];
//  1. 1F40 28020 effalign(8) fda=0 bits=0000 pglist_data.node_zonelists zonelist[2];
//  2. 29F60 0004 effalign(4) fda=0 bits=0000 pglist_data.nr_zones int;
//  3. 29F64 0004 effalign(4) fda=0 bits=0000 pglist_data.node_size_lock spinlock_t;
//  4. 29F68 0008 effalign(8) fda=0 bits=0000 pglist_data.node_start_pfn unsigned __int64;
//  5. 29F70 0008 effalign(8) fda=0 bits=0000 pglist_data.node_present_pages unsigned __int64;
//  6. 29F78 0008 effalign(8) fda=0 bits=0000 pglist_data.node_spanned_pages unsigned __int64;
//  7. 29F80 0004 effalign(4) fda=0 bits=0000 pglist_data.node_id int;
//  8. 29F88 0018 effalign(8) fda=0 bits=0000 pglist_data.kswapd_wait wait_queue_head_t;
//  9. 29FA0 0018 effalign(8) fda=0 bits=0000 pglist_data.pfmemalloc_wait wait_queue_head_t;
// 10. 29FB8 0008 effalign(8) fda=0 bits=0000 pglist_data.kswapd task_struct *;
// 11. 29FC0 0004 effalign(4) fda=0 bits=0000 pglist_data.kswapd_order int;
// 12. 29FC4 0004 effalign(4) fda=0 bits=0000 pglist_data.kswapd_classzone_idx zone_type;
// 13. 29FC8 0004 effalign(4) fda=0 bits=0000 pglist_data.kswapd_failures int;
// 14. 29FCC 0004 effalign(4) fda=0 bits=0000 pglist_data.kcompactd_max_order int;
// 15. 29FD0 0004 effalign(4) fda=0 bits=0000 pglist_data.kcompactd_classzone_idx zone_type;
// 16. 29FD8 0018 effalign(8) fda=0 bits=0000 pglist_data.kcompactd_wait wait_queue_head_t;
// 17. 29FF0 0008 effalign(8) fda=0 bits=0000 pglist_data.kcompactd task_struct *;
// 18. 29FF8 0008 effalign(8) fda=0 bits=0000 pglist_data.totalreserve_pages unsigned __int64;
// 19. 2A000 0008 effalign(8) fda=0 bits=0000 pglist_data.min_unmapped_pages unsigned __int64;
// 20. 2A008 0008 effalign(8) fda=0 bits=0000 pglist_data.min_slab_pages unsigned __int64;
// 21. 2A010 0004 effalign(4) fda=0 bits=0000 pglist_data.lru_lock spinlock_t;
// 22. 2A018 0020 effalign(8) fda=0 bits=0000 pglist_data.deferred_split_queue deferred_split;
// 23. 2A038 0088 effalign(8) fda=0 bits=0000 pglist_data.lruvec lruvec;
// 24. 2A0C0 0008 effalign(8) fda=0 bits=0000 pglist_data.flags unsigned __int64;
// 25. 2A0C8 0008 effalign(8) fda=0 bits=0000 pglist_data.per_cpu_nodestats per_cpu_nodestat *;
// 26. 2A0D0 0100 effalign(8) fda=0 bits=0000 pglist_data.vm_stat atomic_long_t[32];
//          2A1D0 unpadded_size
//          2A200 effalign(64) sda=0 bits=0000 pglist_data struct packalign=0

00000008 struct pgprot
{
  pgprotval_t pgprot;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pgprot.pgprot pgprotval_t;
//          0008 effalign(8) sda=0 bits=0000 pgprot struct packalign=0

00000008 typedef pgprot pgprot_t;
00000008 typedef unsigned __int64 pgprotval_t;
00000008 typedef page *pgtable_t;
00000004 typedef u32 phandle;
00000008 typedef u64 phys_addr_t;
00000004 typedef u32 phys_cpuid_t;
00001000 struct physid_mask
{
  unsigned __int64 mask[512];
};
//  0. 0000 1000 effalign(8) fda=0 bits=0000 physid_mask.mask unsigned __int64[512];
//          1000 effalign(8) sda=0 bits=0000 physid_mask struct packalign=0

00001000 typedef physid_mask physid_mask_t;
00000060 struct pid
{
  refcount_t count;
  unsigned int level;
  hlist_head tasks[4];
  wait_queue_head_t wait_pidfd;
  callback_head rcu;
  upid numbers[1];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pid.count refcount_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 pid.level unsigned int;
//  2. 0008 0020 effalign(8) fda=0 bits=0000 pid.tasks hlist_head[4];
//  3. 0028 0018 effalign(8) fda=0 bits=0000 pid.wait_pidfd wait_queue_head_t;
//  4. 0040 0010 effalign(8) fda=0 bits=0000 pid.rcu callback_head;
//  5. 0050 0010 effalign(8) fda=0 bits=0000 pid.numbers upid[1];
//          0060 effalign(8) sda=0 bits=0000 pid struct packalign=0

FFFFFFFF struct pid_namespace;
00000004 typedef __kernel_pid_t pid_t;
00000004 enum pid_type : unsigned __int32
{
  PIDTYPE_PID = 0x0,
  PIDTYPE_TGID = 0x1,
  PIDTYPE_PGID = 0x2,
  PIDTYPE_SID = 0x3,
  PIDTYPE_MAX = 0x4,
};
00000000 struct pin_cookie
{
};
//          0000 effalign(1) sda=0 bits=0000 pin_cookie struct packalign=0

FFFFFFFF struct pipe_inode_info;
00000008 struct __attribute__((packed)) pkru_state
{
  u32 pkru;
  u32 pad;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 pkru_state.pkru u32;
//  1. 0004 0004 effalign(1) fda=0 bits=0000 pkru_state.pad u32;
//          0008 effalign(1) sda=0 bits=0040 pkru_state struct packalign=0

FFFFFFFF struct platform_device;
00000020 struct platform_device_id
{
  char name[20];
  kernel_ulong_t driver_data;
};
//  0. 0000 0014 effalign(1) fda=0 bits=0000 platform_device_id.name char[20];
//  1. 0018 0008 effalign(8) fda=0 bits=0000 platform_device_id.driver_data kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 platform_device_id struct packalign=0

00000010 struct plist_head
{
  list_head node_list;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 plist_head.node_list list_head;
//          0010 effalign(8) sda=0 bits=0000 plist_head struct packalign=0

00000028 struct plist_node
{
  int prio;
  list_head prio_list;
  list_head node_list;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 plist_node.prio int;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 plist_node.prio_list list_head;
//  2. 0018 0010 effalign(8) fda=0 bits=0000 plist_node.node_list list_head;
//          0028 effalign(8) sda=0 bits=0000 plist_node struct packalign=0

FFFFFFFF struct pm_domain_data;
00000004 struct pm_message
{
  int event;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pm_message.event int;
//          0004 effalign(4) sda=0 bits=0000 pm_message struct packalign=0

00000004 typedef pm_message pm_message_t;
00000020 struct pm_subsys_data
{
  spinlock_t lock;
  unsigned int refcount;
  list_head clock_list;
  pm_domain_data *domain_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pm_subsys_data.lock spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 pm_subsys_data.refcount unsigned int;
//  2. 0008 0010 effalign(8) fda=0 bits=0000 pm_subsys_data.clock_list list_head;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pm_subsys_data.domain_data pm_domain_data *;
//          0020 effalign(8) sda=0 bits=0000 pm_subsys_data struct packalign=0

00000008 struct pmd_t
{
  pmdval_t pmd;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pmd_t.pmd pmdval_t;
//          0008 effalign(8) sda=0 bits=0000 pmd_t struct packalign=0

00000008 typedef unsigned __int64 pmdval_t;
00000050 struct pnp_card_device_id
{
  __u8 id[8];
  kernel_ulong_t driver_data;
  pnp_card_device_id::$11C29912735D64AF520B68F64BB009C0 devs[8];
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 pnp_card_device_id.id __u8[8];
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pnp_card_device_id.driver_data kernel_ulong_t;
//  2. 0010 0040 effalign(1) fda=0 bits=0000 pnp_card_device_id.devs pnp_card_device_id::$11C29912735D64AF520B68F64BB009C0[8];
//          0050 effalign(8) sda=0 bits=0000 pnp_card_device_id struct packalign=0

00000008 struct pnp_card_device_id::$11C29912735D64AF520B68F64BB009C0
{
  __u8 id[8];
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 pnp_card_device_id::$11C29912735D64AF520B68F64BB009C0.id __u8[8];
//          0008 effalign(1) sda=0 bits=0000 pnp_card_device_id::$11C29912735D64AF520B68F64BB009C0 struct packalign=0

00000010 struct pnp_device_id
{
  __u8 id[8];
  kernel_ulong_t driver_data;
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 pnp_device_id.id __u8[8];
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pnp_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 pnp_device_id struct packalign=0

00000008 typedef void (__cdecl *poll_queue_proc)(file *, wait_queue_head_t *, poll_table_struct *);
00000010 typedef poll_table_struct poll_table;
00000040 struct poll_table_entry
{
  file *filp;
  __poll_t key;
  wait_queue_entry_t wait;
  wait_queue_head_t *wait_address;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 poll_table_entry.filp file *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 poll_table_entry.key __poll_t;
//  2. 0010 0028 effalign(8) fda=0 bits=0000 poll_table_entry.wait wait_queue_entry_t;
//  3. 0038 0008 effalign(8) fda=0 bits=0000 poll_table_entry.wait_address wait_queue_head_t *;
//          0040 effalign(8) sda=0 bits=0000 poll_table_entry struct packalign=0

FFFFFFFF struct poll_table_page;
00000010 struct poll_table_struct
{
  poll_queue_proc _qproc;
  __poll_t _key;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 poll_table_struct._qproc poll_queue_proc;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 poll_table_struct._key __poll_t;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 poll_table_struct struct packalign=0

00000230 struct poll_wqueues
{
  poll_table pt;
  poll_table_page *table;
  task_struct *polling_task;
  int triggered;
  int error;
  int inline_index;
  poll_table_entry inline_entries[8];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 poll_wqueues.pt poll_table;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 poll_wqueues.table poll_table_page *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 poll_wqueues.polling_task task_struct *;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 poll_wqueues.triggered int;
//  4. 0024 0004 effalign(4) fda=0 bits=0000 poll_wqueues.error int;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 poll_wqueues.inline_index int;
//  6. 0030 0200 effalign(8) fda=0 bits=0000 poll_wqueues.inline_entries poll_table_entry[8];
//          0230 effalign(8) sda=0 bits=0000 poll_wqueues struct packalign=0

00000008 struct pollfd
{
  int fd;
  __int16 events;
  __int16 revents;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pollfd.fd int;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 pollfd.events __int16;
//  2. 0006 0002 effalign(2) fda=0 bits=0000 pollfd.revents __int16;
//          0008 effalign(4) sda=0 bits=0000 pollfd struct packalign=0

00000004 enum positive_aop_returns : unsigned __int32
{
  AOP_WRITEPAGE_ACTIVATE = 0x80000,
  AOP_TRUNCATED_PAGE = 0x80001,
};
FFFFFFFF struct posix_acl;
00000018 struct posix_cputimer_base
{
  u64 nextevt;
  timerqueue_head tqhead;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 posix_cputimer_base.nextevt u64;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 posix_cputimer_base.tqhead timerqueue_head;
//          0018 effalign(8) sda=0 bits=0000 posix_cputimer_base struct packalign=0

00000050 struct posix_cputimers
{
  posix_cputimer_base bases[3];
  unsigned int timers_active;
  unsigned int expiry_active;
};
//  0. 0000 0048 effalign(8) fda=0 bits=0000 posix_cputimers.bases posix_cputimer_base[3];
//  1. 0048 0004 effalign(4) fda=0 bits=0000 posix_cputimers.timers_active unsigned int;
//  2. 004C 0004 effalign(4) fda=0 bits=0000 posix_cputimers.expiry_active unsigned int;
//          0050 effalign(8) sda=0 bits=0000 posix_cputimers struct packalign=0

FFFFFFFF struct pr_ops;
00000018 struct preempt_notifier
{
  hlist_node link;
  preempt_ops *ops;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 preempt_notifier.link hlist_node;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 preempt_notifier.ops preempt_ops *;
//          0018 effalign(8) sda=0 bits=0000 preempt_notifier struct packalign=0

00000010 struct preempt_ops
{
  void (__cdecl *sched_in)(preempt_notifier *, int);
  void (__cdecl *sched_out)(preempt_notifier *, task_struct *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 preempt_ops.sched_in void (__cdecl *)(preempt_notifier *, int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 preempt_ops.sched_out void (__cdecl *)(preempt_notifier *, task_struct *);
//          0010 effalign(8) sda=0 bits=0000 preempt_ops struct packalign=0

00000018 struct prev_cputime
{
  u64 utime;
  u64 stime;
  raw_spinlock_t lock;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 prev_cputime.utime u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 prev_cputime.stime u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 prev_cputime.lock raw_spinlock_t;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 prev_cputime struct packalign=0

00000004 enum probe_type : unsigned __int32
{
  PROBE_DEFAULT_STRATEGY = 0x0,
  PROBE_PREFER_ASYNCHRONOUS = 0x1,
  PROBE_FORCE_SYNCHRONOUS = 0x2,
};
FFFFFFFF struct proc_dir_entry;
FFFFFFFF typedef int __cdecl proc_handler(ctl_table *, int, void *, size_t *, loff_t *);
00000008 typedef int (__cdecl *proc_write_t)(file *, char *, size_t);
00000004 typedef __kernel_uid32_t projid_t;
00000020 struct property
{
  char *name;
  int length;
  void *value;
  property *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 property.name char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 property.length int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 property.value void *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 property.next property *;
//          0020 effalign(8) sda=0 bits=0000 property struct packalign=0

00000020 struct property_entry
{
  const char *name;
  size_t length;
  bool is_array;
  dev_prop_type type;
  union
  {
    $3EB18370503AAC13F34FCFCFFC2152CC pointer;
    $D0E43D72358DA8AA2A573F3F4043ED1C value;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 property_entry.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 property_entry.length size_t;
//  2. 0010 0001 effalign(1) fda=0 bits=0000 property_entry.is_array bool;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 property_entry.type dev_prop_type;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 property_entry.property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551 property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551;
//          0020 effalign(8) sda=0 bits=0000 property_entry struct packalign=0

00000008 union property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551
{
  $3EB18370503AAC13F34FCFCFFC2152CC pointer;
  $D0E43D72358DA8AA2A573F3F4043ED1C value;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551.pointer $3EB18370503AAC13F34FCFCFFC2152CC;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551.value $D0E43D72358DA8AA2A573F3F4043ED1C;
//          0008 effalign(8) sda=0 bits=0000 property_entry::$BE1FE8EC63D1BFD48C32FA9D60551551 union packalign=0

00000018 struct pstore_ftrace_record
{
  unsigned __int64 ip;
  unsigned __int64 parent_ip;
  u64 ts;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pstore_ftrace_record.ip unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pstore_ftrace_record.parent_ip unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pstore_ftrace_record.ts u64;
//          0018 effalign(8) sda=0 bits=0000 pstore_ftrace_record struct packalign=0

00000098 struct pstore_info
{
  module *owner;
  char *name;
  semaphore buf_lock;
  char *buf;
  size_t bufsize;
  mutex read_mutex;
  int flags;
  void *data;
  int (__cdecl *open)(pstore_info *);
  int (__cdecl *close)(pstore_info *);
  ssize_t (__cdecl *read)(pstore_record *);
  int (__cdecl *write)(pstore_record *);
  int (__cdecl *write_user)(pstore_record *, const char *);
  int (__cdecl *erase)(pstore_record *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pstore_info.owner module *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pstore_info.name char *;
//  2. 0010 0018 effalign(8) fda=0 bits=0000 pstore_info.buf_lock semaphore;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 pstore_info.buf char *;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 pstore_info.bufsize size_t;
//  5. 0038 0020 effalign(8) fda=0 bits=0000 pstore_info.read_mutex mutex;
//  6. 0058 0004 effalign(4) fda=0 bits=0000 pstore_info.flags int;
//  7. 0060 0008 effalign(8) fda=0 bits=0000 pstore_info.data void *;
//  8. 0068 0008 effalign(8) fda=0 bits=0000 pstore_info.open int (__cdecl *)(pstore_info *);
//  9. 0070 0008 effalign(8) fda=0 bits=0000 pstore_info.close int (__cdecl *)(pstore_info *);
// 10. 0078 0008 effalign(8) fda=0 bits=0000 pstore_info.read ssize_t (__cdecl *)(pstore_record *);
// 11. 0080 0008 effalign(8) fda=0 bits=0000 pstore_info.write int (__cdecl *)(pstore_record *);
// 12. 0088 0008 effalign(8) fda=0 bits=0000 pstore_info.write_user int (__cdecl *)(pstore_record *, const char *);
// 13. 0090 0008 effalign(8) fda=0 bits=0000 pstore_info.erase int (__cdecl *)(pstore_record *);
//          0098 effalign(8) sda=0 bits=0000 pstore_info struct packalign=0

00000050 struct pstore_record
{
  pstore_info *psi;
  pstore_type_id type;
  u64 id;
  timespec64 time;
  char *buf;
  ssize_t size;
  ssize_t ecc_notice_size;
  int count;
  kmsg_dump_reason reason;
  unsigned int part;
  bool compressed;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pstore_record.psi pstore_info *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 pstore_record.type pstore_type_id;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pstore_record.id u64;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 pstore_record.time timespec64;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 pstore_record.buf char *;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 pstore_record.size ssize_t;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 pstore_record.ecc_notice_size ssize_t;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 pstore_record.count int;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 pstore_record.reason kmsg_dump_reason;
//  9. 0048 0004 effalign(4) fda=0 bits=0000 pstore_record.part unsigned int;
// 10. 004C 0001 effalign(1) fda=0 bits=0000 pstore_record.compressed bool;
//          004D unpadded_size
//          0050 effalign(8) sda=0 bits=0000 pstore_record struct packalign=0

00000004 enum pstore_type_id : unsigned __int32
{
  PSTORE_TYPE_DMESG = 0x0,
  PSTORE_TYPE_MCE = 0x1,
  PSTORE_TYPE_CONSOLE = 0x2,
  PSTORE_TYPE_FTRACE = 0x3,
  PSTORE_TYPE_PPC_RTAS = 0x4,
  PSTORE_TYPE_PPC_OF = 0x5,
  PSTORE_TYPE_PPC_COMMON = 0x6,
  PSTORE_TYPE_PMSG = 0x7,
  PSTORE_TYPE_PPC_OPAL = 0x8,
  PSTORE_TYPE_MAX = 0x9,
};
000000A8 struct pt_regs
{
  unsigned __int64 r15;
  unsigned __int64 r14;
  unsigned __int64 r13;
  unsigned __int64 r12;
  unsigned __int64 bp;
  unsigned __int64 bx;
  unsigned __int64 r11;
  unsigned __int64 r10;
  unsigned __int64 r9;
  unsigned __int64 r8;
  unsigned __int64 ax;
  unsigned __int64 cx;
  unsigned __int64 dx;
  unsigned __int64 si;
  unsigned __int64 di;
  unsigned __int64 orig_ax;
  unsigned __int64 ip;
  unsigned __int64 cs;
  unsigned __int64 flags;
  unsigned __int64 sp;
  unsigned __int64 ss;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pt_regs.r15 unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pt_regs.r14 unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pt_regs.r13 unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pt_regs.r12 unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pt_regs.bp unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 pt_regs.bx unsigned __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 pt_regs.r11 unsigned __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 pt_regs.r10 unsigned __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 pt_regs.r9 unsigned __int64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 pt_regs.r8 unsigned __int64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 pt_regs.ax unsigned __int64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 pt_regs.cx unsigned __int64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 pt_regs.dx unsigned __int64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 pt_regs.si unsigned __int64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 pt_regs.di unsigned __int64;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 pt_regs.orig_ax unsigned __int64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 pt_regs.ip unsigned __int64;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 pt_regs.cs unsigned __int64;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 pt_regs.flags unsigned __int64;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 pt_regs.sp unsigned __int64;
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 pt_regs.ss unsigned __int64;
//          00A8 effalign(8) sda=0 bits=0000 pt_regs struct packalign=0

00000008 typedef int (__cdecl *pte_fn_t)(pte_t *, unsigned __int64, void *);
00000008 struct pte_t
{
  pteval_t pte;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pte_t.pte pteval_t;
//          0008 effalign(8) sda=0 bits=0000 pte_t struct packalign=0

00000008 typedef unsigned __int64 pteval_t;
00000008 typedef __kernel_ptrdiff_t ptrdiff_t;
00000008 struct pud_t
{
  pudval_t pud;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pud_t.pud pudval_t;
//          0008 effalign(8) sda=0 bits=0000 pud_t struct packalign=0

00000008 typedef unsigned __int64 pudval_t;
00000100 struct pv_cpu_ops
{
  void (*io_delay)(void);
  unsigned __int64 (__cdecl *get_debugreg)(int);
  void (__cdecl *set_debugreg)(int, unsigned __int64);
  unsigned __int64 (*read_cr0)(void);
  void (__cdecl *write_cr0)(unsigned __int64);
  void (__cdecl *write_cr4)(unsigned __int64);
  void (*load_tr_desc)(void);
  void (__cdecl *load_gdt)(const desc_ptr *);
  void (__cdecl *load_idt)(const desc_ptr *);
  void (__cdecl *set_ldt)(const void *, unsigned int);
  unsigned __int64 (*store_tr)(void);
  void (__cdecl *load_tls)(thread_struct *, unsigned int);
  void (__cdecl *load_gs_index)(unsigned int);
  void (__cdecl *write_ldt_entry)(desc_struct *, int, const void *);
  void (__cdecl *write_gdt_entry)(desc_struct *, int, const void *, int);
  void (__cdecl *write_idt_entry)(gate_desc *, int, const gate_desc *);
  void (__cdecl *alloc_ldt)(desc_struct *, unsigned int);
  void (__cdecl *free_ldt)(desc_struct *, unsigned int);
  void (__cdecl *load_sp0)(unsigned __int64);
  void (__cdecl *set_iopl_mask)(unsigned int);
  void (*wbinvd)(void);
  void (__cdecl *cpuid)(unsigned int *, unsigned int *, unsigned int *, unsigned int *);
  u64 (__cdecl *read_msr)(unsigned int);
  void (__cdecl *write_msr)(unsigned int, unsigned int, unsigned int);
  u64 (__cdecl *read_msr_safe)(unsigned int, int *);
  int (__cdecl *write_msr_safe)(unsigned int, unsigned int, unsigned int);
  u64 (__cdecl *read_pmc)(int);
  void (*usergs_sysret64)(void);
  void (*iret)(void);
  void (*swapgs)(void);
  void (__cdecl *start_context_switch)(task_struct *);
  void (__cdecl *end_context_switch)(task_struct *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.io_delay void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.get_debugreg unsigned __int64 (__cdecl *)(int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.set_debugreg void (__cdecl *)(int, unsigned __int64);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.read_cr0 unsigned __int64 (*)(void);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_cr0 void (__cdecl *)(unsigned __int64);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_cr4 void (__cdecl *)(unsigned __int64);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_tr_desc void (*)(void);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_gdt void (__cdecl *)(const desc_ptr *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_idt void (__cdecl *)(const desc_ptr *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.set_ldt void (__cdecl *)(const void *, unsigned int);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.store_tr unsigned __int64 (*)(void);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_tls void (__cdecl *)(thread_struct *, unsigned int);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_gs_index void (__cdecl *)(unsigned int);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_ldt_entry void (__cdecl *)(desc_struct *, int, const void *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_gdt_entry void (__cdecl *)(desc_struct *, int, const void *, int);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_idt_entry void (__cdecl *)(gate_desc *, int, const gate_desc *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.alloc_ldt void (__cdecl *)(desc_struct *, unsigned int);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.free_ldt void (__cdecl *)(desc_struct *, unsigned int);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.load_sp0 void (__cdecl *)(unsigned __int64);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.set_iopl_mask void (__cdecl *)(unsigned int);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.wbinvd void (*)(void);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.cpuid void (__cdecl *)(unsigned int *, unsigned int *, unsigned int *, unsigned int *);
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.read_msr u64 (__cdecl *)(unsigned int);
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_msr void (__cdecl *)(unsigned int, unsigned int, unsigned int);
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.read_msr_safe u64 (__cdecl *)(unsigned int, int *);
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.write_msr_safe int (__cdecl *)(unsigned int, unsigned int, unsigned int);
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.read_pmc u64 (__cdecl *)(int);
// 27. 00D8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.usergs_sysret64 void (*)(void);
// 28. 00E0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.iret void (*)(void);
// 29. 00E8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.swapgs void (*)(void);
// 30. 00F0 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.start_context_switch void (__cdecl *)(task_struct *);
// 31. 00F8 0008 effalign(8) fda=0 bits=0000 pv_cpu_ops.end_context_switch void (__cdecl *)(task_struct *);
//          0100 effalign(8) sda=0 bits=0000 pv_cpu_ops struct packalign=0

00000018 struct pv_info
{
  unsigned int kernel_rpl;
  int shared_kernel_pmd;
  u16 extra_user_64bit_cs;
  const char *name;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 pv_info.kernel_rpl unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 pv_info.shared_kernel_pmd int;
//  2. 0008 0002 effalign(2) fda=0 bits=0000 pv_info.extra_user_64bit_cs u16;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 pv_info.name const char *;
//          0018 effalign(8) sda=0 bits=0000 pv_info struct packalign=0

00000008 struct pv_init_ops
{
  unsigned int (__cdecl *patch)(u8, void *, unsigned __int64, unsigned int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_init_ops.patch unsigned int (__cdecl *)(u8, void *, unsigned __int64, unsigned int);
//          0008 effalign(8) sda=0 bits=0000 pv_init_ops struct packalign=0

00000030 struct pv_irq_ops
{
  paravirt_callee_save save_fl;
  paravirt_callee_save restore_fl;
  paravirt_callee_save irq_disable;
  paravirt_callee_save irq_enable;
  void (*safe_halt)(void);
  void (*halt)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.save_fl paravirt_callee_save;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.restore_fl paravirt_callee_save;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.irq_disable paravirt_callee_save;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.irq_enable paravirt_callee_save;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.safe_halt void (*)(void);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 pv_irq_ops.halt void (*)(void);
//          0030 effalign(8) sda=0 bits=0000 pv_irq_ops struct packalign=0

00000018 struct pv_lazy_ops
{
  void (*enter)(void);
  void (*leave)(void);
  void (*flush)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_lazy_ops.enter void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_lazy_ops.leave void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pv_lazy_ops.flush void (*)(void);
//          0018 effalign(8) sda=0 bits=0000 pv_lazy_ops struct packalign=0

00000028 struct pv_lock_ops
{
  void (__cdecl *queued_spin_lock_slowpath)(qspinlock *, u32);
  paravirt_callee_save queued_spin_unlock;
  void (__cdecl *wait)(u8 *, u8);
  void (__cdecl *kick)(int);
  paravirt_callee_save vcpu_is_preempted;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_lock_ops.queued_spin_lock_slowpath void (__cdecl *)(qspinlock *, u32);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_lock_ops.queued_spin_unlock paravirt_callee_save;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pv_lock_ops.wait void (__cdecl *)(u8 *, u8);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pv_lock_ops.kick void (__cdecl *)(int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pv_lock_ops.vcpu_is_preempted paravirt_callee_save;
//          0028 effalign(8) sda=0 bits=0000 pv_lock_ops struct packalign=0

00000148 struct pv_mmu_ops
{
  void (*flush_tlb_user)(void);
  void (*flush_tlb_kernel)(void);
  void (__cdecl *flush_tlb_one_user)(unsigned __int64);
  void (__cdecl *flush_tlb_others)(const cpumask *, const flush_tlb_info *);
  void (__cdecl *tlb_remove_table)(mmu_gather *, void *);
  void (__cdecl *exit_mmap)(mm_struct *);
  paravirt_callee_save read_cr2;
  void (__cdecl *write_cr2)(unsigned __int64);
  unsigned __int64 (*read_cr3)(void);
  void (__cdecl *write_cr3)(unsigned __int64);
  void (__cdecl *activate_mm)(mm_struct *, mm_struct *);
  void (__cdecl *dup_mmap)(mm_struct *, mm_struct *);
  int (__cdecl *pgd_alloc)(mm_struct *);
  void (__cdecl *pgd_free)(mm_struct *, pgd_t *);
  void (__cdecl *alloc_pte)(mm_struct *, unsigned __int64);
  void (__cdecl *alloc_pmd)(mm_struct *, unsigned __int64);
  void (__cdecl *alloc_pud)(mm_struct *, unsigned __int64);
  void (__cdecl *alloc_p4d)(mm_struct *, unsigned __int64);
  void (__cdecl *release_pte)(unsigned __int64);
  void (__cdecl *release_pmd)(unsigned __int64);
  void (__cdecl *release_pud)(unsigned __int64);
  void (__cdecl *release_p4d)(unsigned __int64);
  void (__cdecl *set_pte)(pte_t *, pte_t);
  void (__cdecl *set_pte_at)(mm_struct *, unsigned __int64, pte_t *, pte_t);
  void (__cdecl *set_pmd)(pmd_t *, pmd_t);
  pte_t (__cdecl *ptep_modify_prot_start)(vm_area_struct *, unsigned __int64, pte_t *);
  void (__cdecl *ptep_modify_prot_commit)(vm_area_struct *, unsigned __int64, pte_t *, pte_t);
  paravirt_callee_save pte_val;
  paravirt_callee_save make_pte;
  paravirt_callee_save pgd_val;
  paravirt_callee_save make_pgd;
  void (__cdecl *set_pud)(pud_t *, pud_t);
  paravirt_callee_save pmd_val;
  paravirt_callee_save make_pmd;
  paravirt_callee_save pud_val;
  paravirt_callee_save make_pud;
  void (__cdecl *set_p4d)(p4d_t *, p4d_t);
  pv_lazy_ops lazy_mode;
  void (__cdecl *set_fixmap)(unsigned int, phys_addr_t, pgprot_t);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.flush_tlb_user void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.flush_tlb_kernel void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.flush_tlb_one_user void (__cdecl *)(unsigned __int64);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.flush_tlb_others void (__cdecl *)(const cpumask *, const flush_tlb_info *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.tlb_remove_table void (__cdecl *)(mmu_gather *, void *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.exit_mmap void (__cdecl *)(mm_struct *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.read_cr2 paravirt_callee_save;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.write_cr2 void (__cdecl *)(unsigned __int64);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.read_cr3 unsigned __int64 (*)(void);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.write_cr3 void (__cdecl *)(unsigned __int64);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.activate_mm void (__cdecl *)(mm_struct *, mm_struct *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.dup_mmap void (__cdecl *)(mm_struct *, mm_struct *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pgd_alloc int (__cdecl *)(mm_struct *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pgd_free void (__cdecl *)(mm_struct *, pgd_t *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.alloc_pte void (__cdecl *)(mm_struct *, unsigned __int64);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.alloc_pmd void (__cdecl *)(mm_struct *, unsigned __int64);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.alloc_pud void (__cdecl *)(mm_struct *, unsigned __int64);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.alloc_p4d void (__cdecl *)(mm_struct *, unsigned __int64);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.release_pte void (__cdecl *)(unsigned __int64);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.release_pmd void (__cdecl *)(unsigned __int64);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.release_pud void (__cdecl *)(unsigned __int64);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.release_p4d void (__cdecl *)(unsigned __int64);
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_pte void (__cdecl *)(pte_t *, pte_t);
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_pte_at void (__cdecl *)(mm_struct *, unsigned __int64, pte_t *, pte_t);
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_pmd void (__cdecl *)(pmd_t *, pmd_t);
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.ptep_modify_prot_start pte_t (__cdecl *)(vm_area_struct *, unsigned __int64, pte_t *);
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.ptep_modify_prot_commit void (__cdecl *)(vm_area_struct *, unsigned __int64, pte_t *, pte_t);
// 27. 00D8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pte_val paravirt_callee_save;
// 28. 00E0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.make_pte paravirt_callee_save;
// 29. 00E8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pgd_val paravirt_callee_save;
// 30. 00F0 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.make_pgd paravirt_callee_save;
// 31. 00F8 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_pud void (__cdecl *)(pud_t *, pud_t);
// 32. 0100 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pmd_val paravirt_callee_save;
// 33. 0108 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.make_pmd paravirt_callee_save;
// 34. 0110 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.pud_val paravirt_callee_save;
// 35. 0118 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.make_pud paravirt_callee_save;
// 36. 0120 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_p4d void (__cdecl *)(p4d_t *, p4d_t);
// 37. 0128 0018 effalign(8) fda=0 bits=0000 pv_mmu_ops.lazy_mode pv_lazy_ops;
// 38. 0140 0008 effalign(8) fda=0 bits=0000 pv_mmu_ops.set_fixmap void (__cdecl *)(unsigned int, phys_addr_t, pgprot_t);
//          0148 effalign(8) sda=0 bits=0000 pv_mmu_ops struct packalign=0

00000010 struct pv_time_ops
{
  unsigned __int64 (*sched_clock)(void);
  unsigned __int64 (__cdecl *steal_clock)(int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 pv_time_ops.sched_clock unsigned __int64 (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 pv_time_ops.steal_clock unsigned __int64 (__cdecl *)(int);
//          0010 effalign(8) sda=0 bits=0000 pv_time_ops struct packalign=0

00000078 struct qc_dqblk
{
  int d_fieldmask;
  u64 d_spc_hardlimit;
  u64 d_spc_softlimit;
  u64 d_ino_hardlimit;
  u64 d_ino_softlimit;
  u64 d_space;
  u64 d_ino_count;
  s64 d_ino_timer;
  s64 d_spc_timer;
  int d_ino_warns;
  int d_spc_warns;
  u64 d_rt_spc_hardlimit;
  u64 d_rt_spc_softlimit;
  u64 d_rt_space;
  s64 d_rt_spc_timer;
  int d_rt_spc_warns;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qc_dqblk.d_fieldmask int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_spc_hardlimit u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_spc_softlimit u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_ino_hardlimit u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_ino_softlimit u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_space u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_ino_count u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_ino_timer s64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_spc_timer s64;
//  9. 0048 0004 effalign(4) fda=0 bits=0000 qc_dqblk.d_ino_warns int;
// 10. 004C 0004 effalign(4) fda=0 bits=0000 qc_dqblk.d_spc_warns int;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_rt_spc_hardlimit u64;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_rt_spc_softlimit u64;
// 13. 0060 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_rt_space u64;
// 14. 0068 0008 effalign(8) fda=0 bits=0000 qc_dqblk.d_rt_spc_timer s64;
// 15. 0070 0004 effalign(4) fda=0 bits=0000 qc_dqblk.d_rt_spc_warns int;
//          0074 unpadded_size
//          0078 effalign(8) sda=0 bits=0000 qc_dqblk struct packalign=0

00000020 struct qc_info
{
  int i_fieldmask;
  unsigned int i_flags;
  unsigned int i_spc_timelimit;
  unsigned int i_ino_timelimit;
  unsigned int i_rt_spc_timelimit;
  unsigned int i_spc_warnlimit;
  unsigned int i_ino_warnlimit;
  unsigned int i_rt_spc_warnlimit;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qc_info.i_fieldmask int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 qc_info.i_flags unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 qc_info.i_spc_timelimit unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 qc_info.i_ino_timelimit unsigned int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 qc_info.i_rt_spc_timelimit unsigned int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 qc_info.i_spc_warnlimit unsigned int;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 qc_info.i_ino_warnlimit unsigned int;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 qc_info.i_rt_spc_warnlimit unsigned int;
//          0020 effalign(4) sda=0 bits=0000 qc_info struct packalign=0

000000B0 struct qc_state
{
  unsigned int s_incoredqs;
  qc_type_state s_state[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qc_state.s_incoredqs unsigned int;
//  1. 0008 00A8 effalign(8) fda=0 bits=0000 qc_state.s_state qc_type_state[3];
//          00B0 effalign(8) sda=0 bits=0000 qc_state struct packalign=0

00000038 struct qc_type_state
{
  unsigned int flags;
  unsigned int spc_timelimit;
  unsigned int ino_timelimit;
  unsigned int rt_spc_timelimit;
  unsigned int spc_warnlimit;
  unsigned int ino_warnlimit;
  unsigned int rt_spc_warnlimit;
  unsigned __int64 ino;
  blkcnt_t blocks;
  blkcnt_t nextents;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qc_type_state.flags unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 qc_type_state.spc_timelimit unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 qc_type_state.ino_timelimit unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 qc_type_state.rt_spc_timelimit unsigned int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 qc_type_state.spc_warnlimit unsigned int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 qc_type_state.ino_warnlimit unsigned int;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 qc_type_state.rt_spc_warnlimit unsigned int;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 qc_type_state.ino unsigned __int64;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 qc_type_state.blocks blkcnt_t;
//  9. 0030 0008 effalign(8) fda=0 bits=0000 qc_type_state.nextents blkcnt_t;
//          0038 effalign(8) sda=0 bits=0000 qc_type_state struct packalign=0

00000004 typedef __kernel_uid32_t qid_t;
00000008 struct qrwlock
{
  union
  {
    atomic_t cnts;
    struct
    {
      u8 wlocked;
      u8 __lstate[3];
    };
  };
  arch_spinlock_t wait_lock;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qrwlock.qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 qrwlock.wait_lock arch_spinlock_t;
//          0008 effalign(4) sda=0 bits=0000 qrwlock struct packalign=0

00000004 union qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D
{
  atomic_t cnts;
  struct
  {
    u8 wlocked;
    u8 __lstate[3];
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D.cnts atomic_t;
//  1. 0000 0004 effalign(1) fda=0 bits=0000 qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D.$274F6A0FE63D1E8E4D8A716FC38C5A7D $274F6A0FE63D1E8E4D8A716FC38C5A7D;
//          0004 effalign(4) sda=0 bits=0000 qrwlock::$00F34FF4C86DDF52D23EB63F57A5254D union packalign=0

00000008 typedef __int64 qsize_t;
00000004 struct qspinlock
{
  union
  {
    atomic_t val;
    struct
    {
      u8 locked;
      u8 pending;
    };
    struct
    {
      u16 locked_pending;
      u16 tail;
    };
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qspinlock.qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00 qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00;
//          0004 effalign(4) sda=0 bits=0000 qspinlock struct packalign=0

00000004 union qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00
{
  atomic_t val;
  struct
  {
    u8 locked;
    u8 pending;
  };
  struct
  {
    u16 locked_pending;
    u16 tail;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00.val atomic_t;
//  1. 0000 0002 effalign(1) fda=0 bits=0000 qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00.$3846E5716A6A61A346C1663F85F1EE2B $3846E5716A6A61A346C1663F85F1EE2B;
//  2. 0000 0004 effalign(2) fda=0 bits=0000 qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00.$4CE1142269C6BA11D3A4D858343DA2F7 $4CE1142269C6BA11D3A4D858343DA2F7;
//          0004 effalign(4) sda=0 bits=0000 qspinlock::$A4FB9BF9E96ACE3660B0DBA26A0B3F00 union packalign=0

00000010 struct qstr
{
  union
  {
    struct
    {
      u32 hash;
      u32 len;
    };
    u64 hash_len;
  };
  const unsigned __int8 *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 qstr.qstr::$C4B1EAD61BB055FAF3F63F476306DE93 qstr::$C4B1EAD61BB055FAF3F63F476306DE93;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 qstr.name const unsigned __int8 *;
//          0010 effalign(8) sda=0 bits=0000 qstr struct packalign=0

00000008 union qstr::$C4B1EAD61BB055FAF3F63F476306DE93
{
  struct
  {
    u32 hash;
    u32 len;
  };
  u64 hash_len;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 qstr::$C4B1EAD61BB055FAF3F63F476306DE93.$19297B8565531AC76857E0FF223BC140 $19297B8565531AC76857E0FF223BC140;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 qstr::$C4B1EAD61BB055FAF3F63F476306DE93.hash_len u64;
//          0008 effalign(8) sda=0 bits=0000 qstr::$C4B1EAD61BB055FAF3F63F476306DE93 union packalign=0

00000018 struct qtree_fmt_operations
{
  void (__cdecl *mem2disk_dqblk)(void *, dquot *);
  void (__cdecl *disk2mem_dqblk)(dquot *, void *);
  int (__cdecl *is_id)(void *, dquot *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 qtree_fmt_operations.mem2disk_dqblk void (__cdecl *)(void *, dquot *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 qtree_fmt_operations.disk2mem_dqblk void (__cdecl *)(dquot *, void *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 qtree_fmt_operations.is_id int (__cdecl *)(void *, dquot *);
//          0018 effalign(8) sda=0 bits=0000 qtree_fmt_operations struct packalign=0

00000030 struct qtree_mem_dqinfo
{
  super_block *dqi_sb;
  int dqi_type;
  unsigned int dqi_blocks;
  unsigned int dqi_free_blk;
  unsigned int dqi_free_entry;
  unsigned int dqi_blocksize_bits;
  unsigned int dqi_entry_size;
  unsigned int dqi_usable_bs;
  unsigned int dqi_qtree_depth;
  const qtree_fmt_operations *dqi_ops;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 qtree_mem_dqinfo.dqi_sb super_block *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_type int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_blocks unsigned int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_free_blk unsigned int;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_free_entry unsigned int;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_blocksize_bits unsigned int;
//  6. 001C 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_entry_size unsigned int;
//  7. 0020 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_usable_bs unsigned int;
//  8. 0024 0004 effalign(4) fda=0 bits=0000 qtree_mem_dqinfo.dqi_qtree_depth unsigned int;
//  9. 0028 0008 effalign(8) fda=0 bits=0000 qtree_mem_dqinfo.dqi_ops const qtree_fmt_operations *;
//          0030 effalign(8) sda=0 bits=0000 qtree_mem_dqinfo struct packalign=0

00000068 struct queue_limits
{
  unsigned __int64 bounce_pfn;
  unsigned __int64 seg_boundary_mask;
  unsigned __int64 virt_boundary_mask;
  unsigned int max_hw_sectors;
  unsigned int max_dev_sectors;
  unsigned int chunk_sectors;
  unsigned int max_sectors;
  unsigned int max_segment_size;
  unsigned int physical_block_size;
  unsigned int logical_block_size;
  unsigned int alignment_offset;
  unsigned int io_min;
  unsigned int io_opt;
  unsigned int max_discard_sectors;
  unsigned int max_hw_discard_sectors;
  unsigned int max_write_same_sectors;
  unsigned int max_write_zeroes_sectors;
  unsigned int discard_granularity;
  unsigned int discard_alignment;
  unsigned __int16 max_segments;
  unsigned __int16 max_integrity_segments;
  unsigned __int16 max_discard_segments;
  unsigned __int8 misaligned;
  unsigned __int8 discard_misaligned;
  unsigned __int8 raid_partial_stripes_expensive;
  blk_zoned_model zoned;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 queue_limits.bounce_pfn unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 queue_limits.seg_boundary_mask unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 queue_limits.virt_boundary_mask unsigned __int64;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 queue_limits.max_hw_sectors unsigned int;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 queue_limits.max_dev_sectors unsigned int;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 queue_limits.chunk_sectors unsigned int;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 queue_limits.max_sectors unsigned int;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 queue_limits.max_segment_size unsigned int;
//  8. 002C 0004 effalign(4) fda=0 bits=0000 queue_limits.physical_block_size unsigned int;
//  9. 0030 0004 effalign(4) fda=0 bits=0000 queue_limits.logical_block_size unsigned int;
// 10. 0034 0004 effalign(4) fda=0 bits=0000 queue_limits.alignment_offset unsigned int;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 queue_limits.io_min unsigned int;
// 12. 003C 0004 effalign(4) fda=0 bits=0000 queue_limits.io_opt unsigned int;
// 13. 0040 0004 effalign(4) fda=0 bits=0000 queue_limits.max_discard_sectors unsigned int;
// 14. 0044 0004 effalign(4) fda=0 bits=0000 queue_limits.max_hw_discard_sectors unsigned int;
// 15. 0048 0004 effalign(4) fda=0 bits=0000 queue_limits.max_write_same_sectors unsigned int;
// 16. 004C 0004 effalign(4) fda=0 bits=0000 queue_limits.max_write_zeroes_sectors unsigned int;
// 17. 0050 0004 effalign(4) fda=0 bits=0000 queue_limits.discard_granularity unsigned int;
// 18. 0054 0004 effalign(4) fda=0 bits=0000 queue_limits.discard_alignment unsigned int;
// 19. 0058 0002 effalign(2) fda=0 bits=0000 queue_limits.max_segments unsigned __int16;
// 20. 005A 0002 effalign(2) fda=0 bits=0000 queue_limits.max_integrity_segments unsigned __int16;
// 21. 005C 0002 effalign(2) fda=0 bits=0000 queue_limits.max_discard_segments unsigned __int16;
// 22. 005E 0001 effalign(1) fda=0 bits=0000 queue_limits.misaligned unsigned __int8;
// 23. 005F 0001 effalign(1) fda=0 bits=0000 queue_limits.discard_misaligned unsigned __int8;
// 24. 0060 0001 effalign(1) fda=0 bits=0000 queue_limits.raid_partial_stripes_expensive unsigned __int8;
// 25. 0064 0004 effalign(4) fda=0 bits=0000 queue_limits.zoned blk_zoned_model;
//          0068 effalign(8) sda=0 bits=0000 queue_limits struct packalign=0

00000040 struct quota_format_ops
{
  int (__cdecl *check_quota_file)(super_block *, int);
  int (__cdecl *read_file_info)(super_block *, int);
  int (__cdecl *write_file_info)(super_block *, int);
  int (__cdecl *free_file_info)(super_block *, int);
  int (__cdecl *read_dqblk)(dquot *);
  int (__cdecl *commit_dqblk)(dquot *);
  int (__cdecl *release_dqblk)(dquot *);
  int (__cdecl *get_next_id)(super_block *, kqid *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 quota_format_ops.check_quota_file int (__cdecl *)(super_block *, int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 quota_format_ops.read_file_info int (__cdecl *)(super_block *, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 quota_format_ops.write_file_info int (__cdecl *)(super_block *, int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 quota_format_ops.free_file_info int (__cdecl *)(super_block *, int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 quota_format_ops.read_dqblk int (__cdecl *)(dquot *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 quota_format_ops.commit_dqblk int (__cdecl *)(dquot *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 quota_format_ops.release_dqblk int (__cdecl *)(dquot *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 quota_format_ops.get_next_id int (__cdecl *)(super_block *, kqid *);
//          0040 effalign(8) sda=0 bits=0000 quota_format_ops struct packalign=0

00000020 struct quota_format_type
{
  int qf_fmt_id;
  const quota_format_ops *qf_ops;
  module *qf_owner;
  quota_format_type *qf_next;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 quota_format_type.qf_fmt_id int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 quota_format_type.qf_ops const quota_format_ops *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 quota_format_type.qf_owner module *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 quota_format_type.qf_next quota_format_type *;
//          0020 effalign(8) sda=0 bits=0000 quota_format_type struct packalign=0

00000138 struct quota_info
{
  unsigned int flags;
  rw_semaphore dqio_sem;
  inode *files[3];
  mem_dqinfo info[3];
  const quota_format_ops *ops[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 quota_info.flags unsigned int;
//  1. 0008 0028 effalign(8) fda=0 bits=0000 quota_info.dqio_sem rw_semaphore;
//  2. 0030 0018 effalign(8) fda=0 bits=0000 quota_info.files inode *[3];
//  3. 0048 00D8 effalign(8) fda=0 bits=0000 quota_info.info mem_dqinfo[3];
//  4. 0120 0018 effalign(8) fda=0 bits=0000 quota_info.ops const quota_format_ops *[3];
//          0138 effalign(8) sda=0 bits=0000 quota_info struct packalign=0

00000010 struct quota_module_name
{
  int qm_fmt_id;
  char *qm_mod_name;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 quota_module_name.qm_fmt_id int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 quota_module_name.qm_mod_name char *;
//          0010 effalign(8) sda=0 bits=0000 quota_module_name struct packalign=0

00000004 enum quota_type : unsigned __int32
{
  USRQUOTA = 0x0,
  GRPQUOTA = 0x1,
  PRJQUOTA = 0x2,
};
00000058 struct quotactl_ops
{
  int (__cdecl *quota_on)(super_block *, int, int, const path *);
  int (__cdecl *quota_off)(super_block *, int);
  int (__cdecl *quota_enable)(super_block *, unsigned int);
  int (__cdecl *quota_disable)(super_block *, unsigned int);
  int (__cdecl *quota_sync)(super_block *, int);
  int (__cdecl *set_info)(super_block *, int, qc_info *);
  int (__cdecl *get_dqblk)(super_block *, kqid, qc_dqblk *);
  int (__cdecl *get_nextdqblk)(super_block *, kqid *, qc_dqblk *);
  int (__cdecl *set_dqblk)(super_block *, kqid, qc_dqblk *);
  int (__cdecl *get_state)(super_block *, qc_state *);
  int (__cdecl *rm_xquota)(super_block *, unsigned int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 quotactl_ops.quota_on int (__cdecl *)(super_block *, int, int, const path *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 quotactl_ops.quota_off int (__cdecl *)(super_block *, int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 quotactl_ops.quota_enable int (__cdecl *)(super_block *, unsigned int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 quotactl_ops.quota_disable int (__cdecl *)(super_block *, unsigned int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 quotactl_ops.quota_sync int (__cdecl *)(super_block *, int);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 quotactl_ops.set_info int (__cdecl *)(super_block *, int, qc_info *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 quotactl_ops.get_dqblk int (__cdecl *)(super_block *, kqid, qc_dqblk *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 quotactl_ops.get_nextdqblk int (__cdecl *)(super_block *, kqid *, qc_dqblk *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 quotactl_ops.set_dqblk int (__cdecl *)(super_block *, kqid, qc_dqblk *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 quotactl_ops.get_state int (__cdecl *)(super_block *, qc_state *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 quotactl_ops.rm_xquota int (__cdecl *)(super_block *, unsigned int);
//          0058 effalign(8) sda=0 bits=0000 quotactl_ops struct packalign=0

00000020 struct radix_tree_iter
{
  unsigned __int64 index;
  unsigned __int64 next_index;
  unsigned __int64 tags;
  xa_node *node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 radix_tree_iter.index unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 radix_tree_iter.next_index unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 radix_tree_iter.tags unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 radix_tree_iter.node xa_node *;
//          0020 effalign(8) sda=0 bits=0000 radix_tree_iter struct packalign=0

00000010 struct range
{
  u64 start;
  u64 end;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 range.start u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 range.end u64;
//          0010 effalign(8) sda=0 bits=0000 range struct packalign=0

00000028 struct ratelimit_state
{
  raw_spinlock_t lock;
  int interval;
  int burst;
  int printed;
  int missed;
  unsigned __int64 begin;
  unsigned __int64 flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ratelimit_state.lock raw_spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 ratelimit_state.interval int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 ratelimit_state.burst int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 ratelimit_state.printed int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 ratelimit_state.missed int;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 ratelimit_state.begin unsigned __int64;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 ratelimit_state.flags unsigned __int64;
//          0028 effalign(8) sda=0 bits=0000 ratelimit_state struct packalign=0

00000008 struct raw_notifier_head
{
  notifier_block *head;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 raw_notifier_head.head notifier_block *;
//          0008 effalign(8) sda=0 bits=0000 raw_notifier_head struct packalign=0

00000004 struct raw_spinlock
{
  arch_spinlock_t raw_lock;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 raw_spinlock.raw_lock arch_spinlock_t;
//          0004 effalign(4) sda=0 bits=0000 raw_spinlock struct packalign=0

00000004 typedef raw_spinlock raw_spinlock_t;
00000018 struct __attribute__((aligned(8))) rb_node
{
  unsigned __int64 __rb_parent_color;
  rb_node *rb_right;
  rb_node *rb_left;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rb_node.__rb_parent_color unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rb_node.rb_right rb_node *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 rb_node.rb_left rb_node *;
//          0018 effalign(8) sda=4 bits=0000 rb_node struct packalign=0

00000008 struct rb_root
{
  rb_node *rb_node;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rb_root.rb_node rb_node *;
//          0008 effalign(8) sda=0 bits=0000 rb_root struct packalign=0

00000010 struct rb_root_cached
{
  rb_root rb_root;
  rb_node *rb_leftmost;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rb_root_cached.rb_root rb_root;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rb_root_cached.rb_leftmost rb_node *;
//          0010 effalign(8) sda=0 bits=0000 rb_root_cached struct packalign=0

00000008 typedef void (__cdecl *rcu_callback_t)(callback_head *);
00000020 struct rcu_cblist
{
  callback_head *head;
  callback_head **tail;
  __int64 len;
  __int64 len_lazy;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rcu_cblist.head callback_head *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rcu_cblist.tail callback_head **;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 rcu_cblist.len __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 rcu_cblist.len_lazy __int64;
//          0020 effalign(8) sda=0 bits=0000 rcu_cblist struct packalign=0

FFFFFFFF struct rcu_node;
00000060 struct rcu_segcblist
{
  callback_head *head;
  callback_head **tails[4];
  unsigned __int64 gp_seq[4];
  __int64 len;
  __int64 len_lazy;
  u8 enabled;
  u8 offloaded;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rcu_segcblist.head callback_head *;
//  1. 0008 0020 effalign(8) fda=0 bits=0000 rcu_segcblist.tails callback_head **[4];
//  2. 0028 0020 effalign(8) fda=0 bits=0000 rcu_segcblist.gp_seq unsigned __int64[4];
//  3. 0048 0008 effalign(8) fda=0 bits=0000 rcu_segcblist.len __int64;
//  4. 0050 0008 effalign(8) fda=0 bits=0000 rcu_segcblist.len_lazy __int64;
//  5. 0058 0001 effalign(1) fda=0 bits=0000 rcu_segcblist.enabled u8;
//  6. 0059 0001 effalign(1) fda=0 bits=0000 rcu_segcblist.offloaded u8;
//          005A unpadded_size
//          0060 effalign(8) sda=0 bits=0000 rcu_segcblist struct packalign=0

00000004 union rcu_special
{
  rcu_special::$CE3F10EDFF518B02410FEFBE7852548E b;
  u32 s;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 rcu_special.b rcu_special::$CE3F10EDFF518B02410FEFBE7852548E;
//  1. 0000 0004 effalign(4) fda=0 bits=0000 rcu_special.s u32;
//          0004 effalign(4) sda=0 bits=0000 rcu_special union packalign=0

00000004 struct rcu_special::$CE3F10EDFF518B02410FEFBE7852548E
{
  u8 blocked;
  u8 need_qs;
  u8 exp_hint;
  u8 deferred_qs;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 rcu_special::$CE3F10EDFF518B02410FEFBE7852548E.blocked u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 rcu_special::$CE3F10EDFF518B02410FEFBE7852548E.need_qs u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 rcu_special::$CE3F10EDFF518B02410FEFBE7852548E.exp_hint u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 rcu_special::$CE3F10EDFF518B02410FEFBE7852548E.deferred_qs u8;
//          0004 effalign(1) sda=0 bits=0000 rcu_special::$CE3F10EDFF518B02410FEFBE7852548E struct packalign=0

00000030 struct rcu_sync
{
  int gp_state;
  int gp_count;
  wait_queue_head_t gp_wait;
  callback_head cb_head;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 rcu_sync.gp_state int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 rcu_sync.gp_count int;
//  2. 0008 0018 effalign(8) fda=0 bits=0000 rcu_sync.gp_wait wait_queue_head_t;
//  3. 0020 0010 effalign(8) fda=0 bits=0000 rcu_sync.cb_head callback_head;
//          0030 effalign(8) sda=0 bits=0000 rcu_sync struct packalign=0

00000038 struct rcu_work
{
  work_struct work;
  callback_head rcu;
  workqueue_struct *wq;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 rcu_work.work work_struct;
//  1. 0020 0010 effalign(8) fda=0 bits=0000 rcu_work.rcu callback_head;
//  2. 0030 0008 effalign(8) fda=0 bits=0000 rcu_work.wq workqueue_struct *;
//          0038 effalign(8) sda=0 bits=0000 rcu_work struct packalign=0

00000008 struct rcuwait
{
  task_struct *task;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rcuwait.task task_struct *;
//          0008 effalign(8) sda=0 bits=0000 rcuwait struct packalign=0

00000008 typedef int (__cdecl *read_actor_t)(read_descriptor_t *, page *, unsigned __int64, unsigned __int64);
00000020 struct read_descriptor_t
{
  size_t written;
  size_t count;
  read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E arg;
  int error;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 read_descriptor_t.written size_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 read_descriptor_t.count size_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 read_descriptor_t.arg read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 read_descriptor_t.error int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 read_descriptor_t struct packalign=0

00000008 union read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E
{
  char *buf;
  void *data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E.buf char *;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E.data void *;
//          0008 effalign(8) sda=0 bits=0000 read_descriptor_t::$C45F8DC4C32DA2CBAA0A747F9EC3922E union packalign=0

00000024 struct real_mode_header
{
  u32 text_start;
  u32 ro_end;
  u32 trampoline_start;
  u32 trampoline_header;
  u32 trampoline_pgd;
  u32 wakeup_start;
  u32 wakeup_header;
  u32 machine_real_restart_asm;
  u32 machine_real_restart_seg;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 real_mode_header.text_start u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 real_mode_header.ro_end u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 real_mode_header.trampoline_start u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 real_mode_header.trampoline_header u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 real_mode_header.trampoline_pgd u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 real_mode_header.wakeup_start u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 real_mode_header.wakeup_header u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 real_mode_header.machine_real_restart_asm u32;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 real_mode_header.machine_real_restart_seg u32;
//          0024 effalign(4) sda=0 bits=0000 real_mode_header struct packalign=0

00000004 enum reboot_mode : __int32
{
  REBOOT_UNDEFINED = 0xFFFFFFFF,
  REBOOT_COLD = 0x0,
  REBOOT_WARM = 0x1,
  REBOOT_HARD = 0x2,
  REBOOT_SOFT = 0x3,
  REBOOT_GPIO = 0x4,
};
00000004 enum reboot_type : unsigned __int32
{
  BOOT_TRIPLE = 0x74,
  BOOT_KBD = 0x6B,
  BOOT_BIOS = 0x62,
  BOOT_ACPI = 0x61,
  BOOT_EFI = 0x65,
  BOOT_CF9_FORCE = 0x70,
  BOOT_CF9_SAFE = 0x71,
};
00000024 struct reclaim_stat
{
  unsigned int nr_dirty;
  unsigned int nr_unqueued_dirty;
  unsigned int nr_congested;
  unsigned int nr_writeback;
  unsigned int nr_immediate;
  unsigned int nr_activate[2];
  unsigned int nr_ref_keep;
  unsigned int nr_unmap_fail;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_dirty unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_unqueued_dirty unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_congested unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_writeback unsigned int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_immediate unsigned int;
//  5. 0014 0008 effalign(4) fda=0 bits=0000 reclaim_stat.nr_activate unsigned int[2];
//  6. 001C 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_ref_keep unsigned int;
//  7. 0020 0004 effalign(4) fda=0 bits=0000 reclaim_stat.nr_unmap_fail unsigned int;
//          0024 effalign(4) sda=0 bits=0000 reclaim_stat struct packalign=0

FFFFFFFF struct reclaim_state;
00000004 enum refcount_saturation_type : unsigned __int32
{
  REFCOUNT_ADD_NOT_ZERO_OVF = 0x0,
  REFCOUNT_ADD_OVF = 0x1,
  REFCOUNT_ADD_UAF = 0x2,
  REFCOUNT_SUB_UAF = 0x3,
  REFCOUNT_DEC_LEAK = 0x4,
};
00000004 struct refcount_struct
{
  atomic_t refs;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 refcount_struct.refs atomic_t;
//          0004 effalign(4) sda=0 bits=0000 refcount_struct struct packalign=0

00000004 typedef refcount_struct refcount_t;
00000010 struct reg_128_bit
{
  u8 regbytes[16];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 reg_128_bit.regbytes u8[16];
//          0010 effalign(1) sda=0 bits=0000 reg_128_bit struct packalign=0

00000020 struct reg_256_bit
{
  u8 regbytes[32];
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 reg_256_bit.regbytes u8[32];
//          0020 effalign(1) sda=0 bits=0000 reg_256_bit struct packalign=0

00000040 struct reg_512_bit
{
  u8 regbytes[64];
};
//  0. 0000 0040 effalign(1) fda=0 bits=0000 reg_512_bit.regbytes u8[64];
//          0040 effalign(1) sda=0 bits=0000 reg_512_bit struct packalign=0

00000004 enum req_flag_bits : unsigned __int32
{
  __REQ_FAILFAST_DEV = 0x8,
  __REQ_FAILFAST_TRANSPORT = 0x9,
  __REQ_FAILFAST_DRIVER = 0xA,
  __REQ_SYNC = 0xB,
  __REQ_META = 0xC,
  __REQ_PRIO = 0xD,
  __REQ_NOMERGE = 0xE,
  __REQ_IDLE = 0xF,
  __REQ_INTEGRITY = 0x10,
  __REQ_FUA = 0x11,
  __REQ_PREFLUSH = 0x12,
  __REQ_RAHEAD = 0x13,
  __REQ_BACKGROUND = 0x14,
  __REQ_NOWAIT = 0x15,
  __REQ_NOWAIT_INLINE = 0x16,
  __REQ_CGROUP_PUNT = 0x17,
  __REQ_NOUNMAP = 0x18,
  __REQ_HIPRI = 0x19,
  __REQ_DRV = 0x1A,
  __REQ_SWAP = 0x1B,
  __REQ_NR_BITS = 0x1C,
};
00000004 typedef __u32 req_flags_t;
00000020 struct req_iterator
{
  bvec_iter iter;
  bio *bio;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 req_iterator.iter bvec_iter;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 req_iterator.bio bio *;
//          0020 effalign(8) sda=0 bits=0000 req_iterator struct packalign=0

00000004 enum req_opf : unsigned __int32
{
  REQ_OP_READ = 0x0,
  REQ_OP_WRITE = 0x1,
  REQ_OP_FLUSH = 0x2,
  REQ_OP_DISCARD = 0x3,
  REQ_OP_SECURE_ERASE = 0x5,
  REQ_OP_ZONE_RESET = 0x6,
  REQ_OP_WRITE_SAME = 0x7,
  REQ_OP_ZONE_RESET_ALL = 0x8,
  REQ_OP_WRITE_ZEROES = 0x9,
  REQ_OP_SCSI_IN = 0x20,
  REQ_OP_SCSI_OUT = 0x21,
  REQ_OP_DRV_IN = 0x22,
  REQ_OP_DRV_OUT = 0x23,
  REQ_OP_LAST = 0x24,
};
00000120 struct request
{
  request_queue *q;
  blk_mq_ctx *mq_ctx;
  blk_mq_hw_ctx *mq_hctx;
  unsigned int cmd_flags;
  req_flags_t rq_flags;
  int tag;
  int internal_tag;
  unsigned int __data_len;
  sector_t __sector;
  bio *bio;
  bio *biotail;
  list_head queuelist;
  union
  {
    hlist_node hash;
    list_head ipi_list;
  };
  union
  {
    rb_node rb_node;
    bio_vec special_vec;
    void *completion_data;
    int error_count;
  };
  union
  {
    $AB2BA2D8FED8EF3F1B006727337A4822 elv;
    $EA376F78C5A06A542D2A89563F183819 flush;
  };
  gendisk *rq_disk;
  hd_struct *part;
  u64 alloc_time_ns;
  u64 start_time_ns;
  u64 io_start_time_ns;
  unsigned __int16 wbt_flags;
  unsigned __int16 stats_sectors;
  unsigned __int16 nr_phys_segments;
  unsigned __int16 nr_integrity_segments;
  unsigned __int16 write_hint;
  unsigned __int16 ioprio;
  unsigned int extra_len;
  mq_rq_state state;
  refcount_t ref;
  unsigned int timeout;
  unsigned __int64 deadline;
  union
  {
    __call_single_data csd;
    u64 fifo_time;
  };
  rq_end_io_fn *end_io;
  void *end_io_data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 request.q request_queue *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 request.mq_ctx blk_mq_ctx *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 request.mq_hctx blk_mq_hw_ctx *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 request.cmd_flags unsigned int;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 request.rq_flags req_flags_t;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 request.tag int;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 request.internal_tag int;
//  7. 0028 0004 effalign(4) fda=0 bits=0000 request.__data_len unsigned int;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 request.__sector sector_t;
//  9. 0038 0008 effalign(8) fda=0 bits=0000 request.bio bio *;
// 10. 0040 0008 effalign(8) fda=0 bits=0000 request.biotail bio *;
// 11. 0048 0010 effalign(8) fda=0 bits=0000 request.queuelist list_head;
// 12. 0058 0010 effalign(8) fda=0 bits=0000 request.request::$51B38C5E08116D748A2BF2F5CCD880DD request::$51B38C5E08116D748A2BF2F5CCD880DD;
// 13. 0068 0018 effalign(8) fda=0 bits=0000 request.request::$DD4EB90F5765FB106091699E3BB9BCB6 request::$DD4EB90F5765FB106091699E3BB9BCB6;
// 14. 0080 0020 effalign(8) fda=0 bits=0000 request.request::$FA5188834C107933A09ABD68BBA3493C request::$FA5188834C107933A09ABD68BBA3493C;
// 15. 00A0 0008 effalign(8) fda=0 bits=0000 request.rq_disk gendisk *;
// 16. 00A8 0008 effalign(8) fda=0 bits=0000 request.part hd_struct *;
// 17. 00B0 0008 effalign(8) fda=0 bits=0000 request.alloc_time_ns u64;
// 18. 00B8 0008 effalign(8) fda=0 bits=0000 request.start_time_ns u64;
// 19. 00C0 0008 effalign(8) fda=0 bits=0000 request.io_start_time_ns u64;
// 20. 00C8 0002 effalign(2) fda=0 bits=0000 request.wbt_flags unsigned __int16;
// 21. 00CA 0002 effalign(2) fda=0 bits=0000 request.stats_sectors unsigned __int16;
// 22. 00CC 0002 effalign(2) fda=0 bits=0000 request.nr_phys_segments unsigned __int16;
// 23. 00CE 0002 effalign(2) fda=0 bits=0000 request.nr_integrity_segments unsigned __int16;
// 24. 00D0 0002 effalign(2) fda=0 bits=0000 request.write_hint unsigned __int16;
// 25. 00D2 0002 effalign(2) fda=0 bits=0000 request.ioprio unsigned __int16;
// 26. 00D4 0004 effalign(4) fda=0 bits=0000 request.extra_len unsigned int;
// 27. 00D8 0004 effalign(4) fda=0 bits=0000 request.state mq_rq_state;
// 28. 00DC 0004 effalign(4) fda=0 bits=0000 request.ref refcount_t;
// 29. 00E0 0004 effalign(4) fda=0 bits=0000 request.timeout unsigned int;
// 30. 00E8 0008 effalign(8) fda=0 bits=0000 request.deadline unsigned __int64;
// 31. 00F0 0020 effalign(8) fda=0 bits=0000 request.request::$C4F9A3A9D9ADB7E718CD38F94A659173 request::$C4F9A3A9D9ADB7E718CD38F94A659173;
// 32. 0110 0008 effalign(8) fda=0 bits=0000 request.end_io rq_end_io_fn *;
// 33. 0118 0008 effalign(8) fda=0 bits=0000 request.end_io_data void *;
//          0120 effalign(8) sda=0 bits=0000 request struct packalign=0

00000010 union request::$51B38C5E08116D748A2BF2F5CCD880DD
{
  hlist_node hash;
  list_head ipi_list;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 request::$51B38C5E08116D748A2BF2F5CCD880DD.hash hlist_node;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 request::$51B38C5E08116D748A2BF2F5CCD880DD.ipi_list list_head;
//          0010 effalign(8) sda=0 bits=0000 request::$51B38C5E08116D748A2BF2F5CCD880DD union packalign=0

00000020 union request::$C4F9A3A9D9ADB7E718CD38F94A659173
{
  __call_single_data csd;
  u64 fifo_time;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 request::$C4F9A3A9D9ADB7E718CD38F94A659173.csd __call_single_data;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 request::$C4F9A3A9D9ADB7E718CD38F94A659173.fifo_time u64;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 request::$C4F9A3A9D9ADB7E718CD38F94A659173 union packalign=0

00000018 union request::$DD4EB90F5765FB106091699E3BB9BCB6
{
  rb_node rb_node;
  bio_vec special_vec;
  void *completion_data;
  int error_count;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 request::$DD4EB90F5765FB106091699E3BB9BCB6.rb_node rb_node;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 request::$DD4EB90F5765FB106091699E3BB9BCB6.special_vec bio_vec;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 request::$DD4EB90F5765FB106091699E3BB9BCB6.completion_data void *;
//  3. 0000 0004 effalign(4) fda=0 bits=0000 request::$DD4EB90F5765FB106091699E3BB9BCB6.error_count int;
//          0018 effalign(8) sda=0 bits=0000 request::$DD4EB90F5765FB106091699E3BB9BCB6 union packalign=0

00000020 union request::$FA5188834C107933A09ABD68BBA3493C
{
  $AB2BA2D8FED8EF3F1B006727337A4822 elv;
  $EA376F78C5A06A542D2A89563F183819 flush;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 request::$FA5188834C107933A09ABD68BBA3493C.elv $AB2BA2D8FED8EF3F1B006727337A4822;
//  1. 0000 0020 effalign(8) fda=0 bits=0000 request::$FA5188834C107933A09ABD68BBA3493C.flush $EA376F78C5A06A542D2A89563F183819;
//          0020 effalign(8) sda=0 bits=0000 request::$FA5188834C107933A09ABD68BBA3493C union packalign=0

00000838 struct request_queue
{
  request *last_merge;
  elevator_queue *elevator;
  blk_queue_stats *stats;
  rq_qos *rq_qos;
  make_request_fn *make_request_fn;
  dma_drain_needed_fn *dma_drain_needed;
  const blk_mq_ops *mq_ops;
  blk_mq_ctx *queue_ctx;
  unsigned int nr_queues;
  unsigned int queue_depth;
  blk_mq_hw_ctx **queue_hw_ctx;
  unsigned int nr_hw_queues;
  backing_dev_info *backing_dev_info;
  void *queuedata;
  unsigned __int64 queue_flags;
  atomic_t pm_only;
  int id;
  gfp_t bounce_gfp;
  spinlock_t queue_lock;
  kobject kobj;
  kobject *mq_kobj;
  blk_integrity integrity;
  device *dev;
  int rpm_status;
  unsigned int nr_pending;
  unsigned __int64 nr_requests;
  unsigned int dma_drain_size;
  void *dma_drain_buffer;
  unsigned int dma_pad_mask;
  unsigned int dma_alignment;
  unsigned int rq_timeout;
  int poll_nsec;
  blk_stat_callback *poll_cb;
  blk_rq_stat poll_stat[16];
  timer_list timeout;
  work_struct timeout_work;
  list_head icq_list;
  unsigned __int64 blkcg_pols[1];
  blkcg_gq *root_blkg;
  list_head blkg_list;
  queue_limits limits;
  unsigned int required_elevator_features;
  unsigned int nr_zones;
  unsigned __int64 *seq_zones_bitmap;
  unsigned __int64 *seq_zones_wlock;
  unsigned int sg_timeout;
  unsigned int sg_reserved_size;
  int node;
  blk_trace *blk_trace;
  mutex blk_trace_mutex;
  blk_flush_queue *fq;
  list_head requeue_list;
  spinlock_t requeue_lock;
  delayed_work requeue_work;
  mutex sysfs_lock;
  mutex sysfs_dir_lock;
  list_head unused_hctx_list;
  spinlock_t unused_hctx_lock;
  int mq_freeze_depth;
  bsg_class_device bsg_dev;
  throtl_data *td;
  callback_head callback_head;
  wait_queue_head_t mq_freeze_wq;
  mutex mq_freeze_lock;
  percpu_ref q_usage_counter;
  blk_mq_tag_set *tag_set;
  list_head tag_set_list;
  bio_set bio_split;
  dentry *debugfs_dir;
  dentry *sched_debugfs_dir;
  dentry *rqos_debugfs_dir;
  bool mq_sysfs_init_done;
  size_t cmd_size;
  work_struct release_work;
  u64 write_hints[5];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 request_queue.last_merge request *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 request_queue.elevator elevator_queue *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 request_queue.stats blk_queue_stats *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 request_queue.rq_qos rq_qos *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 request_queue.make_request_fn make_request_fn *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 request_queue.dma_drain_needed dma_drain_needed_fn *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 request_queue.mq_ops const blk_mq_ops *;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 request_queue.queue_ctx blk_mq_ctx *;
//  8. 0040 0004 effalign(4) fda=0 bits=0000 request_queue.nr_queues unsigned int;
//  9. 0044 0004 effalign(4) fda=0 bits=0000 request_queue.queue_depth unsigned int;
// 10. 0048 0008 effalign(8) fda=0 bits=0000 request_queue.queue_hw_ctx blk_mq_hw_ctx **;
// 11. 0050 0004 effalign(4) fda=0 bits=0000 request_queue.nr_hw_queues unsigned int;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 request_queue.backing_dev_info backing_dev_info *;
// 13. 0060 0008 effalign(8) fda=0 bits=0000 request_queue.queuedata void *;
// 14. 0068 0008 effalign(8) fda=0 bits=0000 request_queue.queue_flags unsigned __int64;
// 15. 0070 0004 effalign(4) fda=0 bits=0000 request_queue.pm_only atomic_t;
// 16. 0074 0004 effalign(4) fda=0 bits=0000 request_queue.id int;
// 17. 0078 0004 effalign(4) fda=0 bits=0000 request_queue.bounce_gfp gfp_t;
// 18. 007C 0004 effalign(4) fda=0 bits=0000 request_queue.queue_lock spinlock_t;
// 19. 0080 0040 effalign(8) fda=0 bits=0000 request_queue.kobj kobject;
// 20. 00C0 0008 effalign(8) fda=0 bits=0000 request_queue.mq_kobj kobject *;
// 21. 00C8 0010 effalign(8) fda=0 bits=0000 request_queue.integrity blk_integrity;
// 22. 00D8 0008 effalign(8) fda=0 bits=0000 request_queue.dev device *;
// 23. 00E0 0004 effalign(4) fda=0 bits=0000 request_queue.rpm_status int;
// 24. 00E4 0004 effalign(4) fda=0 bits=0000 request_queue.nr_pending unsigned int;
// 25. 00E8 0008 effalign(8) fda=0 bits=0000 request_queue.nr_requests unsigned __int64;
// 26. 00F0 0004 effalign(4) fda=0 bits=0000 request_queue.dma_drain_size unsigned int;
// 27. 00F8 0008 effalign(8) fda=0 bits=0000 request_queue.dma_drain_buffer void *;
// 28. 0100 0004 effalign(4) fda=0 bits=0000 request_queue.dma_pad_mask unsigned int;
// 29. 0104 0004 effalign(4) fda=0 bits=0000 request_queue.dma_alignment unsigned int;
// 30. 0108 0004 effalign(4) fda=0 bits=0000 request_queue.rq_timeout unsigned int;
// 31. 010C 0004 effalign(4) fda=0 bits=0000 request_queue.poll_nsec int;
// 32. 0110 0008 effalign(8) fda=0 bits=0000 request_queue.poll_cb blk_stat_callback *;
// 33. 0118 0280 effalign(8) fda=0 bits=0000 request_queue.poll_stat blk_rq_stat[16];
// 34. 0398 0028 effalign(8) fda=0 bits=0000 request_queue.timeout timer_list;
// 35. 03C0 0020 effalign(8) fda=0 bits=0000 request_queue.timeout_work work_struct;
// 36. 03E0 0010 effalign(8) fda=0 bits=0000 request_queue.icq_list list_head;
// 37. 03F0 0008 effalign(8) fda=0 bits=0000 request_queue.blkcg_pols unsigned __int64[1];
// 38. 03F8 0008 effalign(8) fda=0 bits=0000 request_queue.root_blkg blkcg_gq *;
// 39. 0400 0010 effalign(8) fda=0 bits=0000 request_queue.blkg_list list_head;
// 40. 0410 0068 effalign(8) fda=0 bits=0000 request_queue.limits queue_limits;
// 41. 0478 0004 effalign(4) fda=0 bits=0000 request_queue.required_elevator_features unsigned int;
// 42. 047C 0004 effalign(4) fda=0 bits=0000 request_queue.nr_zones unsigned int;
// 43. 0480 0008 effalign(8) fda=0 bits=0000 request_queue.seq_zones_bitmap unsigned __int64 *;
// 44. 0488 0008 effalign(8) fda=0 bits=0000 request_queue.seq_zones_wlock unsigned __int64 *;
// 45. 0490 0004 effalign(4) fda=0 bits=0000 request_queue.sg_timeout unsigned int;
// 46. 0494 0004 effalign(4) fda=0 bits=0000 request_queue.sg_reserved_size unsigned int;
// 47. 0498 0004 effalign(4) fda=0 bits=0000 request_queue.node int;
// 48. 04A0 0008 effalign(8) fda=0 bits=0000 request_queue.blk_trace blk_trace *;
// 49. 04A8 0020 effalign(8) fda=0 bits=0000 request_queue.blk_trace_mutex mutex;
// 50. 04C8 0008 effalign(8) fda=0 bits=0000 request_queue.fq blk_flush_queue *;
// 51. 04D0 0010 effalign(8) fda=0 bits=0000 request_queue.requeue_list list_head;
// 52. 04E0 0004 effalign(4) fda=0 bits=0000 request_queue.requeue_lock spinlock_t;
// 53. 04E8 0058 effalign(8) fda=0 bits=0000 request_queue.requeue_work delayed_work;
// 54. 0540 0020 effalign(8) fda=0 bits=0000 request_queue.sysfs_lock mutex;
// 55. 0560 0020 effalign(8) fda=0 bits=0000 request_queue.sysfs_dir_lock mutex;
// 56. 0580 0010 effalign(8) fda=0 bits=0000 request_queue.unused_hctx_list list_head;
// 57. 0590 0004 effalign(4) fda=0 bits=0000 request_queue.unused_hctx_lock spinlock_t;
// 58. 0594 0004 effalign(4) fda=0 bits=0000 request_queue.mq_freeze_depth int;
// 59. 0598 0020 effalign(8) fda=0 bits=0000 request_queue.bsg_dev bsg_class_device;
// 60. 05B8 0008 effalign(8) fda=0 bits=0000 request_queue.td throtl_data *;
// 61. 05C0 0010 effalign(8) fda=0 bits=0000 request_queue.callback_head callback_head;
// 62. 05D0 0018 effalign(8) fda=0 bits=0000 request_queue.mq_freeze_wq wait_queue_head_t;
// 63. 05E8 0020 effalign(8) fda=0 bits=0000 request_queue.mq_freeze_lock mutex;
// 64. 0608 0038 effalign(8) fda=0 bits=0000 request_queue.q_usage_counter percpu_ref;
// 65. 0640 0008 effalign(8) fda=0 bits=0000 request_queue.tag_set blk_mq_tag_set *;
// 66. 0648 0010 effalign(8) fda=0 bits=0000 request_queue.tag_set_list list_head;
// 67. 0658 0170 effalign(8) fda=0 bits=0000 request_queue.bio_split bio_set;
// 68. 07C8 0008 effalign(8) fda=0 bits=0000 request_queue.debugfs_dir dentry *;
// 69. 07D0 0008 effalign(8) fda=0 bits=0000 request_queue.sched_debugfs_dir dentry *;
// 70. 07D8 0008 effalign(8) fda=0 bits=0000 request_queue.rqos_debugfs_dir dentry *;
// 71. 07E0 0001 effalign(1) fda=0 bits=0000 request_queue.mq_sysfs_init_done bool;
// 72. 07E8 0008 effalign(8) fda=0 bits=0000 request_queue.cmd_size size_t;
// 73. 07F0 0020 effalign(8) fda=0 bits=0000 request_queue.release_work work_struct;
// 74. 0810 0028 effalign(8) fda=0 bits=0000 request_queue.write_hints u64[5];
//          0838 effalign(8) sda=0 bits=0000 request_queue struct packalign=0

00000040 struct resource
{
  resource_size_t start;
  resource_size_t end;
  const char *name;
  unsigned __int64 flags;
  unsigned __int64 desc;
  resource *parent;
  resource *sibling;
  resource *child;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 resource.start resource_size_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 resource.end resource_size_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 resource.name const char *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 resource.flags unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 resource.desc unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 resource.parent resource *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 resource.sibling resource *;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 resource.child resource *;
//          0040 effalign(8) sda=0 bits=0000 resource struct packalign=0

00000060 struct resource_entry
{
  list_head node;
  resource *res;
  resource_size_t offset;
  resource __res;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 resource_entry.node list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 resource_entry.res resource *;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 resource_entry.offset resource_size_t;
//  3. 0020 0040 effalign(8) fda=0 bits=0000 resource_entry.__res resource;
//          0060 effalign(8) sda=0 bits=0000 resource_entry struct packalign=0

00000008 typedef phys_addr_t resource_size_t;
00000048 struct resource_win
{
  resource res;
  resource_size_t offset;
};
//  0. 0000 0040 effalign(8) fda=0 bits=0000 resource_win.res resource;
//  1. 0040 0008 effalign(8) fda=0 bits=0000 resource_win.offset resource_size_t;
//          0048 effalign(8) sda=0 bits=0000 resource_win struct packalign=0

00000030 struct restart_block
{
  __int64 (__cdecl *fn)(restart_block *);
  union
  {
    $9F8590F102EB2841150ECC2E0574E358 futex;
    $599CAA50DA31E34ACF419229BA5AB7AB nanosleep;
    $F3CAA52711B0FBBABA04D84B2645ECC4 poll;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 restart_block.fn __int64 (__cdecl *)(restart_block *);
//  1. 0008 0028 effalign(8) fda=0 bits=0000 restart_block.restart_block::$AA842036A9572CA971A17D3B4CEAC3A8 restart_block::$AA842036A9572CA971A17D3B4CEAC3A8;
//          0030 effalign(8) sda=0 bits=0000 restart_block struct packalign=0

00000028 union restart_block::$AA842036A9572CA971A17D3B4CEAC3A8
{
  $9F8590F102EB2841150ECC2E0574E358 futex;
  $599CAA50DA31E34ACF419229BA5AB7AB nanosleep;
  $F3CAA52711B0FBBABA04D84B2645ECC4 poll;
};
//  0. 0000 0028 effalign(8) fda=0 bits=0000 restart_block::$AA842036A9572CA971A17D3B4CEAC3A8.futex $9F8590F102EB2841150ECC2E0574E358;
//  1. 0000 0018 effalign(8) fda=0 bits=0000 restart_block::$AA842036A9572CA971A17D3B4CEAC3A8.nanosleep $599CAA50DA31E34ACF419229BA5AB7AB;
//  2. 0000 0020 effalign(8) fda=0 bits=0000 restart_block::$AA842036A9572CA971A17D3B4CEAC3A8.poll $F3CAA52711B0FBBABA04D84B2645ECC4;
//          0028 effalign(8) sda=0 bits=0000 restart_block::$AA842036A9572CA971A17D3B4CEAC3A8 union packalign=0

00000030 struct return_instance
{
  uprobe *uprobe;
  unsigned __int64 func;
  unsigned __int64 stack;
  unsigned __int64 orig_ret_vaddr;
  bool chained;
  return_instance *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 return_instance.uprobe uprobe *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 return_instance.func unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 return_instance.stack unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 return_instance.orig_ret_vaddr unsigned __int64;
//  4. 0020 0001 effalign(1) fda=0 bits=0000 return_instance.chained bool;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 return_instance.next return_instance *;
//          0030 effalign(8) sda=0 bits=0000 return_instance struct packalign=0

00000008 struct rhash_head
{
  rhash_head *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rhash_head.next rhash_head *;
//          0008 effalign(8) sda=0 bits=0000 rhash_head struct packalign=0

00000088 struct rhashtable
{
  bucket_table *tbl;
  unsigned int key_len;
  unsigned int max_elems;
  rhashtable_params p;
  bool rhlist;
  work_struct run_work;
  mutex mutex;
  spinlock_t lock;
  atomic_t nelems;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rhashtable.tbl bucket_table *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 rhashtable.key_len unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 rhashtable.max_elems unsigned int;
//  3. 0010 0028 effalign(8) fda=0 bits=0000 rhashtable.p rhashtable_params;
//  4. 0038 0001 effalign(1) fda=0 bits=0000 rhashtable.rhlist bool;
//  5. 0040 0020 effalign(8) fda=0 bits=0000 rhashtable.run_work work_struct;
//  6. 0060 0020 effalign(8) fda=0 bits=0000 rhashtable.mutex mutex;
//  7. 0080 0004 effalign(4) fda=0 bits=0000 rhashtable.lock spinlock_t;
//  8. 0084 0004 effalign(4) fda=0 bits=0000 rhashtable.nelems atomic_t;
//          0088 effalign(8) sda=0 bits=0000 rhashtable struct packalign=0

00000010 struct rhashtable_compare_arg
{
  rhashtable *ht;
  const void *key;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rhashtable_compare_arg.ht rhashtable *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rhashtable_compare_arg.key const void *;
//          0010 effalign(8) sda=0 bits=0000 rhashtable_compare_arg struct packalign=0

00000040 struct rhashtable_iter
{
  rhashtable *ht;
  rhash_head *p;
  rhlist_head *list;
  rhashtable_walker walker;
  unsigned int slot;
  unsigned int skip;
  bool end_of_table;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rhashtable_iter.ht rhashtable *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rhashtable_iter.p rhash_head *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 rhashtable_iter.list rhlist_head *;
//  3. 0018 0018 effalign(8) fda=0 bits=0000 rhashtable_iter.walker rhashtable_walker;
//  4. 0030 0004 effalign(4) fda=0 bits=0000 rhashtable_iter.slot unsigned int;
//  5. 0034 0004 effalign(4) fda=0 bits=0000 rhashtable_iter.skip unsigned int;
//  6. 0038 0001 effalign(1) fda=0 bits=0000 rhashtable_iter.end_of_table bool;
//          0039 unpadded_size
//          0040 effalign(8) sda=0 bits=0000 rhashtable_iter struct packalign=0

00000028 struct rhashtable_params
{
  u16 nelem_hint;
  u16 key_len;
  u16 key_offset;
  u16 head_offset;
  unsigned int max_size;
  u16 min_size;
  bool automatic_shrinking;
  rht_hashfn_t hashfn;
  rht_obj_hashfn_t obj_hashfn;
  rht_obj_cmpfn_t obj_cmpfn;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 rhashtable_params.nelem_hint u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 rhashtable_params.key_len u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 rhashtable_params.key_offset u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 rhashtable_params.head_offset u16;
//  4. 0008 0004 effalign(4) fda=0 bits=0000 rhashtable_params.max_size unsigned int;
//  5. 000C 0002 effalign(2) fda=0 bits=0000 rhashtable_params.min_size u16;
//  6. 000E 0001 effalign(1) fda=0 bits=0000 rhashtable_params.automatic_shrinking bool;
//  7. 0010 0008 effalign(8) fda=0 bits=0000 rhashtable_params.hashfn rht_hashfn_t;
//  8. 0018 0008 effalign(8) fda=0 bits=0000 rhashtable_params.obj_hashfn rht_obj_hashfn_t;
//  9. 0020 0008 effalign(8) fda=0 bits=0000 rhashtable_params.obj_cmpfn rht_obj_cmpfn_t;
//          0028 effalign(8) sda=0 bits=0000 rhashtable_params struct packalign=0

00000018 struct rhashtable_walker
{
  list_head list;
  bucket_table *tbl;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 rhashtable_walker.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 rhashtable_walker.tbl bucket_table *;
//          0018 effalign(8) sda=0 bits=0000 rhashtable_walker struct packalign=0

00000010 struct rhlist_head
{
  rhash_head rhead;
  rhlist_head *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rhlist_head.rhead rhash_head;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rhlist_head.next rhlist_head *;
//          0010 effalign(8) sda=0 bits=0000 rhlist_head struct packalign=0

00000088 struct rhltable
{
  rhashtable ht;
};
//  0. 0000 0088 effalign(8) fda=0 bits=0000 rhltable.ht rhashtable;
//          0088 effalign(8) sda=0 bits=0000 rhltable struct packalign=0

00000008 typedef u32 (__cdecl *rht_hashfn_t)(const void *, u32, u32);
00000008 typedef int (__cdecl *rht_obj_cmpfn_t)(rhashtable_compare_arg *, const void *);
00000008 typedef u32 (__cdecl *rht_obj_hashfn_t)(const void *, u32, u32);
00000008 struct rio_device_id
{
  __u16 did;
  __u16 vid;
  __u16 asm_did;
  __u16 asm_vid;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 rio_device_id.did __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 rio_device_id.vid __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 rio_device_id.asm_did __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 rio_device_id.asm_vid __u16;
//          0008 effalign(2) sda=0 bits=0000 rio_device_id struct packalign=0

00000010 struct rlimit
{
  __kernel_ulong_t rlim_cur;
  __kernel_ulong_t rlim_max;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rlimit.rlim_cur __kernel_ulong_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rlimit.rlim_max __kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 rlimit struct packalign=0

00000010 struct rlimit64
{
  __u64 rlim_cur;
  __u64 rlim_max;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rlimit64.rlim_cur __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rlimit64.rlim_max __u64;
//          0010 effalign(8) sda=0 bits=0000 rlimit64 struct packalign=0

FFFFFFFF struct robust_list_head;
FFFFFFFF struct root_domain;
00000004 enum rp_check : unsigned __int32
{
  RP_CHECK_CALL = 0x0,
  RP_CHECK_CHAIN_CALL = 0x1,
  RP_CHECK_RET = 0x2,
};
00000004 enum rpm_request : unsigned __int32
{
  RPM_REQ_NONE = 0x0,
  RPM_REQ_IDLE = 0x1,
  RPM_REQ_SUSPEND = 0x2,
  RPM_REQ_AUTOSUSPEND = 0x3,
  RPM_REQ_RESUME = 0x4,
};
00000004 enum rpm_status : unsigned __int32
{
  RPM_ACTIVE = 0x0,
  RPM_RESUMING = 0x1,
  RPM_SUSPENDED = 0x2,
  RPM_SUSPENDING = 0x3,
};
00000020 struct rpmsg_device_id
{
  char name[32];
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 rpmsg_device_id.name char[32];
//          0020 effalign(1) sda=0 bits=0000 rpmsg_device_id struct packalign=0

FFFFFFFF struct rq;
FFFFFFFF typedef void __cdecl rq_end_io_fn(request *, blk_status_t);
00000020 struct rq_map_data
{
  page **pages;
  int page_order;
  int nr_entries;
  unsigned __int64 offset;
  int null_mapped;
  int from_user;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rq_map_data.pages page **;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 rq_map_data.page_order int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 rq_map_data.nr_entries int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 rq_map_data.offset unsigned __int64;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 rq_map_data.null_mapped int;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 rq_map_data.from_user int;
//          0020 effalign(8) sda=0 bits=0000 rq_map_data struct packalign=0

FFFFFFFF struct rq_qos;
00000020 struct __attribute__((aligned(32))) rseq
{
  __u32 cpu_id_start;
  __u32 cpu_id;
  rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB rseq_cs;
  __u32 flags;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 rseq.cpu_id_start __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 rseq.cpu_id __u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 rseq.rseq_cs rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 rseq.flags __u32;
//          0014 unpadded_size
//          0020 effalign(32) sda=6 bits=0000 rseq struct packalign=0

00000008 union rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB
{
  __u64 ptr64;
  __u64 ptr;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB.ptr64 __u64;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB.ptr __u64;
//          0008 effalign(8) sda=0 bits=0000 rseq::$5D6BA9B2D1B2AC5A96A098137BC139DB union packalign=0

00000004 enum rseq_cpu_id_state : __int32
{
  RSEQ_CPU_ID_UNINITIALIZED = 0xFFFFFFFF,
  RSEQ_CPU_ID_REGISTRATION_FAILED = 0xFFFFFFFE,
};
00000020 struct __attribute__((aligned(32))) rseq_cs
{
  __u32 version;
  __u32 flags;
  __u64 start_ip;
  __u64 post_commit_offset;
  __u64 abort_ip;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 rseq_cs.version __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 rseq_cs.flags __u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 rseq_cs.start_ip __u64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 rseq_cs.post_commit_offset __u64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 rseq_cs.abort_ip __u64;
//          0020 effalign(32) sda=6 bits=0000 rseq_cs struct packalign=0

00000004 enum rseq_cs_flags : unsigned __int32
{
  RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 0x1,
  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 0x2,
  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 0x4,
};
00000004 enum rseq_cs_flags_bit : unsigned __int32
{
  RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0x0,
  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 0x1,
  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 0x2,
};
00000004 enum rseq_event_mask : unsigned __int32
{
  RSEQ_EVENT_PREEMPT = 0x1,
  RSEQ_EVENT_SIGNAL = 0x2,
  RSEQ_EVENT_MIGRATE = 0x4,
};
00000004 enum rseq_event_mask_bits : unsigned __int32
{
  RSEQ_EVENT_PREEMPT_BIT = 0x0,
  RSEQ_EVENT_SIGNAL_BIT = 0x1,
  RSEQ_EVENT_MIGRATE_BIT = 0x2,
};
00000004 enum rseq_flags : unsigned __int32
{
  RSEQ_FLAG_UNREGISTER = 0x1,
};
FFFFFFFF struct rt_mutex_waiter;
00000048 struct rtc_class_ops
{
  int (__cdecl *ioctl)(device *, unsigned int, unsigned __int64);
  int (__cdecl *read_time)(device *, rtc_time *);
  int (__cdecl *set_time)(device *, rtc_time *);
  int (__cdecl *read_alarm)(device *, rtc_wkalrm *);
  int (__cdecl *set_alarm)(device *, rtc_wkalrm *);
  int (__cdecl *proc)(device *, seq_file *);
  int (__cdecl *alarm_irq_enable)(device *, unsigned int);
  int (__cdecl *read_offset)(device *, __int64 *);
  int (__cdecl *set_offset)(device *, __int64);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.ioctl int (__cdecl *)(device *, unsigned int, unsigned __int64);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.read_time int (__cdecl *)(device *, rtc_time *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.set_time int (__cdecl *)(device *, rtc_time *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.read_alarm int (__cdecl *)(device *, rtc_wkalrm *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.set_alarm int (__cdecl *)(device *, rtc_wkalrm *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.proc int (__cdecl *)(device *, seq_file *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.alarm_irq_enable int (__cdecl *)(device *, unsigned int);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.read_offset int (__cdecl *)(device *, __int64 *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 rtc_class_ops.set_offset int (__cdecl *)(device *, __int64);
//          0048 effalign(8) sda=0 bits=0000 rtc_class_ops struct packalign=0

000004F8 struct rtc_device
{
  device dev;
  module *owner;
  int id;
  const rtc_class_ops *ops;
  mutex ops_lock;
  cdev char_dev;
  unsigned __int64 flags;
  unsigned __int64 irq_data;
  spinlock_t irq_lock;
  wait_queue_head_t irq_queue;
  fasync_struct *async_queue;
  int irq_freq;
  int max_user_freq;
  timerqueue_head timerqueue;
  rtc_timer aie_timer;
  rtc_timer uie_rtctimer;
  hrtimer pie_timer;
  int pie_enabled;
  work_struct irqwork;
  int uie_unsupported;
  __int64 set_offset_nsec;
  bool registered;
  bool nvram_old_abi;
  bin_attribute *nvram;
  time64_t range_min;
  timeu64_t range_max;
  time64_t start_secs;
  time64_t offset_secs;
  bool set_start_time;
};
//  0. 0000 02D8 effalign(8) fda=0 bits=0000 rtc_device.dev device;
//  1. 02D8 0008 effalign(8) fda=0 bits=0000 rtc_device.owner module *;
//  2. 02E0 0004 effalign(4) fda=0 bits=0000 rtc_device.id int;
//  3. 02E8 0008 effalign(8) fda=0 bits=0000 rtc_device.ops const rtc_class_ops *;
//  4. 02F0 0020 effalign(8) fda=0 bits=0000 rtc_device.ops_lock mutex;
//  5. 0310 0068 effalign(8) fda=0 bits=0000 rtc_device.char_dev cdev;
//  6. 0378 0008 effalign(8) fda=0 bits=0000 rtc_device.flags unsigned __int64;
//  7. 0380 0008 effalign(8) fda=0 bits=0000 rtc_device.irq_data unsigned __int64;
//  8. 0388 0004 effalign(4) fda=0 bits=0000 rtc_device.irq_lock spinlock_t;
//  9. 0390 0018 effalign(8) fda=0 bits=0000 rtc_device.irq_queue wait_queue_head_t;
// 10. 03A8 0008 effalign(8) fda=0 bits=0000 rtc_device.async_queue fasync_struct *;
// 11. 03B0 0004 effalign(4) fda=0 bits=0000 rtc_device.irq_freq int;
// 12. 03B4 0004 effalign(4) fda=0 bits=0000 rtc_device.max_user_freq int;
// 13. 03B8 0010 effalign(8) fda=0 bits=0000 rtc_device.timerqueue timerqueue_head;
// 14. 03C8 0040 effalign(8) fda=0 bits=0000 rtc_device.aie_timer rtc_timer;
// 15. 0408 0040 effalign(8) fda=0 bits=0000 rtc_device.uie_rtctimer rtc_timer;
// 16. 0448 0040 effalign(8) fda=0 bits=0000 rtc_device.pie_timer hrtimer;
// 17. 0488 0004 effalign(4) fda=0 bits=0000 rtc_device.pie_enabled int;
// 18. 0490 0020 effalign(8) fda=0 bits=0000 rtc_device.irqwork work_struct;
// 19. 04B0 0004 effalign(4) fda=0 bits=0000 rtc_device.uie_unsupported int;
// 20. 04B8 0008 effalign(8) fda=0 bits=0000 rtc_device.set_offset_nsec __int64;
// 21. 04C0 0001 effalign(1) fda=0 bits=0000 rtc_device.registered bool;
// 22. 04C1 0001 effalign(1) fda=0 bits=0000 rtc_device.nvram_old_abi bool;
// 23. 04C8 0008 effalign(8) fda=0 bits=0000 rtc_device.nvram bin_attribute *;
// 24. 04D0 0008 effalign(8) fda=0 bits=0000 rtc_device.range_min time64_t;
// 25. 04D8 0008 effalign(8) fda=0 bits=0000 rtc_device.range_max timeu64_t;
// 26. 04E0 0008 effalign(8) fda=0 bits=0000 rtc_device.start_secs time64_t;
// 27. 04E8 0008 effalign(8) fda=0 bits=0000 rtc_device.offset_secs time64_t;
// 28. 04F0 0001 effalign(1) fda=0 bits=0000 rtc_device.set_start_time bool;
//          04F1 unpadded_size
//          04F8 effalign(8) sda=0 bits=0000 rtc_device struct packalign=0

00000020 struct rtc_pll_info
{
  int pll_ctrl;
  int pll_value;
  int pll_max;
  int pll_min;
  int pll_posmult;
  int pll_negmult;
  __int64 pll_clock;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_ctrl int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_value int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_max int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_min int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_posmult int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 rtc_pll_info.pll_negmult int;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 rtc_pll_info.pll_clock __int64;
//          0020 effalign(8) sda=0 bits=0000 rtc_pll_info struct packalign=0

00000024 struct rtc_time
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_sec int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_min int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_hour int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_mday int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_mon int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_year int;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_wday int;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_yday int;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 rtc_time.tm_isdst int;
//          0024 effalign(4) sda=0 bits=0000 rtc_time struct packalign=0

00000040 struct rtc_timer
{
  timerqueue_node node;
  ktime_t period;
  void (__cdecl *func)(rtc_device *);
  rtc_device *rtc;
  int enabled;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 rtc_timer.node timerqueue_node;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 rtc_timer.period ktime_t;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 rtc_timer.func void (__cdecl *)(rtc_device *);
//  3. 0030 0008 effalign(8) fda=0 bits=0000 rtc_timer.rtc rtc_device *;
//  4. 0038 0004 effalign(4) fda=0 bits=0000 rtc_timer.enabled int;
//          003C unpadded_size
//          0040 effalign(8) sda=0 bits=0000 rtc_timer struct packalign=0

00000028 struct rtc_wkalrm
{
  unsigned __int8 enabled;
  unsigned __int8 pending;
  rtc_time time;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 rtc_wkalrm.enabled unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 rtc_wkalrm.pending unsigned __int8;
//  2. 0004 0024 effalign(4) fda=0 bits=0000 rtc_wkalrm.time rtc_time;
//          0028 effalign(4) sda=0 bits=0000 rtc_wkalrm struct packalign=0

00000090 struct rusage
{
  timeval ru_utime;
  timeval ru_stime;
  __kernel_long_t ru_maxrss;
  __kernel_long_t ru_ixrss;
  __kernel_long_t ru_idrss;
  __kernel_long_t ru_isrss;
  __kernel_long_t ru_minflt;
  __kernel_long_t ru_majflt;
  __kernel_long_t ru_nswap;
  __kernel_long_t ru_inblock;
  __kernel_long_t ru_oublock;
  __kernel_long_t ru_msgsnd;
  __kernel_long_t ru_msgrcv;
  __kernel_long_t ru_nsignals;
  __kernel_long_t ru_nvcsw;
  __kernel_long_t ru_nivcsw;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 rusage.ru_utime timeval;
//  1. 0010 0010 effalign(8) fda=0 bits=0000 rusage.ru_stime timeval;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 rusage.ru_maxrss __kernel_long_t;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 rusage.ru_ixrss __kernel_long_t;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 rusage.ru_idrss __kernel_long_t;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 rusage.ru_isrss __kernel_long_t;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 rusage.ru_minflt __kernel_long_t;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 rusage.ru_majflt __kernel_long_t;
//  8. 0050 0008 effalign(8) fda=0 bits=0000 rusage.ru_nswap __kernel_long_t;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 rusage.ru_inblock __kernel_long_t;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 rusage.ru_oublock __kernel_long_t;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 rusage.ru_msgsnd __kernel_long_t;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 rusage.ru_msgrcv __kernel_long_t;
// 13. 0078 0008 effalign(8) fda=0 bits=0000 rusage.ru_nsignals __kernel_long_t;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 rusage.ru_nvcsw __kernel_long_t;
// 15. 0088 0008 effalign(8) fda=0 bits=0000 rusage.ru_nivcsw __kernel_long_t;
//          0090 effalign(8) sda=0 bits=0000 rusage struct packalign=0

00000004 enum rw_hint : unsigned __int32
{
  WRITE_LIFE_NOT_SET = 0x0,
  WRITE_LIFE_NONE = 0x1,
  WRITE_LIFE_SHORT = 0x2,
  WRITE_LIFE_MEDIUM = 0x3,
  WRITE_LIFE_LONG = 0x4,
  WRITE_LIFE_EXTREME = 0x5,
};
00000028 struct rw_semaphore
{
  atomic_long_t count;
  atomic_long_t owner;
  optimistic_spin_queue osq;
  raw_spinlock_t wait_lock;
  list_head wait_list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 rw_semaphore.count atomic_long_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 rw_semaphore.owner atomic_long_t;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 rw_semaphore.osq optimistic_spin_queue;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 rw_semaphore.wait_lock raw_spinlock_t;
//  4. 0018 0010 effalign(8) fda=0 bits=0000 rw_semaphore.wait_list list_head;
//          0028 effalign(8) sda=0 bits=0000 rw_semaphore struct packalign=0

00000004 typedef __kernel_rwf_t rwf_t;
00000008 struct rwlock_t
{
  arch_rwlock_t raw_lock;
};
//  0. 0000 0008 effalign(4) fda=0 bits=0000 rwlock_t.raw_lock arch_rwlock_t;
//          0008 effalign(4) sda=0 bits=0000 rwlock_t struct packalign=0

00000002 typedef __s16 s16;
00000004 typedef __s32 s32;
00000008 typedef __s64 s64;
00000001 typedef __s8 s8;
00000028 struct saved_msr
{
  bool valid;
  msr_info info;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 saved_msr.valid bool;
//  1. 0008 0020 effalign(8) fda=0 bits=0000 saved_msr.info msr_info;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 saved_msr struct packalign=0

00000010 struct saved_msrs
{
  unsigned int num;
  saved_msr *array;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 saved_msrs.num unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 saved_msrs.array saved_msr *;
//          0010 effalign(8) sda=0 bits=0000 saved_msrs struct packalign=0

00000170 struct sb_writers
{
  int frozen;
  wait_queue_head_t wait_unfrozen;
  percpu_rw_semaphore rw_sem[3];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 sb_writers.frozen int;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 sb_writers.wait_unfrozen wait_queue_head_t;
//  2. 0020 0150 effalign(8) fda=0 bits=0000 sb_writers.rw_sem percpu_rw_semaphore[3];
//          0170 effalign(8) sda=0 bits=0000 sb_writers struct packalign=0

00000020 struct scatterlist
{
  unsigned __int64 page_link;
  unsigned int offset;
  unsigned int length;
  dma_addr_t dma_address;
  unsigned int dma_length;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 scatterlist.page_link unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 scatterlist.offset unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 scatterlist.length unsigned int;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 scatterlist.dma_address dma_addr_t;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 scatterlist.dma_length unsigned int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 scatterlist struct packalign=0

FFFFFFFF struct sched_attr;
00000040 struct __attribute__((aligned(64))) sched_avg
{
  u64 last_update_time;
  u64 load_sum;
  u64 runnable_load_sum;
  u32 util_sum;
  u32 period_contrib;
  unsigned __int64 load_avg;
  unsigned __int64 runnable_load_avg;
  unsigned __int64 util_avg;
  util_est util_est;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sched_avg.last_update_time u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sched_avg.load_sum u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sched_avg.runnable_load_sum u64;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 sched_avg.util_sum u32;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 sched_avg.period_contrib u32;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 sched_avg.load_avg unsigned __int64;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 sched_avg.runnable_load_avg unsigned __int64;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 sched_avg.util_avg unsigned __int64;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 sched_avg.util_est util_est;
//          0040 effalign(64) sda=7 bits=0000 sched_avg struct packalign=0

FFFFFFFF struct sched_class;
000000E0 struct sched_dl_entity
{
  rb_node rb_node;
  u64 dl_runtime;
  u64 dl_deadline;
  u64 dl_period;
  u64 dl_bw;
  u64 dl_density;
  s64 runtime;
  u64 deadline;
  unsigned int flags;
  unsigned __int32 dl_throttled : 1;
  unsigned __int32 dl_yielded : 1;
  unsigned __int32 dl_non_contending : 1;
  unsigned __int32 dl_overrun : 1;
  hrtimer dl_timer;
  hrtimer inactive_timer;
  sched_dl_entity *pi_se;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 sched_dl_entity.rb_node rb_node;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_runtime u64;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_deadline u64;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_period u64;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_bw u64;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_density u64;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.runtime s64;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.deadline u64;
//  8. 0050 0004 effalign(4) fda=0 bits=0000 sched_dl_entity.flags unsigned int;
//  9. 0054. 0 1 effalign(1) fda=0 bits=0000 sched_dl_entity.dl_throttled bi.nbytes=4 U
// 10. 0054. 1 1 effalign(1) fda=0 bits=0000 sched_dl_entity.dl_yielded bi.nbytes=4 U
// 11. 0054. 2 1 effalign(1) fda=0 bits=0000 sched_dl_entity.dl_non_contending bi.nbytes=4 U
// 12. 0054. 3 1 effalign(1) fda=0 bits=0000 sched_dl_entity.dl_overrun bi.nbytes=4 U
// 13. 0058 0040 effalign(8) fda=0 bits=0000 sched_dl_entity.dl_timer hrtimer;
// 14. 0098 0040 effalign(8) fda=0 bits=0000 sched_dl_entity.inactive_timer hrtimer;
// 15. 00D8 0008 effalign(8) fda=0 bits=0000 sched_dl_entity.pi_se sched_dl_entity *;
//          00E0 effalign(8) sda=0 bits=0000 sched_dl_entity struct packalign=0

FFFFFFFF struct sched_domain;
000001C0 struct sched_entity
{
  load_weight load;
  unsigned __int64 runnable_weight;
  rb_node run_node;
  list_head group_node;
  unsigned int on_rq;
  u64 exec_start;
  u64 sum_exec_runtime;
  u64 vruntime;
  u64 prev_sum_exec_runtime;
  u64 nr_migrations;
  sched_statistics statistics;
  int depth;
  sched_entity *parent;
  cfs_rq *cfs_rq;
  cfs_rq *my_q;
  sched_avg avg;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 sched_entity.load load_weight;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 sched_entity.runnable_weight unsigned __int64;
//  2. 0018 0018 effalign(8) fda=0 bits=0000 sched_entity.run_node rb_node;
//  3. 0030 0010 effalign(8) fda=0 bits=0000 sched_entity.group_node list_head;
//  4. 0040 0004 effalign(4) fda=0 bits=0000 sched_entity.on_rq unsigned int;
//  5. 0048 0008 effalign(8) fda=0 bits=0000 sched_entity.exec_start u64;
//  6. 0050 0008 effalign(8) fda=0 bits=0000 sched_entity.sum_exec_runtime u64;
//  7. 0058 0008 effalign(8) fda=0 bits=0000 sched_entity.vruntime u64;
//  8. 0060 0008 effalign(8) fda=0 bits=0000 sched_entity.prev_sum_exec_runtime u64;
//  9. 0068 0008 effalign(8) fda=0 bits=0000 sched_entity.nr_migrations u64;
// 10. 0070 00D8 effalign(8) fda=0 bits=0000 sched_entity.statistics sched_statistics;
// 11. 0148 0004 effalign(4) fda=0 bits=0000 sched_entity.depth int;
// 12. 0150 0008 effalign(8) fda=0 bits=0000 sched_entity.parent sched_entity *;
// 13. 0158 0008 effalign(8) fda=0 bits=0000 sched_entity.cfs_rq cfs_rq *;
// 14. 0160 0008 effalign(8) fda=0 bits=0000 sched_entity.my_q cfs_rq *;
// 15. 0180 0040 effalign(64) fda=0 bits=0000 sched_entity.avg sched_avg;
//          01C0 effalign(64) sda=0 bits=0000 sched_entity struct packalign=0

00000020 struct sched_info
{
  unsigned __int64 pcount;
  unsigned __int64 run_delay;
  unsigned __int64 last_arrival;
  unsigned __int64 last_queued;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sched_info.pcount unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sched_info.run_delay unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sched_info.last_arrival unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 sched_info.last_queued unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 sched_info struct packalign=0

FFFFFFFF struct sched_param;
00000030 struct sched_rt_entity
{
  list_head run_list;
  unsigned __int64 timeout;
  unsigned __int64 watchdog_stamp;
  unsigned int time_slice;
  unsigned __int16 on_rq;
  unsigned __int16 on_list;
  sched_rt_entity *back;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 sched_rt_entity.run_list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 sched_rt_entity.timeout unsigned __int64;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 sched_rt_entity.watchdog_stamp unsigned __int64;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 sched_rt_entity.time_slice unsigned int;
//  4. 0024 0002 effalign(2) fda=0 bits=0000 sched_rt_entity.on_rq unsigned __int16;
//  5. 0026 0002 effalign(2) fda=0 bits=0000 sched_rt_entity.on_list unsigned __int16;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 sched_rt_entity.back sched_rt_entity *;
//          0030 effalign(8) sda=0 bits=0000 sched_rt_entity struct packalign=0

000000D8 struct sched_statistics
{
  u64 wait_start;
  u64 wait_max;
  u64 wait_count;
  u64 wait_sum;
  u64 iowait_count;
  u64 iowait_sum;
  u64 sleep_start;
  u64 sleep_max;
  s64 sum_sleep_runtime;
  u64 block_start;
  u64 block_max;
  u64 exec_max;
  u64 slice_max;
  u64 nr_migrations_cold;
  u64 nr_failed_migrations_affine;
  u64 nr_failed_migrations_running;
  u64 nr_failed_migrations_hot;
  u64 nr_forced_migrations;
  u64 nr_wakeups;
  u64 nr_wakeups_sync;
  u64 nr_wakeups_migrate;
  u64 nr_wakeups_local;
  u64 nr_wakeups_remote;
  u64 nr_wakeups_affine;
  u64 nr_wakeups_affine_attempts;
  u64 nr_wakeups_passive;
  u64 nr_wakeups_idle;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sched_statistics.wait_start u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sched_statistics.wait_max u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sched_statistics.wait_count u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 sched_statistics.wait_sum u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 sched_statistics.iowait_count u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 sched_statistics.iowait_sum u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 sched_statistics.sleep_start u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 sched_statistics.sleep_max u64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 sched_statistics.sum_sleep_runtime s64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 sched_statistics.block_start u64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 sched_statistics.block_max u64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 sched_statistics.exec_max u64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 sched_statistics.slice_max u64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_migrations_cold u64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_failed_migrations_affine u64;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_failed_migrations_running u64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_failed_migrations_hot u64;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_forced_migrations u64;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups u64;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_sync u64;
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_migrate u64;
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_local u64;
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_remote u64;
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_affine u64;
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_affine_attempts u64;
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_passive u64;
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 sched_statistics.nr_wakeups_idle u64;
//          00D8 effalign(8) sda=0 bits=0000 sched_statistics struct packalign=0

00000040 struct __attribute__((packed)) screen_info
{
  __u8 orig_x;
  __u8 orig_y;
  __u16 ext_mem_k;
  __u16 orig_video_page;
  __u8 orig_video_mode;
  __u8 orig_video_cols;
  __u8 flags;
  __u8 unused2;
  __u16 orig_video_ega_bx;
  __u16 unused3;
  __u8 orig_video_lines;
  __u8 orig_video_isVGA;
  __u16 orig_video_points;
  __u16 lfb_width;
  __u16 lfb_height;
  __u16 lfb_depth;
  __u32 lfb_base;
  __u32 lfb_size;
  __u16 cl_magic;
  __u16 cl_offset;
  __u16 lfb_linelength;
  __u8 red_size;
  __u8 red_pos;
  __u8 green_size;
  __u8 green_pos;
  __u8 blue_size;
  __u8 blue_pos;
  __u8 rsvd_size;
  __u8 rsvd_pos;
  __u16 vesapm_seg;
  __u16 vesapm_off;
  __u16 pages;
  __u16 vesa_attributes;
  __u32 capabilities;
  __u32 ext_lfb_base;
  __u8 _reserved[2];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 screen_info.orig_x __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 screen_info.orig_y __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 screen_info.ext_mem_k __u16;
//  3. 0004 0002 effalign(1) fda=0 bits=0000 screen_info.orig_video_page __u16;
//  4. 0006 0001 effalign(1) fda=0 bits=0000 screen_info.orig_video_mode __u8;
//  5. 0007 0001 effalign(1) fda=0 bits=0000 screen_info.orig_video_cols __u8;
//  6. 0008 0001 effalign(1) fda=0 bits=0000 screen_info.flags __u8;
//  7. 0009 0001 effalign(1) fda=0 bits=0000 screen_info.unused2 __u8;
//  8. 000A 0002 effalign(1) fda=0 bits=0000 screen_info.orig_video_ega_bx __u16;
//  9. 000C 0002 effalign(1) fda=0 bits=0000 screen_info.unused3 __u16;
// 10. 000E 0001 effalign(1) fda=0 bits=0000 screen_info.orig_video_lines __u8;
// 11. 000F 0001 effalign(1) fda=0 bits=0000 screen_info.orig_video_isVGA __u8;
// 12. 0010 0002 effalign(1) fda=0 bits=0000 screen_info.orig_video_points __u16;
// 13. 0012 0002 effalign(1) fda=0 bits=0000 screen_info.lfb_width __u16;
// 14. 0014 0002 effalign(1) fda=0 bits=0000 screen_info.lfb_height __u16;
// 15. 0016 0002 effalign(1) fda=0 bits=0000 screen_info.lfb_depth __u16;
// 16. 0018 0004 effalign(1) fda=0 bits=0000 screen_info.lfb_base __u32;
// 17. 001C 0004 effalign(1) fda=0 bits=0000 screen_info.lfb_size __u32;
// 18. 0020 0002 effalign(1) fda=0 bits=0000 screen_info.cl_magic __u16;
// 19. 0022 0002 effalign(1) fda=0 bits=0000 screen_info.cl_offset __u16;
// 20. 0024 0002 effalign(1) fda=0 bits=0000 screen_info.lfb_linelength __u16;
// 21. 0026 0001 effalign(1) fda=0 bits=0000 screen_info.red_size __u8;
// 22. 0027 0001 effalign(1) fda=0 bits=0000 screen_info.red_pos __u8;
// 23. 0028 0001 effalign(1) fda=0 bits=0000 screen_info.green_size __u8;
// 24. 0029 0001 effalign(1) fda=0 bits=0000 screen_info.green_pos __u8;
// 25. 002A 0001 effalign(1) fda=0 bits=0000 screen_info.blue_size __u8;
// 26. 002B 0001 effalign(1) fda=0 bits=0000 screen_info.blue_pos __u8;
// 27. 002C 0001 effalign(1) fda=0 bits=0000 screen_info.rsvd_size __u8;
// 28. 002D 0001 effalign(1) fda=0 bits=0000 screen_info.rsvd_pos __u8;
// 29. 002E 0002 effalign(1) fda=0 bits=0000 screen_info.vesapm_seg __u16;
// 30. 0030 0002 effalign(1) fda=0 bits=0000 screen_info.vesapm_off __u16;
// 31. 0032 0002 effalign(1) fda=0 bits=0000 screen_info.pages __u16;
// 32. 0034 0002 effalign(1) fda=0 bits=0000 screen_info.vesa_attributes __u16;
// 33. 0036 0004 effalign(1) fda=0 bits=0000 screen_info.capabilities __u32;
// 34. 003A 0004 effalign(1) fda=0 bits=0000 screen_info.ext_lfb_base __u32;
// 35. 003E 0002 effalign(1) fda=0 bits=0000 screen_info._reserved __u8[2];
//          0040 effalign(1) sda=0 bits=0040 screen_info struct packalign=0

FFFFFFFF struct scsi_ioctl_command;
00000010 struct sdio_device_id
{
  __u8 class;
  __u16 vendor;
  __u16 device;
  kernel_ulong_t driver_data;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 sdio_device_id.class __u8;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 sdio_device_id.vendor __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 sdio_device_id.device __u16;
//  3. 0008 0008 effalign(8) fda=0 bits=0000 sdio_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 sdio_device_id struct packalign=0

00000010 struct sdw_device_id
{
  __u16 mfg_id;
  __u16 part_id;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 sdw_device_id.mfg_id __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 sdw_device_id.part_id __u16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 sdw_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 sdw_device_id struct packalign=0

00000010 struct seccomp
{
  int mode;
  seccomp_filter *filter;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 seccomp.mode int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 seccomp.filter seccomp_filter *;
//          0010 effalign(8) sda=0 bits=0000 seccomp struct packalign=0

00000040 struct seccomp_data
{
  int nr;
  __u32 arch;
  __u64 instruction_pointer;
  __u64 args[6];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 seccomp_data.nr int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 seccomp_data.arch __u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 seccomp_data.instruction_pointer __u64;
//  3. 0010 0030 effalign(8) fda=0 bits=0000 seccomp_data.args __u64[6];
//          0040 effalign(8) sda=0 bits=0000 seccomp_data struct packalign=0

FFFFFFFF struct seccomp_filter;
00000050 struct seccomp_notif
{
  __u64 id;
  __u32 pid;
  __u32 flags;
  seccomp_data data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 seccomp_notif.id __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 seccomp_notif.pid __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 seccomp_notif.flags __u32;
//  3. 0010 0040 effalign(8) fda=0 bits=0000 seccomp_notif.data seccomp_data;
//          0050 effalign(8) sda=0 bits=0000 seccomp_notif struct packalign=0

00000018 struct seccomp_notif_resp
{
  __u64 id;
  __s64 val;
  __s32 error;
  __u32 flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 seccomp_notif_resp.id __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 seccomp_notif_resp.val __s64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 seccomp_notif_resp.error __s32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 seccomp_notif_resp.flags __u32;
//          0018 effalign(8) sda=0 bits=0000 seccomp_notif_resp struct packalign=0

00000006 struct seccomp_notif_sizes
{
  __u16 seccomp_notif;
  __u16 seccomp_notif_resp;
  __u16 seccomp_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 seccomp_notif_sizes.seccomp_notif __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 seccomp_notif_sizes.seccomp_notif_resp __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 seccomp_notif_sizes.seccomp_data __u16;
//          0006 effalign(2) sda=0 bits=0000 seccomp_notif_sizes struct packalign=0

00000008 typedef u64 sector_t;
FFFFFFFF struct sem;
FFFFFFFF struct sem_queue;
FFFFFFFF struct sem_undo;
FFFFFFFF struct sem_undo_list;
00000018 struct semaphore
{
  raw_spinlock_t lock;
  unsigned int count;
  list_head wait_list;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 semaphore.lock raw_spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 semaphore.count unsigned int;
//  2. 0008 0010 effalign(8) fda=0 bits=0000 semaphore.wait_list list_head;
//          0018 effalign(8) sda=0 bits=0000 semaphore struct packalign=0

00000006 struct sembuf
{
  unsigned __int16 sem_num;
  __int16 sem_op;
  __int16 sem_flg;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 sembuf.sem_num unsigned __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 sembuf.sem_op __int16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 sembuf.sem_flg __int16;
//          0006 effalign(2) sda=0 bits=0000 sembuf struct packalign=0

00000068 struct semid64_ds
{
  ipc64_perm sem_perm;
  __kernel_time_t sem_otime;
  __kernel_ulong_t __unused1;
  __kernel_time_t sem_ctime;
  __kernel_ulong_t __unused2;
  __kernel_ulong_t sem_nsems;
  __kernel_ulong_t __unused3;
  __kernel_ulong_t __unused4;
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 semid64_ds.sem_perm ipc64_perm;
//  1. 0030 0008 effalign(8) fda=0 bits=0000 semid64_ds.sem_otime __kernel_time_t;
//  2. 0038 0008 effalign(8) fda=0 bits=0000 semid64_ds.__unused1 __kernel_ulong_t;
//  3. 0040 0008 effalign(8) fda=0 bits=0000 semid64_ds.sem_ctime __kernel_time_t;
//  4. 0048 0008 effalign(8) fda=0 bits=0000 semid64_ds.__unused2 __kernel_ulong_t;
//  5. 0050 0008 effalign(8) fda=0 bits=0000 semid64_ds.sem_nsems __kernel_ulong_t;
//  6. 0058 0008 effalign(8) fda=0 bits=0000 semid64_ds.__unused3 __kernel_ulong_t;
//  7. 0060 0008 effalign(8) fda=0 bits=0000 semid64_ds.__unused4 __kernel_ulong_t;
//          0068 effalign(8) sda=0 bits=0000 semid64_ds struct packalign=0

00000058 struct semid_ds
{
  ipc_perm sem_perm;
  __kernel_time_t sem_otime;
  __kernel_time_t sem_ctime;
  sem *sem_base;
  sem_queue *sem_pending;
  sem_queue **sem_pending_last;
  sem_undo *undo;
  unsigned __int16 sem_nsems;
};
//  0. 0000 001C effalign(4) fda=0 bits=0000 semid_ds.sem_perm ipc_perm;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 semid_ds.sem_otime __kernel_time_t;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 semid_ds.sem_ctime __kernel_time_t;
//  3. 0030 0008 effalign(8) fda=0 bits=0000 semid_ds.sem_base sem *;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 semid_ds.sem_pending sem_queue *;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 semid_ds.sem_pending_last sem_queue **;
//  6. 0048 0008 effalign(8) fda=0 bits=0000 semid_ds.undo sem_undo *;
//  7. 0050 0002 effalign(2) fda=0 bits=0000 semid_ds.sem_nsems unsigned __int16;
//          0052 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 semid_ds struct packalign=0

00000028 struct seminfo
{
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 seminfo.semmap int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 seminfo.semmni int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 seminfo.semmns int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 seminfo.semmnu int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 seminfo.semmsl int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 seminfo.semopm int;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 seminfo.semume int;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 seminfo.semusz int;
//  8. 0020 0004 effalign(4) fda=0 bits=0000 seminfo.semvmx int;
//  9. 0024 0004 effalign(4) fda=0 bits=0000 seminfo.semaem int;
//          0028 effalign(4) sda=0 bits=0000 seminfo struct packalign=0

00000008 union semun
{
  int val;
  semid_ds *buf;
  unsigned __int16 *array;
  seminfo *__buf;
  void *__pad;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 semun.val int;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 semun.buf semid_ds *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 semun.array unsigned __int16 *;
//  3. 0000 0008 effalign(8) fda=0 bits=0000 semun.__buf seminfo *;
//  4. 0000 0008 effalign(8) fda=0 bits=0000 semun.__pad void *;
//          0008 effalign(8) sda=0 bits=0000 semun union packalign=0

00000080 struct seq_file
{
  char *buf;
  size_t size;
  size_t from;
  size_t count;
  size_t pad_until;
  loff_t index;
  loff_t read_pos;
  u64 version;
  mutex lock;
  const seq_operations *op;
  int poll_event;
  const file *file;
  void *private;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 seq_file.buf char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 seq_file.size size_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 seq_file.from size_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 seq_file.count size_t;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 seq_file.pad_until size_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 seq_file.index loff_t;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 seq_file.read_pos loff_t;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 seq_file.version u64;
//  8. 0040 0020 effalign(8) fda=0 bits=0000 seq_file.lock mutex;
//  9. 0060 0008 effalign(8) fda=0 bits=0000 seq_file.op const seq_operations *;
// 10. 0068 0004 effalign(4) fda=0 bits=0000 seq_file.poll_event int;
// 11. 0070 0008 effalign(8) fda=0 bits=0000 seq_file.file const file *;
// 12. 0078 0008 effalign(8) fda=0 bits=0000 seq_file.private void *;
//          0080 effalign(8) sda=0 bits=0000 seq_file struct packalign=0

00000020 struct seq_operations
{
  void *(__cdecl *start)(seq_file *, loff_t *);
  void (__cdecl *stop)(seq_file *, void *);
  void *(__cdecl *next)(seq_file *, void *, loff_t *);
  int (__cdecl *show)(seq_file *, void *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 seq_operations.start void *(__cdecl *)(seq_file *, loff_t *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 seq_operations.stop void (__cdecl *)(seq_file *, void *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 seq_operations.next void *(__cdecl *)(seq_file *, void *, loff_t *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 seq_operations.show int (__cdecl *)(seq_file *, void *);
//          0020 effalign(8) sda=0 bits=0000 seq_operations struct packalign=0

00000004 struct seqcount
{
  unsigned int sequence;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 seqcount.sequence unsigned int;
//          0004 effalign(4) sda=0 bits=0000 seqcount struct packalign=0

00000004 typedef seqcount seqcount_t;
00000008 struct seqlock_t
{
  seqcount seqcount;
  spinlock_t lock;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 seqlock_t.seqcount seqcount;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 seqlock_t.lock spinlock_t;
//          0008 effalign(4) sda=0 bits=0000 seqlock_t struct packalign=0

00000004 struct serio_device_id
{
  __u8 type;
  __u8 extra;
  __u8 id;
  __u8 proto;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 serio_device_id.type __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 serio_device_id.extra __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 serio_device_id.id __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 serio_device_id.proto __u8;
//          0004 effalign(1) sda=0 bits=0000 serio_device_id struct packalign=0

00000010 struct setup_data
{
  __u64 next;
  __u32 type;
  __u32 len;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 setup_data.next __u64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 setup_data.type __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 setup_data.len __u32;
//          0010 effalign(8) sda=0 bits=0000 setup_data struct packalign=0

00000077 struct __attribute__((packed)) setup_header
{
  __u8 setup_sects;
  __u16 root_flags;
  __u32 syssize;
  __u16 ram_size;
  __u16 vid_mode;
  __u16 root_dev;
  __u16 boot_flag;
  __u16 jump;
  __u32 header;
  __u16 version;
  __u32 realmode_swtch;
  __u16 start_sys_seg;
  __u16 kernel_version;
  __u8 type_of_loader;
  __u8 loadflags;
  __u16 setup_move_size;
  __u32 code32_start;
  __u32 ramdisk_image;
  __u32 ramdisk_size;
  __u32 bootsect_kludge;
  __u16 heap_end_ptr;
  __u8 ext_loader_ver;
  __u8 ext_loader_type;
  __u32 cmd_line_ptr;
  __u32 initrd_addr_max;
  __u32 kernel_alignment;
  __u8 relocatable_kernel;
  __u8 min_alignment;
  __u16 xloadflags;
  __u32 cmdline_size;
  __u32 hardware_subarch;
  __u64 hardware_subarch_data;
  __u32 payload_offset;
  __u32 payload_length;
  __u64 setup_data;
  __u64 pref_address;
  __u32 init_size;
  __u32 handover_offset;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 setup_header.setup_sects __u8;
//  1. 0001 0002 effalign(1) fda=0 bits=0000 setup_header.root_flags __u16;
//  2. 0003 0004 effalign(1) fda=0 bits=0000 setup_header.syssize __u32;
//  3. 0007 0002 effalign(1) fda=0 bits=0000 setup_header.ram_size __u16;
//  4. 0009 0002 effalign(1) fda=0 bits=0000 setup_header.vid_mode __u16;
//  5. 000B 0002 effalign(1) fda=0 bits=0000 setup_header.root_dev __u16;
//  6. 000D 0002 effalign(1) fda=0 bits=0000 setup_header.boot_flag __u16;
//  7. 000F 0002 effalign(1) fda=0 bits=0000 setup_header.jump __u16;
//  8. 0011 0004 effalign(1) fda=0 bits=0000 setup_header.header __u32;
//  9. 0015 0002 effalign(1) fda=0 bits=0000 setup_header.version __u16;
// 10. 0017 0004 effalign(1) fda=0 bits=0000 setup_header.realmode_swtch __u32;
// 11. 001B 0002 effalign(1) fda=0 bits=0000 setup_header.start_sys_seg __u16;
// 12. 001D 0002 effalign(1) fda=0 bits=0000 setup_header.kernel_version __u16;
// 13. 001F 0001 effalign(1) fda=0 bits=0000 setup_header.type_of_loader __u8;
// 14. 0020 0001 effalign(1) fda=0 bits=0000 setup_header.loadflags __u8;
// 15. 0021 0002 effalign(1) fda=0 bits=0000 setup_header.setup_move_size __u16;
// 16. 0023 0004 effalign(1) fda=0 bits=0000 setup_header.code32_start __u32;
// 17. 0027 0004 effalign(1) fda=0 bits=0000 setup_header.ramdisk_image __u32;
// 18. 002B 0004 effalign(1) fda=0 bits=0000 setup_header.ramdisk_size __u32;
// 19. 002F 0004 effalign(1) fda=0 bits=0000 setup_header.bootsect_kludge __u32;
// 20. 0033 0002 effalign(1) fda=0 bits=0000 setup_header.heap_end_ptr __u16;
// 21. 0035 0001 effalign(1) fda=0 bits=0000 setup_header.ext_loader_ver __u8;
// 22. 0036 0001 effalign(1) fda=0 bits=0000 setup_header.ext_loader_type __u8;
// 23. 0037 0004 effalign(1) fda=0 bits=0000 setup_header.cmd_line_ptr __u32;
// 24. 003B 0004 effalign(1) fda=0 bits=0000 setup_header.initrd_addr_max __u32;
// 25. 003F 0004 effalign(1) fda=0 bits=0000 setup_header.kernel_alignment __u32;
// 26. 0043 0001 effalign(1) fda=0 bits=0000 setup_header.relocatable_kernel __u8;
// 27. 0044 0001 effalign(1) fda=0 bits=0000 setup_header.min_alignment __u8;
// 28. 0045 0002 effalign(1) fda=0 bits=0000 setup_header.xloadflags __u16;
// 29. 0047 0004 effalign(1) fda=0 bits=0000 setup_header.cmdline_size __u32;
// 30. 004B 0004 effalign(1) fda=0 bits=0000 setup_header.hardware_subarch __u32;
// 31. 004F 0008 effalign(1) fda=0 bits=0000 setup_header.hardware_subarch_data __u64;
// 32. 0057 0004 effalign(1) fda=0 bits=0000 setup_header.payload_offset __u32;
// 33. 005B 0004 effalign(1) fda=0 bits=0000 setup_header.payload_length __u32;
// 34. 005F 0008 effalign(1) fda=0 bits=0000 setup_header.setup_data __u64;
// 35. 0067 0008 effalign(1) fda=0 bits=0000 setup_header.pref_address __u64;
// 36. 006F 0004 effalign(1) fda=0 bits=0000 setup_header.init_size __u32;
// 37. 0073 0004 effalign(1) fda=0 bits=0000 setup_header.handover_offset __u32;
//          0077 effalign(1) sda=0 bits=0040 setup_header struct packalign=0

FFFFFFFF typedef scatterlist *__cdecl sg_alloc_fn(unsigned int, gfp_t);
00000018 struct sg_dma_page_iter
{
  sg_page_iter base;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 sg_dma_page_iter.base sg_page_iter;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 sg_dma_page_iter struct packalign=0

FFFFFFFF typedef void __cdecl sg_free_fn(scatterlist *, unsigned int);
FFFFFFFF struct sg_io_hdr;
000000A0 struct sg_io_v4
{
  __s32 guard;
  __u32 protocol;
  __u32 subprotocol;
  __u32 request_len;
  __u64 request;
  __u64 request_tag;
  __u32 request_attr;
  __u32 request_priority;
  __u32 request_extra;
  __u32 max_response_len;
  __u64 response;
  __u32 dout_iovec_count;
  __u32 dout_xfer_len;
  __u32 din_iovec_count;
  __u32 din_xfer_len;
  __u64 dout_xferp;
  __u64 din_xferp;
  __u32 timeout;
  __u32 flags;
  __u64 usr_ptr;
  __u32 spare_in;
  __u32 driver_status;
  __u32 transport_status;
  __u32 device_status;
  __u32 retry_delay;
  __u32 info;
  __u32 duration;
  __u32 response_len;
  __s32 din_resid;
  __s32 dout_resid;
  __u64 generated_tag;
  __u32 spare_out;
  __u32 padding;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 sg_io_v4.guard __s32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 sg_io_v4.protocol __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 sg_io_v4.subprotocol __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.request_len __u32;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 sg_io_v4.request __u64;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 sg_io_v4.request_tag __u64;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 sg_io_v4.request_attr __u32;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 sg_io_v4.request_priority __u32;
//  8. 0028 0004 effalign(4) fda=0 bits=0000 sg_io_v4.request_extra __u32;
//  9. 002C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.max_response_len __u32;
// 10. 0030 0008 effalign(8) fda=0 bits=0000 sg_io_v4.response __u64;
// 11. 0038 0004 effalign(4) fda=0 bits=0000 sg_io_v4.dout_iovec_count __u32;
// 12. 003C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.dout_xfer_len __u32;
// 13. 0040 0004 effalign(4) fda=0 bits=0000 sg_io_v4.din_iovec_count __u32;
// 14. 0044 0004 effalign(4) fda=0 bits=0000 sg_io_v4.din_xfer_len __u32;
// 15. 0048 0008 effalign(8) fda=0 bits=0000 sg_io_v4.dout_xferp __u64;
// 16. 0050 0008 effalign(8) fda=0 bits=0000 sg_io_v4.din_xferp __u64;
// 17. 0058 0004 effalign(4) fda=0 bits=0000 sg_io_v4.timeout __u32;
// 18. 005C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.flags __u32;
// 19. 0060 0008 effalign(8) fda=0 bits=0000 sg_io_v4.usr_ptr __u64;
// 20. 0068 0004 effalign(4) fda=0 bits=0000 sg_io_v4.spare_in __u32;
// 21. 006C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.driver_status __u32;
// 22. 0070 0004 effalign(4) fda=0 bits=0000 sg_io_v4.transport_status __u32;
// 23. 0074 0004 effalign(4) fda=0 bits=0000 sg_io_v4.device_status __u32;
// 24. 0078 0004 effalign(4) fda=0 bits=0000 sg_io_v4.retry_delay __u32;
// 25. 007C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.info __u32;
// 26. 0080 0004 effalign(4) fda=0 bits=0000 sg_io_v4.duration __u32;
// 27. 0084 0004 effalign(4) fda=0 bits=0000 sg_io_v4.response_len __u32;
// 28. 0088 0004 effalign(4) fda=0 bits=0000 sg_io_v4.din_resid __s32;
// 29. 008C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.dout_resid __s32;
// 30. 0090 0008 effalign(8) fda=0 bits=0000 sg_io_v4.generated_tag __u64;
// 31. 0098 0004 effalign(4) fda=0 bits=0000 sg_io_v4.spare_out __u32;
// 32. 009C 0004 effalign(4) fda=0 bits=0000 sg_io_v4.padding __u32;
//          00A0 effalign(8) sda=0 bits=0000 sg_io_v4 struct packalign=0

00000048 struct sg_mapping_iter
{
  page *page;
  void *addr;
  size_t length;
  size_t consumed;
  sg_page_iter piter;
  unsigned int __offset;
  unsigned int __remaining;
  unsigned int __flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sg_mapping_iter.page page *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sg_mapping_iter.addr void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sg_mapping_iter.length size_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 sg_mapping_iter.consumed size_t;
//  4. 0020 0018 effalign(8) fda=0 bits=0000 sg_mapping_iter.piter sg_page_iter;
//  5. 0038 0004 effalign(4) fda=0 bits=0000 sg_mapping_iter.__offset unsigned int;
//  6. 003C 0004 effalign(4) fda=0 bits=0000 sg_mapping_iter.__remaining unsigned int;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 sg_mapping_iter.__flags unsigned int;
//          0044 unpadded_size
//          0048 effalign(8) sda=0 bits=0000 sg_mapping_iter struct packalign=0

00000018 struct sg_page_iter
{
  scatterlist *sg;
  unsigned int sg_pgoffset;
  unsigned int __nents;
  int __pg_advance;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sg_page_iter.sg scatterlist *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 sg_page_iter.sg_pgoffset unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 sg_page_iter.__nents unsigned int;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 sg_page_iter.__pg_advance int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 sg_page_iter struct packalign=0

00000010 struct sg_table
{
  scatterlist *sgl;
  unsigned int nents;
  unsigned int orig_nents;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sg_table.sgl scatterlist *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 sg_table.nents unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 sg_table.orig_nents unsigned int;
//          0010 effalign(8) sda=0 bits=0000 sg_table struct packalign=0

00000030 struct shm_info
{
  int used_ids;
  __kernel_ulong_t shm_tot;
  __kernel_ulong_t shm_rss;
  __kernel_ulong_t shm_swp;
  __kernel_ulong_t swap_attempts;
  __kernel_ulong_t swap_successes;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 shm_info.used_ids int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 shm_info.shm_tot __kernel_ulong_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 shm_info.shm_rss __kernel_ulong_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 shm_info.shm_swp __kernel_ulong_t;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 shm_info.swap_attempts __kernel_ulong_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 shm_info.swap_successes __kernel_ulong_t;
//          0030 effalign(8) sda=0 bits=0000 shm_info struct packalign=0

00000070 struct shmid64_ds
{
  ipc64_perm shm_perm;
  size_t shm_segsz;
  __kernel_time_t shm_atime;
  __kernel_time_t shm_dtime;
  __kernel_time_t shm_ctime;
  __kernel_pid_t shm_cpid;
  __kernel_pid_t shm_lpid;
  unsigned __int64 shm_nattch;
  unsigned __int64 __unused4;
  unsigned __int64 __unused5;
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 shmid64_ds.shm_perm ipc64_perm;
//  1. 0030 0008 effalign(8) fda=0 bits=0000 shmid64_ds.shm_segsz size_t;
//  2. 0038 0008 effalign(8) fda=0 bits=0000 shmid64_ds.shm_atime __kernel_time_t;
//  3. 0040 0008 effalign(8) fda=0 bits=0000 shmid64_ds.shm_dtime __kernel_time_t;
//  4. 0048 0008 effalign(8) fda=0 bits=0000 shmid64_ds.shm_ctime __kernel_time_t;
//  5. 0050 0004 effalign(4) fda=0 bits=0000 shmid64_ds.shm_cpid __kernel_pid_t;
//  6. 0054 0004 effalign(4) fda=0 bits=0000 shmid64_ds.shm_lpid __kernel_pid_t;
//  7. 0058 0008 effalign(8) fda=0 bits=0000 shmid64_ds.shm_nattch unsigned __int64;
//  8. 0060 0008 effalign(8) fda=0 bits=0000 shmid64_ds.__unused4 unsigned __int64;
//  9. 0068 0008 effalign(8) fda=0 bits=0000 shmid64_ds.__unused5 unsigned __int64;
//          0070 effalign(8) sda=0 bits=0000 shmid64_ds struct packalign=0

00000058 struct shmid_ds
{
  ipc_perm shm_perm;
  int shm_segsz;
  __kernel_time_t shm_atime;
  __kernel_time_t shm_dtime;
  __kernel_time_t shm_ctime;
  __kernel_ipc_pid_t shm_cpid;
  __kernel_ipc_pid_t shm_lpid;
  unsigned __int16 shm_nattch;
  unsigned __int16 shm_unused;
  void *shm_unused2;
  void *shm_unused3;
};
//  0. 0000 001C effalign(4) fda=0 bits=0000 shmid_ds.shm_perm ipc_perm;
//  1. 001C 0004 effalign(4) fda=0 bits=0000 shmid_ds.shm_segsz int;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 shmid_ds.shm_atime __kernel_time_t;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 shmid_ds.shm_dtime __kernel_time_t;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 shmid_ds.shm_ctime __kernel_time_t;
//  5. 0038 0004 effalign(4) fda=0 bits=0000 shmid_ds.shm_cpid __kernel_ipc_pid_t;
//  6. 003C 0004 effalign(4) fda=0 bits=0000 shmid_ds.shm_lpid __kernel_ipc_pid_t;
//  7. 0040 0002 effalign(2) fda=0 bits=0000 shmid_ds.shm_nattch unsigned __int16;
//  8. 0042 0002 effalign(2) fda=0 bits=0000 shmid_ds.shm_unused unsigned __int16;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 shmid_ds.shm_unused2 void *;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 shmid_ds.shm_unused3 void *;
//          0058 effalign(8) sda=0 bits=0000 shmid_ds struct packalign=0

00000014 struct shminfo
{
  int shmmax;
  int shmmin;
  int shmmni;
  int shmseg;
  int shmall;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 shminfo.shmmax int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 shminfo.shmmin int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 shminfo.shmmni int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 shminfo.shmseg int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 shminfo.shmall int;
//          0014 effalign(4) sda=0 bits=0000 shminfo struct packalign=0

00000048 struct shminfo64
{
  unsigned __int64 shmmax;
  unsigned __int64 shmmin;
  unsigned __int64 shmmni;
  unsigned __int64 shmseg;
  unsigned __int64 shmall;
  unsigned __int64 __unused1;
  unsigned __int64 __unused2;
  unsigned __int64 __unused3;
  unsigned __int64 __unused4;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 shminfo64.shmmax unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 shminfo64.shmmin unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 shminfo64.shmmni unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 shminfo64.shmseg unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 shminfo64.shmall unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 shminfo64.__unused1 unsigned __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 shminfo64.__unused2 unsigned __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 shminfo64.__unused3 unsigned __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 shminfo64.__unused4 unsigned __int64;
//          0048 effalign(8) sda=0 bits=0000 shminfo64 struct packalign=0

00000020 struct shrink_control
{
  gfp_t gfp_mask;
  int nid;
  unsigned __int64 nr_to_scan;
  unsigned __int64 nr_scanned;
  mem_cgroup *memcg;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 shrink_control.gfp_mask gfp_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 shrink_control.nid int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 shrink_control.nr_to_scan unsigned __int64;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 shrink_control.nr_scanned unsigned __int64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 shrink_control.memcg mem_cgroup *;
//          0020 effalign(8) sda=0 bits=0000 shrink_control struct packalign=0

00000040 struct shrinker
{
  unsigned __int64 (__cdecl *count_objects)(shrinker *, shrink_control *);
  unsigned __int64 (__cdecl *scan_objects)(shrinker *, shrink_control *);
  __int64 batch;
  int seeks;
  unsigned int flags;
  list_head list;
  int id;
  atomic_long_t *nr_deferred;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 shrinker.count_objects unsigned __int64 (__cdecl *)(shrinker *, shrink_control *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 shrinker.scan_objects unsigned __int64 (__cdecl *)(shrinker *, shrink_control *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 shrinker.batch __int64;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 shrinker.seeks int;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 shrinker.flags unsigned int;
//  5. 0020 0010 effalign(8) fda=0 bits=0000 shrinker.list list_head;
//  6. 0030 0004 effalign(4) fda=0 bits=0000 shrinker.id int;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 shrinker.nr_deferred atomic_long_t *;
//          0040 effalign(8) sda=0 bits=0000 shrinker struct packalign=0

00000020 struct sigaction
{
  __sighandler_t sa_handler;
  unsigned __int64 sa_flags;
  __sigrestore_t sa_restorer;
  sigset_t sa_mask;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sigaction.sa_handler __sighandler_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sigaction.sa_flags unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sigaction.sa_restorer __sigrestore_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 sigaction.sa_mask sigset_t;
//          0020 effalign(8) sda=0 bits=0000 sigaction struct packalign=0

00000018 struct sigaltstack
{
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sigaltstack.ss_sp void *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 sigaltstack.ss_flags int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sigaltstack.ss_size size_t;
//          0018 effalign(8) sda=0 bits=0000 sigaltstack struct packalign=0

00000058 struct sigcontext_32
{
  __u16 gs;
  __u16 __gsh;
  __u16 fs;
  __u16 __fsh;
  __u16 es;
  __u16 __esh;
  __u16 ds;
  __u16 __dsh;
  __u32 di;
  __u32 si;
  __u32 bp;
  __u32 sp;
  __u32 bx;
  __u32 dx;
  __u32 cx;
  __u32 ax;
  __u32 trapno;
  __u32 err;
  __u32 ip;
  __u16 cs;
  __u16 __csh;
  __u32 flags;
  __u32 sp_at_signal;
  __u16 ss;
  __u16 __ssh;
  __u32 fpstate;
  __u32 oldmask;
  __u32 cr2;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 sigcontext_32.gs __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__gsh __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 sigcontext_32.fs __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__fsh __u16;
//  4. 0008 0002 effalign(2) fda=0 bits=0000 sigcontext_32.es __u16;
//  5. 000A 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__esh __u16;
//  6. 000C 0002 effalign(2) fda=0 bits=0000 sigcontext_32.ds __u16;
//  7. 000E 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__dsh __u16;
//  8. 0010 0004 effalign(4) fda=0 bits=0000 sigcontext_32.di __u32;
//  9. 0014 0004 effalign(4) fda=0 bits=0000 sigcontext_32.si __u32;
// 10. 0018 0004 effalign(4) fda=0 bits=0000 sigcontext_32.bp __u32;
// 11. 001C 0004 effalign(4) fda=0 bits=0000 sigcontext_32.sp __u32;
// 12. 0020 0004 effalign(4) fda=0 bits=0000 sigcontext_32.bx __u32;
// 13. 0024 0004 effalign(4) fda=0 bits=0000 sigcontext_32.dx __u32;
// 14. 0028 0004 effalign(4) fda=0 bits=0000 sigcontext_32.cx __u32;
// 15. 002C 0004 effalign(4) fda=0 bits=0000 sigcontext_32.ax __u32;
// 16. 0030 0004 effalign(4) fda=0 bits=0000 sigcontext_32.trapno __u32;
// 17. 0034 0004 effalign(4) fda=0 bits=0000 sigcontext_32.err __u32;
// 18. 0038 0004 effalign(4) fda=0 bits=0000 sigcontext_32.ip __u32;
// 19. 003C 0002 effalign(2) fda=0 bits=0000 sigcontext_32.cs __u16;
// 20. 003E 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__csh __u16;
// 21. 0040 0004 effalign(4) fda=0 bits=0000 sigcontext_32.flags __u32;
// 22. 0044 0004 effalign(4) fda=0 bits=0000 sigcontext_32.sp_at_signal __u32;
// 23. 0048 0002 effalign(2) fda=0 bits=0000 sigcontext_32.ss __u16;
// 24. 004A 0002 effalign(2) fda=0 bits=0000 sigcontext_32.__ssh __u16;
// 25. 004C 0004 effalign(4) fda=0 bits=0000 sigcontext_32.fpstate __u32;
// 26. 0050 0004 effalign(4) fda=0 bits=0000 sigcontext_32.oldmask __u32;
// 27. 0054 0004 effalign(4) fda=0 bits=0000 sigcontext_32.cr2 __u32;
//          0058 effalign(4) sda=0 bits=0000 sigcontext_32 struct packalign=0

00000100 struct sigcontext_64
{
  __u64 r8;
  __u64 r9;
  __u64 r10;
  __u64 r11;
  __u64 r12;
  __u64 r13;
  __u64 r14;
  __u64 r15;
  __u64 di;
  __u64 si;
  __u64 bp;
  __u64 bx;
  __u64 dx;
  __u64 ax;
  __u64 cx;
  __u64 sp;
  __u64 ip;
  __u64 flags;
  __u16 cs;
  __u16 gs;
  __u16 fs;
  __u16 ss;
  __u64 err;
  __u64 trapno;
  __u64 oldmask;
  __u64 cr2;
  __u64 fpstate;
  __u64 reserved1[8];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r8 __u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r9 __u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r10 __u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r11 __u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r12 __u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r13 __u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r14 __u64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 sigcontext_64.r15 __u64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 sigcontext_64.di __u64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 sigcontext_64.si __u64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 sigcontext_64.bp __u64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 sigcontext_64.bx __u64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 sigcontext_64.dx __u64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 sigcontext_64.ax __u64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 sigcontext_64.cx __u64;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 sigcontext_64.sp __u64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 sigcontext_64.ip __u64;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 sigcontext_64.flags __u64;
// 18. 0090 0002 effalign(2) fda=0 bits=0000 sigcontext_64.cs __u16;
// 19. 0092 0002 effalign(2) fda=0 bits=0000 sigcontext_64.gs __u16;
// 20. 0094 0002 effalign(2) fda=0 bits=0000 sigcontext_64.fs __u16;
// 21. 0096 0002 effalign(2) fda=0 bits=0000 sigcontext_64.ss __u16;
// 22. 0098 0008 effalign(8) fda=0 bits=0000 sigcontext_64.err __u64;
// 23. 00A0 0008 effalign(8) fda=0 bits=0000 sigcontext_64.trapno __u64;
// 24. 00A8 0008 effalign(8) fda=0 bits=0000 sigcontext_64.oldmask __u64;
// 25. 00B0 0008 effalign(8) fda=0 bits=0000 sigcontext_64.cr2 __u64;
// 26. 00B8 0008 effalign(8) fda=0 bits=0000 sigcontext_64.fpstate __u64;
// 27. 00C0 0040 effalign(8) fda=0 bits=0000 sigcontext_64.reserved1 __u64[8];
//          0100 effalign(8) sda=0 bits=0000 sigcontext_64 struct packalign=0

00000040 struct sigevent
{
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  sigevent::$436D4785166B028C119417249B10F5CD _sigev_un;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sigevent.sigev_value sigval_t;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 sigevent.sigev_signo int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 sigevent.sigev_notify int;
//  3. 0010 0030 effalign(8) fda=0 bits=0000 sigevent._sigev_un sigevent::$436D4785166B028C119417249B10F5CD;
//          0040 effalign(8) sda=0 bits=0000 sigevent struct packalign=0

00000030 union sigevent::$436D4785166B028C119417249B10F5CD
{
  int _pad[12];
  int _tid;
  $52EB9FD98AFFF636B8D8273C5836D4A5 _sigev_thread;
};
//  0. 0000 0030 effalign(4) fda=0 bits=0000 sigevent::$436D4785166B028C119417249B10F5CD._pad int[12];
//  1. 0000 0004 effalign(4) fda=0 bits=0000 sigevent::$436D4785166B028C119417249B10F5CD._tid int;
//  2. 0000 0010 effalign(8) fda=0 bits=0000 sigevent::$436D4785166B028C119417249B10F5CD._sigev_thread $52EB9FD98AFFF636B8D8273C5836D4A5;
//          0030 effalign(8) sda=0 bits=0000 sigevent::$436D4785166B028C119417249B10F5CD union packalign=0

00000040 typedef sigevent sigevent_t;
FFFFFFFF struct sighand_struct;
00000080 struct siginfo
{
  union
  {
    struct
    {
      int si_signo;
      int si_errno;
      int si_code;
      __sifields _sifields;
    };
    int _si_pad[32];
  };
};
//  0. 0000 0080 effalign(8) fda=0 bits=0000 siginfo.siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7 siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7;
//          0080 effalign(8) sda=0 bits=0000 siginfo struct packalign=0

00000080 union siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7
{
  struct
  {
    int si_signo;
    int si_errno;
    int si_code;
    __sifields _sifields;
  };
  int _si_pad[32];
};
//  0. 0000 0030 effalign(8) fda=0 bits=0000 siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7.$EEA86D27551D0E98B064575E41986325 $EEA86D27551D0E98B064575E41986325;
//  1. 0000 0080 effalign(4) fda=0 bits=0000 siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7._si_pad int[32];
//          0080 effalign(8) sda=0 bits=0000 siginfo::$C1D7B7F82FC7637C5062ED16FAD0FCA7 union packalign=0

00000080 typedef siginfo siginfo_t;
FFFFFFFF struct signal_struct;
00000018 struct sigpending
{
  list_head list;
  sigset_t signal;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 sigpending.list list_head;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 sigpending.signal sigset_t;
//          0018 effalign(8) sda=0 bits=0000 sigpending struct packalign=0

00000050 struct sigqueue
{
  list_head list;
  int flags;
  kernel_siginfo_t info;
  user_struct *user;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 sigqueue.list list_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 sigqueue.flags int;
//  2. 0018 0030 effalign(8) fda=0 bits=0000 sigqueue.info kernel_siginfo_t;
//  3. 0048 0008 effalign(8) fda=0 bits=0000 sigqueue.user user_struct *;
//          0050 effalign(8) sda=0 bits=0000 sigqueue struct packalign=0

00000008 struct sigset_t
{
  unsigned __int64 sig[1];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sigset_t.sig unsigned __int64[1];
//          0008 effalign(8) sda=0 bits=0000 sigset_t struct packalign=0

00000008 union sigval
{
  int sival_int;
  void *sival_ptr;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 sigval.sival_int int;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 sigval.sival_ptr void *;
//          0008 effalign(8) sda=0 bits=0000 sigval union packalign=0

00000008 typedef sigval sigval_t;
00000008 struct simple_transaction_argresp
{
  ssize_t size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 simple_transaction_argresp.size ssize_t;
//          0008 effalign(8) sda=0 bits=0000 simple_transaction_argresp struct packalign=0

00000008 typedef __kernel_size_t size_t;
00000004 enum sk_action : unsigned __int32
{
  SK_DROP = 0x0,
  SK_PASS = 0x1,
};
FFFFFFFF struct sk_buff;
00000048 struct sk_msg_md
{
  union __attribute__((aligned(8)))
  {
    void *data;
    unsigned __int64 : 64;
  };
  union __attribute__((aligned(8)))
  {
    void *data_end;
    unsigned __int64 : 64;
  };
  unsigned int family;
  __u32 remote_ip4;
  __u32 local_ip4;
  __u32 remote_ip6[4];
  __u32 local_ip6[4];
  __u32 remote_port;
  __u32 local_port;
  __u32 size;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_msg_md.sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319 sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sk_msg_md.sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5 sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 sk_msg_md.family __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 sk_msg_md.remote_ip4 __u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 sk_msg_md.local_ip4 __u32;
//  5. 001C 0010 effalign(4) fda=0 bits=0000 sk_msg_md.remote_ip6 __u32[4];
//  6. 002C 0010 effalign(4) fda=0 bits=0000 sk_msg_md.local_ip6 __u32[4];
//  7. 003C 0004 effalign(4) fda=0 bits=0000 sk_msg_md.remote_port __u32;
//  8. 0040 0004 effalign(4) fda=0 bits=0000 sk_msg_md.local_port __u32;
//  9. 0044 0004 effalign(4) fda=0 bits=0000 sk_msg_md.size __u32;
//          0048 effalign(8) sda=0 bits=0000 sk_msg_md struct packalign=0

00000008 union __attribute__((aligned(8))) sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319
{
  void *data;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319.data void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 sk_msg_md::$2B8B040AFD77C85A47AF3D63B66D2319 union packalign=0

00000008 union __attribute__((aligned(8))) sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5
{
  void *data_end;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5.data_end void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 sk_msg_md::$BAD9C022845DC13A89FBF0CA7B41ADD5 union packalign=0

00000028 struct sk_reuseport_md
{
  union __attribute__((aligned(8)))
  {
    void *data;
    unsigned __int64 : 64;
  };
  union __attribute__((aligned(8)))
  {
    void *data_end;
    unsigned __int64 : 64;
  };
  unsigned int len;
  __u32 eth_protocol;
  __u32 ip_protocol;
  __u32 bind_inany;
  __u32 hash;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_reuseport_md.sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319 sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sk_reuseport_md.sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5 sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 sk_reuseport_md.len __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 sk_reuseport_md.eth_protocol __u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 sk_reuseport_md.ip_protocol __u32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 sk_reuseport_md.bind_inany __u32;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 sk_reuseport_md.hash __u32;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 sk_reuseport_md struct packalign=0

00000008 union __attribute__((aligned(8))) sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319
{
  void *data;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319.data void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 sk_reuseport_md::$2B8B040AFD77C85A47AF3D63B66D2319 union packalign=0

00000008 union __attribute__((aligned(8))) sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5
{
  void *data_end;
  unsigned __int64 : 64;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5.data_end void *;
//  1. 0000. 0 64 effalign(8) fda=0 bits=0000 sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5.(null) bi.nbytes=8 U
//          0008 effalign(8) sda=4 bits=0000 sk_reuseport_md::$BAD9C022845DC13A89FBF0CA7B41ADD5 union packalign=0

00000004 typedef unsigned int slab_flags_t;
00000010 struct slim_device_id
{
  __u16 manf_id;
  __u16 prod_code;
  __u16 dev_index;
  __u16 instance;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 slim_device_id.manf_id __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 slim_device_id.prod_code __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 slim_device_id.dev_index __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 slim_device_id.instance __u16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 slim_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 slim_device_id struct packalign=0

00000008 typedef void (__cdecl *smp_call_func_t)(void *);
00000060 struct smp_ops
{
  void (*smp_prepare_boot_cpu)(void);
  void (__cdecl *smp_prepare_cpus)(unsigned int);
  void (__cdecl *smp_cpus_done)(unsigned int);
  void (__cdecl *stop_other_cpus)(int);
  void (*crash_stop_other_cpus)(void);
  void (__cdecl *smp_send_reschedule)(int);
  int (__cdecl *cpu_up)(unsigned int, task_struct *);
  int (*cpu_disable)(void);
  void (__cdecl *cpu_die)(unsigned int);
  void (*play_dead)(void);
  void (__cdecl *send_call_func_ipi)(const cpumask *);
  void (__cdecl *send_call_func_single_ipi)(int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 smp_ops.smp_prepare_boot_cpu void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 smp_ops.smp_prepare_cpus void (__cdecl *)(unsigned int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 smp_ops.smp_cpus_done void (__cdecl *)(unsigned int);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 smp_ops.stop_other_cpus void (__cdecl *)(int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 smp_ops.crash_stop_other_cpus void (*)(void);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 smp_ops.smp_send_reschedule void (__cdecl *)(int);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 smp_ops.cpu_up int (__cdecl *)(unsigned int, task_struct *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 smp_ops.cpu_disable int (*)(void);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 smp_ops.cpu_die void (__cdecl *)(unsigned int);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 smp_ops.play_dead void (*)(void);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 smp_ops.send_call_func_ipi void (__cdecl *)(const cpumask *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 smp_ops.send_call_func_single_ipi void (__cdecl *)(int);
//          0060 effalign(8) sda=0 bits=0000 smp_ops struct packalign=0

FFFFFFFF struct sock;
00000008 struct softirq_action
{
  void (__cdecl *action)(softirq_action *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 softirq_action.action void (__cdecl *)(softirq_action *);
//          0008 effalign(8) sda=0 bits=0000 softirq_action struct packalign=0

00000020 struct software_node
{
  const char *name;
  const software_node *parent;
  const property_entry *properties;
  const software_node_reference *references;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 software_node.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 software_node.parent const software_node *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 software_node.properties const property_entry *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 software_node.references const software_node_reference *;
//          0020 effalign(8) sda=0 bits=0000 software_node struct packalign=0

00000050 struct software_node_ref_args
{
  const software_node *node;
  unsigned int nargs;
  u64 args[8];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 software_node_ref_args.node const software_node *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 software_node_ref_args.nargs unsigned int;
//  2. 0010 0040 effalign(8) fda=0 bits=0000 software_node_ref_args.args u64[8];
//          0050 effalign(8) sda=0 bits=0000 software_node_ref_args struct packalign=0

00000018 struct software_node_reference
{
  const char *name;
  unsigned int nrefs;
  const software_node_ref_args *refs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 software_node_reference.name const char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 software_node_reference.nrefs unsigned int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 software_node_reference.refs const software_node_ref_args *;
//          0018 effalign(8) sda=0 bits=0000 software_node_reference struct packalign=0

0000000C struct solaris_x86_slice
{
  __le16 s_tag;
  __le16 s_flag;
  __le32 s_start;
  __le32 s_size;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 solaris_x86_slice.s_tag __le16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 solaris_x86_slice.s_flag __le16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 solaris_x86_slice.s_start __le32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 solaris_x86_slice.s_size __le32;
//          000C effalign(4) sda=0 bits=0000 solaris_x86_slice struct packalign=0

000001C8 struct solaris_x86_vtoc
{
  unsigned int v_bootinfo[3];
  __le32 v_sanity;
  __le32 v_version;
  char v_volume[8];
  __le16 v_sectorsz;
  __le16 v_nparts;
  unsigned int v_reserved[10];
  solaris_x86_slice v_slice[16];
  unsigned int timestamp[16];
  char v_asciilabel[128];
};
//  0. 0000 000C effalign(4) fda=0 bits=0000 solaris_x86_vtoc.v_bootinfo unsigned int[3];
//  1. 000C 0004 effalign(4) fda=0 bits=0000 solaris_x86_vtoc.v_sanity __le32;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 solaris_x86_vtoc.v_version __le32;
//  3. 0014 0008 effalign(1) fda=0 bits=0000 solaris_x86_vtoc.v_volume char[8];
//  4. 001C 0002 effalign(2) fda=0 bits=0000 solaris_x86_vtoc.v_sectorsz __le16;
//  5. 001E 0002 effalign(2) fda=0 bits=0000 solaris_x86_vtoc.v_nparts __le16;
//  6. 0020 0028 effalign(4) fda=0 bits=0000 solaris_x86_vtoc.v_reserved unsigned int[10];
//  7. 0048 00C0 effalign(4) fda=0 bits=0000 solaris_x86_vtoc.v_slice solaris_x86_slice[16];
//  8. 0108 0040 effalign(4) fda=0 bits=0000 solaris_x86_vtoc.timestamp unsigned int[16];
//  9. 0148 0080 effalign(1) fda=0 bits=0000 solaris_x86_vtoc.v_asciilabel char[128];
//          01C8 effalign(4) sda=0 bits=0000 solaris_x86_vtoc struct packalign=0

00000004 enum spectre_v2_mitigation : unsigned __int32
{
  SPECTRE_V2_NONE = 0x0,
  SPECTRE_V2_RETPOLINE = 0x1,
  SPECTRE_V2_LFENCE = 0x2,
  SPECTRE_V2_EIBRS = 0x3,
  SPECTRE_V2_EIBRS_RETPOLINE = 0x4,
  SPECTRE_V2_EIBRS_LFENCE = 0x5,
  SPECTRE_V2_IBRS = 0x6,
};
00000004 enum spectre_v2_user_mitigation : unsigned __int32
{
  SPECTRE_V2_USER_NONE = 0x0,
  SPECTRE_V2_USER_STRICT = 0x1,
  SPECTRE_V2_USER_STRICT_PREFERRED = 0x2,
  SPECTRE_V2_USER_PRCTL = 0x3,
  SPECTRE_V2_USER_SECCOMP = 0x4,
};
00000028 struct spi_device_id
{
  char name[32];
  kernel_ulong_t driver_data;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 spi_device_id.name char[32];
//  1. 0020 0008 effalign(8) fda=0 bits=0000 spi_device_id.driver_data kernel_ulong_t;
//          0028 effalign(8) sda=0 bits=0000 spi_device_id struct packalign=0

00000004 struct spinlock
{
  union
  {
    raw_spinlock rlock;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 spinlock.spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E;
//          0004 effalign(4) sda=0 bits=0000 spinlock struct packalign=0

00000004 union spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E
{
  raw_spinlock rlock;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E.rlock raw_spinlock;
//          0004 effalign(4) sda=0 bits=0000 spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E union packalign=0

00000004 typedef spinlock spinlock_t;
00000028 struct spmi_device_id
{
  char name[32];
  kernel_ulong_t driver_data;
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 spmi_device_id.name char[32];
//  1. 0020 0008 effalign(8) fda=0 bits=0000 spmi_device_id.driver_data kernel_ulong_t;
//          0028 effalign(8) sda=0 bits=0000 spmi_device_id struct packalign=0

00000140 struct srcu_data
{
  unsigned __int64 srcu_lock_count[2];
  unsigned __int64 srcu_unlock_count[2];
  __attribute__((aligned(64))) spinlock_t lock;
  rcu_segcblist srcu_cblist;
  unsigned __int64 srcu_gp_seq_needed;
  unsigned __int64 srcu_gp_seq_needed_exp;
  bool srcu_cblist_invoking;
  timer_list delay_work;
  work_struct work;
  callback_head srcu_barrier_head;
  srcu_node *mynode;
  unsigned __int64 grpmask;
  int cpu;
  srcu_struct *ssp;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 srcu_data.srcu_lock_count unsigned __int64[2];
//  1. 0010 0010 effalign(8) fda=0 bits=0000 srcu_data.srcu_unlock_count unsigned __int64[2];
//  2. 0040 0004 effalign(64) fda=7 bits=0000 srcu_data.lock spinlock_t;
//  3. 0048 0060 effalign(8) fda=0 bits=0000 srcu_data.srcu_cblist rcu_segcblist;
//  4. 00A8 0008 effalign(8) fda=0 bits=0000 srcu_data.srcu_gp_seq_needed unsigned __int64;
//  5. 00B0 0008 effalign(8) fda=0 bits=0000 srcu_data.srcu_gp_seq_needed_exp unsigned __int64;
//  6. 00B8 0001 effalign(1) fda=0 bits=0000 srcu_data.srcu_cblist_invoking bool;
//  7. 00C0 0028 effalign(8) fda=0 bits=0000 srcu_data.delay_work timer_list;
//  8. 00E8 0020 effalign(8) fda=0 bits=0000 srcu_data.work work_struct;
//  9. 0108 0010 effalign(8) fda=0 bits=0000 srcu_data.srcu_barrier_head callback_head;
// 10. 0118 0008 effalign(8) fda=0 bits=0000 srcu_data.mynode srcu_node *;
// 11. 0120 0008 effalign(8) fda=0 bits=0000 srcu_data.grpmask unsigned __int64;
// 12. 0128 0004 effalign(4) fda=0 bits=0000 srcu_data.cpu int;
// 13. 0130 0008 effalign(8) fda=0 bits=0000 srcu_data.ssp srcu_struct *;
//          0138 unpadded_size
//          0140 effalign(64) sda=0 bits=0000 srcu_data struct packalign=0

00000060 struct srcu_node
{
  spinlock_t lock;
  unsigned __int64 srcu_have_cbs[4];
  unsigned __int64 srcu_data_have_cbs[4];
  unsigned __int64 srcu_gp_seq_needed_exp;
  srcu_node *srcu_parent;
  int grplo;
  int grphi;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 srcu_node.lock spinlock_t;
//  1. 0008 0020 effalign(8) fda=0 bits=0000 srcu_node.srcu_have_cbs unsigned __int64[4];
//  2. 0028 0020 effalign(8) fda=0 bits=0000 srcu_node.srcu_data_have_cbs unsigned __int64[4];
//  3. 0048 0008 effalign(8) fda=0 bits=0000 srcu_node.srcu_gp_seq_needed_exp unsigned __int64;
//  4. 0050 0008 effalign(8) fda=0 bits=0000 srcu_node.srcu_parent srcu_node *;
//  5. 0058 0004 effalign(4) fda=0 bits=0000 srcu_node.grplo int;
//  6. 005C 0004 effalign(4) fda=0 bits=0000 srcu_node.grphi int;
//          0060 effalign(8) sda=0 bits=0000 srcu_node struct packalign=0

0000C4C8 struct srcu_notifier_head
{
  mutex mutex;
  srcu_struct srcu;
  notifier_block *head;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 srcu_notifier_head.mutex mutex;
//  1. 0020 C4A0 effalign(8) fda=0 bits=0000 srcu_notifier_head.srcu srcu_struct;
//  2. C4C0 0008 effalign(8) fda=0 bits=0000 srcu_notifier_head.head notifier_block *;
//          C4C8 effalign(8) sda=0 bits=0000 srcu_notifier_head struct packalign=0

0000C4A0 struct srcu_struct
{
  srcu_node node[521];
  srcu_node *level[4];
  mutex srcu_cb_mutex;
  spinlock_t lock;
  mutex srcu_gp_mutex;
  unsigned int srcu_idx;
  unsigned __int64 srcu_gp_seq;
  unsigned __int64 srcu_gp_seq_needed;
  unsigned __int64 srcu_gp_seq_needed_exp;
  unsigned __int64 srcu_last_gp_end;
  srcu_data *sda;
  unsigned __int64 srcu_barrier_seq;
  mutex srcu_barrier_mutex;
  completion srcu_barrier_completion;
  atomic_t srcu_barrier_cpu_cnt;
  delayed_work work;
};
//  0. 0000 C360 effalign(8) fda=0 bits=0000 srcu_struct.node srcu_node[521];
//  1. C360 0020 effalign(8) fda=0 bits=0000 srcu_struct.level srcu_node *[4];
//  2. C380 0020 effalign(8) fda=0 bits=0000 srcu_struct.srcu_cb_mutex mutex;
//  3. C3A0 0004 effalign(4) fda=0 bits=0000 srcu_struct.lock spinlock_t;
//  4. C3A8 0020 effalign(8) fda=0 bits=0000 srcu_struct.srcu_gp_mutex mutex;
//  5. C3C8 0004 effalign(4) fda=0 bits=0000 srcu_struct.srcu_idx unsigned int;
//  6. C3D0 0008 effalign(8) fda=0 bits=0000 srcu_struct.srcu_gp_seq unsigned __int64;
//  7. C3D8 0008 effalign(8) fda=0 bits=0000 srcu_struct.srcu_gp_seq_needed unsigned __int64;
//  8. C3E0 0008 effalign(8) fda=0 bits=0000 srcu_struct.srcu_gp_seq_needed_exp unsigned __int64;
//  9. C3E8 0008 effalign(8) fda=0 bits=0000 srcu_struct.srcu_last_gp_end unsigned __int64;
// 10. C3F0 0008 effalign(8) fda=0 bits=0000 srcu_struct.sda srcu_data *;
// 11. C3F8 0008 effalign(8) fda=0 bits=0000 srcu_struct.srcu_barrier_seq unsigned __int64;
// 12. C400 0020 effalign(8) fda=0 bits=0000 srcu_struct.srcu_barrier_mutex mutex;
// 13. C420 0020 effalign(8) fda=0 bits=0000 srcu_struct.srcu_barrier_completion completion;
// 14. C440 0004 effalign(4) fda=0 bits=0000 srcu_struct.srcu_barrier_cpu_cnt atomic_t;
// 15. C448 0058 effalign(8) fda=0 bits=0000 srcu_struct.work delayed_work;
//          C49C unpadded_size
//          C4A0 effalign(8) sda=0 bits=0000 srcu_struct struct packalign=0

00000006 struct __attribute__((packed)) __attribute__((aligned(2))) ssb_device_id
{
  __u16 vendor;
  __u16 coreid;
  __u8 revision;
  __u8 __pad;
};
//  0. 0000 0002 effalign(1) fda=0 bits=0000 ssb_device_id.vendor __u16;
//  1. 0002 0002 effalign(1) fda=0 bits=0000 ssb_device_id.coreid __u16;
//  2. 0004 0001 effalign(1) fda=0 bits=0000 ssb_device_id.revision __u8;
//  3. 0005 0001 effalign(1) fda=0 bits=0000 ssb_device_id.__pad __u8;
//          0006 effalign(2) sda=2 bits=0040 ssb_device_id struct packalign=0

00000004 enum ssb_mitigation : unsigned __int32
{
  SPEC_STORE_BYPASS_NONE = 0x0,
  SPEC_STORE_BYPASS_DISABLE = 0x1,
  SPEC_STORE_BYPASS_PRCTL = 0x2,
  SPEC_STORE_BYPASS_SECCOMP = 0x3,
};
00000008 typedef __kernel_ssize_t ssize_t;
00000018 typedef sigaltstack stack_t;
00000008 typedef bool (__cdecl *stack_trace_consume_fn)(void *, unsigned __int64, bool);
00000090 struct stat
{
  __kernel_ulong_t st_dev;
  __kernel_ulong_t st_ino;
  __kernel_ulong_t st_nlink;
  unsigned int st_mode;
  unsigned int st_uid;
  unsigned int st_gid;
  unsigned int __pad0;
  __kernel_ulong_t st_rdev;
  __kernel_long_t st_size;
  __kernel_long_t st_blksize;
  __kernel_long_t st_blocks;
  __kernel_ulong_t st_atime;
  __kernel_ulong_t st_atime_nsec;
  __kernel_ulong_t st_mtime;
  __kernel_ulong_t st_mtime_nsec;
  __kernel_ulong_t st_ctime;
  __kernel_ulong_t st_ctime_nsec;
  __kernel_long_t __unused[3];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 stat.st_dev __kernel_ulong_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 stat.st_ino __kernel_ulong_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 stat.st_nlink __kernel_ulong_t;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 stat.st_mode unsigned int;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 stat.st_uid unsigned int;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 stat.st_gid unsigned int;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 stat.__pad0 unsigned int;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 stat.st_rdev __kernel_ulong_t;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 stat.st_size __kernel_long_t;
//  9. 0038 0008 effalign(8) fda=0 bits=0000 stat.st_blksize __kernel_long_t;
// 10. 0040 0008 effalign(8) fda=0 bits=0000 stat.st_blocks __kernel_long_t;
// 11. 0048 0008 effalign(8) fda=0 bits=0000 stat.st_atime __kernel_ulong_t;
// 12. 0050 0008 effalign(8) fda=0 bits=0000 stat.st_atime_nsec __kernel_ulong_t;
// 13. 0058 0008 effalign(8) fda=0 bits=0000 stat.st_mtime __kernel_ulong_t;
// 14. 0060 0008 effalign(8) fda=0 bits=0000 stat.st_mtime_nsec __kernel_ulong_t;
// 15. 0068 0008 effalign(8) fda=0 bits=0000 stat.st_ctime __kernel_ulong_t;
// 16. 0070 0008 effalign(8) fda=0 bits=0000 stat.st_ctime_nsec __kernel_ulong_t;
// 17. 0078 0018 effalign(8) fda=0 bits=0000 stat.__unused __kernel_long_t[3];
//          0090 effalign(8) sda=0 bits=0000 stat struct packalign=0

00000004 enum stat_group : unsigned __int32
{
  STAT_READ = 0x0,
  STAT_WRITE = 0x1,
  STAT_DISCARD = 0x2,
  NR_STAT_GROUPS = 0x3,
};
00000010 struct static_key
{
  atomic_t enabled;
  union
  {
    unsigned __int64 type;
    jump_entry *entries;
    static_key_mod *next;
  };
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 static_key.enabled atomic_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 static_key.static_key::$15D808B9BC6BCFB2F1E1C63606903167 static_key::$15D808B9BC6BCFB2F1E1C63606903167;
//          0010 effalign(8) sda=0 bits=0000 static_key struct packalign=0

00000008 union static_key::$15D808B9BC6BCFB2F1E1C63606903167
{
  unsigned __int64 type;
  jump_entry *entries;
  static_key_mod *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 static_key::$15D808B9BC6BCFB2F1E1C63606903167.type unsigned __int64;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 static_key::$15D808B9BC6BCFB2F1E1C63606903167.entries jump_entry *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 static_key::$15D808B9BC6BCFB2F1E1C63606903167.next static_key_mod *;
//          0008 effalign(8) sda=0 bits=0000 static_key::$15D808B9BC6BCFB2F1E1C63606903167 union packalign=0

00000010 struct static_key_false
{
  static_key key;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 static_key_false.key static_key;
//          0010 effalign(8) sda=0 bits=0000 static_key_false struct packalign=0

FFFFFFFF struct static_key_mod;
00000010 struct static_key_true
{
  static_key key;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 static_key_true.key static_key;
//          0010 effalign(8) sda=0 bits=0000 static_key_true struct packalign=0

00000100 struct statx
{
  __u32 stx_mask;
  __u32 stx_blksize;
  __u64 stx_attributes;
  __u32 stx_nlink;
  __u32 stx_uid;
  __u32 stx_gid;
  __u16 stx_mode;
  __u16 __spare0[1];
  __u64 stx_ino;
  __u64 stx_size;
  __u64 stx_blocks;
  __u64 stx_attributes_mask;
  statx_timestamp stx_atime;
  statx_timestamp stx_btime;
  statx_timestamp stx_ctime;
  statx_timestamp stx_mtime;
  __u32 stx_rdev_major;
  __u32 stx_rdev_minor;
  __u32 stx_dev_major;
  __u32 stx_dev_minor;
  __u64 __spare2[14];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 statx.stx_mask __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 statx.stx_blksize __u32;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 statx.stx_attributes __u64;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 statx.stx_nlink __u32;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 statx.stx_uid __u32;
//  5. 0018 0004 effalign(4) fda=0 bits=0000 statx.stx_gid __u32;
//  6. 001C 0002 effalign(2) fda=0 bits=0000 statx.stx_mode __u16;
//  7. 001E 0002 effalign(2) fda=0 bits=0000 statx.__spare0 __u16[1];
//  8. 0020 0008 effalign(8) fda=0 bits=0000 statx.stx_ino __u64;
//  9. 0028 0008 effalign(8) fda=0 bits=0000 statx.stx_size __u64;
// 10. 0030 0008 effalign(8) fda=0 bits=0000 statx.stx_blocks __u64;
// 11. 0038 0008 effalign(8) fda=0 bits=0000 statx.stx_attributes_mask __u64;
// 12. 0040 0010 effalign(8) fda=0 bits=0000 statx.stx_atime statx_timestamp;
// 13. 0050 0010 effalign(8) fda=0 bits=0000 statx.stx_btime statx_timestamp;
// 14. 0060 0010 effalign(8) fda=0 bits=0000 statx.stx_ctime statx_timestamp;
// 15. 0070 0010 effalign(8) fda=0 bits=0000 statx.stx_mtime statx_timestamp;
// 16. 0080 0004 effalign(4) fda=0 bits=0000 statx.stx_rdev_major __u32;
// 17. 0084 0004 effalign(4) fda=0 bits=0000 statx.stx_rdev_minor __u32;
// 18. 0088 0004 effalign(4) fda=0 bits=0000 statx.stx_dev_major __u32;
// 19. 008C 0004 effalign(4) fda=0 bits=0000 statx.stx_dev_minor __u32;
// 20. 0090 0070 effalign(8) fda=0 bits=0000 statx.__spare2 __u64[14];
//          0100 effalign(8) sda=0 bits=0000 statx struct packalign=0

00000010 struct statx_timestamp
{
  __s64 tv_sec;
  __u32 tv_nsec;
  __s32 __reserved;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 statx_timestamp.tv_sec __s64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 statx_timestamp.tv_nsec __u32;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 statx_timestamp.__reserved __s32;
//          0010 effalign(8) sda=0 bits=0000 statx_timestamp struct packalign=0

00000070 struct subprocess_info
{
  work_struct work;
  completion *complete;
  const char *path;
  char **argv;
  char **envp;
  file *file;
  int wait;
  int retval;
  pid_t pid;
  int (__cdecl *init)(subprocess_info *, cred *);
  void (__cdecl *cleanup)(subprocess_info *);
  void *data;
};
//  0. 0000 0020 effalign(8) fda=0 bits=0000 subprocess_info.work work_struct;
//  1. 0020 0008 effalign(8) fda=0 bits=0000 subprocess_info.complete completion *;
//  2. 0028 0008 effalign(8) fda=0 bits=0000 subprocess_info.path const char *;
//  3. 0030 0008 effalign(8) fda=0 bits=0000 subprocess_info.argv char **;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 subprocess_info.envp char **;
//  5. 0040 0008 effalign(8) fda=0 bits=0000 subprocess_info.file file *;
//  6. 0048 0004 effalign(4) fda=0 bits=0000 subprocess_info.wait int;
//  7. 004C 0004 effalign(4) fda=0 bits=0000 subprocess_info.retval int;
//  8. 0050 0004 effalign(4) fda=0 bits=0000 subprocess_info.pid pid_t;
//  9. 0058 0008 effalign(8) fda=0 bits=0000 subprocess_info.init int (__cdecl *)(subprocess_info *, cred *);
// 10. 0060 0008 effalign(8) fda=0 bits=0000 subprocess_info.cleanup void (__cdecl *)(subprocess_info *);
// 11. 0068 0008 effalign(8) fda=0 bits=0000 subprocess_info.data void *;
//          0070 effalign(8) sda=0 bits=0000 subprocess_info struct packalign=0

00000018 struct subsys_dev_iter
{
  klist_iter ki;
  const device_type *type;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 subsys_dev_iter.ki klist_iter;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 subsys_dev_iter.type const device_type *;
//          0018 effalign(8) sda=0 bits=0000 subsys_dev_iter struct packalign=0

00000030 struct subsys_interface
{
  const char *name;
  bus_type *subsys;
  list_head node;
  int (__cdecl *add_dev)(device *, subsys_interface *);
  void (__cdecl *remove_dev)(device *, subsys_interface *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 subsys_interface.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 subsys_interface.subsys bus_type *;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 subsys_interface.node list_head;
//  3. 0020 0008 effalign(8) fda=0 bits=0000 subsys_interface.add_dev int (__cdecl *)(device *, subsys_interface *);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 subsys_interface.remove_dev void (__cdecl *)(device *, subsys_interface *);
//          0030 effalign(8) sda=0 bits=0000 subsys_interface struct packalign=0

FFFFFFFF struct subsys_private;
000005C0 struct super_block
{
  list_head s_list;
  dev_t s_dev;
  unsigned __int8 s_blocksize_bits;
  unsigned __int64 s_blocksize;
  loff_t s_maxbytes;
  file_system_type *s_type;
  const super_operations *s_op;
  const dquot_operations *dq_op;
  const quotactl_ops *s_qcop;
  const export_operations *s_export_op;
  unsigned __int64 s_flags;
  unsigned __int64 s_iflags;
  unsigned __int64 s_magic;
  dentry *s_root;
  rw_semaphore s_umount;
  int s_count;
  atomic_t s_active;
  void *s_security;
  const xattr_handler **s_xattr;
  const fscrypt_operations *s_cop;
  key *s_master_keys;
  const fsverity_operations *s_vop;
  hlist_bl_head s_roots;
  list_head s_mounts;
  block_device *s_bdev;
  backing_dev_info *s_bdi;
  mtd_info *s_mtd;
  hlist_node s_instances;
  unsigned int s_quota_types;
  quota_info s_dquot;
  sb_writers s_writers;
  void *s_fs_info;
  u32 s_time_gran;
  time64_t s_time_min;
  time64_t s_time_max;
  __u32 s_fsnotify_mask;
  fsnotify_mark_connector *s_fsnotify_marks;
  char s_id[32];
  uuid_t s_uuid;
  unsigned int s_max_links;
  fmode_t s_mode;
  mutex s_vfs_rename_mutex;
  const char *s_subtype;
  const dentry_operations *s_d_op;
  int cleancache_poolid;
  shrinker s_shrink;
  atomic_long_t s_remove_count;
  atomic_long_t s_fsnotify_inode_refs;
  int s_readonly_remount;
  workqueue_struct *s_dio_done_wq;
  hlist_head s_pins;
  user_namespace *s_user_ns;
  list_lru s_dentry_lru;
  list_lru s_inode_lru;
  callback_head rcu;
  work_struct destroy_work;
  mutex s_sync_lock;
  int s_stack_depth;
  __attribute__((aligned(64))) spinlock_t s_inode_list_lock;
  list_head s_inodes;
  spinlock_t s_inode_wblist_lock;
  list_head s_inodes_wb;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 super_block.s_list list_head;
//  1. 0010 0004 effalign(4) fda=0 bits=0000 super_block.s_dev dev_t;
//  2. 0014 0001 effalign(1) fda=0 bits=0000 super_block.s_blocksize_bits unsigned __int8;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 super_block.s_blocksize unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 super_block.s_maxbytes loff_t;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 super_block.s_type file_system_type *;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 super_block.s_op const super_operations *;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 super_block.dq_op const dquot_operations *;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 super_block.s_qcop const quotactl_ops *;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 super_block.s_export_op const export_operations *;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 super_block.s_flags unsigned __int64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 super_block.s_iflags unsigned __int64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 super_block.s_magic unsigned __int64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 super_block.s_root dentry *;
// 14. 0070 0028 effalign(8) fda=0 bits=0000 super_block.s_umount rw_semaphore;
// 15. 0098 0004 effalign(4) fda=0 bits=0000 super_block.s_count int;
// 16. 009C 0004 effalign(4) fda=0 bits=0000 super_block.s_active atomic_t;
// 17. 00A0 0008 effalign(8) fda=0 bits=0000 super_block.s_security void *;
// 18. 00A8 0008 effalign(8) fda=0 bits=0000 super_block.s_xattr const xattr_handler **;
// 19. 00B0 0008 effalign(8) fda=0 bits=0000 super_block.s_cop const fscrypt_operations *;
// 20. 00B8 0008 effalign(8) fda=0 bits=0000 super_block.s_master_keys key *;
// 21. 00C0 0008 effalign(8) fda=0 bits=0000 super_block.s_vop const fsverity_operations *;
// 22. 00C8 0008 effalign(8) fda=0 bits=0000 super_block.s_roots hlist_bl_head;
// 23. 00D0 0010 effalign(8) fda=0 bits=0000 super_block.s_mounts list_head;
// 24. 00E0 0008 effalign(8) fda=0 bits=0000 super_block.s_bdev block_device *;
// 25. 00E8 0008 effalign(8) fda=0 bits=0000 super_block.s_bdi backing_dev_info *;
// 26. 00F0 0008 effalign(8) fda=0 bits=0000 super_block.s_mtd mtd_info *;
// 27. 00F8 0010 effalign(8) fda=0 bits=0000 super_block.s_instances hlist_node;
// 28. 0108 0004 effalign(4) fda=0 bits=0000 super_block.s_quota_types unsigned int;
// 29. 0110 0138 effalign(8) fda=0 bits=0000 super_block.s_dquot quota_info;
// 30. 0248 0170 effalign(8) fda=0 bits=0000 super_block.s_writers sb_writers;
// 31. 03B8 0008 effalign(8) fda=0 bits=0000 super_block.s_fs_info void *;
// 32. 03C0 0004 effalign(4) fda=0 bits=0000 super_block.s_time_gran u32;
// 33. 03C8 0008 effalign(8) fda=0 bits=0000 super_block.s_time_min time64_t;
// 34. 03D0 0008 effalign(8) fda=0 bits=0000 super_block.s_time_max time64_t;
// 35. 03D8 0004 effalign(4) fda=0 bits=0000 super_block.s_fsnotify_mask __u32;
// 36. 03E0 0008 effalign(8) fda=0 bits=0000 super_block.s_fsnotify_marks fsnotify_mark_connector *;
// 37. 03E8 0020 effalign(1) fda=0 bits=0000 super_block.s_id char[32];
// 38. 0408 0010 effalign(1) fda=0 bits=0000 super_block.s_uuid uuid_t;
// 39. 0418 0004 effalign(4) fda=0 bits=0000 super_block.s_max_links unsigned int;
// 40. 041C 0004 effalign(4) fda=0 bits=0000 super_block.s_mode fmode_t;
// 41. 0420 0020 effalign(8) fda=0 bits=0000 super_block.s_vfs_rename_mutex mutex;
// 42. 0440 0008 effalign(8) fda=0 bits=0000 super_block.s_subtype const char *;
// 43. 0448 0008 effalign(8) fda=0 bits=0000 super_block.s_d_op const dentry_operations *;
// 44. 0450 0004 effalign(4) fda=0 bits=0000 super_block.cleancache_poolid int;
// 45. 0458 0040 effalign(8) fda=0 bits=0000 super_block.s_shrink shrinker;
// 46. 0498 0008 effalign(8) fda=0 bits=0000 super_block.s_remove_count atomic_long_t;
// 47. 04A0 0008 effalign(8) fda=0 bits=0000 super_block.s_fsnotify_inode_refs atomic_long_t;
// 48. 04A8 0004 effalign(4) fda=0 bits=0000 super_block.s_readonly_remount int;
// 49. 04B0 0008 effalign(8) fda=0 bits=0000 super_block.s_dio_done_wq workqueue_struct *;
// 50. 04B8 0008 effalign(8) fda=0 bits=0000 super_block.s_pins hlist_head;
// 51. 04C0 0008 effalign(8) fda=0 bits=0000 super_block.s_user_ns user_namespace *;
// 52. 04C8 0020 effalign(8) fda=0 bits=0000 super_block.s_dentry_lru list_lru;
// 53. 04E8 0020 effalign(8) fda=0 bits=0000 super_block.s_inode_lru list_lru;
// 54. 0508 0010 effalign(8) fda=0 bits=0000 super_block.rcu callback_head;
// 55. 0518 0020 effalign(8) fda=0 bits=0000 super_block.destroy_work work_struct;
// 56. 0538 0020 effalign(8) fda=0 bits=0000 super_block.s_sync_lock mutex;
// 57. 0558 0004 effalign(4) fda=0 bits=0000 super_block.s_stack_depth int;
// 58. 0580 0004 effalign(64) fda=7 bits=0000 super_block.s_inode_list_lock spinlock_t;
// 59. 0588 0010 effalign(8) fda=0 bits=0000 super_block.s_inodes list_head;
// 60. 0598 0004 effalign(4) fda=0 bits=0000 super_block.s_inode_wblist_lock spinlock_t;
// 61. 05A0 0010 effalign(8) fda=0 bits=0000 super_block.s_inodes_wb list_head;
//          05B0 unpadded_size
//          05C0 effalign(64) sda=0 bits=0000 super_block struct packalign=0

000000D8 struct super_operations
{
  inode *(__cdecl *alloc_inode)(super_block *);
  void (__cdecl *destroy_inode)(inode *);
  void (__cdecl *free_inode)(inode *);
  void (__cdecl *dirty_inode)(inode *, int);
  int (__cdecl *write_inode)(inode *, writeback_control *);
  int (__cdecl *drop_inode)(inode *);
  void (__cdecl *evict_inode)(inode *);
  void (__cdecl *put_super)(super_block *);
  int (__cdecl *sync_fs)(super_block *, int);
  int (__cdecl *freeze_super)(super_block *);
  int (__cdecl *freeze_fs)(super_block *);
  int (__cdecl *thaw_super)(super_block *);
  int (__cdecl *unfreeze_fs)(super_block *);
  int (__cdecl *statfs)(dentry *, kstatfs *);
  int (__cdecl *remount_fs)(super_block *, int *, char *);
  void (__cdecl *umount_begin)(super_block *);
  int (__cdecl *show_options)(seq_file *, dentry *);
  int (__cdecl *show_devname)(seq_file *, dentry *);
  int (__cdecl *show_path)(seq_file *, dentry *);
  int (__cdecl *show_stats)(seq_file *, dentry *);
  ssize_t (__cdecl *quota_read)(super_block *, int, char *, size_t, loff_t);
  ssize_t (__cdecl *quota_write)(super_block *, int, const char *, size_t, loff_t);
  dquot **(__cdecl *get_dquots)(inode *);
  int (__cdecl *bdev_try_to_free_page)(super_block *, page *, gfp_t);
  __int64 (__cdecl *nr_cached_objects)(super_block *, shrink_control *);
  __int64 (__cdecl *free_cached_objects)(super_block *, shrink_control *);
  file *(__cdecl *real_loop)(file *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 super_operations.alloc_inode inode *(__cdecl *)(super_block *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 super_operations.destroy_inode void (__cdecl *)(inode *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 super_operations.free_inode void (__cdecl *)(inode *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 super_operations.dirty_inode void (__cdecl *)(inode *, int);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 super_operations.write_inode int (__cdecl *)(inode *, writeback_control *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 super_operations.drop_inode int (__cdecl *)(inode *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 super_operations.evict_inode void (__cdecl *)(inode *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 super_operations.put_super void (__cdecl *)(super_block *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 super_operations.sync_fs int (__cdecl *)(super_block *, int);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 super_operations.freeze_super int (__cdecl *)(super_block *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 super_operations.freeze_fs int (__cdecl *)(super_block *);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 super_operations.thaw_super int (__cdecl *)(super_block *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 super_operations.unfreeze_fs int (__cdecl *)(super_block *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 super_operations.statfs int (__cdecl *)(dentry *, kstatfs *);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 super_operations.remount_fs int (__cdecl *)(super_block *, int *, char *);
// 15. 0078 0008 effalign(8) fda=0 bits=0000 super_operations.umount_begin void (__cdecl *)(super_block *);
// 16. 0080 0008 effalign(8) fda=0 bits=0000 super_operations.show_options int (__cdecl *)(seq_file *, dentry *);
// 17. 0088 0008 effalign(8) fda=0 bits=0000 super_operations.show_devname int (__cdecl *)(seq_file *, dentry *);
// 18. 0090 0008 effalign(8) fda=0 bits=0000 super_operations.show_path int (__cdecl *)(seq_file *, dentry *);
// 19. 0098 0008 effalign(8) fda=0 bits=0000 super_operations.show_stats int (__cdecl *)(seq_file *, dentry *);
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 super_operations.quota_read ssize_t (__cdecl *)(super_block *, int, char *, size_t, loff_t);
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 super_operations.quota_write ssize_t (__cdecl *)(super_block *, int, const char *, size_t, loff_t);
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 super_operations.get_dquots dquot **(__cdecl *)(inode *);
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 super_operations.bdev_try_to_free_page int (__cdecl *)(super_block *, page *, gfp_t);
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 super_operations.nr_cached_objects __int64 (__cdecl *)(super_block *, shrink_control *);
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 super_operations.free_cached_objects __int64 (__cdecl *)(super_block *, shrink_control *);
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 super_operations.real_loop file *(__cdecl *)(file *);
//          00D8 effalign(8) sda=0 bits=0000 super_operations struct packalign=0

00000008 typedef __kernel_suseconds_t suseconds_t;
FFFFFFFF struct swap_info_struct;
00000008 struct swp_entry_t
{
  unsigned __int64 val;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 swp_entry_t.val unsigned __int64;
//          0008 effalign(8) sda=0 bits=0000 swp_entry_t struct packalign=0

00000088 struct swregs_state
{
  u32 cwd;
  u32 swd;
  u32 twd;
  u32 fip;
  u32 fcs;
  u32 foo;
  u32 fos;
  u32 st_space[20];
  u8 ftop;
  u8 changed;
  u8 lookahead;
  u8 no_update;
  u8 rm;
  u8 alimit;
  math_emu_info *info;
  u32 entry_eip;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 swregs_state.cwd u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 swregs_state.swd u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 swregs_state.twd u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 swregs_state.fip u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 swregs_state.fcs u32;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 swregs_state.foo u32;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 swregs_state.fos u32;
//  7. 001C 0050 effalign(4) fda=0 bits=0000 swregs_state.st_space u32[20];
//  8. 006C 0001 effalign(1) fda=0 bits=0000 swregs_state.ftop u8;
//  9. 006D 0001 effalign(1) fda=0 bits=0000 swregs_state.changed u8;
// 10. 006E 0001 effalign(1) fda=0 bits=0000 swregs_state.lookahead u8;
// 11. 006F 0001 effalign(1) fda=0 bits=0000 swregs_state.no_update u8;
// 12. 0070 0001 effalign(1) fda=0 bits=0000 swregs_state.rm u8;
// 13. 0071 0001 effalign(1) fda=0 bits=0000 swregs_state.alimit u8;
// 14. 0078 0008 effalign(8) fda=0 bits=0000 swregs_state.info math_emu_info *;
// 15. 0080 0004 effalign(4) fda=0 bits=0000 swregs_state.entry_eip u32;
//          0084 unpadded_size
//          0088 effalign(8) sda=0 bits=0000 swregs_state struct packalign=0

00000020 struct symsearch
{
  const kernel_symbol *start;
  const kernel_symbol *stop;
  const s32 *crcs;
  symsearch::$918E90F7BDB99030C053413DA08D0BB9 licence;
  bool unused;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 symsearch.start const kernel_symbol *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 symsearch.stop const kernel_symbol *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 symsearch.crcs const s32 *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 symsearch.licence symsearch::$918E90F7BDB99030C053413DA08D0BB9;
//  4. 001C 0001 effalign(1) fda=0 bits=0000 symsearch.unused bool;
//          001D unpadded_size
//          0020 effalign(8) sda=0 bits=0000 symsearch struct packalign=0

00000004 enum symsearch::$918E90F7BDB99030C053413DA08D0BB9 : unsigned __int32
{
  NOT_GPL_ONLY = 0x0,
  GPL_ONLY = 0x1,
  WILL_BE_GPL_ONLY = 0x2,
};
00000010 struct sys_desc_table
{
  __u16 length;
  __u8 table[14];
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 sys_desc_table.length __u16;
//  1. 0002 000E effalign(1) fda=0 bits=0000 sys_desc_table.table __u8[14];
//          0010 effalign(2) sda=0 bits=0000 sys_desc_table struct packalign=0

00000010 struct sysfs_ops
{
  ssize_t (__cdecl *show)(kobject *, attribute *, char *);
  ssize_t (__cdecl *store)(kobject *, attribute *, const char *, size_t);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sysfs_ops.show ssize_t (__cdecl *)(kobject *, attribute *, char *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 sysfs_ops.store ssize_t (__cdecl *)(kobject *, attribute *, const char *, size_t);
//          0010 effalign(8) sda=0 bits=0000 sysfs_ops struct packalign=0

00000070 struct sysinfo
{
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sysinfo.uptime __kernel_long_t;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 sysinfo.loads __kernel_ulong_t[3];
//  2. 0020 0008 effalign(8) fda=0 bits=0000 sysinfo.totalram __kernel_ulong_t;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 sysinfo.freeram __kernel_ulong_t;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 sysinfo.sharedram __kernel_ulong_t;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 sysinfo.bufferram __kernel_ulong_t;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 sysinfo.totalswap __kernel_ulong_t;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 sysinfo.freeswap __kernel_ulong_t;
//  8. 0050 0002 effalign(2) fda=0 bits=0000 sysinfo.procs __u16;
//  9. 0052 0002 effalign(2) fda=0 bits=0000 sysinfo.pad __u16;
// 10. 0058 0008 effalign(8) fda=0 bits=0000 sysinfo.totalhigh __kernel_ulong_t;
// 11. 0060 0008 effalign(8) fda=0 bits=0000 sysinfo.freehigh __kernel_ulong_t;
// 12. 0068 0004 effalign(4) fda=0 bits=0000 sysinfo.mem_unit __u32;
//          006C unpadded_size
//          0070 effalign(8) sda=0 bits=0000 sysinfo struct packalign=0

00000010 struct system_counterval_t
{
  u64 cycles;
  clocksource *cs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 system_counterval_t.cycles u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 system_counterval_t.cs clocksource *;
//          0010 effalign(8) sda=0 bits=0000 system_counterval_t struct packalign=0

00000018 struct system_device_crosststamp
{
  ktime_t device;
  ktime_t sys_realtime;
  ktime_t sys_monoraw;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 system_device_crosststamp.device ktime_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 system_device_crosststamp.sys_realtime ktime_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 system_device_crosststamp.sys_monoraw ktime_t;
//          0018 effalign(8) sda=0 bits=0000 system_device_crosststamp struct packalign=0

00000004 enum system_states : unsigned __int32
{
  SYSTEM_BOOTING = 0x0,
  SYSTEM_SCHEDULING = 0x1,
  SYSTEM_RUNNING = 0x2,
  SYSTEM_HALT = 0x3,
  SYSTEM_POWER_OFF = 0x4,
  SYSTEM_RESTART = 0x5,
  SYSTEM_SUSPEND = 0x6,
};
00000020 struct system_time_snapshot
{
  u64 cycles;
  ktime_t real;
  ktime_t raw;
  unsigned int clock_was_set_seq;
  u8 cs_was_changed_seq;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 system_time_snapshot.cycles u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 system_time_snapshot.real ktime_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 system_time_snapshot.raw ktime_t;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 system_time_snapshot.clock_was_set_seq unsigned int;
//  4. 001C 0001 effalign(1) fda=0 bits=0000 system_time_snapshot.cs_was_changed_seq u8;
//          001D unpadded_size
//          0020 effalign(8) sda=0 bits=0000 system_time_snapshot struct packalign=0

00000008 struct sysv_sem
{
  sem_undo_list *undo_list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 sysv_sem.undo_list sem_undo_list *;
//          0008 effalign(8) sda=0 bits=0000 sysv_sem struct packalign=0

00000010 struct sysv_shm
{
  list_head shm_clist;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 sysv_shm.shm_clist list_head;
//          0010 effalign(8) sda=0 bits=0000 sysv_shm struct packalign=0

00000004 enum taa_mitigations : unsigned __int32
{
  TAA_MITIGATION_OFF = 0x0,
  TAA_MITIGATION_UCODE_NEEDED = 0x1,
  TAA_MITIGATION_VERW = 0x2,
  TAA_MITIGATION_TSX_DISABLED = 0x3,
};
00000003 struct taint_flag
{
  char c_true;
  char c_false;
  bool module;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 taint_flag.c_true char;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 taint_flag.c_false char;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 taint_flag.module bool;
//          0003 effalign(1) sda=0 bits=0000 taint_flag struct packalign=0

00000018 struct task_cputime
{
  u64 stime;
  u64 utime;
  unsigned __int64 sum_exec_runtime;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 task_cputime.stime u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 task_cputime.utime u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 task_cputime.sum_exec_runtime unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 task_cputime struct packalign=0

FFFFFFFF struct task_delay_info;
FFFFFFFF struct task_group;
00000038 struct task_io_accounting
{
  u64 rchar;
  u64 wchar;
  u64 syscr;
  u64 syscw;
  u64 read_bytes;
  u64 write_bytes;
  u64 cancelled_write_bytes;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 task_io_accounting.rchar u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 task_io_accounting.wchar u64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 task_io_accounting.syscr u64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 task_io_accounting.syscw u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 task_io_accounting.read_bytes u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 task_io_accounting.write_bytes u64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 task_io_accounting.cancelled_write_bytes u64;
//          0038 effalign(8) sda=0 bits=0000 task_io_accounting struct packalign=0

00000014 struct task_rss_stat
{
  int events;
  int count[4];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 task_rss_stat.events int;
//  1. 0004 0010 effalign(4) fda=0 bits=0000 task_rss_stat.count int[4];
//          0014 effalign(4) sda=0 bits=0000 task_rss_stat struct packalign=0

00002440 struct task_struct
{
  thread_info thread_info;
  __int64 state;
  void *stack;
  refcount_t usage;
  unsigned int flags;
  unsigned int ptrace;
  llist_node wake_entry;
  int on_cpu;
  unsigned int cpu;
  unsigned int wakee_flips;
  unsigned __int64 wakee_flip_decay_ts;
  task_struct *last_wakee;
  int recent_used_cpu;
  int wake_cpu;
  int on_rq;
  int prio;
  int static_prio;
  int normal_prio;
  unsigned int rt_priority;
  const sched_class *sched_class;
  sched_entity se;
  sched_rt_entity rt;
  task_group *sched_task_group;
  sched_dl_entity dl;
  uclamp_se uclamp_req[2];
  uclamp_se uclamp[2];
  hlist_head preempt_notifiers;
  unsigned int btrace_seq;
  unsigned int policy;
  int nr_cpus_allowed;
  const cpumask_t *cpus_ptr;
  cpumask_t cpus_mask;
  unsigned __int64 rcu_tasks_nvcsw;
  u8 rcu_tasks_holdout;
  u8 rcu_tasks_idx;
  int rcu_tasks_idle_cpu;
  list_head rcu_tasks_holdout_list;
  sched_info sched_info;
  list_head tasks;
  plist_node pushable_tasks;
  rb_node pushable_dl_tasks;
  mm_struct *mm;
  mm_struct *active_mm;
  vmacache vmacache;
  task_rss_stat rss_stat;
  int exit_state;
  int exit_code;
  int exit_signal;
  int pdeath_signal;
  unsigned __int64 jobctl;
  unsigned int personality;
  unsigned __int32 sched_reset_on_fork : 1;
  unsigned __int32 sched_contributes_to_load : 1;
  unsigned __int32 sched_migrated : 1;
  unsigned __int32 sched_remote_wakeup : 1;
  unsigned __int32 sched_psi_wake_requeue : 1;
  unsigned __int32 : 0;
  unsigned __int32 in_execve : 1;
  unsigned __int32 in_iowait : 1;
  unsigned __int32 restore_sigmask : 1;
  unsigned __int32 in_user_fault : 1;
  unsigned __int32 no_cgroup_migration : 1;
  unsigned __int32 frozen : 1;
  unsigned __int32 use_memdelay : 1;
  unsigned __int64 atomic_flags;
  struct
  {
    __int64 (__cdecl *fn)(restart_block *);
    union
    {
      $9F8590F102EB2841150ECC2E0574E358 futex;
      $599CAA50DA31E34ACF419229BA5AB7AB nanosleep;
      $F3CAA52711B0FBBABA04D84B2645ECC4 poll;
    };
  } restart_block;
  pid_t pid;
  pid_t tgid;
  unsigned __int64 stack_canary;
  task_struct *real_parent;
  task_struct *parent;
  list_head children;
  list_head sibling;
  task_struct *group_leader;
  list_head ptraced;
  list_head ptrace_entry;
  pid *thread_pid;
  hlist_node pid_links[4];
  list_head thread_group;
  list_head thread_node;
  completion *vfork_done;
  int *set_child_tid;
  int *clear_child_tid;
  u64 utime;
  u64 stime;
  u64 gtime;
  prev_cputime prev_cputime;
  unsigned __int64 nvcsw;
  unsigned __int64 nivcsw;
  u64 start_time;
  u64 real_start_time;
  unsigned __int64 min_flt;
  unsigned __int64 maj_flt;
  posix_cputimers posix_cputimers;
  const cred *ptracer_cred;
  const cred *real_cred;
  const cred *cred;
  key *cached_requested_key;
  char comm[16];
  nameidata *nameidata;
  sysv_sem sysvsem;
  sysv_shm sysvshm;
  unsigned __int64 last_switch_count;
  unsigned __int64 last_switch_time;
  fs_struct *fs;
  files_struct *files;
  nsproxy *nsproxy;
  signal_struct *signal;
  sighand_struct *sighand;
  sigset_t blocked;
  sigset_t real_blocked;
  sigset_t saved_sigmask;
  sigpending pending;
  unsigned __int64 sas_ss_sp;
  size_t sas_ss_size;
  unsigned int sas_ss_flags;
  callback_head *task_works;
  audit_context *audit_context;
  kuid_t loginuid;
  unsigned int sessionid;
  seccomp seccomp;
  u64 parent_exec_id;
  u64 self_exec_id;
  spinlock_t alloc_lock;
  raw_spinlock_t pi_lock;
  wake_q_node wake_q;
  rb_root_cached pi_waiters;
  task_struct *pi_top_task;
  rt_mutex_waiter *pi_blocked_on;
  void *journal_info;
  bio_list *bio_list;
  blk_plug *plug;
  reclaim_state *reclaim_state;
  backing_dev_info *backing_dev_info;
  io_context *io_context;
  capture_control *capture_control;
  unsigned __int64 ptrace_message;
  kernel_siginfo_t *last_siginfo;
  task_io_accounting ioac;
  unsigned int psi_flags;
  u64 acct_rss_mem1;
  u64 acct_vm_mem1;
  u64 acct_timexpd;
  nodemask_t mems_allowed;
  seqcount_t mems_allowed_seq;
  int cpuset_mem_spread_rotor;
  int cpuset_slab_spread_rotor;
  css_set *cgroups;
  list_head cg_list;
  u32 closid;
  u32 rmid;
  robust_list_head *robust_list;
  compat_robust_list_head *compat_robust_list;
  list_head pi_state_list;
  futex_pi_state *pi_state_cache;
  mutex futex_exit_mutex;
  unsigned int futex_state;
  perf_event_context *perf_event_ctxp[2];
  mutex perf_event_mutex;
  list_head perf_event_list;
  mempolicy *mempolicy;
  __int16 il_prev;
  __int16 pref_node_fork;
  int numa_scan_seq;
  unsigned int numa_scan_period;
  unsigned int numa_scan_period_max;
  int numa_preferred_nid;
  unsigned __int64 numa_migrate_retry;
  u64 node_stamp;
  u64 last_task_numa_placement;
  u64 last_sum_exec_runtime;
  callback_head numa_work;
  numa_group *numa_group;
  unsigned __int64 *numa_faults;
  unsigned __int64 total_numa_faults;
  unsigned __int64 numa_faults_locality[3];
  unsigned __int64 numa_pages_migrated;
  rseq *rseq;
  u32 rseq_sig;
  unsigned __int64 rseq_event_mask;
  tlbflush_unmap_batch tlb_ubc;
  union
  {
    refcount_t rcu_users;
    callback_head rcu;
  };
  pipe_inode_info *splice_pipe;
  page_frag task_frag;
  task_delay_info *delays;
  int nr_dirtied;
  int nr_dirtied_pause;
  unsigned __int64 dirty_paused_when;
  u64 timer_slack_ns;
  u64 default_timer_slack_ns;
  int curr_ret_stack;
  int curr_ret_depth;
  ftrace_ret_stack *ret_stack;
  unsigned __int64 ftrace_timestamp;
  atomic_t trace_overrun;
  atomic_t tracing_graph_pause;
  unsigned __int64 trace;
  unsigned __int64 trace_recursion;
  mem_cgroup *memcg_in_oom;
  gfp_t memcg_oom_gfp_mask;
  int memcg_oom_order;
  unsigned int memcg_nr_pages_over_high;
  mem_cgroup *active_memcg;
  request_queue *throttle_queue;
  uprobe_task *utask;
  unsigned int sequential_io;
  unsigned int sequential_io_avg;
  int pagefault_disabled;
  task_struct *oom_reaper_list;
  timer_list oom_reaper_timer;
  vm_struct *stack_vm_area;
  refcount_t stack_refcount;
  int patch_state;
  void *security;
  thread_struct thread;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 task_struct.thread_info thread_info;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 task_struct.state __int64;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 task_struct.stack void *;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 task_struct.usage refcount_t;
//  4. 0024 0004 effalign(4) fda=0 bits=0000 task_struct.flags unsigned int;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 task_struct.ptrace unsigned int;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 task_struct.wake_entry llist_node;
//  7. 0038 0004 effalign(4) fda=0 bits=0000 task_struct.on_cpu int;
//  8. 003C 0004 effalign(4) fda=0 bits=0000 task_struct.cpu unsigned int;
//  9. 0040 0004 effalign(4) fda=0 bits=0000 task_struct.wakee_flips unsigned int;
// 10. 0048 0008 effalign(8) fda=0 bits=0000 task_struct.wakee_flip_decay_ts unsigned __int64;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 task_struct.last_wakee task_struct *;
// 12. 0058 0004 effalign(4) fda=0 bits=0000 task_struct.recent_used_cpu int;
// 13. 005C 0004 effalign(4) fda=0 bits=0000 task_struct.wake_cpu int;
// 14. 0060 0004 effalign(4) fda=0 bits=0000 task_struct.on_rq int;
// 15. 0064 0004 effalign(4) fda=0 bits=0000 task_struct.prio int;
// 16. 0068 0004 effalign(4) fda=0 bits=0000 task_struct.static_prio int;
// 17. 006C 0004 effalign(4) fda=0 bits=0000 task_struct.normal_prio int;
// 18. 0070 0004 effalign(4) fda=0 bits=0000 task_struct.rt_priority unsigned int;
// 19. 0078 0008 effalign(8) fda=0 bits=0000 task_struct.sched_class const sched_class *;
// 20. 0080 01C0 effalign(64) fda=0 bits=0000 task_struct.se sched_entity;
// 21. 0240 0030 effalign(8) fda=0 bits=0000 task_struct.rt sched_rt_entity;
// 22. 0270 0008 effalign(8) fda=0 bits=0000 task_struct.sched_task_group task_group *;
// 23. 0278 00E0 effalign(8) fda=0 bits=0000 task_struct.dl sched_dl_entity;
// 24. 0358 0008 effalign(4) fda=0 bits=0000 task_struct.uclamp_req uclamp_se[2];
// 25. 0360 0008 effalign(4) fda=0 bits=0000 task_struct.uclamp uclamp_se[2];
// 26. 0368 0008 effalign(8) fda=0 bits=0000 task_struct.preempt_notifiers hlist_head;
// 27. 0370 0004 effalign(4) fda=0 bits=0000 task_struct.btrace_seq unsigned int;
// 28. 0374 0004 effalign(4) fda=0 bits=0000 task_struct.policy unsigned int;
// 29. 0378 0004 effalign(4) fda=0 bits=0000 task_struct.nr_cpus_allowed int;
// 30. 0380 0008 effalign(8) fda=0 bits=0000 task_struct.cpus_ptr const cpumask_t *;
// 31. 0388 0400 effalign(8) fda=0 bits=0000 task_struct.cpus_mask cpumask_t;
// 32. 0788 0008 effalign(8) fda=0 bits=0000 task_struct.rcu_tasks_nvcsw unsigned __int64;
// 33. 0790 0001 effalign(1) fda=0 bits=0000 task_struct.rcu_tasks_holdout u8;
// 34. 0791 0001 effalign(1) fda=0 bits=0000 task_struct.rcu_tasks_idx u8;
// 35. 0794 0004 effalign(4) fda=0 bits=0000 task_struct.rcu_tasks_idle_cpu int;
// 36. 0798 0010 effalign(8) fda=0 bits=0000 task_struct.rcu_tasks_holdout_list list_head;
// 37. 07A8 0020 effalign(8) fda=0 bits=0000 task_struct.sched_info sched_info;
// 38. 07C8 0010 effalign(8) fda=0 bits=0000 task_struct.tasks list_head;
// 39. 07D8 0028 effalign(8) fda=0 bits=0000 task_struct.pushable_tasks plist_node;
// 40. 0800 0018 effalign(8) fda=0 bits=0000 task_struct.pushable_dl_tasks rb_node;
// 41. 0818 0008 effalign(8) fda=0 bits=0000 task_struct.mm mm_struct *;
// 42. 0820 0008 effalign(8) fda=0 bits=0000 task_struct.active_mm mm_struct *;
// 43. 0828 0028 effalign(8) fda=0 bits=0000 task_struct.vmacache vmacache;
// 44. 0850 0014 effalign(4) fda=0 bits=0000 task_struct.rss_stat task_rss_stat;
// 45. 0864 0004 effalign(4) fda=0 bits=0000 task_struct.exit_state int;
// 46. 0868 0004 effalign(4) fda=0 bits=0000 task_struct.exit_code int;
// 47. 086C 0004 effalign(4) fda=0 bits=0000 task_struct.exit_signal int;
// 48. 0870 0004 effalign(4) fda=0 bits=0000 task_struct.pdeath_signal int;
// 49. 0878 0008 effalign(8) fda=0 bits=0000 task_struct.jobctl unsigned __int64;
// 50. 0880 0004 effalign(4) fda=0 bits=0000 task_struct.personality unsigned int;
// 51. 0884. 0 1 effalign(1) fda=0 bits=0000 task_struct.sched_reset_on_fork bi.nbytes=4 U
// 52. 0884. 1 1 effalign(1) fda=0 bits=0000 task_struct.sched_contributes_to_load bi.nbytes=4 U
// 53. 0884. 2 1 effalign(1) fda=0 bits=0000 task_struct.sched_migrated bi.nbytes=4 U
// 54. 0884. 3 1 effalign(1) fda=0 bits=0000 task_struct.sched_remote_wakeup bi.nbytes=4 U
// 55. 0884. 4 1 effalign(1) fda=0 bits=0000 task_struct.sched_psi_wake_requeue bi.nbytes=4 U
// 56. 0884. 8 0 effalign(1) fda=0 bits=0000 task_struct.(null) bi.nbytes=4 U
// 57. 0884. 8 1 effalign(1) fda=0 bits=0000 task_struct.in_execve bi.nbytes=4 U
// 58. 0884. 9 1 effalign(1) fda=0 bits=0000 task_struct.in_iowait bi.nbytes=4 U
// 59. 0884.10 1 effalign(1) fda=0 bits=0000 task_struct.restore_sigmask bi.nbytes=4 U
// 60. 0884.11 1 effalign(1) fda=0 bits=0000 task_struct.in_user_fault bi.nbytes=4 U
// 61. 0884.12 1 effalign(1) fda=0 bits=0000 task_struct.no_cgroup_migration bi.nbytes=4 U
// 62. 0884.13 1 effalign(1) fda=0 bits=0000 task_struct.frozen bi.nbytes=4 U
// 63. 0884.14 1 effalign(1) fda=0 bits=0000 task_struct.use_memdelay bi.nbytes=4 U
// 64. 0888 0008 effalign(8) fda=0 bits=0000 task_struct.atomic_flags unsigned __int64;
// 65. 0890 0030 effalign(8) fda=0 bits=0000 task_struct.restart_block restart_block;
// 66. 08C0 0004 effalign(4) fda=0 bits=0000 task_struct.pid pid_t;
// 67. 08C4 0004 effalign(4) fda=0 bits=0000 task_struct.tgid pid_t;
// 68. 08C8 0008 effalign(8) fda=0 bits=0000 task_struct.stack_canary unsigned __int64;
// 69. 08D0 0008 effalign(8) fda=0 bits=0000 task_struct.real_parent task_struct *;
// 70. 08D8 0008 effalign(8) fda=0 bits=0000 task_struct.parent task_struct *;
// 71. 08E0 0010 effalign(8) fda=0 bits=0000 task_struct.children list_head;
// 72. 08F0 0010 effalign(8) fda=0 bits=0000 task_struct.sibling list_head;
// 73. 0900 0008 effalign(8) fda=0 bits=0000 task_struct.group_leader task_struct *;
// 74. 0908 0010 effalign(8) fda=0 bits=0000 task_struct.ptraced list_head;
// 75. 0918 0010 effalign(8) fda=0 bits=0000 task_struct.ptrace_entry list_head;
// 76. 0928 0008 effalign(8) fda=0 bits=0000 task_struct.thread_pid pid *;
// 77. 0930 0040 effalign(8) fda=0 bits=0000 task_struct.pid_links hlist_node[4];
// 78. 0970 0010 effalign(8) fda=0 bits=0000 task_struct.thread_group list_head;
// 79. 0980 0010 effalign(8) fda=0 bits=0000 task_struct.thread_node list_head;
// 80. 0990 0008 effalign(8) fda=0 bits=0000 task_struct.vfork_done completion *;
// 81. 0998 0008 effalign(8) fda=0 bits=0000 task_struct.set_child_tid int *;
// 82. 09A0 0008 effalign(8) fda=0 bits=0000 task_struct.clear_child_tid int *;
// 83. 09A8 0008 effalign(8) fda=0 bits=0000 task_struct.utime u64;
// 84. 09B0 0008 effalign(8) fda=0 bits=0000 task_struct.stime u64;
// 85. 09B8 0008 effalign(8) fda=0 bits=0000 task_struct.gtime u64;
// 86. 09C0 0018 effalign(8) fda=0 bits=0000 task_struct.prev_cputime prev_cputime;
// 87. 09D8 0008 effalign(8) fda=0 bits=0000 task_struct.nvcsw unsigned __int64;
// 88. 09E0 0008 effalign(8) fda=0 bits=0000 task_struct.nivcsw unsigned __int64;
// 89. 09E8 0008 effalign(8) fda=0 bits=0000 task_struct.start_time u64;
// 90. 09F0 0008 effalign(8) fda=0 bits=0000 task_struct.real_start_time u64;
// 91. 09F8 0008 effalign(8) fda=0 bits=0000 task_struct.min_flt unsigned __int64;
// 92. 0A00 0008 effalign(8) fda=0 bits=0000 task_struct.maj_flt unsigned __int64;
// 93. 0A08 0050 effalign(8) fda=0 bits=0000 task_struct.posix_cputimers posix_cputimers;
// 94. 0A58 0008 effalign(8) fda=0 bits=0000 task_struct.ptracer_cred const cred *;
// 95. 0A60 0008 effalign(8) fda=0 bits=0000 task_struct.real_cred const cred *;
// 96. 0A68 0008 effalign(8) fda=0 bits=0000 task_struct.cred const cred *;
// 97. 0A70 0008 effalign(8) fda=0 bits=0000 task_struct.cached_requested_key key *;
// 98. 0A78 0010 effalign(1) fda=0 bits=0000 task_struct.comm char[16];
// 99. 0A88 0008 effalign(8) fda=0 bits=0000 task_struct.nameidata nameidata *;
// 100. 0A90 0008 effalign(8) fda=0 bits=0000 task_struct.sysvsem sysv_sem;
// 101. 0A98 0010 effalign(8) fda=0 bits=0000 task_struct.sysvshm sysv_shm;
// 102. 0AA8 0008 effalign(8) fda=0 bits=0000 task_struct.last_switch_count unsigned __int64;
// 103. 0AB0 0008 effalign(8) fda=0 bits=0000 task_struct.last_switch_time unsigned __int64;
// 104. 0AB8 0008 effalign(8) fda=0 bits=0000 task_struct.fs fs_struct *;
// 105. 0AC0 0008 effalign(8) fda=0 bits=0000 task_struct.files files_struct *;
// 106. 0AC8 0008 effalign(8) fda=0 bits=0000 task_struct.nsproxy nsproxy *;
// 107. 0AD0 0008 effalign(8) fda=0 bits=0000 task_struct.signal signal_struct *;
// 108. 0AD8 0008 effalign(8) fda=0 bits=0000 task_struct.sighand sighand_struct *;
// 109. 0AE0 0008 effalign(8) fda=0 bits=0000 task_struct.blocked sigset_t;
// 110. 0AE8 0008 effalign(8) fda=0 bits=0000 task_struct.real_blocked sigset_t;
// 111. 0AF0 0008 effalign(8) fda=0 bits=0000 task_struct.saved_sigmask sigset_t;
// 112. 0AF8 0018 effalign(8) fda=0 bits=0000 task_struct.pending sigpending;
// 113. 0B10 0008 effalign(8) fda=0 bits=0000 task_struct.sas_ss_sp unsigned __int64;
// 114. 0B18 0008 effalign(8) fda=0 bits=0000 task_struct.sas_ss_size size_t;
// 115. 0B20 0004 effalign(4) fda=0 bits=0000 task_struct.sas_ss_flags unsigned int;
// 116. 0B28 0008 effalign(8) fda=0 bits=0000 task_struct.task_works callback_head *;
// 117. 0B30 0008 effalign(8) fda=0 bits=0000 task_struct.audit_context audit_context *;
// 118. 0B38 0004 effalign(4) fda=0 bits=0000 task_struct.loginuid kuid_t;
// 119. 0B3C 0004 effalign(4) fda=0 bits=0000 task_struct.sessionid unsigned int;
// 120. 0B40 0010 effalign(8) fda=0 bits=0000 task_struct.seccomp seccomp;
// 121. 0B50 0008 effalign(8) fda=0 bits=0000 task_struct.parent_exec_id u64;
// 122. 0B58 0008 effalign(8) fda=0 bits=0000 task_struct.self_exec_id u64;
// 123. 0B60 0004 effalign(4) fda=0 bits=0000 task_struct.alloc_lock spinlock_t;
// 124. 0B64 0004 effalign(4) fda=0 bits=0000 task_struct.pi_lock raw_spinlock_t;
// 125. 0B68 0008 effalign(8) fda=0 bits=0000 task_struct.wake_q wake_q_node;
// 126. 0B70 0010 effalign(8) fda=0 bits=0000 task_struct.pi_waiters rb_root_cached;
// 127. 0B80 0008 effalign(8) fda=0 bits=0000 task_struct.pi_top_task task_struct *;
// 128. 0B88 0008 effalign(8) fda=0 bits=0000 task_struct.pi_blocked_on rt_mutex_waiter *;
// 129. 0B90 0008 effalign(8) fda=0 bits=0000 task_struct.journal_info void *;
// 130. 0B98 0008 effalign(8) fda=0 bits=0000 task_struct.bio_list bio_list *;
// 131. 0BA0 0008 effalign(8) fda=0 bits=0000 task_struct.plug blk_plug *;
// 132. 0BA8 0008 effalign(8) fda=0 bits=0000 task_struct.reclaim_state reclaim_state *;
// 133. 0BB0 0008 effalign(8) fda=0 bits=0000 task_struct.backing_dev_info backing_dev_info *;
// 134. 0BB8 0008 effalign(8) fda=0 bits=0000 task_struct.io_context io_context *;
// 135. 0BC0 0008 effalign(8) fda=0 bits=0000 task_struct.capture_control capture_control *;
// 136. 0BC8 0008 effalign(8) fda=0 bits=0000 task_struct.ptrace_message unsigned __int64;
// 137. 0BD0 0008 effalign(8) fda=0 bits=0000 task_struct.last_siginfo kernel_siginfo_t *;
// 138. 0BD8 0038 effalign(8) fda=0 bits=0000 task_struct.ioac task_io_accounting;
// 139. 0C10 0004 effalign(4) fda=0 bits=0000 task_struct.psi_flags unsigned int;
// 140. 0C18 0008 effalign(8) fda=0 bits=0000 task_struct.acct_rss_mem1 u64;
// 141. 0C20 0008 effalign(8) fda=0 bits=0000 task_struct.acct_vm_mem1 u64;
// 142. 0C28 0008 effalign(8) fda=0 bits=0000 task_struct.acct_timexpd u64;
// 143. 0C30 0080 effalign(8) fda=0 bits=0000 task_struct.mems_allowed nodemask_t;
// 144. 0CB0 0004 effalign(4) fda=0 bits=0000 task_struct.mems_allowed_seq seqcount_t;
// 145. 0CB4 0004 effalign(4) fda=0 bits=0000 task_struct.cpuset_mem_spread_rotor int;
// 146. 0CB8 0004 effalign(4) fda=0 bits=0000 task_struct.cpuset_slab_spread_rotor int;
// 147. 0CC0 0008 effalign(8) fda=0 bits=0000 task_struct.cgroups css_set *;
// 148. 0CC8 0010 effalign(8) fda=0 bits=0000 task_struct.cg_list list_head;
// 149. 0CD8 0004 effalign(4) fda=0 bits=0000 task_struct.closid u32;
// 150. 0CDC 0004 effalign(4) fda=0 bits=0000 task_struct.rmid u32;
// 151. 0CE0 0008 effalign(8) fda=0 bits=0000 task_struct.robust_list robust_list_head *;
// 152. 0CE8 0008 effalign(8) fda=0 bits=0000 task_struct.compat_robust_list compat_robust_list_head *;
// 153. 0CF0 0010 effalign(8) fda=0 bits=0000 task_struct.pi_state_list list_head;
// 154. 0D00 0008 effalign(8) fda=0 bits=0000 task_struct.pi_state_cache futex_pi_state *;
// 155. 0D08 0020 effalign(8) fda=0 bits=0000 task_struct.futex_exit_mutex mutex;
// 156. 0D28 0004 effalign(4) fda=0 bits=0000 task_struct.futex_state unsigned int;
// 157. 0D30 0010 effalign(8) fda=0 bits=0000 task_struct.perf_event_ctxp perf_event_context *[2];
// 158. 0D40 0020 effalign(8) fda=0 bits=0000 task_struct.perf_event_mutex mutex;
// 159. 0D60 0010 effalign(8) fda=0 bits=0000 task_struct.perf_event_list list_head;
// 160. 0D70 0008 effalign(8) fda=0 bits=0000 task_struct.mempolicy mempolicy *;
// 161. 0D78 0002 effalign(2) fda=0 bits=0000 task_struct.il_prev __int16;
// 162. 0D7A 0002 effalign(2) fda=0 bits=0000 task_struct.pref_node_fork __int16;
// 163. 0D7C 0004 effalign(4) fda=0 bits=0000 task_struct.numa_scan_seq int;
// 164. 0D80 0004 effalign(4) fda=0 bits=0000 task_struct.numa_scan_period unsigned int;
// 165. 0D84 0004 effalign(4) fda=0 bits=0000 task_struct.numa_scan_period_max unsigned int;
// 166. 0D88 0004 effalign(4) fda=0 bits=0000 task_struct.numa_preferred_nid int;
// 167. 0D90 0008 effalign(8) fda=0 bits=0000 task_struct.numa_migrate_retry unsigned __int64;
// 168. 0D98 0008 effalign(8) fda=0 bits=0000 task_struct.node_stamp u64;
// 169. 0DA0 0008 effalign(8) fda=0 bits=0000 task_struct.last_task_numa_placement u64;
// 170. 0DA8 0008 effalign(8) fda=0 bits=0000 task_struct.last_sum_exec_runtime u64;
// 171. 0DB0 0010 effalign(8) fda=0 bits=0000 task_struct.numa_work callback_head;
// 172. 0DC0 0008 effalign(8) fda=0 bits=0000 task_struct.numa_group numa_group *;
// 173. 0DC8 0008 effalign(8) fda=0 bits=0000 task_struct.numa_faults unsigned __int64 *;
// 174. 0DD0 0008 effalign(8) fda=0 bits=0000 task_struct.total_numa_faults unsigned __int64;
// 175. 0DD8 0018 effalign(8) fda=0 bits=0000 task_struct.numa_faults_locality unsigned __int64[3];
// 176. 0DF0 0008 effalign(8) fda=0 bits=0000 task_struct.numa_pages_migrated unsigned __int64;
// 177. 0DF8 0008 effalign(8) fda=0 bits=0000 task_struct.rseq rseq *;
// 178. 0E00 0004 effalign(4) fda=0 bits=0000 task_struct.rseq_sig u32;
// 179. 0E08 0008 effalign(8) fda=0 bits=0000 task_struct.rseq_event_mask unsigned __int64;
// 180. 0E10 0408 effalign(8) fda=0 bits=0000 task_struct.tlb_ubc tlbflush_unmap_batch;
// 181. 1218 0010 effalign(8) fda=0 bits=0000 task_struct.task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC;
// 182. 1228 0008 effalign(8) fda=0 bits=0000 task_struct.splice_pipe pipe_inode_info *;
// 183. 1230 0010 effalign(8) fda=0 bits=0000 task_struct.task_frag page_frag;
// 184. 1240 0008 effalign(8) fda=0 bits=0000 task_struct.delays task_delay_info *;
// 185. 1248 0004 effalign(4) fda=0 bits=0000 task_struct.nr_dirtied int;
// 186. 124C 0004 effalign(4) fda=0 bits=0000 task_struct.nr_dirtied_pause int;
// 187. 1250 0008 effalign(8) fda=0 bits=0000 task_struct.dirty_paused_when unsigned __int64;
// 188. 1258 0008 effalign(8) fda=0 bits=0000 task_struct.timer_slack_ns u64;
// 189. 1260 0008 effalign(8) fda=0 bits=0000 task_struct.default_timer_slack_ns u64;
// 190. 1268 0004 effalign(4) fda=0 bits=0000 task_struct.curr_ret_stack int;
// 191. 126C 0004 effalign(4) fda=0 bits=0000 task_struct.curr_ret_depth int;
// 192. 1270 0008 effalign(8) fda=0 bits=0000 task_struct.ret_stack ftrace_ret_stack *;
// 193. 1278 0008 effalign(8) fda=0 bits=0000 task_struct.ftrace_timestamp unsigned __int64;
// 194. 1280 0004 effalign(4) fda=0 bits=0000 task_struct.trace_overrun atomic_t;
// 195. 1284 0004 effalign(4) fda=0 bits=0000 task_struct.tracing_graph_pause atomic_t;
// 196. 1288 0008 effalign(8) fda=0 bits=0000 task_struct.trace unsigned __int64;
// 197. 1290 0008 effalign(8) fda=0 bits=0000 task_struct.trace_recursion unsigned __int64;
// 198. 1298 0008 effalign(8) fda=0 bits=0000 task_struct.memcg_in_oom mem_cgroup *;
// 199. 12A0 0004 effalign(4) fda=0 bits=0000 task_struct.memcg_oom_gfp_mask gfp_t;
// 200. 12A4 0004 effalign(4) fda=0 bits=0000 task_struct.memcg_oom_order int;
// 201. 12A8 0004 effalign(4) fda=0 bits=0000 task_struct.memcg_nr_pages_over_high unsigned int;
// 202. 12B0 0008 effalign(8) fda=0 bits=0000 task_struct.active_memcg mem_cgroup *;
// 203. 12B8 0008 effalign(8) fda=0 bits=0000 task_struct.throttle_queue request_queue *;
// 204. 12C0 0008 effalign(8) fda=0 bits=0000 task_struct.utask uprobe_task *;
// 205. 12C8 0004 effalign(4) fda=0 bits=0000 task_struct.sequential_io unsigned int;
// 206. 12CC 0004 effalign(4) fda=0 bits=0000 task_struct.sequential_io_avg unsigned int;
// 207. 12D0 0004 effalign(4) fda=0 bits=0000 task_struct.pagefault_disabled int;
// 208. 12D8 0008 effalign(8) fda=0 bits=0000 task_struct.oom_reaper_list task_struct *;
// 209. 12E0 0028 effalign(8) fda=0 bits=0000 task_struct.oom_reaper_timer timer_list;
// 210. 1308 0008 effalign(8) fda=0 bits=0000 task_struct.stack_vm_area vm_struct *;
// 211. 1310 0004 effalign(4) fda=0 bits=0000 task_struct.stack_refcount refcount_t;
// 212. 1314 0004 effalign(4) fda=0 bits=0000 task_struct.patch_state int;
// 213. 1318 0008 effalign(8) fda=0 bits=0000 task_struct.security void *;
// 214. 1340 1100 effalign(64) fda=0 bits=0000 task_struct.thread thread_struct;
//          2440 effalign(64) sda=0 bits=0000 task_struct struct packalign=0

00000010 union task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC
{
  refcount_t rcu_users;
  callback_head rcu;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC.rcu_users refcount_t;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC.rcu callback_head;
//          0010 effalign(8) sda=0 bits=0000 task_struct::$BCED48C3E5831A0B3F83E2B565ACDAFC union packalign=0

00000028 struct tasklet_struct
{
  tasklet_struct *next;
  unsigned __int64 state;
  atomic_t count;
  void (__cdecl *func)(unsigned __int64);
  unsigned __int64 data;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 tasklet_struct.next tasklet_struct *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 tasklet_struct.state unsigned __int64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 tasklet_struct.count atomic_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 tasklet_struct.func void (__cdecl *)(unsigned __int64);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 tasklet_struct.data unsigned __int64;
//          0028 effalign(8) sda=0 bits=0000 tasklet_struct struct packalign=0

00000028 struct tb_service_id
{
  __u32 match_flags;
  char protocol_key[9];
  __u32 protocol_id;
  __u32 protocol_version;
  __u32 protocol_revision;
  kernel_ulong_t driver_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 tb_service_id.match_flags __u32;
//  1. 0004 0009 effalign(1) fda=0 bits=0000 tb_service_id.protocol_key char[9];
//  2. 0010 0004 effalign(4) fda=0 bits=0000 tb_service_id.protocol_id __u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 tb_service_id.protocol_version __u32;
//  4. 0018 0004 effalign(4) fda=0 bits=0000 tb_service_id.protocol_revision __u32;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 tb_service_id.driver_data kernel_ulong_t;
//          0028 effalign(8) sda=0 bits=0000 tb_service_id struct packalign=0

00000010 struct tee_client_device_id
{
  uuid_t uuid;
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 tee_client_device_id.uuid uuid_t;
//          0010 effalign(1) sda=0 bits=0000 tee_client_device_id struct packalign=0

00000010 struct thread_info
{
  unsigned __int64 flags;
  u32 status;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 thread_info.flags unsigned __int64;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 thread_info.status u32;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 thread_info struct packalign=0

00001100 struct thread_struct
{
  desc_struct tls_array[3];
  unsigned __int64 sp;
  unsigned __int16 es;
  unsigned __int16 ds;
  unsigned __int16 fsindex;
  unsigned __int16 gsindex;
  unsigned __int64 fsbase;
  unsigned __int64 gsbase;
  perf_event *ptrace_bps[4];
  unsigned __int64 debugreg6;
  unsigned __int64 ptrace_dr7;
  unsigned __int64 cr2;
  unsigned __int64 trap_nr;
  unsigned __int64 error_code;
  unsigned __int64 *io_bitmap_ptr;
  unsigned __int64 iopl;
  unsigned int io_bitmap_max;
  mm_segment_t addr_limit;
  unsigned __int32 sig_on_uaccess_err : 1;
  unsigned __int32 uaccess_err : 1;
  fpu fpu;
};
//  0. 0000 0018 effalign(1) fda=0 bits=0000 thread_struct.tls_array desc_struct[3];
//  1. 0018 0008 effalign(8) fda=0 bits=0000 thread_struct.sp unsigned __int64;
//  2. 0020 0002 effalign(2) fda=0 bits=0000 thread_struct.es unsigned __int16;
//  3. 0022 0002 effalign(2) fda=0 bits=0000 thread_struct.ds unsigned __int16;
//  4. 0024 0002 effalign(2) fda=0 bits=0000 thread_struct.fsindex unsigned __int16;
//  5. 0026 0002 effalign(2) fda=0 bits=0000 thread_struct.gsindex unsigned __int16;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 thread_struct.fsbase unsigned __int64;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 thread_struct.gsbase unsigned __int64;
//  8. 0038 0020 effalign(8) fda=0 bits=0000 thread_struct.ptrace_bps perf_event *[4];
//  9. 0058 0008 effalign(8) fda=0 bits=0000 thread_struct.debugreg6 unsigned __int64;
// 10. 0060 0008 effalign(8) fda=0 bits=0000 thread_struct.ptrace_dr7 unsigned __int64;
// 11. 0068 0008 effalign(8) fda=0 bits=0000 thread_struct.cr2 unsigned __int64;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 thread_struct.trap_nr unsigned __int64;
// 13. 0078 0008 effalign(8) fda=0 bits=0000 thread_struct.error_code unsigned __int64;
// 14. 0080 0008 effalign(8) fda=0 bits=0000 thread_struct.io_bitmap_ptr unsigned __int64 *;
// 15. 0088 0008 effalign(8) fda=0 bits=0000 thread_struct.iopl unsigned __int64;
// 16. 0090 0004 effalign(4) fda=0 bits=0000 thread_struct.io_bitmap_max unsigned int;
// 17. 0098 0008 effalign(8) fda=0 bits=0000 thread_struct.addr_limit mm_segment_t;
// 18. 00A0. 0 1 effalign(1) fda=0 bits=0000 thread_struct.sig_on_uaccess_err bi.nbytes=4 U
// 19. 00A0. 1 1 effalign(1) fda=0 bits=0000 thread_struct.uaccess_err bi.nbytes=4 U
// 20. 00C0 1040 effalign(64) fda=0 bits=0000 thread_struct.fpu fpu;
//          1100 effalign(64) sda=0 bits=0000 thread_struct struct packalign=0

00004000 union thread_union
{
  task_struct task;
  unsigned __int64 stack[2048];
};
//  0. 0000 2440 effalign(64) fda=0 bits=0000 thread_union.task task_struct;
//  1. 0000 4000 effalign(8) fda=0 bits=0000 thread_union.stack unsigned __int64[2048];
//          4000 effalign(64) sda=0 bits=0000 thread_union union packalign=0

FFFFFFFF struct throtl_data;
FFFFFFFF struct tick_device;
00000008 typedef __s64 time64_t;
00000008 typedef __kernel_time_t time_t;
00000028 struct timer_list
{
  hlist_node entry;
  unsigned __int64 expires;
  void (__cdecl *function)(timer_list *);
  u32 flags;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 timer_list.entry hlist_node;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 timer_list.expires unsigned __int64;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 timer_list.function void (__cdecl *)(timer_list *);
//  3. 0020 0004 effalign(4) fda=0 bits=0000 timer_list.flags u32;
//          0024 unpadded_size
//          0028 effalign(8) sda=0 bits=0000 timer_list struct packalign=0

FFFFFFFF struct timer_rand_state;
00000004 typedef __kernel_timer_t timer_t;
00000010 struct timerqueue_head
{
  rb_root_cached rb_root;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 timerqueue_head.rb_root rb_root_cached;
//          0010 effalign(8) sda=0 bits=0000 timerqueue_head struct packalign=0

00000020 struct timerqueue_node
{
  rb_node node;
  ktime_t expires;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 timerqueue_node.node rb_node;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 timerqueue_node.expires ktime_t;
//          0020 effalign(8) sda=0 bits=0000 timerqueue_node struct packalign=0

00000010 struct timespec
{
  __kernel_time_t tv_sec;
  __int64 tv_nsec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 timespec.tv_sec __kernel_time_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 timespec.tv_nsec __int64;
//          0010 effalign(8) sda=0 bits=0000 timespec struct packalign=0

00000010 struct timespec64
{
  time64_t tv_sec;
  __int64 tv_nsec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 timespec64.tv_sec time64_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 timespec64.tv_nsec __int64;
//          0010 effalign(8) sda=0 bits=0000 timespec64 struct packalign=0

00000004 enum timespec_type : unsigned __int32
{
  TT_NONE = 0x0,
  TT_NATIVE = 0x1,
  TT_COMPAT = 0x2,
};
00000008 typedef __u64 timeu64_t;
00000010 struct timeval
{
  __kernel_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 timeval.tv_sec __kernel_time_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 timeval.tv_usec __kernel_suseconds_t;
//          0010 effalign(8) sda=0 bits=0000 timeval struct packalign=0

000000D0 struct timex
{
  unsigned int modes;
  __kernel_long_t offset;
  __kernel_long_t freq;
  __kernel_long_t maxerror;
  __kernel_long_t esterror;
  int status;
  __kernel_long_t constant;
  __kernel_long_t precision;
  __kernel_long_t tolerance;
  timeval time;
  __kernel_long_t tick;
  __kernel_long_t ppsfreq;
  __kernel_long_t jitter;
  int shift;
  __kernel_long_t stabil;
  __kernel_long_t jitcnt;
  __kernel_long_t calcnt;
  __kernel_long_t errcnt;
  __kernel_long_t stbcnt;
  int tai;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
  __int32 : 32;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 timex.modes unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 timex.offset __kernel_long_t;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 timex.freq __kernel_long_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 timex.maxerror __kernel_long_t;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 timex.esterror __kernel_long_t;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 timex.status int;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 timex.constant __kernel_long_t;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 timex.precision __kernel_long_t;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 timex.tolerance __kernel_long_t;
//  9. 0048 0010 effalign(8) fda=0 bits=0000 timex.time timeval;
// 10. 0058 0008 effalign(8) fda=0 bits=0000 timex.tick __kernel_long_t;
// 11. 0060 0008 effalign(8) fda=0 bits=0000 timex.ppsfreq __kernel_long_t;
// 12. 0068 0008 effalign(8) fda=0 bits=0000 timex.jitter __kernel_long_t;
// 13. 0070 0004 effalign(4) fda=0 bits=0000 timex.shift int;
// 14. 0078 0008 effalign(8) fda=0 bits=0000 timex.stabil __kernel_long_t;
// 15. 0080 0008 effalign(8) fda=0 bits=0000 timex.jitcnt __kernel_long_t;
// 16. 0088 0008 effalign(8) fda=0 bits=0000 timex.calcnt __kernel_long_t;
// 17. 0090 0008 effalign(8) fda=0 bits=0000 timex.errcnt __kernel_long_t;
// 18. 0098 0008 effalign(8) fda=0 bits=0000 timex.stbcnt __kernel_long_t;
// 19. 00A0 0004 effalign(4) fda=0 bits=0000 timex.tai int;
// 20. 00A4. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 21. 00A8. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 22. 00AC. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 23. 00B0. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 24. 00B4. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 25. 00B8. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 26. 00BC. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 27. 00C0. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 28. 00C4. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 29. 00C8. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
// 30. 00CC. 0 32 effalign(4) fda=0 bits=0000 timex.(null) bi.nbytes=4 S
//          00D0 effalign(8) sda=0 bits=0000 timex struct packalign=0

00000008 struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 timezone.tz_minuteswest int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 timezone.tz_dsttime int;
//          0008 effalign(4) sda=0 bits=0000 timezone struct packalign=0

00000004 enum tk_offsets : unsigned __int32
{
  TK_OFFS_REAL = 0x0,
  TK_OFFS_BOOT = 0x1,
  TK_OFFS_TAI = 0x2,
  TK_OFFS_MAX = 0x3,
};
00000004 enum tlb_flush_reason : unsigned __int32
{
  TLB_FLUSH_ON_TASK_SWITCH = 0x0,
  TLB_REMOTE_SHOOTDOWN = 0x1,
  TLB_LOCAL_SHOOTDOWN = 0x2,
  TLB_LOCAL_MM_SHOOTDOWN = 0x3,
  TLB_REMOTE_SEND_IPI = 0x4,
  NR_TLB_FLUSH_REASONS = 0x5,
};
00000004 enum tlb_infos : unsigned __int32
{
  ENTRIES = 0x0,
  NR_INFO = 0x1,
};
00000408 struct tlbflush_unmap_batch
{
  arch_tlbflush_unmap_batch arch;
  bool flush_required;
  bool writable;
};
//  0. 0000 0400 effalign(8) fda=0 bits=0000 tlbflush_unmap_batch.arch arch_tlbflush_unmap_batch;
//  1. 0400 0001 effalign(1) fda=0 bits=0000 tlbflush_unmap_batch.flush_required bool;
//  2. 0401 0001 effalign(1) fda=0 bits=0000 tlbflush_unmap_batch.writable bool;
//          0402 unpadded_size
//          0408 effalign(8) sda=0 bits=0000 tlbflush_unmap_batch struct packalign=0

00000028 struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  __int64 tm_year;
  int tm_wday;
  int tm_yday;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 tm.tm_sec int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 tm.tm_min int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 tm.tm_hour int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 tm.tm_mday int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 tm.tm_mon int;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 tm.tm_year __int64;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 tm.tm_wday int;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 tm.tm_yday int;
//          0028 effalign(8) sda=0 bits=0000 tm struct packalign=0

FFFFFFFF struct trace_eval_map;
FFFFFFFF struct trace_event_call;
00000010 struct trace_print_flags
{
  unsigned __int64 mask;
  const char *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 trace_print_flags.mask unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 trace_print_flags.name const char *;
//          0010 effalign(8) sda=0 bits=0000 trace_print_flags struct packalign=0

00000010 struct trace_print_flags_u64
{
  unsigned __int64 mask;
  const char *name;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 trace_print_flags_u64.mask unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 trace_print_flags_u64.name const char *;
//          0010 effalign(8) sda=0 bits=0000 trace_print_flags_u64 struct packalign=0

00000030 struct tracepoint
{
  const char *name;
  static_key key;
  int (*regfunc)(void);
  void (*unregfunc)(void);
  tracepoint_func *funcs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 tracepoint.name const char *;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 tracepoint.key static_key;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 tracepoint.regfunc int (*)(void);
//  3. 0020 0008 effalign(8) fda=0 bits=0000 tracepoint.unregfunc void (*)(void);
//  4. 0028 0008 effalign(8) fda=0 bits=0000 tracepoint.funcs tracepoint_func *;
//          0030 effalign(8) sda=0 bits=0000 tracepoint struct packalign=0

00000018 struct tracepoint_func
{
  void *func;
  void *data;
  int prio;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 tracepoint_func.func void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 tracepoint_func.data void *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 tracepoint_func.prio int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 tracepoint_func struct packalign=0

00000004 typedef const int tracepoint_ptr_t;
00000018 struct trampoline_header
{
  u64 start;
  u64 efer;
  u32 cr4;
  u32 flags;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 trampoline_header.start u64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 trampoline_header.efer u64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 trampoline_header.cr4 u32;
//  3. 0014 0004 effalign(4) fda=0 bits=0000 trampoline_header.flags u32;
//          0018 effalign(8) sda=0 bits=0000 trampoline_header struct packalign=0

00000004 enum transparent_hugepage_flag : unsigned __int32
{
  TRANSPARENT_HUGEPAGE_FLAG = 0x0,
  TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 0x1,
  TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 0x2,
  TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 0x3,
  TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 0x4,
  TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 0x5,
  TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 0x6,
  TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 0x7,
};
00000018 struct tree_descr
{
  const char *name;
  const file_operations *ops;
  int mode;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 tree_descr.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 tree_descr.ops const file_operations *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 tree_descr.mode int;
//          0014 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 tree_descr struct packalign=0

00000010 typedef ldttss_desc tss_desc;
00003000 struct __attribute__((aligned(4096))) tss_struct
{
  x86_hw_tss x86_tss;
  unsigned __int64 io_bitmap[1025];
};
//  0. 0000 0068 effalign(1) fda=0 bits=0000 tss_struct.x86_tss x86_hw_tss;
//  1. 0068 2008 effalign(8) fda=0 bits=0000 tss_struct.io_bitmap unsigned __int64[1025];
//          2070 unpadded_size
//          3000 effalign(4096) sda=13 bits=0000 tss_struct struct packalign=0

00000010 struct typec_device_id
{
  __u16 svid;
  __u8 mode;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 typec_device_id.svid __u16;
//  1. 0002 0001 effalign(1) fda=0 bits=0000 typec_device_id.mode __u8;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 typec_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 typec_device_id struct packalign=0

00000002 typedef __u16 u16;
00000004 typedef __u32 u32;
00000008 typedef __u64 u64;
00000000 struct u64_stats_sync
{
};
//          0000 effalign(1) sda=0 bits=0000 u64_stats_sync struct packalign=0

00000001 typedef __u8 u8;
00000001 typedef unsigned __int8 u_char;
00000004 typedef unsigned int u_int;
00000002 typedef u16 u_int16_t;
00000004 typedef u32 u_int32_t;
00000008 typedef u64 u_int64_t;
00000001 typedef u8 u_int8_t;
00000008 typedef unsigned __int64 u_long;
00000002 typedef unsigned __int16 u_short;
00000004 enum uclamp_id : unsigned __int32
{
  UCLAMP_MIN = 0x0,
  UCLAMP_MAX = 0x1,
  UCLAMP_CNT = 0x2,
};
00000004 struct uclamp_se
{
  unsigned __int32 value : 11;
  unsigned __int32 bucket_id : 3;
  unsigned __int32 active : 1;
  unsigned __int32 user_defined : 1;
};
//  0. 0000. 0 11 effalign(2) fda=0 bits=0000 uclamp_se.value bi.nbytes=4 U
//  1. 0000.11 3 effalign(2) fda=0 bits=0000 uclamp_se.bucket_id bi.nbytes=4 U
//  2. 0000.14 1 effalign(2) fda=0 bits=0000 uclamp_se.active bi.nbytes=4 U
//  3. 0000.15 1 effalign(2) fda=0 bits=0000 uclamp_se.user_defined bi.nbytes=4 U
//          0002 unpadded_size
//          0004 effalign(4) sda=0 bits=0000 uclamp_se struct packalign=0

00000002 typedef __kernel_uid16_t uid16_t;
00000004 typedef __kernel_uid32_t uid_t;
00000004 typedef unsigned int uint;
00000002 typedef u16 uint16_t;
00000004 typedef u32 uint32_t;
00000008 typedef u64 uint64_t;
00000001 typedef u8 uint8_t;
00000008 typedef unsigned __int64 uintptr_t;
00000008 typedef unsigned __int64 ulong;
00000010 struct ulpi_device_id
{
  __u16 vendor;
  __u16 product;
  kernel_ulong_t driver_data;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 ulpi_device_id.vendor __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 ulpi_device_id.product __u16;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 ulpi_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 ulpi_device_id struct packalign=0

00000004 enum umh_disable_depth : unsigned __int32
{
  UMH_ENABLED = 0x0,
  UMH_FREEZING = 0x1,
  UMH_DISABLED = 0x2,
};
00000038 struct umh_info
{
  const char *cmdline;
  file *pipe_to_umh;
  file *pipe_from_umh;
  list_head list;
  void (__cdecl *cleanup)(umh_info *);
  pid_t pid;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 umh_info.cmdline const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 umh_info.pipe_to_umh file *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 umh_info.pipe_from_umh file *;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 umh_info.list list_head;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 umh_info.cleanup void (__cdecl *)(umh_info *);
//  5. 0030 0004 effalign(4) fda=0 bits=0000 umh_info.pid pid_t;
//          0034 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 umh_info struct packalign=0

00000002 typedef unsigned __int16 umode_t;
00000001 typedef unsigned __int8 unchar;
00000198 struct unixware_disklabel
{
  __le32 d_type;
  __le32 d_magic;
  __le32 d_version;
  char d_serial[12];
  __le32 d_ncylinders;
  __le32 d_ntracks;
  __le32 d_nsectors;
  __le32 d_secsize;
  __le32 d_part_start;
  __le32 d_unknown1[12];
  __le32 d_alt_tbl;
  __le32 d_alt_len;
  __le32 d_phys_cyl;
  __le32 d_phys_trk;
  __le32 d_phys_sec;
  __le32 d_phys_bytes;
  __le32 d_unknown2;
  __le32 d_unknown3;
  __le32 d_pad[8];
  unixware_vtoc vtoc;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_type __le32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_magic __le32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_version __le32;
//  3. 000C 000C effalign(1) fda=0 bits=0000 unixware_disklabel.d_serial char[12];
//  4. 0018 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_ncylinders __le32;
//  5. 001C 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_ntracks __le32;
//  6. 0020 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_nsectors __le32;
//  7. 0024 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_secsize __le32;
//  8. 0028 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_part_start __le32;
//  9. 002C 0030 effalign(4) fda=0 bits=0000 unixware_disklabel.d_unknown1 __le32[12];
// 10. 005C 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_alt_tbl __le32;
// 11. 0060 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_alt_len __le32;
// 12. 0064 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_phys_cyl __le32;
// 13. 0068 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_phys_trk __le32;
// 14. 006C 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_phys_sec __le32;
// 15. 0070 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_phys_bytes __le32;
// 16. 0074 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_unknown2 __le32;
// 17. 0078 0004 effalign(4) fda=0 bits=0000 unixware_disklabel.d_unknown3 __le32;
// 18. 007C 0020 effalign(4) fda=0 bits=0000 unixware_disklabel.d_pad __le32[8];
// 19. 009C 00FC effalign(4) fda=0 bits=0000 unixware_disklabel.vtoc unixware_vtoc;
//          0198 effalign(4) sda=0 bits=0000 unixware_disklabel struct packalign=0

0000000C struct unixware_slice
{
  __le16 s_label;
  __le16 s_flags;
  __le32 start_sect;
  __le32 nr_sects;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 unixware_slice.s_label __le16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 unixware_slice.s_flags __le16;
//  2. 0004 0004 effalign(4) fda=0 bits=0000 unixware_slice.start_sect __le32;
//  3. 0008 0004 effalign(4) fda=0 bits=0000 unixware_slice.nr_sects __le32;
//          000C effalign(4) sda=0 bits=0000 unixware_slice struct packalign=0

000000FC struct unixware_vtoc
{
  __le32 v_magic;
  __le32 v_version;
  char v_name[8];
  __le16 v_nslices;
  __le16 v_unknown1;
  __le32 v_reserved[10];
  unixware_slice v_slice[16];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 unixware_vtoc.v_magic __le32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 unixware_vtoc.v_version __le32;
//  2. 0008 0008 effalign(1) fda=0 bits=0000 unixware_vtoc.v_name char[8];
//  3. 0010 0002 effalign(2) fda=0 bits=0000 unixware_vtoc.v_nslices __le16;
//  4. 0012 0002 effalign(2) fda=0 bits=0000 unixware_vtoc.v_unknown1 __le16;
//  5. 0014 0028 effalign(4) fda=0 bits=0000 unixware_vtoc.v_reserved __le32[10];
//  6. 003C 00C0 effalign(4) fda=0 bits=0000 unixware_vtoc.v_slice unixware_slice[16];
//          00FC effalign(4) sda=0 bits=0000 unixware_vtoc struct packalign=0

0000000C struct unwind_hint
{
  u32 ip;
  s16 sp_offset;
  u8 sp_reg;
  u8 type;
  u8 end;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 unwind_hint.ip u32;
//  1. 0004 0002 effalign(2) fda=0 bits=0000 unwind_hint.sp_offset s16;
//  2. 0006 0001 effalign(1) fda=0 bits=0000 unwind_hint.sp_reg u8;
//  3. 0007 0001 effalign(1) fda=0 bits=0000 unwind_hint.type u8;
//  4. 0008 0001 effalign(1) fda=0 bits=0000 unwind_hint.end u8;
//          0009 unpadded_size
//          000C effalign(4) sda=0 bits=0000 unwind_hint struct packalign=0

00000010 struct upid
{
  int nr;
  pid_namespace *ns;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 upid.nr int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 upid.ns pid_namespace *;
//          0010 effalign(8) sda=0 bits=0000 upid struct packalign=0

FFFFFFFF struct uprobe;
00000020 struct uprobe_consumer
{
  int (__cdecl *handler)(uprobe_consumer *, pt_regs *);
  int (__cdecl *ret_handler)(uprobe_consumer *, unsigned __int64, pt_regs *);
  bool (__cdecl *filter)(uprobe_consumer *, uprobe_filter_ctx, mm_struct *);
  uprobe_consumer *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 uprobe_consumer.handler int (__cdecl *)(uprobe_consumer *, pt_regs *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 uprobe_consumer.ret_handler int (__cdecl *)(uprobe_consumer *, unsigned __int64, pt_regs *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 uprobe_consumer.filter bool (__cdecl *)(uprobe_consumer *, uprobe_filter_ctx, mm_struct *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 uprobe_consumer.next uprobe_consumer *;
//          0020 effalign(8) sda=0 bits=0000 uprobe_consumer struct packalign=0

00000004 enum uprobe_filter_ctx : unsigned __int32
{
  UPROBE_FILTER_REGISTER = 0x0,
  UPROBE_FILTER_UNREGISTER = 0x1,
  UPROBE_FILTER_MMAP = 0x2,
};
00000001 typedef u8 uprobe_opcode_t;
00000040 struct uprobe_task
{
  uprobe_task_state state;
  union
  {
    struct
    {
      arch_uprobe_task autask;
      unsigned __int64 vaddr;
    };
    struct
    {
      callback_head dup_xol_work;
      unsigned __int64 dup_xol_addr;
    };
  };
  uprobe *active_uprobe;
  unsigned __int64 xol_vaddr;
  return_instance *return_instances;
  unsigned int depth;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 uprobe_task.state uprobe_task_state;
//  1. 0008 0018 effalign(8) fda=0 bits=0000 uprobe_task.uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27 uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 uprobe_task.active_uprobe uprobe *;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 uprobe_task.xol_vaddr unsigned __int64;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 uprobe_task.return_instances return_instance *;
//  5. 0038 0004 effalign(4) fda=0 bits=0000 uprobe_task.depth unsigned int;
//          003C unpadded_size
//          0040 effalign(8) sda=0 bits=0000 uprobe_task struct packalign=0

00000018 union uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27
{
  struct
  {
    arch_uprobe_task autask;
    unsigned __int64 vaddr;
  };
  struct
  {
    callback_head dup_xol_work;
    unsigned __int64 dup_xol_addr;
  };
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27.$5D35329CDE05C1838A937F7339567B02 $5D35329CDE05C1838A937F7339567B02;
//  1. 0000 0018 effalign(8) fda=0 bits=0000 uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27.$2F8F0B40204E9F9467F489FB07BFF473 $2F8F0B40204E9F9467F489FB07BFF473;
//          0018 effalign(8) sda=0 bits=0000 uprobe_task::$46B3313BAC420E5D6ED743F318D5CE27 union packalign=0

00000004 enum uprobe_task_state : unsigned __int32
{
  UTASK_RUNNING = 0x0,
  UTASK_SSTEP = 0x1,
  UTASK_SSTEP_ACK = 0x2,
  UTASK_SSTEP_TRAPPED = 0x3,
};
FFFFFFFF struct uprobe_xol_ops;
00000008 struct uprobes_state
{
  xol_area *xol_area;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 uprobes_state.xol_area xol_area *;
//          0008 effalign(8) sda=0 bits=0000 uprobes_state struct packalign=0

000000B8 struct urb
{
  kref kref;
  int unlinked;
  void *hcpriv;
  atomic_t use_count;
  atomic_t reject;
  list_head urb_list;
  list_head anchor_list;
  usb_anchor *anchor;
  usb_device *dev;
  usb_host_endpoint *ep;
  unsigned int pipe;
  unsigned int stream_id;
  int status;
  unsigned int transfer_flags;
  void *transfer_buffer;
  dma_addr_t transfer_dma;
  scatterlist *sg;
  int num_mapped_sgs;
  int num_sgs;
  u32 transfer_buffer_length;
  u32 actual_length;
  unsigned __int8 *setup_packet;
  dma_addr_t setup_dma;
  int start_frame;
  int number_of_packets;
  int interval;
  int error_count;
  void *context;
  usb_complete_t complete;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 urb.kref kref;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 urb.unlinked int;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 urb.hcpriv void *;
//  3. 0010 0004 effalign(4) fda=0 bits=0000 urb.use_count atomic_t;
//  4. 0014 0004 effalign(4) fda=0 bits=0000 urb.reject atomic_t;
//  5. 0018 0010 effalign(8) fda=0 bits=0000 urb.urb_list list_head;
//  6. 0028 0010 effalign(8) fda=0 bits=0000 urb.anchor_list list_head;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 urb.anchor usb_anchor *;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 urb.dev usb_device *;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 urb.ep usb_host_endpoint *;
// 10. 0050 0004 effalign(4) fda=0 bits=0000 urb.pipe unsigned int;
// 11. 0054 0004 effalign(4) fda=0 bits=0000 urb.stream_id unsigned int;
// 12. 0058 0004 effalign(4) fda=0 bits=0000 urb.status int;
// 13. 005C 0004 effalign(4) fda=0 bits=0000 urb.transfer_flags unsigned int;
// 14. 0060 0008 effalign(8) fda=0 bits=0000 urb.transfer_buffer void *;
// 15. 0068 0008 effalign(8) fda=0 bits=0000 urb.transfer_dma dma_addr_t;
// 16. 0070 0008 effalign(8) fda=0 bits=0000 urb.sg scatterlist *;
// 17. 0078 0004 effalign(4) fda=0 bits=0000 urb.num_mapped_sgs int;
// 18. 007C 0004 effalign(4) fda=0 bits=0000 urb.num_sgs int;
// 19. 0080 0004 effalign(4) fda=0 bits=0000 urb.transfer_buffer_length u32;
// 20. 0084 0004 effalign(4) fda=0 bits=0000 urb.actual_length u32;
// 21. 0088 0008 effalign(8) fda=0 bits=0000 urb.setup_packet unsigned __int8 *;
// 22. 0090 0008 effalign(8) fda=0 bits=0000 urb.setup_dma dma_addr_t;
// 23. 0098 0004 effalign(4) fda=0 bits=0000 urb.start_frame int;
// 24. 009C 0004 effalign(4) fda=0 bits=0000 urb.number_of_packets int;
// 25. 00A0 0004 effalign(4) fda=0 bits=0000 urb.interval int;
// 26. 00A4 0004 effalign(4) fda=0 bits=0000 urb.error_count int;
// 27. 00A8 0008 effalign(8) fda=0 bits=0000 urb.context void *;
// 28. 00B0 0008 effalign(8) fda=0 bits=0000 urb.complete usb_complete_t;
//          00B8 effalign(8) sda=0 bits=0000 urb struct packalign=0

00000008 struct usb2_lpm_parameters
{
  unsigned int besl;
  int timeout;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb2_lpm_parameters.besl unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 usb2_lpm_parameters.timeout int;
//          0008 effalign(4) sda=0 bits=0000 usb2_lpm_parameters struct packalign=0

00000004 enum usb3_link_state : unsigned __int32
{
  USB3_LPM_U0 = 0x0,
  USB3_LPM_U1 = 0x1,
  USB3_LPM_U2 = 0x2,
  USB3_LPM_U3 = 0x3,
};
00000010 struct usb3_lpm_parameters
{
  unsigned int mel;
  unsigned int pel;
  unsigned int sel;
  int timeout;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb3_lpm_parameters.mel unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 usb3_lpm_parameters.pel unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 usb3_lpm_parameters.sel unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 usb3_lpm_parameters.timeout int;
//          0010 effalign(4) sda=0 bits=0000 usb3_lpm_parameters struct packalign=0

00000038 struct usb_anchor
{
  list_head urb_list;
  wait_queue_head_t wait;
  spinlock_t lock;
  atomic_t suspend_wakeups;
  unsigned __int32 poisoned : 1;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 usb_anchor.urb_list list_head;
//  1. 0010 0018 effalign(8) fda=0 bits=0000 usb_anchor.wait wait_queue_head_t;
//  2. 0028 0004 effalign(4) fda=0 bits=0000 usb_anchor.lock spinlock_t;
//  3. 002C 0004 effalign(4) fda=0 bits=0000 usb_anchor.suspend_wakeups atomic_t;
//  4. 0030. 0 1 effalign(1) fda=0 bits=0000 usb_anchor.poisoned bi.nbytes=4 U
//          0031 unpadded_size
//          0038 effalign(8) sda=0 bits=0000 usb_anchor struct packalign=0

00000005 struct __attribute__((packed)) usb_bos_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 wTotalLength;
  __u8 bNumDeviceCaps;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_bos_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_bos_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_bos_descriptor.wTotalLength __le16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 usb_bos_descriptor.bNumDeviceCaps __u8;
//          0005 effalign(1) sda=0 bits=0040 usb_bos_descriptor struct packalign=0

00000090 struct usb_bus
{
  device *controller;
  device *sysdev;
  int busnum;
  const char *bus_name;
  u8 uses_pio_for_control;
  u8 otg_port;
  unsigned __int32 is_b_host : 1;
  unsigned __int32 b_hnp_enable : 1;
  unsigned __int32 no_stop_on_short : 1;
  unsigned __int32 no_sg_constraint : 1;
  unsigned int sg_tablesize;
  int devnum_next;
  mutex devnum_next_mutex;
  usb_devmap devmap;
  usb_device *root_hub;
  usb_bus *hs_companion;
  int bandwidth_allocated;
  int bandwidth_int_reqs;
  int bandwidth_isoc_reqs;
  unsigned int resuming_ports;
  mon_bus *mon_bus;
  int monitored;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_bus.controller device *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_bus.sysdev device *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 usb_bus.busnum int;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_bus.bus_name const char *;
//  4. 0020 0001 effalign(1) fda=0 bits=0000 usb_bus.uses_pio_for_control u8;
//  5. 0021 0001 effalign(1) fda=0 bits=0000 usb_bus.otg_port u8;
//  6. 0020.16 1 effalign(1) fda=0 bits=0000 usb_bus.is_b_host bi.nbytes=4 U
//  7. 0020.17 1 effalign(1) fda=0 bits=0000 usb_bus.b_hnp_enable bi.nbytes=4 U
//  8. 0020.18 1 effalign(1) fda=0 bits=0000 usb_bus.no_stop_on_short bi.nbytes=4 U
//  9. 0020.19 1 effalign(1) fda=0 bits=0000 usb_bus.no_sg_constraint bi.nbytes=4 U
// 10. 0024 0004 effalign(4) fda=0 bits=0000 usb_bus.sg_tablesize unsigned int;
// 11. 0028 0004 effalign(4) fda=0 bits=0000 usb_bus.devnum_next int;
// 12. 0030 0020 effalign(8) fda=0 bits=0000 usb_bus.devnum_next_mutex mutex;
// 13. 0050 0010 effalign(8) fda=0 bits=0000 usb_bus.devmap usb_devmap;
// 14. 0060 0008 effalign(8) fda=0 bits=0000 usb_bus.root_hub usb_device *;
// 15. 0068 0008 effalign(8) fda=0 bits=0000 usb_bus.hs_companion usb_bus *;
// 16. 0070 0004 effalign(4) fda=0 bits=0000 usb_bus.bandwidth_allocated int;
// 17. 0074 0004 effalign(4) fda=0 bits=0000 usb_bus.bandwidth_int_reqs int;
// 18. 0078 0004 effalign(4) fda=0 bits=0000 usb_bus.bandwidth_isoc_reqs int;
// 19. 007C 0004 effalign(4) fda=0 bits=0000 usb_bus.resuming_ports unsigned int;
// 20. 0080 0008 effalign(8) fda=0 bits=0000 usb_bus.mon_bus mon_bus *;
// 21. 0088 0004 effalign(4) fda=0 bits=0000 usb_bus.monitored int;
//          008C unpadded_size
//          0090 effalign(8) sda=0 bits=0000 usb_bus struct packalign=0

00000020 struct usb_class_driver
{
  char *name;
  char *(__cdecl *devnode)(device *, umode_t *);
  const file_operations *fops;
  int minor_base;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_class_driver.name char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_class_driver.devnode char *(__cdecl *)(device *, umode_t *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 usb_class_driver.fops const file_operations *;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 usb_class_driver.minor_base int;
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 usb_class_driver struct packalign=0

00000008 typedef void (__cdecl *usb_complete_t)(urb *);
00000009 struct __attribute__((packed)) usb_config_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 wTotalLength;
  __u8 bNumInterfaces;
  __u8 bConfigurationValue;
  __u8 iConfiguration;
  __u8 bmAttributes;
  __u8 bMaxPower;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_config_descriptor.wTotalLength __le16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bNumInterfaces __u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bConfigurationValue __u8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.iConfiguration __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bmAttributes __u8;
//  7. 0008 0001 effalign(1) fda=0 bits=0000 usb_config_descriptor.bMaxPower __u8;
//          0009 effalign(1) sda=0 bits=0040 usb_config_descriptor struct packalign=0

00000030 struct __attribute__((packed)) usb_connection_context
{
  __u8 CHID[16];
  __u8 CDID[16];
  __u8 CK[16];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 usb_connection_context.CHID __u8[16];
//  1. 0010 0010 effalign(1) fda=0 bits=0000 usb_connection_context.CDID __u8[16];
//  2. 0020 0010 effalign(1) fda=0 bits=0000 usb_connection_context.CK __u8[16];
//          0030 effalign(1) sda=0 bits=0040 usb_connection_context struct packalign=0

00000008 struct __attribute__((packed)) usb_ctrlrequest
{
  __u8 bRequestType;
  __u8 bRequest;
  __le16 wValue;
  __le16 wIndex;
  __le16 wLength;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ctrlrequest.bRequestType __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ctrlrequest.bRequest __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_ctrlrequest.wValue __le16;
//  3. 0004 0002 effalign(1) fda=0 bits=0000 usb_ctrlrequest.wIndex __le16;
//  4. 0006 0002 effalign(1) fda=0 bits=0000 usb_ctrlrequest.wLength __le16;
//          0008 effalign(1) sda=0 bits=0040 usb_ctrlrequest struct packalign=0

00000004 struct __attribute__((packed)) usb_debug_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDebugInEndpoint;
  __u8 bDebugOutEndpoint;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_debug_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_debug_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_debug_descriptor.bDebugInEndpoint __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_debug_descriptor.bDebugOutEndpoint __u8;
//          0004 effalign(1) sda=0 bits=0040 usb_debug_descriptor struct packalign=0

00000002 struct __attribute__((packed)) usb_descriptor_header
{
  __u8 bLength;
  __u8 bDescriptorType;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_descriptor_header.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_descriptor_header.bDescriptorType __u8;
//          0002 effalign(1) sda=0 bits=0040 usb_descriptor_header struct packalign=0

00000003 struct __attribute__((packed)) usb_dev_cap_header
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_dev_cap_header.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_dev_cap_header.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_dev_cap_header.bDevCapabilityType __u8;
//          0003 effalign(1) sda=0 bits=0040 usb_dev_cap_header struct packalign=0

FFFFFFFF struct usb_dev_state;
00000550 struct usb_device
{
  int devnum;
  char devpath[16];
  u32 route;
  usb_device_state state;
  usb_device_speed speed;
  unsigned int rx_lanes;
  unsigned int tx_lanes;
  usb_tt *tt;
  int ttport;
  unsigned int toggle[2];
  usb_device *parent;
  usb_bus *bus;
  usb_host_endpoint ep0;
  device dev;
  usb_device_descriptor descriptor;
  usb_host_bos *bos;
  usb_host_config *config;
  usb_host_config *actconfig;
  usb_host_endpoint *ep_in[16];
  usb_host_endpoint *ep_out[16];
  char **rawdescriptors;
  unsigned __int16 bus_mA;
  u8 portnum;
  u8 level;
  u8 devaddr;
  unsigned __int32 can_submit : 1;
  unsigned __int32 persist_enabled : 1;
  unsigned __int32 reset_in_progress : 1;
  unsigned __int32 have_langid : 1;
  unsigned __int32 authorized : 1;
  unsigned __int32 authenticated : 1;
  unsigned __int32 wusb : 1;
  unsigned __int32 lpm_capable : 1;
  unsigned __int32 usb2_hw_lpm_capable : 1;
  unsigned __int32 usb2_hw_lpm_besl_capable : 1;
  unsigned __int32 usb2_hw_lpm_enabled : 1;
  unsigned __int32 usb2_hw_lpm_allowed : 1;
  unsigned __int32 usb3_lpm_u1_enabled : 1;
  unsigned __int32 usb3_lpm_u2_enabled : 1;
  int string_langid;
  char *product;
  char *manufacturer;
  char *serial;
  list_head filelist;
  int maxchild;
  u32 quirks;
  atomic_t urbnum;
  unsigned __int64 active_duration;
  unsigned __int64 connect_time;
  unsigned __int32 do_remote_wakeup : 1;
  unsigned __int32 reset_resume : 1;
  unsigned __int32 port_is_suspended : 1;
  wusb_dev *wusb_dev;
  int slot_id;
  usb_device_removable removable;
  usb2_lpm_parameters l1_params;
  usb3_lpm_parameters u1_params;
  usb3_lpm_parameters u2_params;
  unsigned int lpm_disable_count;
  u16 hub_delay;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb_device.devnum int;
//  1. 0004 0010 effalign(1) fda=0 bits=0000 usb_device.devpath char[16];
//  2. 0014 0004 effalign(4) fda=0 bits=0000 usb_device.route u32;
//  3. 0018 0004 effalign(4) fda=0 bits=0000 usb_device.state usb_device_state;
//  4. 001C 0004 effalign(4) fda=0 bits=0000 usb_device.speed usb_device_speed;
//  5. 0020 0004 effalign(4) fda=0 bits=0000 usb_device.rx_lanes unsigned int;
//  6. 0024 0004 effalign(4) fda=0 bits=0000 usb_device.tx_lanes unsigned int;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 usb_device.tt usb_tt *;
//  8. 0030 0004 effalign(4) fda=0 bits=0000 usb_device.ttport int;
//  9. 0034 0008 effalign(4) fda=0 bits=0000 usb_device.toggle unsigned int[2];
// 10. 0040 0008 effalign(8) fda=0 bits=0000 usb_device.parent usb_device *;
// 11. 0048 0008 effalign(8) fda=0 bits=0000 usb_device.bus usb_bus *;
// 12. 0050 0050 effalign(8) fda=0 bits=0000 usb_device.ep0 usb_host_endpoint;
// 13. 00A0 02D8 effalign(8) fda=0 bits=0000 usb_device.dev device;
// 14. 0378 0012 effalign(1) fda=0 bits=0000 usb_device.descriptor usb_device_descriptor;
// 15. 0390 0008 effalign(8) fda=0 bits=0000 usb_device.bos usb_host_bos *;
// 16. 0398 0008 effalign(8) fda=0 bits=0000 usb_device.config usb_host_config *;
// 17. 03A0 0008 effalign(8) fda=0 bits=0000 usb_device.actconfig usb_host_config *;
// 18. 03A8 0080 effalign(8) fda=0 bits=0000 usb_device.ep_in usb_host_endpoint *[16];
// 19. 0428 0080 effalign(8) fda=0 bits=0000 usb_device.ep_out usb_host_endpoint *[16];
// 20. 04A8 0008 effalign(8) fda=0 bits=0000 usb_device.rawdescriptors char **;
// 21. 04B0 0002 effalign(2) fda=0 bits=0000 usb_device.bus_mA unsigned __int16;
// 22. 04B2 0001 effalign(1) fda=0 bits=0000 usb_device.portnum u8;
// 23. 04B3 0001 effalign(1) fda=0 bits=0000 usb_device.level u8;
// 24. 04B4 0001 effalign(1) fda=0 bits=0000 usb_device.devaddr u8;
// 25. 04B4. 8 1 effalign(1) fda=0 bits=0000 usb_device.can_submit bi.nbytes=4 U
// 26. 04B4. 9 1 effalign(1) fda=0 bits=0000 usb_device.persist_enabled bi.nbytes=4 U
// 27. 04B4.10 1 effalign(1) fda=0 bits=0000 usb_device.reset_in_progress bi.nbytes=4 U
// 28. 04B4.11 1 effalign(1) fda=0 bits=0000 usb_device.have_langid bi.nbytes=4 U
// 29. 04B4.12 1 effalign(1) fda=0 bits=0000 usb_device.authorized bi.nbytes=4 U
// 30. 04B4.13 1 effalign(1) fda=0 bits=0000 usb_device.authenticated bi.nbytes=4 U
// 31. 04B4.14 1 effalign(1) fda=0 bits=0000 usb_device.wusb bi.nbytes=4 U
// 32. 04B4.15 1 effalign(1) fda=0 bits=0000 usb_device.lpm_capable bi.nbytes=4 U
// 33. 04B4.16 1 effalign(1) fda=0 bits=0000 usb_device.usb2_hw_lpm_capable bi.nbytes=4 U
// 34. 04B4.17 1 effalign(1) fda=0 bits=0000 usb_device.usb2_hw_lpm_besl_capable bi.nbytes=4 U
// 35. 04B4.18 1 effalign(1) fda=0 bits=0000 usb_device.usb2_hw_lpm_enabled bi.nbytes=4 U
// 36. 04B4.19 1 effalign(1) fda=0 bits=0000 usb_device.usb2_hw_lpm_allowed bi.nbytes=4 U
// 37. 04B4.20 1 effalign(1) fda=0 bits=0000 usb_device.usb3_lpm_u1_enabled bi.nbytes=4 U
// 38. 04B4.21 1 effalign(1) fda=0 bits=0000 usb_device.usb3_lpm_u2_enabled bi.nbytes=4 U
// 39. 04B8 0004 effalign(4) fda=0 bits=0000 usb_device.string_langid int;
// 40. 04C0 0008 effalign(8) fda=0 bits=0000 usb_device.product char *;
// 41. 04C8 0008 effalign(8) fda=0 bits=0000 usb_device.manufacturer char *;
// 42. 04D0 0008 effalign(8) fda=0 bits=0000 usb_device.serial char *;
// 43. 04D8 0010 effalign(8) fda=0 bits=0000 usb_device.filelist list_head;
// 44. 04E8 0004 effalign(4) fda=0 bits=0000 usb_device.maxchild int;
// 45. 04EC 0004 effalign(4) fda=0 bits=0000 usb_device.quirks u32;
// 46. 04F0 0004 effalign(4) fda=0 bits=0000 usb_device.urbnum atomic_t;
// 47. 04F8 0008 effalign(8) fda=0 bits=0000 usb_device.active_duration unsigned __int64;
// 48. 0500 0008 effalign(8) fda=0 bits=0000 usb_device.connect_time unsigned __int64;
// 49. 0508. 0 1 effalign(1) fda=0 bits=0000 usb_device.do_remote_wakeup bi.nbytes=4 U
// 50. 0508. 1 1 effalign(1) fda=0 bits=0000 usb_device.reset_resume bi.nbytes=4 U
// 51. 0508. 2 1 effalign(1) fda=0 bits=0000 usb_device.port_is_suspended bi.nbytes=4 U
// 52. 0510 0008 effalign(8) fda=0 bits=0000 usb_device.wusb_dev wusb_dev *;
// 53. 0518 0004 effalign(4) fda=0 bits=0000 usb_device.slot_id int;
// 54. 051C 0004 effalign(4) fda=0 bits=0000 usb_device.removable usb_device_removable;
// 55. 0520 0008 effalign(4) fda=0 bits=0000 usb_device.l1_params usb2_lpm_parameters;
// 56. 0528 0010 effalign(4) fda=0 bits=0000 usb_device.u1_params usb3_lpm_parameters;
// 57. 0538 0010 effalign(4) fda=0 bits=0000 usb_device.u2_params usb3_lpm_parameters;
// 58. 0548 0004 effalign(4) fda=0 bits=0000 usb_device.lpm_disable_count unsigned int;
// 59. 054C 0002 effalign(2) fda=0 bits=0000 usb_device.hub_delay u16;
//          054E unpadded_size
//          0550 effalign(8) sda=0 bits=0000 usb_device struct packalign=0

00000012 struct __attribute__((packed)) usb_device_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 bcdUSB;
  __u8 bDeviceClass;
  __u8 bDeviceSubClass;
  __u8 bDeviceProtocol;
  __u8 bMaxPacketSize0;
  __le16 idVendor;
  __le16 idProduct;
  __le16 bcdDevice;
  __u8 iManufacturer;
  __u8 iProduct;
  __u8 iSerialNumber;
  __u8 bNumConfigurations;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_device_descriptor.bcdUSB __le16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bDeviceClass __u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bDeviceSubClass __u8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bDeviceProtocol __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bMaxPacketSize0 __u8;
//  7. 0008 0002 effalign(1) fda=0 bits=0000 usb_device_descriptor.idVendor __le16;
//  8. 000A 0002 effalign(1) fda=0 bits=0000 usb_device_descriptor.idProduct __le16;
//  9. 000C 0002 effalign(1) fda=0 bits=0000 usb_device_descriptor.bcdDevice __le16;
// 10. 000E 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.iManufacturer __u8;
// 11. 000F 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.iProduct __u8;
// 12. 0010 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.iSerialNumber __u8;
// 13. 0011 0001 effalign(1) fda=0 bits=0000 usb_device_descriptor.bNumConfigurations __u8;
//          0012 effalign(1) sda=0 bits=0040 usb_device_descriptor struct packalign=0

000000C8 struct usb_device_driver
{
  const char *name;
  int (__cdecl *probe)(usb_device *);
  void (__cdecl *disconnect)(usb_device *);
  int (__cdecl *suspend)(usb_device *, pm_message_t);
  int (__cdecl *resume)(usb_device *, pm_message_t);
  const attribute_group **dev_groups;
  usbdrv_wrap drvwrap;
  unsigned __int32 supports_autosuspend : 1;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_device_driver.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_device_driver.probe int (__cdecl *)(usb_device *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 usb_device_driver.disconnect void (__cdecl *)(usb_device *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_device_driver.suspend int (__cdecl *)(usb_device *, pm_message_t);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 usb_device_driver.resume int (__cdecl *)(usb_device *, pm_message_t);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 usb_device_driver.dev_groups const attribute_group **;
//  6. 0030 0090 effalign(8) fda=0 bits=0000 usb_device_driver.drvwrap usbdrv_wrap;
//  7. 00C0. 0 1 effalign(1) fda=0 bits=0000 usb_device_driver.supports_autosuspend bi.nbytes=4 U
//          00C1 unpadded_size
//          00C8 effalign(8) sda=0 bits=0000 usb_device_driver struct packalign=0

00000020 struct usb_device_id
{
  __u16 match_flags;
  __u16 idVendor;
  __u16 idProduct;
  __u16 bcdDevice_lo;
  __u16 bcdDevice_hi;
  __u8 bDeviceClass;
  __u8 bDeviceSubClass;
  __u8 bDeviceProtocol;
  __u8 bInterfaceClass;
  __u8 bInterfaceSubClass;
  __u8 bInterfaceProtocol;
  __u8 bInterfaceNumber;
  __attribute__((aligned(8))) kernel_ulong_t driver_info;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 usb_device_id.match_flags __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 usb_device_id.idVendor __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 usb_device_id.idProduct __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 usb_device_id.bcdDevice_lo __u16;
//  4. 0008 0002 effalign(2) fda=0 bits=0000 usb_device_id.bcdDevice_hi __u16;
//  5. 000A 0001 effalign(1) fda=0 bits=0000 usb_device_id.bDeviceClass __u8;
//  6. 000B 0001 effalign(1) fda=0 bits=0000 usb_device_id.bDeviceSubClass __u8;
//  7. 000C 0001 effalign(1) fda=0 bits=0000 usb_device_id.bDeviceProtocol __u8;
//  8. 000D 0001 effalign(1) fda=0 bits=0000 usb_device_id.bInterfaceClass __u8;
//  9. 000E 0001 effalign(1) fda=0 bits=0000 usb_device_id.bInterfaceSubClass __u8;
// 10. 000F 0001 effalign(1) fda=0 bits=0000 usb_device_id.bInterfaceProtocol __u8;
// 11. 0010 0001 effalign(1) fda=0 bits=0000 usb_device_id.bInterfaceNumber __u8;
// 12. 0018 0008 effalign(8) fda=4 bits=0000 usb_device_id.driver_info kernel_ulong_t;
//          0020 effalign(8) sda=0 bits=0000 usb_device_id struct packalign=0

00000004 enum usb_device_removable : unsigned __int32
{
  USB_DEVICE_REMOVABLE_UNKNOWN = 0x0,
  USB_DEVICE_REMOVABLE = 0x1,
  USB_DEVICE_FIXED = 0x2,
};
00000004 enum usb_device_speed : unsigned __int32
{
  USB_SPEED_UNKNOWN = 0x0,
  USB_SPEED_LOW = 0x1,
  USB_SPEED_FULL = 0x2,
  USB_SPEED_HIGH = 0x3,
  USB_SPEED_WIRELESS = 0x4,
  USB_SPEED_SUPER = 0x5,
  USB_SPEED_SUPER_PLUS = 0x6,
};
00000004 enum usb_device_state : unsigned __int32
{
  USB_STATE_NOTATTACHED = 0x0,
  USB_STATE_ATTACHED = 0x1,
  USB_STATE_POWERED = 0x2,
  USB_STATE_RECONNECTING = 0x3,
  USB_STATE_UNAUTHENTICATED = 0x4,
  USB_STATE_DEFAULT = 0x5,
  USB_STATE_ADDRESS = 0x6,
  USB_STATE_CONFIGURED = 0x7,
  USB_STATE_SUSPENDED = 0x8,
};
00000010 struct usb_devmap
{
  unsigned __int64 devicemap[2];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 usb_devmap.devicemap unsigned __int64[2];
//          0010 effalign(8) sda=0 bits=0000 usb_devmap struct packalign=0

00000108 struct usb_driver
{
  const char *name;
  int (__cdecl *probe)(usb_interface *, const usb_device_id *);
  void (__cdecl *disconnect)(usb_interface *);
  int (__cdecl *unlocked_ioctl)(usb_interface *, unsigned int, void *);
  int (__cdecl *suspend)(usb_interface *, pm_message_t);
  int (__cdecl *resume)(usb_interface *);
  int (__cdecl *reset_resume)(usb_interface *);
  int (__cdecl *pre_reset)(usb_interface *);
  int (__cdecl *post_reset)(usb_interface *);
  const usb_device_id *id_table;
  const attribute_group **dev_groups;
  usb_dynids dynids;
  usbdrv_wrap drvwrap;
  unsigned __int32 no_dynamic_id : 1;
  unsigned __int32 supports_autosuspend : 1;
  unsigned __int32 disable_hub_initiated_lpm : 1;
  unsigned __int32 soft_unbind : 1;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_driver.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_driver.probe int (__cdecl *)(usb_interface *, const usb_device_id *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 usb_driver.disconnect void (__cdecl *)(usb_interface *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_driver.unlocked_ioctl int (__cdecl *)(usb_interface *, unsigned int, void *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 usb_driver.suspend int (__cdecl *)(usb_interface *, pm_message_t);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 usb_driver.resume int (__cdecl *)(usb_interface *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 usb_driver.reset_resume int (__cdecl *)(usb_interface *);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 usb_driver.pre_reset int (__cdecl *)(usb_interface *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 usb_driver.post_reset int (__cdecl *)(usb_interface *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 usb_driver.id_table const usb_device_id *;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 usb_driver.dev_groups const attribute_group **;
// 11. 0058 0018 effalign(8) fda=0 bits=0000 usb_driver.dynids usb_dynids;
// 12. 0070 0090 effalign(8) fda=0 bits=0000 usb_driver.drvwrap usbdrv_wrap;
// 13. 0100. 0 1 effalign(1) fda=0 bits=0000 usb_driver.no_dynamic_id bi.nbytes=4 U
// 14. 0100. 1 1 effalign(1) fda=0 bits=0000 usb_driver.supports_autosuspend bi.nbytes=4 U
// 15. 0100. 2 1 effalign(1) fda=0 bits=0000 usb_driver.disable_hub_initiated_lpm bi.nbytes=4 U
// 16. 0100. 3 1 effalign(1) fda=0 bits=0000 usb_driver.soft_unbind bi.nbytes=4 U
//          0101 unpadded_size
//          0108 effalign(8) sda=0 bits=0000 usb_driver struct packalign=0

00000030 struct usb_dynid
{
  list_head node;
  usb_device_id id;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 usb_dynid.node list_head;
//  1. 0010 0020 effalign(8) fda=0 bits=0000 usb_dynid.id usb_device_id;
//          0030 effalign(8) sda=0 bits=0000 usb_dynid struct packalign=0

00000018 struct usb_dynids
{
  spinlock_t lock;
  list_head list;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb_dynids.lock spinlock_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 usb_dynids.list list_head;
//          0018 effalign(8) sda=0 bits=0000 usb_dynids struct packalign=0

00000005 struct __attribute__((packed)) usb_encryption_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bEncryptionType;
  __u8 bEncryptionValue;
  __u8 bAuthKeyIndex;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_encryption_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_encryption_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_encryption_descriptor.bEncryptionType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_encryption_descriptor.bEncryptionValue __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_encryption_descriptor.bAuthKeyIndex __u8;
//          0005 effalign(1) sda=0 bits=0040 usb_encryption_descriptor struct packalign=0

00000009 struct __attribute__((packed)) usb_endpoint_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bEndpointAddress;
  __u8 bmAttributes;
  __le16 wMaxPacketSize;
  __u8 bInterval;
  __u8 bRefresh;
  __u8 bSynchAddress;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bEndpointAddress __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bmAttributes __u8;
//  4. 0004 0002 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.wMaxPacketSize __le16;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bInterval __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bRefresh __u8;
//  7. 0008 0001 effalign(1) fda=0 bits=0000 usb_endpoint_descriptor.bSynchAddress __u8;
//          0009 effalign(1) sda=0 bits=0040 usb_endpoint_descriptor struct packalign=0

00000007 struct __attribute__((packed)) usb_ext_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __le32 bmAttributes;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ext_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ext_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ext_cap_descriptor.bDevCapabilityType __u8;
//  3. 0003 0004 effalign(1) fda=0 bits=0000 usb_ext_cap_descriptor.bmAttributes __le32;
//          0007 effalign(1) sda=0 bits=0040 usb_ext_cap_descriptor struct packalign=0

0000002E struct __attribute__((packed)) usb_handshake
{
  __u8 bMessageNumber;
  __u8 bStatus;
  __u8 tTKID[3];
  __u8 bReserved;
  __u8 CDID[16];
  __u8 nonce[16];
  __u8 MIC[8];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_handshake.bMessageNumber __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_handshake.bStatus __u8;
//  2. 0002 0003 effalign(1) fda=0 bits=0000 usb_handshake.tTKID __u8[3];
//  3. 0005 0001 effalign(1) fda=0 bits=0000 usb_handshake.bReserved __u8;
//  4. 0006 0010 effalign(1) fda=0 bits=0000 usb_handshake.CDID __u8[16];
//  5. 0016 0010 effalign(1) fda=0 bits=0000 usb_handshake.nonce __u8[16];
//  6. 0026 0008 effalign(1) fda=0 bits=0000 usb_handshake.MIC __u8[8];
//          002E effalign(1) sda=0 bits=0040 usb_handshake struct packalign=0

00000030 struct usb_host_bos
{
  usb_bos_descriptor *desc;
  usb_ext_cap_descriptor *ext_cap;
  usb_ss_cap_descriptor *ss_cap;
  usb_ssp_cap_descriptor *ssp_cap;
  usb_ss_container_id_descriptor *ss_id;
  usb_ptm_cap_descriptor *ptm_cap;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_host_bos.desc usb_bos_descriptor *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_host_bos.ext_cap usb_ext_cap_descriptor *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 usb_host_bos.ss_cap usb_ss_cap_descriptor *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_host_bos.ssp_cap usb_ssp_cap_descriptor *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 usb_host_bos.ss_id usb_ss_container_id_descriptor *;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 usb_host_bos.ptm_cap usb_ptm_cap_descriptor *;
//          0030 effalign(8) sda=0 bits=0000 usb_host_bos struct packalign=0

000002A8 struct usb_host_config
{
  usb_config_descriptor desc;
  char *string;
  usb_interface_assoc_descriptor *intf_assoc[16];
  usb_interface *interface[32];
  usb_interface_cache *intf_cache[32];
  unsigned __int8 *extra;
  int extralen;
};
//  0. 0000 0009 effalign(1) fda=0 bits=0000 usb_host_config.desc usb_config_descriptor;
//  1. 0010 0008 effalign(8) fda=0 bits=0000 usb_host_config.string char *;
//  2. 0018 0080 effalign(8) fda=0 bits=0000 usb_host_config.intf_assoc usb_interface_assoc_descriptor *[16];
//  3. 0098 0100 effalign(8) fda=0 bits=0000 usb_host_config.interface usb_interface *[32];
//  4. 0198 0100 effalign(8) fda=0 bits=0000 usb_host_config.intf_cache usb_interface_cache *[32];
//  5. 0298 0008 effalign(8) fda=0 bits=0000 usb_host_config.extra unsigned __int8 *;
//  6. 02A0 0004 effalign(4) fda=0 bits=0000 usb_host_config.extralen int;
//          02A4 unpadded_size
//          02A8 effalign(8) sda=0 bits=0000 usb_host_config struct packalign=0

00000050 struct usb_host_endpoint
{
  usb_endpoint_descriptor desc;
  usb_ss_ep_comp_descriptor ss_ep_comp;
  usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
  list_head urb_list;
  void *hcpriv;
  ep_device *ep_dev;
  unsigned __int8 *extra;
  int extralen;
  int enabled;
  int streams;
};
//  0. 0000 0009 effalign(1) fda=0 bits=0000 usb_host_endpoint.desc usb_endpoint_descriptor;
//  1. 0009 0006 effalign(1) fda=0 bits=0000 usb_host_endpoint.ss_ep_comp usb_ss_ep_comp_descriptor;
//  2. 000F 0008 effalign(1) fda=0 bits=0000 usb_host_endpoint.ssp_isoc_ep_comp usb_ssp_isoc_ep_comp_descriptor;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 usb_host_endpoint.urb_list list_head;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 usb_host_endpoint.hcpriv void *;
//  5. 0030 0008 effalign(8) fda=0 bits=0000 usb_host_endpoint.ep_dev ep_device *;
//  6. 0038 0008 effalign(8) fda=0 bits=0000 usb_host_endpoint.extra unsigned __int8 *;
//  7. 0040 0004 effalign(4) fda=0 bits=0000 usb_host_endpoint.extralen int;
//  8. 0044 0004 effalign(4) fda=0 bits=0000 usb_host_endpoint.enabled int;
//  9. 0048 0004 effalign(4) fda=0 bits=0000 usb_host_endpoint.streams int;
//          004C unpadded_size
//          0050 effalign(8) sda=0 bits=0000 usb_host_endpoint struct packalign=0

00000028 struct usb_host_interface
{
  usb_interface_descriptor desc;
  int extralen;
  unsigned __int8 *extra;
  usb_host_endpoint *endpoint;
  char *string;
};
//  0. 0000 0009 effalign(1) fda=0 bits=0000 usb_host_interface.desc usb_interface_descriptor;
//  1. 000C 0004 effalign(4) fda=0 bits=0000 usb_host_interface.extralen int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 usb_host_interface.extra unsigned __int8 *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_host_interface.endpoint usb_host_endpoint *;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 usb_host_interface.string char *;
//          0028 effalign(8) sda=0 bits=0000 usb_host_interface struct packalign=0

00000330 struct usb_interface
{
  usb_host_interface *altsetting;
  usb_host_interface *cur_altsetting;
  unsigned int num_altsetting;
  usb_interface_assoc_descriptor *intf_assoc;
  int minor;
  usb_interface_condition condition;
  unsigned __int32 sysfs_files_created : 1;
  unsigned __int32 ep_devs_created : 1;
  unsigned __int32 unregistering : 1;
  unsigned __int32 needs_remote_wakeup : 1;
  unsigned __int32 needs_altsetting0 : 1;
  unsigned __int32 needs_binding : 1;
  unsigned __int32 resetting_device : 1;
  unsigned __int32 authorized : 1;
  device dev;
  device *usb_dev;
  work_struct reset_ws;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 usb_interface.altsetting usb_host_interface *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_interface.cur_altsetting usb_host_interface *;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 usb_interface.num_altsetting unsigned int;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_interface.intf_assoc usb_interface_assoc_descriptor *;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 usb_interface.minor int;
//  5. 0024 0004 effalign(4) fda=0 bits=0000 usb_interface.condition usb_interface_condition;
//  6. 0028. 0 1 effalign(1) fda=0 bits=0000 usb_interface.sysfs_files_created bi.nbytes=4 U
//  7. 0028. 1 1 effalign(1) fda=0 bits=0000 usb_interface.ep_devs_created bi.nbytes=4 U
//  8. 0028. 2 1 effalign(1) fda=0 bits=0000 usb_interface.unregistering bi.nbytes=4 U
//  9. 0028. 3 1 effalign(1) fda=0 bits=0000 usb_interface.needs_remote_wakeup bi.nbytes=4 U
// 10. 0028. 4 1 effalign(1) fda=0 bits=0000 usb_interface.needs_altsetting0 bi.nbytes=4 U
// 11. 0028. 5 1 effalign(1) fda=0 bits=0000 usb_interface.needs_binding bi.nbytes=4 U
// 12. 0028. 6 1 effalign(1) fda=0 bits=0000 usb_interface.resetting_device bi.nbytes=4 U
// 13. 0028. 7 1 effalign(1) fda=0 bits=0000 usb_interface.authorized bi.nbytes=4 U
// 14. 0030 02D8 effalign(8) fda=0 bits=0000 usb_interface.dev device;
// 15. 0308 0008 effalign(8) fda=0 bits=0000 usb_interface.usb_dev device *;
// 16. 0310 0020 effalign(8) fda=0 bits=0000 usb_interface.reset_ws work_struct;
//          0330 effalign(8) sda=0 bits=0000 usb_interface struct packalign=0

00000008 struct __attribute__((packed)) usb_interface_assoc_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bFirstInterface;
  __u8 bInterfaceCount;
  __u8 bFunctionClass;
  __u8 bFunctionSubClass;
  __u8 bFunctionProtocol;
  __u8 iFunction;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bFirstInterface __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bInterfaceCount __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bFunctionClass __u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bFunctionSubClass __u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.bFunctionProtocol __u8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 usb_interface_assoc_descriptor.iFunction __u8;
//          0008 effalign(1) sda=0 bits=0040 usb_interface_assoc_descriptor struct packalign=0

00000008 struct usb_interface_cache
{
  unsigned int num_altsetting;
  kref ref;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb_interface_cache.num_altsetting unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 usb_interface_cache.ref kref;
//          0008 effalign(4) sda=0 bits=0000 usb_interface_cache struct packalign=0

00000004 enum usb_interface_condition : unsigned __int32
{
  USB_INTERFACE_UNBOUND = 0x0,
  USB_INTERFACE_BINDING = 0x1,
  USB_INTERFACE_BOUND = 0x2,
  USB_INTERFACE_UNBINDING = 0x3,
};
00000009 struct __attribute__((packed)) usb_interface_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bInterfaceNumber;
  __u8 bAlternateSetting;
  __u8 bNumEndpoints;
  __u8 bInterfaceClass;
  __u8 bInterfaceSubClass;
  __u8 bInterfaceProtocol;
  __u8 iInterface;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bInterfaceNumber __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bAlternateSetting __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bNumEndpoints __u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bInterfaceClass __u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bInterfaceSubClass __u8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.bInterfaceProtocol __u8;
//  8. 0008 0001 effalign(1) fda=0 bits=0000 usb_interface_descriptor.iInterface __u8;
//          0009 effalign(1) sda=0 bits=0040 usb_interface_descriptor struct packalign=0

00000010 struct usb_iso_packet_descriptor
{
  unsigned int offset;
  unsigned int length;
  unsigned int actual_length;
  int status;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb_iso_packet_descriptor.offset unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 usb_iso_packet_descriptor.length unsigned int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 usb_iso_packet_descriptor.actual_length unsigned int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 usb_iso_packet_descriptor.status int;
//          0010 effalign(4) sda=0 bits=0000 usb_iso_packet_descriptor struct packalign=0

00000006 struct __attribute__((packed)) usb_key_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 tTKID[3];
  __u8 bReserved;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_key_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_key_descriptor.bDescriptorType __u8;
//  2. 0002 0003 effalign(1) fda=0 bits=0000 usb_key_descriptor.tTKID __u8[3];
//  3. 0005 0001 effalign(1) fda=0 bits=0000 usb_key_descriptor.bReserved __u8;
//          0006 effalign(1) sda=0 bits=0040 usb_key_descriptor struct packalign=0

00000004 enum usb_led_event : unsigned __int32
{
  USB_LED_EVENT_HOST = 0x0,
  USB_LED_EVENT_GADGET = 0x1,
};
00000005 struct __attribute__((packed)) usb_otg20_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bmAttributes;
  __le16 bcdOTG;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_otg20_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_otg20_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_otg20_descriptor.bmAttributes __u8;
//  3. 0003 0002 effalign(1) fda=0 bits=0000 usb_otg20_descriptor.bcdOTG __le16;
//          0005 effalign(1) sda=0 bits=0040 usb_otg20_descriptor struct packalign=0

00000003 struct __attribute__((packed)) usb_otg_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bmAttributes;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_otg_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_otg_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_otg_descriptor.bmAttributes __u8;
//          0003 effalign(1) sda=0 bits=0040 usb_otg_descriptor struct packalign=0

00000018 struct __attribute__((packed)) usb_pd_cap_battery_info_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 iBattery;
  __u8 iSerial;
  __u8 iManufacturer;
  __u8 bBatteryId;
  __u8 bReserved;
  __le32 dwChargedThreshold;
  __le32 dwWeakThreshold;
  __le32 dwBatteryDesignCapacity;
  __le32 dwBatteryLastFullchargeCapacity;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.iBattery __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.iSerial __u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.iManufacturer __u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.bBatteryId __u8;
//  7. 0007 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.bReserved __u8;
//  8. 0008 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.dwChargedThreshold __le32;
//  9. 000C 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.dwWeakThreshold __le32;
// 10. 0010 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.dwBatteryDesignCapacity __le32;
// 11. 0014 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_battery_info_descriptor.dwBatteryLastFullchargeCapacity __le32;
//          0018 effalign(1) sda=0 bits=0040 usb_pd_cap_battery_info_descriptor struct packalign=0

00000017 struct __attribute__((packed)) usb_pd_cap_consumer_port_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bReserved;
  __u8 bmCapabilities;
  __le16 wMinVoltage;
  __le16 wMaxVoltage;
  __u16 wReserved;
  __le32 dwMaxOperatingPower;
  __le32 dwMaxPeakPower;
  __le32 dwMaxPeakPowerTime;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.bReserved __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.bmCapabilities __u8;
//  5. 0005 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.wMinVoltage __le16;
//  6. 0007 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.wMaxVoltage __le16;
//  7. 0009 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.wReserved __u16;
//  8. 000B 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.dwMaxOperatingPower __le32;
//  9. 000F 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.dwMaxPeakPower __le32;
// 10. 0013 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_consumer_port_descriptor.dwMaxPeakPowerTime __le32;
//          0017 effalign(1) sda=0 bits=0040 usb_pd_cap_consumer_port_descriptor struct packalign=0

00000012 struct __attribute__((packed)) usb_pd_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bReserved;
  __le32 bmAttributes;
  __le16 bmProviderPorts;
  __le16 bmConsumerPorts;
  __le16 bcdBCVersion;
  __le16 bcdPDVersion;
  __le16 bcdUSBTypeCVersion;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bReserved __u8;
//  4. 0004 0004 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bmAttributes __le32;
//  5. 0008 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bmProviderPorts __le16;
//  6. 000A 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bmConsumerPorts __le16;
//  7. 000C 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bcdBCVersion __le16;
//  8. 000E 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bcdPDVersion __le16;
//  9. 0010 0002 effalign(1) fda=0 bits=0000 usb_pd_cap_descriptor.bcdUSBTypeCVersion __le16;
//          0012 effalign(1) sda=0 bits=0040 usb_pd_cap_descriptor struct packalign=0

00000007 struct __attribute__((packed)) usb_pd_cap_provider_port_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bReserved1;
  __u8 bmCapabilities;
  __u8 bNumOfPDObjects;
  __u8 bReserved2;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bReserved1 __u8;
//  4. 0004 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bmCapabilities __u8;
//  5. 0005 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bNumOfPDObjects __u8;
//  6. 0006 0001 effalign(1) fda=0 bits=0000 usb_pd_cap_provider_port_descriptor.bReserved2 __u8;
//          0007 effalign(1) sda=0 bits=0040 usb_pd_cap_provider_port_descriptor struct packalign=0

00000004 enum usb_port_connect_type : unsigned __int32
{
  USB_PORT_CONNECT_TYPE_UNKNOWN = 0x0,
  USB_PORT_CONNECT_TYPE_HOT_PLUG = 0x1,
  USB_PORT_CONNECT_TYPE_HARD_WIRED = 0x2,
  USB_PORT_NOT_USED = 0x3,
};
00000003 struct __attribute__((packed)) usb_ptm_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ptm_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ptm_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ptm_cap_descriptor.bDevCapabilityType __u8;
//          0003 effalign(1) sda=0 bits=0040 usb_ptm_cap_descriptor struct packalign=0

0000000A struct __attribute__((packed)) usb_qualifier_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 bcdUSB;
  __u8 bDeviceClass;
  __u8 bDeviceSubClass;
  __u8 bDeviceProtocol;
  __u8 bMaxPacketSize0;
  __u8 bNumConfigurations;
  __u8 bRESERVED;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bcdUSB __le16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bDeviceClass __u8;
//  4. 0005 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bDeviceSubClass __u8;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bDeviceProtocol __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bMaxPacketSize0 __u8;
//  7. 0008 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bNumConfigurations __u8;
//  8. 0009 0001 effalign(1) fda=0 bits=0000 usb_qualifier_descriptor.bRESERVED __u8;
//          000A effalign(1) sda=0 bits=0040 usb_qualifier_descriptor struct packalign=0

00000005 struct __attribute__((packed)) usb_security_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 wTotalLength;
  __u8 bNumEncryptionTypes;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_security_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_security_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_security_descriptor.wTotalLength __le16;
//  3. 0004 0001 effalign(1) fda=0 bits=0000 usb_security_descriptor.bNumEncryptionTypes __u8;
//          0005 effalign(1) sda=0 bits=0040 usb_security_descriptor struct packalign=0

00000006 struct __attribute__((packed)) usb_set_sel_req
{
  __u8 u1_sel;
  __u8 u1_pel;
  __le16 u2_sel;
  __le16 u2_pel;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_set_sel_req.u1_sel __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_set_sel_req.u1_pel __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_set_sel_req.u2_sel __le16;
//  3. 0004 0002 effalign(1) fda=0 bits=0000 usb_set_sel_req.u2_pel __le16;
//          0006 effalign(1) sda=0 bits=0040 usb_set_sel_req struct packalign=0

00000058 struct usb_sg_request
{
  int status;
  size_t bytes;
  spinlock_t lock;
  usb_device *dev;
  int pipe;
  int entries;
  urb **urbs;
  int count;
  completion complete;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 usb_sg_request.status int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 usb_sg_request.bytes size_t;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 usb_sg_request.lock spinlock_t;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 usb_sg_request.dev usb_device *;
//  4. 0020 0004 effalign(4) fda=0 bits=0000 usb_sg_request.pipe int;
//  5. 0024 0004 effalign(4) fda=0 bits=0000 usb_sg_request.entries int;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 usb_sg_request.urbs urb **;
//  7. 0030 0004 effalign(4) fda=0 bits=0000 usb_sg_request.count int;
//  8. 0038 0020 effalign(8) fda=0 bits=0000 usb_sg_request.complete completion;
//          0058 effalign(8) sda=0 bits=0000 usb_sg_request struct packalign=0

0000000A struct __attribute__((packed)) usb_ss_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bmAttributes;
  __le16 wSpeedSupported;
  __u8 bFunctionalitySupport;
  __u8 bU1devExitLat;
  __le16 bU2DevExitLat;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bmAttributes __u8;
//  4. 0004 0002 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.wSpeedSupported __le16;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bFunctionalitySupport __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bU1devExitLat __u8;
//  7. 0008 0002 effalign(1) fda=0 bits=0000 usb_ss_cap_descriptor.bU2DevExitLat __le16;
//          000A effalign(1) sda=0 bits=0040 usb_ss_cap_descriptor struct packalign=0

00000014 struct __attribute__((packed)) usb_ss_container_id_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bReserved;
  __u8 ContainerID[16];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ss_container_id_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ss_container_id_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ss_container_id_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_ss_container_id_descriptor.bReserved __u8;
//  4. 0004 0010 effalign(1) fda=0 bits=0000 usb_ss_container_id_descriptor.ContainerID __u8[16];
//          0014 effalign(1) sda=0 bits=0040 usb_ss_container_id_descriptor struct packalign=0

00000006 struct __attribute__((packed)) usb_ss_ep_comp_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bMaxBurst;
  __u8 bmAttributes;
  __le16 wBytesPerInterval;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ss_ep_comp_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ss_ep_comp_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ss_ep_comp_descriptor.bMaxBurst __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_ss_ep_comp_descriptor.bmAttributes __u8;
//  4. 0004 0002 effalign(1) fda=0 bits=0000 usb_ss_ep_comp_descriptor.wBytesPerInterval __le16;
//          0006 effalign(1) sda=0 bits=0040 usb_ss_ep_comp_descriptor struct packalign=0

00000010 struct __attribute__((packed)) usb_ssp_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bReserved;
  __le32 bmAttributes;
  __le16 wFunctionalitySupport;
  __le16 wReserved;
  __le32 bmSublinkSpeedAttr[1];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bReserved __u8;
//  4. 0004 0004 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bmAttributes __le32;
//  5. 0008 0002 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.wFunctionalitySupport __le16;
//  6. 000A 0002 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.wReserved __le16;
//  7. 000C 0004 effalign(1) fda=0 bits=0000 usb_ssp_cap_descriptor.bmSublinkSpeedAttr __le32[1];
//          0010 effalign(1) sda=0 bits=0040 usb_ssp_cap_descriptor struct packalign=0

00000008 struct __attribute__((packed)) usb_ssp_isoc_ep_comp_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 wReseved;
  __le32 dwBytesPerInterval;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_ssp_isoc_ep_comp_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_ssp_isoc_ep_comp_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_ssp_isoc_ep_comp_descriptor.wReseved __le16;
//  3. 0004 0004 effalign(1) fda=0 bits=0000 usb_ssp_isoc_ep_comp_descriptor.dwBytesPerInterval __le32;
//          0008 effalign(1) sda=0 bits=0040 usb_ssp_isoc_ep_comp_descriptor struct packalign=0

00000004 struct __attribute__((packed)) usb_string_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __le16 wData[1];
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_string_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_string_descriptor.bDescriptorType __u8;
//  2. 0002 0002 effalign(1) fda=0 bits=0000 usb_string_descriptor.wData __le16[1];
//          0004 effalign(1) sda=0 bits=0040 usb_string_descriptor struct packalign=0

FFFFFFFF struct usb_tt;
0000000B struct __attribute__((packed)) usb_wireless_cap_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bDevCapabilityType;
  __u8 bmAttributes;
  __le16 wPHYRates;
  __u8 bmTFITXPowerInfo;
  __u8 bmFFITXPowerInfo;
  __le16 bmBandGroup;
  __u8 bReserved;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bDevCapabilityType __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bmAttributes __u8;
//  4. 0004 0002 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.wPHYRates __le16;
//  5. 0006 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bmTFITXPowerInfo __u8;
//  6. 0007 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bmFFITXPowerInfo __u8;
//  7. 0008 0002 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bmBandGroup __le16;
//  8. 000A 0001 effalign(1) fda=0 bits=0000 usb_wireless_cap_descriptor.bReserved __u8;
//          000B effalign(1) sda=0 bits=0040 usb_wireless_cap_descriptor struct packalign=0

0000000A struct __attribute__((packed)) usb_wireless_ep_comp_descriptor
{
  __u8 bLength;
  __u8 bDescriptorType;
  __u8 bMaxBurst;
  __u8 bMaxSequence;
  __le16 wMaxStreamDelay;
  __le16 wOverTheAirPacketSize;
  __u8 bOverTheAirInterval;
  __u8 bmCompAttributes;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bLength __u8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bDescriptorType __u8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bMaxBurst __u8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bMaxSequence __u8;
//  4. 0004 0002 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.wMaxStreamDelay __le16;
//  5. 0006 0002 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.wOverTheAirPacketSize __le16;
//  6. 0008 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bOverTheAirInterval __u8;
//  7. 0009 0001 effalign(1) fda=0 bits=0000 usb_wireless_ep_comp_descriptor.bmCompAttributes __u8;
//          000A effalign(1) sda=0 bits=0040 usb_wireless_ep_comp_descriptor struct packalign=0

00000090 struct usbdrv_wrap
{
  device_driver driver;
  int for_devices;
};
//  0. 0000 0088 effalign(8) fda=0 bits=0000 usbdrv_wrap.driver device_driver;
//  1. 0088 0004 effalign(4) fda=0 bits=0000 usbdrv_wrap.for_devices int;
//          008C unpadded_size
//          0090 effalign(8) sda=0 bits=0000 usbdrv_wrap struct packalign=0

000003A0 struct user
{
  user_regs_struct regs;
  int u_fpvalid;
  int pad0;
  user_i387_struct i387;
  unsigned __int64 u_tsize;
  unsigned __int64 u_dsize;
  unsigned __int64 u_ssize;
  unsigned __int64 start_code;
  unsigned __int64 start_stack;
  __int64 signal;
  int reserved;
  int pad1;
  unsigned __int64 u_ar0;
  user_i387_struct *u_fpstate;
  unsigned __int64 magic;
  char u_comm[32];
  unsigned __int64 u_debugreg[8];
  unsigned __int64 error_code;
  unsigned __int64 fault_address;
};
//  0. 0000 00D8 effalign(8) fda=0 bits=0000 user.regs user_regs_struct;
//  1. 00D8 0004 effalign(4) fda=0 bits=0000 user.u_fpvalid int;
//  2. 00DC 0004 effalign(4) fda=0 bits=0000 user.pad0 int;
//  3. 00E0 0200 effalign(8) fda=0 bits=0000 user.i387 user_i387_struct;
//  4. 02E0 0008 effalign(8) fda=0 bits=0000 user.u_tsize unsigned __int64;
//  5. 02E8 0008 effalign(8) fda=0 bits=0000 user.u_dsize unsigned __int64;
//  6. 02F0 0008 effalign(8) fda=0 bits=0000 user.u_ssize unsigned __int64;
//  7. 02F8 0008 effalign(8) fda=0 bits=0000 user.start_code unsigned __int64;
//  8. 0300 0008 effalign(8) fda=0 bits=0000 user.start_stack unsigned __int64;
//  9. 0308 0008 effalign(8) fda=0 bits=0000 user.signal __int64;
// 10. 0310 0004 effalign(4) fda=0 bits=0000 user.reserved int;
// 11. 0314 0004 effalign(4) fda=0 bits=0000 user.pad1 int;
// 12. 0318 0008 effalign(8) fda=0 bits=0000 user.u_ar0 unsigned __int64;
// 13. 0320 0008 effalign(8) fda=0 bits=0000 user.u_fpstate user_i387_struct *;
// 14. 0328 0008 effalign(8) fda=0 bits=0000 user.magic unsigned __int64;
// 15. 0330 0020 effalign(1) fda=0 bits=0000 user.u_comm char[32];
// 16. 0350 0040 effalign(8) fda=0 bits=0000 user.u_debugreg unsigned __int64[8];
// 17. 0390 0008 effalign(8) fda=0 bits=0000 user.error_code unsigned __int64;
// 18. 0398 0008 effalign(8) fda=0 bits=0000 user.fault_address unsigned __int64;
//          03A0 effalign(8) sda=0 bits=0000 user struct packalign=0

FFFFFFFF struct user_desc;
00000200 struct user_i387_struct
{
  unsigned __int16 cwd;
  unsigned __int16 swd;
  unsigned __int16 twd;
  unsigned __int16 fop;
  __u64 rip;
  __u64 rdp;
  __u32 mxcsr;
  __u32 mxcsr_mask;
  __u32 st_space[32];
  __u32 xmm_space[64];
  __u32 padding[24];
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 user_i387_struct.cwd unsigned __int16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 user_i387_struct.swd unsigned __int16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 user_i387_struct.twd unsigned __int16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 user_i387_struct.fop unsigned __int16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 user_i387_struct.rip __u64;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 user_i387_struct.rdp __u64;
//  6. 0018 0004 effalign(4) fda=0 bits=0000 user_i387_struct.mxcsr __u32;
//  7. 001C 0004 effalign(4) fda=0 bits=0000 user_i387_struct.mxcsr_mask __u32;
//  8. 0020 0080 effalign(4) fda=0 bits=0000 user_i387_struct.st_space __u32[32];
//  9. 00A0 0100 effalign(4) fda=0 bits=0000 user_i387_struct.xmm_space __u32[64];
// 10. 01A0 0060 effalign(4) fda=0 bits=0000 user_i387_struct.padding __u32[24];
//          0200 effalign(8) sda=0 bits=0000 user_i387_struct struct packalign=0

FFFFFFFF struct user_namespace;
000000D8 struct user_regs_struct
{
  unsigned __int64 r15;
  unsigned __int64 r14;
  unsigned __int64 r13;
  unsigned __int64 r12;
  unsigned __int64 bp;
  unsigned __int64 bx;
  unsigned __int64 r11;
  unsigned __int64 r10;
  unsigned __int64 r9;
  unsigned __int64 r8;
  unsigned __int64 ax;
  unsigned __int64 cx;
  unsigned __int64 dx;
  unsigned __int64 si;
  unsigned __int64 di;
  unsigned __int64 orig_ax;
  unsigned __int64 ip;
  unsigned __int64 cs;
  unsigned __int64 flags;
  unsigned __int64 sp;
  unsigned __int64 ss;
  unsigned __int64 fs_base;
  unsigned __int64 gs_base;
  unsigned __int64 ds;
  unsigned __int64 es;
  unsigned __int64 fs;
  unsigned __int64 gs;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r15 unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r14 unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r13 unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r12 unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 user_regs_struct.bp unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 user_regs_struct.bx unsigned __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r11 unsigned __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r10 unsigned __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r9 unsigned __int64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 user_regs_struct.r8 unsigned __int64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 user_regs_struct.ax unsigned __int64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 user_regs_struct.cx unsigned __int64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 user_regs_struct.dx unsigned __int64;
// 13. 0068 0008 effalign(8) fda=0 bits=0000 user_regs_struct.si unsigned __int64;
// 14. 0070 0008 effalign(8) fda=0 bits=0000 user_regs_struct.di unsigned __int64;
// 15. 0078 0008 effalign(8) fda=0 bits=0000 user_regs_struct.orig_ax unsigned __int64;
// 16. 0080 0008 effalign(8) fda=0 bits=0000 user_regs_struct.ip unsigned __int64;
// 17. 0088 0008 effalign(8) fda=0 bits=0000 user_regs_struct.cs unsigned __int64;
// 18. 0090 0008 effalign(8) fda=0 bits=0000 user_regs_struct.flags unsigned __int64;
// 19. 0098 0008 effalign(8) fda=0 bits=0000 user_regs_struct.sp unsigned __int64;
// 20. 00A0 0008 effalign(8) fda=0 bits=0000 user_regs_struct.ss unsigned __int64;
// 21. 00A8 0008 effalign(8) fda=0 bits=0000 user_regs_struct.fs_base unsigned __int64;
// 22. 00B0 0008 effalign(8) fda=0 bits=0000 user_regs_struct.gs_base unsigned __int64;
// 23. 00B8 0008 effalign(8) fda=0 bits=0000 user_regs_struct.ds unsigned __int64;
// 24. 00C0 0008 effalign(8) fda=0 bits=0000 user_regs_struct.es unsigned __int64;
// 25. 00C8 0008 effalign(8) fda=0 bits=0000 user_regs_struct.fs unsigned __int64;
// 26. 00D0 0008 effalign(8) fda=0 bits=0000 user_regs_struct.gs unsigned __int64;
//          00D8 effalign(8) sda=0 bits=0000 user_regs_struct struct packalign=0

00000080 struct user_struct
{
  refcount_t __count;
  atomic_t processes;
  atomic_t sigpending;
  atomic_t fanotify_listeners;
  atomic_long_t epoll_watches;
  unsigned __int64 mq_bytes;
  unsigned __int64 locked_shm;
  unsigned __int64 unix_inflight;
  atomic_long_t pipe_bufs;
  hlist_node uidhash_node;
  kuid_t uid;
  atomic_long_t locked_vm;
  ratelimit_state ratelimit;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 user_struct.__count refcount_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 user_struct.processes atomic_t;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 user_struct.sigpending atomic_t;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 user_struct.fanotify_listeners atomic_t;
//  4. 0010 0008 effalign(8) fda=0 bits=0000 user_struct.epoll_watches atomic_long_t;
//  5. 0018 0008 effalign(8) fda=0 bits=0000 user_struct.mq_bytes unsigned __int64;
//  6. 0020 0008 effalign(8) fda=0 bits=0000 user_struct.locked_shm unsigned __int64;
//  7. 0028 0008 effalign(8) fda=0 bits=0000 user_struct.unix_inflight unsigned __int64;
//  8. 0030 0008 effalign(8) fda=0 bits=0000 user_struct.pipe_bufs atomic_long_t;
//  9. 0038 0010 effalign(8) fda=0 bits=0000 user_struct.uidhash_node hlist_node;
// 10. 0048 0004 effalign(4) fda=0 bits=0000 user_struct.uid kuid_t;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 user_struct.locked_vm atomic_long_t;
// 12. 0058 0028 effalign(8) fda=0 bits=0000 user_struct.ratelimit ratelimit_state;
//          0080 effalign(8) sda=0 bits=0000 user_struct struct packalign=0

00000040 struct user_xstate_header
{
  __u64 xfeatures;
  __u64 reserved1[2];
  __u64 reserved2[5];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 user_xstate_header.xfeatures __u64;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 user_xstate_header.reserved1 __u64[2];
//  2. 0018 0028 effalign(8) fda=0 bits=0000 user_xstate_header.reserved2 __u64[5];
//          0040 effalign(8) sda=0 bits=0000 user_xstate_header struct packalign=0

00000340 struct user_xstateregs
{
  user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244 i387;
  user_xstate_header header;
  user_ymmh_regs ymmh;
};
//  0. 0000 0200 effalign(8) fda=0 bits=0000 user_xstateregs.i387 user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244;
//  1. 0200 0040 effalign(8) fda=0 bits=0000 user_xstateregs.header user_xstate_header;
//  2. 0240 0100 effalign(4) fda=0 bits=0000 user_xstateregs.ymmh user_ymmh_regs;
//          0340 effalign(8) sda=0 bits=0000 user_xstateregs struct packalign=0

00000200 struct user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244
{
  __u64 fpx_space[58];
  __u64 xstate_fx_sw[6];
};
//  0. 0000 01D0 effalign(8) fda=0 bits=0000 user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244.fpx_space __u64[58];
//  1. 01D0 0030 effalign(8) fda=0 bits=0000 user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244.xstate_fx_sw __u64[6];
//          0200 effalign(8) sda=0 bits=0000 user_xstateregs::$25D7EDC8E1459B9C4CCC106867F6F244 struct packalign=0

00000100 struct user_ymmh_regs
{
  __u32 ymmh_space[64];
};
//  0. 0000 0100 effalign(4) fda=0 bits=0000 user_ymmh_regs.ymmh_space __u32[64];
//          0100 effalign(4) sda=0 bits=0000 user_ymmh_regs struct packalign=0

FFFFFFFF struct userfaultfd_ctx;
00000002 typedef unsigned __int16 ushort;
00000020 struct ustat
{
  __kernel_daddr_t f_tfree;
  __kernel_ino_t f_tinode;
  char f_fname[6];
  char f_fpack[6];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 ustat.f_tfree __kernel_daddr_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 ustat.f_tinode __kernel_ino_t;
//  2. 0010 0006 effalign(1) fda=0 bits=0000 ustat.f_fname char[6];
//  3. 0016 0006 effalign(1) fda=0 bits=0000 ustat.f_fpack char[6];
//          001C unpadded_size
//          0020 effalign(8) sda=0 bits=0000 ustat struct packalign=0

00000008 struct __attribute__((aligned(8))) util_est
{
  unsigned int enqueued;
  unsigned int ewma;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 util_est.enqueued unsigned int;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 util_est.ewma unsigned int;
//          0008 effalign(8) sda=4 bits=0000 util_est struct packalign=0

00000010 typedef guid_t uuid_le;
00000010 struct uuid_t
{
  __u8 b[16];
};
//  0. 0000 0010 effalign(1) fda=0 bits=0000 uuid_t.b __u8[16];
//          0010 effalign(1) sda=0 bits=0000 uuid_t struct packalign=0

00000040 struct __attribute__((aligned(64))) va_alignment
{
  int flags;
  unsigned __int64 mask;
  unsigned __int64 bits;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 va_alignment.flags int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 va_alignment.mask unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 va_alignment.bits unsigned __int64;
//          0018 unpadded_size
//          0040 effalign(64) sda=7 bits=0000 va_alignment struct packalign=0

00000010 struct va_format
{
  const char *fmt;
  va_list *va;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 va_format.fmt const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 va_format.va va_list *;
//          0010 effalign(8) sda=0 bits=0000 va_format struct packalign=0

00000018 typedef __gnuc_va_list va_list;
00000068 struct vdso_image
{
  void *data;
  unsigned __int64 size;
  unsigned __int64 alt;
  unsigned __int64 alt_len;
  __int64 sym_vvar_start;
  __int64 sym_vvar_page;
  __int64 sym_pvclock_page;
  __int64 sym_hvclock_page;
  __int64 sym_VDSO32_NOTE_MASK;
  __int64 sym___kernel_sigreturn;
  __int64 sym___kernel_rt_sigreturn;
  __int64 sym___kernel_vsyscall;
  __int64 sym_int80_landing_pad;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vdso_image.data void *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vdso_image.size unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vdso_image.alt unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vdso_image.alt_len unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_vvar_start __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_vvar_page __int64;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_pvclock_page __int64;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_hvclock_page __int64;
//  8. 0040 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_VDSO32_NOTE_MASK __int64;
//  9. 0048 0008 effalign(8) fda=0 bits=0000 vdso_image.sym___kernel_sigreturn __int64;
// 10. 0050 0008 effalign(8) fda=0 bits=0000 vdso_image.sym___kernel_rt_sigreturn __int64;
// 11. 0058 0008 effalign(8) fda=0 bits=0000 vdso_image.sym___kernel_vsyscall __int64;
// 12. 0060 0008 effalign(8) fda=0 bits=0000 vdso_image.sym_int80_landing_pad __int64;
//          0068 effalign(8) sda=0 bits=0000 vdso_image struct packalign=0

00000014 struct vfs_cap_data
{
  __le32 magic_etc;
  vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421 data[2];
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 vfs_cap_data.magic_etc __le32;
//  1. 0004 0010 effalign(4) fda=0 bits=0000 vfs_cap_data.data vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421[2];
//          0014 effalign(4) sda=0 bits=0000 vfs_cap_data struct packalign=0

00000008 struct vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421
{
  __le32 permitted;
  __le32 inheritable;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421.permitted __le32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421.inheritable __le32;
//          0008 effalign(4) sda=0 bits=0000 vfs_cap_data::$1A090B8EA054F4F02D05FCE87D20A421 struct packalign=0

00000018 struct vfs_ns_cap_data
{
  __le32 magic_etc;
  vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421 data[2];
  __le32 rootid;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 vfs_ns_cap_data.magic_etc __le32;
//  1. 0004 0010 effalign(4) fda=0 bits=0000 vfs_ns_cap_data.data vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421[2];
//  2. 0014 0004 effalign(4) fda=0 bits=0000 vfs_ns_cap_data.rootid __le32;
//          0018 effalign(4) sda=0 bits=0000 vfs_ns_cap_data struct packalign=0

00000008 struct vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421
{
  __le32 permitted;
  __le32 inheritable;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421.permitted __le32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421.inheritable __le32;
//          0008 effalign(4) sda=0 bits=0000 vfs_ns_cap_data::$1A090B8EA054F4F02D05FCE87D20A421 struct packalign=0

00000008 typedef ssize_t (__cdecl *vfs_readf_t)(file *, char *, size_t, loff_t *);
00000008 typedef ssize_t (__cdecl *vfs_writef_t)(file *, const char *, size_t, loff_t *);
FFFFFFFF struct vfsmount;
00000040 struct vio_device_id
{
  char type[32];
  char compat[32];
};
//  0. 0000 0020 effalign(1) fda=0 bits=0000 vio_device_id.type char[32];
//  1. 0020 0020 effalign(1) fda=0 bits=0000 vio_device_id.compat char[32];
//          0040 effalign(1) sda=0 bits=0000 vio_device_id struct packalign=0

00000008 struct virtio_device_id
{
  __u32 device;
  __u32 vendor;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 virtio_device_id.device __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 virtio_device_id.vendor __u32;
//          0008 effalign(4) sda=0 bits=0000 virtio_device_id struct packalign=0

FFFFFFFF struct vm86;
000000D0 struct vm_area_struct
{
  unsigned __int64 vm_start;
  unsigned __int64 vm_end;
  vm_area_struct *vm_next;
  vm_area_struct *vm_prev;
  rb_node vm_rb;
  unsigned __int64 rb_subtree_gap;
  mm_struct *vm_mm;
  pgprot_t vm_page_prot;
  unsigned __int64 vm_flags;
  vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551 shared;
  list_head anon_vma_chain;
  anon_vma *anon_vma;
  const vm_operations_struct *vm_ops;
  unsigned __int64 vm_pgoff;
  file *vm_file;
  file *vm_prfile;
  void *vm_private_data;
  atomic_long_t swap_readahead_info;
  mempolicy *vm_policy;
  vm_userfaultfd_ctx vm_userfaultfd_ctx;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_start unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_end unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_next vm_area_struct *;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_prev vm_area_struct *;
//  4. 0020 0018 effalign(8) fda=0 bits=0000 vm_area_struct.vm_rb rb_node;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 vm_area_struct.rb_subtree_gap unsigned __int64;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_mm mm_struct *;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_page_prot pgprot_t;
//  8. 0050 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_flags unsigned __int64;
//  9. 0058 0020 effalign(8) fda=0 bits=0000 vm_area_struct.shared vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551;
// 10. 0078 0010 effalign(8) fda=0 bits=0000 vm_area_struct.anon_vma_chain list_head;
// 11. 0088 0008 effalign(8) fda=0 bits=0000 vm_area_struct.anon_vma anon_vma *;
// 12. 0090 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_ops const vm_operations_struct *;
// 13. 0098 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_pgoff unsigned __int64;
// 14. 00A0 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_file file *;
// 15. 00A8 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_prfile file *;
// 16. 00B0 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_private_data void *;
// 17. 00B8 0008 effalign(8) fda=0 bits=0000 vm_area_struct.swap_readahead_info atomic_long_t;
// 18. 00C0 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_policy mempolicy *;
// 19. 00C8 0008 effalign(8) fda=0 bits=0000 vm_area_struct.vm_userfaultfd_ctx vm_userfaultfd_ctx;
//          00D0 effalign(8) sda=0 bits=0000 vm_area_struct struct packalign=0

00000020 struct vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551
{
  rb_node rb;
  unsigned __int64 rb_subtree_last;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551.rb rb_node;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551.rb_subtree_last unsigned __int64;
//          0020 effalign(8) sda=0 bits=0000 vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551 struct packalign=0

00000004 enum vm_event_item : unsigned __int32
{
  PGPGIN = 0x0,
  PGPGOUT = 0x1,
  PSWPIN = 0x2,
  PSWPOUT = 0x3,
  PGALLOC_DMA = 0x4,
  PGALLOC_DMA32 = 0x5,
  PGALLOC_NORMAL = 0x6,
  PGALLOC_MOVABLE = 0x7,
  ALLOCSTALL_DMA = 0x8,
  ALLOCSTALL_DMA32 = 0x9,
  ALLOCSTALL_NORMAL = 0xA,
  ALLOCSTALL_MOVABLE = 0xB,
  PGSCAN_SKIP_DMA = 0xC,
  PGSCAN_SKIP_DMA32 = 0xD,
  PGSCAN_SKIP_NORMAL = 0xE,
  PGSCAN_SKIP_MOVABLE = 0xF,
  PGFREE = 0x10,
  PGACTIVATE = 0x11,
  PGDEACTIVATE = 0x12,
  PGLAZYFREE = 0x13,
  PGFAULT = 0x14,
  PGMAJFAULT = 0x15,
  PGLAZYFREED = 0x16,
  PGREFILL = 0x17,
  PGSTEAL_KSWAPD = 0x18,
  PGSTEAL_DIRECT = 0x19,
  PGSCAN_KSWAPD = 0x1A,
  PGSCAN_DIRECT = 0x1B,
  PGSCAN_DIRECT_THROTTLE = 0x1C,
  PGSCAN_ZONE_RECLAIM_FAILED = 0x1D,
  PGINODESTEAL = 0x1E,
  SLABS_SCANNED = 0x1F,
  KSWAPD_INODESTEAL = 0x20,
  KSWAPD_LOW_WMARK_HIT_QUICKLY = 0x21,
  KSWAPD_HIGH_WMARK_HIT_QUICKLY = 0x22,
  PAGEOUTRUN = 0x23,
  PGROTATED = 0x24,
  DROP_PAGECACHE = 0x25,
  DROP_SLAB = 0x26,
  OOM_KILL = 0x27,
  NUMA_PTE_UPDATES = 0x28,
  NUMA_HUGE_PTE_UPDATES = 0x29,
  NUMA_HINT_FAULTS = 0x2A,
  NUMA_HINT_FAULTS_LOCAL = 0x2B,
  NUMA_PAGE_MIGRATE = 0x2C,
  PGMIGRATE_SUCCESS = 0x2D,
  PGMIGRATE_FAIL = 0x2E,
  COMPACTMIGRATE_SCANNED = 0x2F,
  COMPACTFREE_SCANNED = 0x30,
  COMPACTISOLATED = 0x31,
  COMPACTSTALL = 0x32,
  COMPACTFAIL = 0x33,
  COMPACTSUCCESS = 0x34,
  KCOMPACTD_WAKE = 0x35,
  KCOMPACTD_MIGRATE_SCANNED = 0x36,
  KCOMPACTD_FREE_SCANNED = 0x37,
  HTLB_BUDDY_PGALLOC = 0x38,
  HTLB_BUDDY_PGALLOC_FAIL = 0x39,
  UNEVICTABLE_PGCULLED = 0x3A,
  UNEVICTABLE_PGSCANNED = 0x3B,
  UNEVICTABLE_PGRESCUED = 0x3C,
  UNEVICTABLE_PGMLOCKED = 0x3D,
  UNEVICTABLE_PGMUNLOCKED = 0x3E,
  UNEVICTABLE_PGCLEARED = 0x3F,
  UNEVICTABLE_PGSTRANDED = 0x40,
  THP_FAULT_ALLOC = 0x41,
  THP_FAULT_FALLBACK = 0x42,
  THP_COLLAPSE_ALLOC = 0x43,
  THP_COLLAPSE_ALLOC_FAILED = 0x44,
  THP_FILE_ALLOC = 0x45,
  THP_FILE_MAPPED = 0x46,
  THP_SPLIT_PAGE = 0x47,
  THP_SPLIT_PAGE_FAILED = 0x48,
  THP_DEFERRED_SPLIT_PAGE = 0x49,
  THP_SPLIT_PMD = 0x4A,
  THP_SPLIT_PUD = 0x4B,
  THP_ZERO_PAGE_ALLOC = 0x4C,
  THP_ZERO_PAGE_ALLOC_FAILED = 0x4D,
  THP_SWPOUT = 0x4E,
  THP_SWPOUT_FALLBACK = 0x4F,
  BALLOON_INFLATE = 0x50,
  BALLOON_DEFLATE = 0x51,
  BALLOON_MIGRATE = 0x52,
  SWAP_RA = 0x53,
  SWAP_RA_HIT = 0x54,
  NR_VM_EVENT_ITEMS = 0x55,
};
000002A8 struct vm_event_state
{
  unsigned __int64 event[85];
};
//  0. 0000 02A8 effalign(8) fda=0 bits=0000 vm_event_state.event unsigned __int64[85];
//          02A8 effalign(8) sda=0 bits=0000 vm_event_state struct packalign=0

00000068 struct vm_fault
{
  vm_area_struct *vma;
  unsigned int flags;
  gfp_t gfp_mask;
  unsigned __int64 pgoff;
  unsigned __int64 address;
  pmd_t *pmd;
  pud_t *pud;
  pte_t orig_pte;
  page *cow_page;
  mem_cgroup *memcg;
  page *page;
  pte_t *pte;
  spinlock_t *ptl;
  pgtable_t prealloc_pte;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_fault.vma vm_area_struct *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 vm_fault.flags unsigned int;
//  2. 000C 0004 effalign(4) fda=0 bits=0000 vm_fault.gfp_mask gfp_t;
//  3. 0010 0008 effalign(8) fda=0 bits=0000 vm_fault.pgoff unsigned __int64;
//  4. 0018 0008 effalign(8) fda=0 bits=0000 vm_fault.address unsigned __int64;
//  5. 0020 0008 effalign(8) fda=0 bits=0000 vm_fault.pmd pmd_t *;
//  6. 0028 0008 effalign(8) fda=0 bits=0000 vm_fault.pud pud_t *;
//  7. 0030 0008 effalign(8) fda=0 bits=0000 vm_fault.orig_pte pte_t;
//  8. 0038 0008 effalign(8) fda=0 bits=0000 vm_fault.cow_page page *;
//  9. 0040 0008 effalign(8) fda=0 bits=0000 vm_fault.memcg mem_cgroup *;
// 10. 0048 0008 effalign(8) fda=0 bits=0000 vm_fault.page page *;
// 11. 0050 0008 effalign(8) fda=0 bits=0000 vm_fault.pte pte_t *;
// 12. 0058 0008 effalign(8) fda=0 bits=0000 vm_fault.ptl spinlock_t *;
// 13. 0060 0008 effalign(8) fda=0 bits=0000 vm_fault.prealloc_pte pgtable_t;
//          0068 effalign(8) sda=0 bits=0000 vm_fault struct packalign=0

00000004 enum vm_fault_reason : unsigned __int32
{
  VM_FAULT_OOM = 0x1,
  VM_FAULT_SIGBUS = 0x2,
  VM_FAULT_MAJOR = 0x4,
  VM_FAULT_WRITE = 0x8,
  VM_FAULT_HWPOISON = 0x10,
  VM_FAULT_HWPOISON_LARGE = 0x20,
  VM_FAULT_SIGSEGV = 0x40,
  VM_FAULT_NOPAGE = 0x100,
  VM_FAULT_LOCKED = 0x200,
  VM_FAULT_RETRY = 0x400,
  VM_FAULT_FALLBACK = 0x800,
  VM_FAULT_DONE_COW = 0x1000,
  VM_FAULT_NEEDDSYNC = 0x2000,
  VM_FAULT_HINDEX_MASK = 0xF0000,
};
00000004 typedef unsigned int vm_fault_t;
00000008 typedef unsigned __int64 vm_flags_t;
00000078 struct vm_operations_struct
{
  void (__cdecl *open)(vm_area_struct *);
  void (__cdecl *close)(vm_area_struct *);
  int (__cdecl *split)(vm_area_struct *, unsigned __int64);
  int (__cdecl *mremap)(vm_area_struct *);
  vm_fault_t (__cdecl *fault)(vm_fault *);
  vm_fault_t (__cdecl *huge_fault)(vm_fault *, page_entry_size);
  void (__cdecl *map_pages)(vm_fault *, unsigned __int64, unsigned __int64);
  unsigned __int64 (__cdecl *pagesize)(vm_area_struct *);
  vm_fault_t (__cdecl *page_mkwrite)(vm_fault *);
  vm_fault_t (__cdecl *pfn_mkwrite)(vm_fault *);
  int (__cdecl *access)(vm_area_struct *, unsigned __int64, void *, int, int);
  const char *(__cdecl *name)(vm_area_struct *);
  int (__cdecl *set_policy)(vm_area_struct *, mempolicy *);
  mempolicy *(__cdecl *get_policy)(vm_area_struct *, unsigned __int64);
  page *(__cdecl *find_special_page)(vm_area_struct *, unsigned __int64);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.open void (__cdecl *)(vm_area_struct *);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.close void (__cdecl *)(vm_area_struct *);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.split int (__cdecl *)(vm_area_struct *, unsigned __int64);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.mremap int (__cdecl *)(vm_area_struct *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.fault vm_fault_t (__cdecl *)(vm_fault *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.huge_fault vm_fault_t (__cdecl *)(vm_fault *, page_entry_size);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.map_pages void (__cdecl *)(vm_fault *, unsigned __int64, unsigned __int64);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.pagesize unsigned __int64 (__cdecl *)(vm_area_struct *);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.page_mkwrite vm_fault_t (__cdecl *)(vm_fault *);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.pfn_mkwrite vm_fault_t (__cdecl *)(vm_fault *);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.access int (__cdecl *)(vm_area_struct *, unsigned __int64, void *, int, int);
// 11. 0058 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.name const char *(__cdecl *)(vm_area_struct *);
// 12. 0060 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.set_policy int (__cdecl *)(vm_area_struct *, mempolicy *);
// 13. 0068 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.get_policy mempolicy *(__cdecl *)(vm_area_struct *, unsigned __int64);
// 14. 0070 0008 effalign(8) fda=0 bits=0000 vm_operations_struct.find_special_page page *(__cdecl *)(vm_area_struct *, unsigned __int64);
//          0078 effalign(8) sda=0 bits=0000 vm_operations_struct struct packalign=0

00000058 struct vm_region
{
  rb_node vm_rb;
  vm_flags_t vm_flags;
  unsigned __int64 vm_start;
  unsigned __int64 vm_end;
  unsigned __int64 vm_top;
  unsigned __int64 vm_pgoff;
  file *vm_file;
  file *vm_prfile;
  int vm_usage;
  __int8 vm_icache_flushed : 1;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 vm_region.vm_rb rb_node;
//  1. 0018 0008 effalign(8) fda=0 bits=0000 vm_region.vm_flags vm_flags_t;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 vm_region.vm_start unsigned __int64;
//  3. 0028 0008 effalign(8) fda=0 bits=0000 vm_region.vm_end unsigned __int64;
//  4. 0030 0008 effalign(8) fda=0 bits=0000 vm_region.vm_top unsigned __int64;
//  5. 0038 0008 effalign(8) fda=0 bits=0000 vm_region.vm_pgoff unsigned __int64;
//  6. 0040 0008 effalign(8) fda=0 bits=0000 vm_region.vm_file file *;
//  7. 0048 0008 effalign(8) fda=0 bits=0000 vm_region.vm_prfile file *;
//  8. 0050 0004 effalign(4) fda=0 bits=0000 vm_region.vm_usage int;
//  9. 0054. 0 1 effalign(1) fda=0 bits=0000 vm_region.vm_icache_flushed bi.nbytes=1 S
//          0055 unpadded_size
//          0058 effalign(8) sda=0 bits=0000 vm_region struct packalign=0

00000020 struct vm_special_mapping
{
  const char *name;
  page **pages;
  vm_fault_t (__cdecl *fault)(const vm_special_mapping *, vm_area_struct *, vm_fault *);
  int (__cdecl *mremap)(const vm_special_mapping *, vm_area_struct *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_special_mapping.name const char *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vm_special_mapping.pages page **;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vm_special_mapping.fault vm_fault_t (__cdecl *)(const vm_special_mapping *, vm_area_struct *, vm_fault *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vm_special_mapping.mremap int (__cdecl *)(const vm_special_mapping *, vm_area_struct *);
//          0020 effalign(8) sda=0 bits=0000 vm_special_mapping struct packalign=0

00000040 struct vm_struct
{
  vm_struct *next;
  void *addr;
  unsigned __int64 size;
  unsigned __int64 flags;
  page **pages;
  unsigned int nr_pages;
  phys_addr_t phys_addr;
  const void *caller;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_struct.next vm_struct *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vm_struct.addr void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vm_struct.size unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vm_struct.flags unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vm_struct.pages page **;
//  5. 0028 0004 effalign(4) fda=0 bits=0000 vm_struct.nr_pages unsigned int;
//  6. 0030 0008 effalign(8) fda=0 bits=0000 vm_struct.phys_addr phys_addr_t;
//  7. 0038 0008 effalign(8) fda=0 bits=0000 vm_struct.caller const void *;
//          0040 effalign(8) sda=0 bits=0000 vm_struct struct packalign=0

00000030 struct vm_unmapped_area_info
{
  unsigned __int64 flags;
  unsigned __int64 length;
  unsigned __int64 low_limit;
  unsigned __int64 high_limit;
  unsigned __int64 align_mask;
  unsigned __int64 align_offset;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.flags unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.length unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.low_limit unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.high_limit unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.align_mask unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 vm_unmapped_area_info.align_offset unsigned __int64;
//          0030 effalign(8) sda=0 bits=0000 vm_unmapped_area_info struct packalign=0

00000008 struct vm_userfaultfd_ctx
{
  userfaultfd_ctx *ctx;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vm_userfaultfd_ctx.ctx userfaultfd_ctx *;
//          0008 effalign(8) sda=0 bits=0000 vm_userfaultfd_ctx struct packalign=0

00000028 struct vmacache
{
  u64 seqnum;
  vm_area_struct *vmas[4];
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vmacache.seqnum u64;
//  1. 0008 0020 effalign(8) fda=0 bits=0000 vmacache.vmas vm_area_struct *[4];
//          0028 effalign(8) sda=0 bits=0000 vmacache struct packalign=0

00000040 struct vmap_area
{
  unsigned __int64 va_start;
  unsigned __int64 va_end;
  rb_node rb_node;
  list_head list;
  union
  {
    unsigned __int64 subtree_max_size;
    vm_struct *vm;
    llist_node purge_list;
  };
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vmap_area.va_start unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vmap_area.va_end unsigned __int64;
//  2. 0010 0018 effalign(8) fda=0 bits=0000 vmap_area.rb_node rb_node;
//  3. 0028 0010 effalign(8) fda=0 bits=0000 vmap_area.list list_head;
//  4. 0038 0008 effalign(8) fda=0 bits=0000 vmap_area.vmap_area::$17F05D78027BF9E150A58B5C19847D1A vmap_area::$17F05D78027BF9E150A58B5C19847D1A;
//          0040 effalign(8) sda=0 bits=0000 vmap_area struct packalign=0

00000008 union vmap_area::$17F05D78027BF9E150A58B5C19847D1A
{
  unsigned __int64 subtree_max_size;
  vm_struct *vm;
  llist_node purge_list;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vmap_area::$17F05D78027BF9E150A58B5C19847D1A.subtree_max_size unsigned __int64;
//  1. 0000 0008 effalign(8) fda=0 bits=0000 vmap_area::$17F05D78027BF9E150A58B5C19847D1A.vm vm_struct *;
//  2. 0000 0008 effalign(8) fda=0 bits=0000 vmap_area::$17F05D78027BF9E150A58B5C19847D1A.purge_list llist_node;
//          0008 effalign(8) sda=0 bits=0000 vmap_area::$17F05D78027BF9E150A58B5C19847D1A union packalign=0

00000030 struct vmem_altmap
{
  const unsigned __int64 base_pfn;
  const unsigned __int64 end_pfn;
  const unsigned __int64 reserve;
  unsigned __int64 free;
  unsigned __int64 align;
  unsigned __int64 alloc;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 vmem_altmap.base_pfn const unsigned __int64;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vmem_altmap.end_pfn const unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 vmem_altmap.reserve const unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vmem_altmap.free unsigned __int64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vmem_altmap.align unsigned __int64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 vmem_altmap.alloc unsigned __int64;
//          0030 effalign(8) sda=0 bits=0000 vmem_altmap struct packalign=0

00000004 enum vsyscall_num : unsigned __int32
{
  __NR_vgettimeofday = 0x0,
  __NR_vtime = 0x1,
  __NR_vgetcpu = 0x2,
};
00000030 struct vtime
{
  seqcount_t seqcount;
  unsigned __int64 starttime;
  vtime_state state;
  u64 utime;
  u64 stime;
  u64 gtime;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 vtime.seqcount seqcount_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 vtime.starttime unsigned __int64;
//  2. 0010 0004 effalign(4) fda=0 bits=0000 vtime.state vtime_state;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 vtime.utime u64;
//  4. 0020 0008 effalign(8) fda=0 bits=0000 vtime.stime u64;
//  5. 0028 0008 effalign(8) fda=0 bits=0000 vtime.gtime u64;
//          0030 effalign(8) sda=0 bits=0000 vtime struct packalign=0

00000004 enum vtime_state : unsigned __int32
{
  VTIME_INACTIVE = 0x0,
  VTIME_USER = 0x1,
  VTIME_SYS = 0x2,
};
FFFFFFFF typedef int __cdecl wait_bit_action_f(wait_bit_key *, int);
00000018 struct wait_bit_key
{
  void *flags;
  int bit_nr;
  unsigned __int64 timeout;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 wait_bit_key.flags void *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 wait_bit_key.bit_nr int;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 wait_bit_key.timeout unsigned __int64;
//          0018 effalign(8) sda=0 bits=0000 wait_bit_key struct packalign=0

00000040 struct wait_bit_queue_entry
{
  wait_bit_key key;
  wait_queue_entry wq_entry;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 wait_bit_queue_entry.key wait_bit_key;
//  1. 0018 0028 effalign(8) fda=0 bits=0000 wait_bit_queue_entry.wq_entry wait_queue_entry;
//          0040 effalign(8) sda=0 bits=0000 wait_bit_queue_entry struct packalign=0

00000028 struct wait_queue_entry
{
  unsigned int flags;
  void *private;
  wait_queue_func_t func;
  list_head entry;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 wait_queue_entry.flags unsigned int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 wait_queue_entry.private void *;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 wait_queue_entry.func wait_queue_func_t;
//  3. 0018 0010 effalign(8) fda=0 bits=0000 wait_queue_entry.entry list_head;
//          0028 effalign(8) sda=0 bits=0000 wait_queue_entry struct packalign=0

00000028 typedef wait_queue_entry wait_queue_entry_t;
00000008 typedef int (__cdecl *wait_queue_func_t)(wait_queue_entry *, unsigned int, int, void *);
00000018 struct wait_queue_head
{
  spinlock_t lock;
  list_head head;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 wait_queue_head.lock spinlock_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 wait_queue_head.head list_head;
//          0018 effalign(8) sda=0 bits=0000 wait_queue_head struct packalign=0

00000018 typedef wait_queue_head wait_queue_head_t;
FFFFFFFF struct wake_irq;
00000008 struct wake_q_node
{
  wake_q_node *next;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 wake_q_node.next wake_q_node *;
//          0008 effalign(8) sda=0 bits=0000 wake_q_node struct packalign=0

000000C0 struct wakeup_source
{
  const char *name;
  int id;
  list_head entry;
  spinlock_t lock;
  wake_irq *wakeirq;
  timer_list timer;
  unsigned __int64 timer_expires;
  ktime_t total_time;
  ktime_t max_time;
  ktime_t last_time;
  ktime_t start_prevent_time;
  ktime_t prevent_sleep_time;
  unsigned __int64 event_count;
  unsigned __int64 active_count;
  unsigned __int64 relax_count;
  unsigned __int64 expire_count;
  unsigned __int64 wakeup_count;
  device *dev;
  __int8 active : 1;
  __int8 autosleep_enabled : 1;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 wakeup_source.name const char *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 wakeup_source.id int;
//  2. 0010 0010 effalign(8) fda=0 bits=0000 wakeup_source.entry list_head;
//  3. 0020 0004 effalign(4) fda=0 bits=0000 wakeup_source.lock spinlock_t;
//  4. 0028 0008 effalign(8) fda=0 bits=0000 wakeup_source.wakeirq wake_irq *;
//  5. 0030 0028 effalign(8) fda=0 bits=0000 wakeup_source.timer timer_list;
//  6. 0058 0008 effalign(8) fda=0 bits=0000 wakeup_source.timer_expires unsigned __int64;
//  7. 0060 0008 effalign(8) fda=0 bits=0000 wakeup_source.total_time ktime_t;
//  8. 0068 0008 effalign(8) fda=0 bits=0000 wakeup_source.max_time ktime_t;
//  9. 0070 0008 effalign(8) fda=0 bits=0000 wakeup_source.last_time ktime_t;
// 10. 0078 0008 effalign(8) fda=0 bits=0000 wakeup_source.start_prevent_time ktime_t;
// 11. 0080 0008 effalign(8) fda=0 bits=0000 wakeup_source.prevent_sleep_time ktime_t;
// 12. 0088 0008 effalign(8) fda=0 bits=0000 wakeup_source.event_count unsigned __int64;
// 13. 0090 0008 effalign(8) fda=0 bits=0000 wakeup_source.active_count unsigned __int64;
// 14. 0098 0008 effalign(8) fda=0 bits=0000 wakeup_source.relax_count unsigned __int64;
// 15. 00A0 0008 effalign(8) fda=0 bits=0000 wakeup_source.expire_count unsigned __int64;
// 16. 00A8 0008 effalign(8) fda=0 bits=0000 wakeup_source.wakeup_count unsigned __int64;
// 17. 00B0 0008 effalign(8) fda=0 bits=0000 wakeup_source.dev device *;
// 18. 00B8. 0 1 effalign(1) fda=0 bits=0000 wakeup_source.active bi.nbytes=1 S
// 19. 00B8. 1 1 effalign(1) fda=0 bits=0000 wakeup_source.autosleep_enabled bi.nbytes=1 S
//          00B9 unpadded_size
//          00C0 effalign(8) sda=0 bits=0000 wakeup_source struct packalign=0

FFFFFFFF struct warn_args;
00000010 struct wb_completion
{
  atomic_t cnt;
  wait_queue_head_t *waitq;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 wb_completion.cnt atomic_t;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 wb_completion.waitq wait_queue_head_t *;
//          0010 effalign(8) sda=0 bits=0000 wb_completion struct packalign=0

00000004 enum wb_congested_state : unsigned __int32
{
  WB_async_congested = 0x0,
  WB_sync_congested = 0x1,
};
00000010 struct wb_lock_cookie
{
  bool locked;
  unsigned __int64 flags;
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 wb_lock_cookie.locked bool;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 wb_lock_cookie.flags unsigned __int64;
//          0010 effalign(8) sda=0 bits=0000 wb_lock_cookie struct packalign=0

00000004 enum wb_reason : unsigned __int32
{
  WB_REASON_BACKGROUND = 0x0,
  WB_REASON_VMSCAN = 0x1,
  WB_REASON_SYNC = 0x2,
  WB_REASON_PERIODIC = 0x3,
  WB_REASON_LAPTOP_TIMER = 0x4,
  WB_REASON_FREE_MORE_MEM = 0x5,
  WB_REASON_FS_FREE_SPACE = 0x6,
  WB_REASON_FORKER_THREAD = 0x7,
  WB_REASON_FOREIGN_FLUSH = 0x8,
  WB_REASON_MAX = 0x9,
};
00000004 enum wb_stat_item : unsigned __int32
{
  WB_RECLAIMABLE = 0x0,
  WB_WRITEBACK = 0x1,
  WB_DIRTIED = 0x2,
  WB_WRITTEN = 0x3,
  NR_WB_STAT_ITEMS = 0x4,
};
00000004 enum wb_state : unsigned __int32
{
  WB_registered = 0x0,
  WB_writeback_running = 0x1,
  WB_has_dirty_io = 0x2,
  WB_start_all = 0x3,
};
00000030 struct wmi_device_id
{
  const char guid_string[37];
  const void *context;
};
//  0. 0000 0025 effalign(1) fda=0 bits=0000 wmi_device_id.guid_string const char[37];
//  1. 0028 0008 effalign(8) fda=0 bits=0000 wmi_device_id.context const void *;
//          0030 effalign(8) sda=0 bits=0000 wmi_device_id struct packalign=0

00000008 typedef void (__cdecl *wmi_notify_handler)(u32, void *);
00000008 typedef void (__cdecl *work_func_t)(work_struct *);
00000020 struct work_struct
{
  atomic_long_t data;
  list_head entry;
  work_func_t func;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 work_struct.data atomic_long_t;
//  1. 0008 0010 effalign(8) fda=0 bits=0000 work_struct.entry list_head;
//  2. 0018 0008 effalign(8) fda=0 bits=0000 work_struct.func work_func_t;
//          0020 effalign(8) sda=0 bits=0000 work_struct struct packalign=0

00000018 struct workqueue_attrs
{
  int nice;
  cpumask_var_t cpumask;
  bool no_numa;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 workqueue_attrs.nice int;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 workqueue_attrs.cpumask cpumask_var_t;
//  2. 0010 0001 effalign(1) fda=0 bits=0000 workqueue_attrs.no_numa bool;
//          0011 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 workqueue_attrs struct packalign=0

FFFFFFFF struct workqueue_struct;
FFFFFFFF struct writeback_control;
FFFFFFFF struct wusb_dev;
FFFFFFFF struct ww_acquire_ctx;
00000010 struct x86_apic_ops
{
  unsigned int (__cdecl *io_apic_read)(unsigned int, unsigned int);
  void (*restore)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_apic_ops.io_apic_read unsigned int (__cdecl *)(unsigned int, unsigned int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_apic_ops.restore void (*)(void);
//          0010 effalign(8) sda=0 bits=0000 x86_apic_ops struct packalign=0

00000018 struct x86_cpu_id
{
  __u16 vendor;
  __u16 family;
  __u16 model;
  __u16 feature;
  kernel_ulong_t driver_data;
  __u16 steppings;
};
//  0. 0000 0002 effalign(2) fda=0 bits=0000 x86_cpu_id.vendor __u16;
//  1. 0002 0002 effalign(2) fda=0 bits=0000 x86_cpu_id.family __u16;
//  2. 0004 0002 effalign(2) fda=0 bits=0000 x86_cpu_id.model __u16;
//  3. 0006 0002 effalign(2) fda=0 bits=0000 x86_cpu_id.feature __u16;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 x86_cpu_id.driver_data kernel_ulong_t;
//  5. 0010 0002 effalign(2) fda=0 bits=0000 x86_cpu_id.steppings __u16;
//          0012 unpadded_size
//          0018 effalign(8) sda=0 bits=0000 x86_cpu_id struct packalign=0

00000018 struct x86_cpuinit_ops
{
  void (*setup_percpu_clockev)(void);
  void (*early_percpu_clock_init)(void);
  void (__cdecl *fixup_cpu_id)(cpuinfo_x86 *, int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_cpuinit_ops.setup_percpu_clockev void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_cpuinit_ops.early_percpu_clock_init void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_cpuinit_ops.fixup_cpu_id void (__cdecl *)(cpuinfo_x86 *, int);
//          0018 effalign(8) sda=0 bits=0000 x86_cpuinit_ops struct packalign=0

00000004 enum x86_hardware_subarch : unsigned __int32
{
  X86_SUBARCH_PC = 0x0,
  X86_SUBARCH_LGUEST = 0x1,
  X86_SUBARCH_XEN = 0x2,
  X86_SUBARCH_INTEL_MID = 0x3,
  X86_SUBARCH_CE4100 = 0x4,
  X86_NR_SUBARCHS = 0x5,
};
00000068 struct __attribute__((packed)) x86_hw_tss
{
  u32 reserved1;
  u64 sp0;
  u64 sp1;
  u64 sp2;
  u64 reserved2;
  u64 ist[7];
  u32 reserved3;
  u32 reserved4;
  u16 reserved5;
  u16 io_bitmap_base;
};
//  0. 0000 0004 effalign(1) fda=0 bits=0000 x86_hw_tss.reserved1 u32;
//  1. 0004 0008 effalign(1) fda=0 bits=0000 x86_hw_tss.sp0 u64;
//  2. 000C 0008 effalign(1) fda=0 bits=0000 x86_hw_tss.sp1 u64;
//  3. 0014 0008 effalign(1) fda=0 bits=0000 x86_hw_tss.sp2 u64;
//  4. 001C 0008 effalign(1) fda=0 bits=0000 x86_hw_tss.reserved2 u64;
//  5. 0024 0038 effalign(1) fda=0 bits=0000 x86_hw_tss.ist u64[7];
//  6. 005C 0004 effalign(1) fda=0 bits=0000 x86_hw_tss.reserved3 u32;
//  7. 0060 0004 effalign(1) fda=0 bits=0000 x86_hw_tss.reserved4 u32;
//  8. 0064 0002 effalign(1) fda=0 bits=0000 x86_hw_tss.reserved5 u16;
//  9. 0066 0002 effalign(1) fda=0 bits=0000 x86_hw_tss.io_bitmap_base u16;
//          0068 effalign(1) sda=0 bits=0040 x86_hw_tss struct packalign=0

00000028 struct x86_hyper_init
{
  void (*init_platform)(void);
  void (*guest_late_init)(void);
  bool (*x2apic_available)(void);
  void (*init_mem_mapping)(void);
  void (*init_after_bootmem)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_hyper_init.init_platform void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_hyper_init.guest_late_init void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_hyper_init.x2apic_available bool (*)(void);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_hyper_init.init_mem_mapping void (*)(void);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 x86_hyper_init.init_after_bootmem void (*)(void);
//          0028 effalign(8) sda=0 bits=0000 x86_hyper_init struct packalign=0

00000008 struct x86_hyper_runtime
{
  void (__cdecl *pin_vcpu)(int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_hyper_runtime.pin_vcpu void (__cdecl *)(int);
//          0008 effalign(8) sda=0 bits=0000 x86_hyper_runtime struct packalign=0

00000018 struct x86_init_acpi
{
  void (__cdecl *set_root_pointer)(u64);
  u64 (*get_root_pointer)(void);
  void (*reduced_hw_early_init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_acpi.set_root_pointer void (__cdecl *)(u64);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_acpi.get_root_pointer u64 (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_acpi.reduced_hw_early_init void (*)(void);
//          0018 effalign(8) sda=0 bits=0000 x86_init_acpi struct packalign=0

00000008 struct x86_init_iommu
{
  int (*iommu_init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_iommu.iommu_init int (*)(void);
//          0008 effalign(8) sda=0 bits=0000 x86_init_iommu struct packalign=0

00000028 struct x86_init_irqs
{
  void (*pre_vector_init)(void);
  void (*intr_init)(void);
  void (*trap_init)(void);
  void (*intr_mode_select)(void);
  void (*intr_mode_init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_irqs.pre_vector_init void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_irqs.intr_init void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_irqs.trap_init void (*)(void);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_init_irqs.intr_mode_select void (*)(void);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 x86_init_irqs.intr_mode_init void (*)(void);
//          0028 effalign(8) sda=0 bits=0000 x86_init_irqs struct packalign=0

00000040 struct x86_init_mpparse
{
  void (__cdecl *mpc_record)(unsigned int);
  void (*setup_ioapic_ids)(void);
  int (__cdecl *mpc_apic_id)(mpc_cpu *);
  void (__cdecl *smp_read_mpc_oem)(mpc_table *);
  void (__cdecl *mpc_oem_pci_bus)(mpc_bus *);
  void (__cdecl *mpc_oem_bus_info)(mpc_bus *, char *);
  void (*find_smp_config)(void);
  void (__cdecl *get_smp_config)(unsigned int);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.mpc_record void (__cdecl *)(unsigned int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.setup_ioapic_ids void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.mpc_apic_id int (__cdecl *)(mpc_cpu *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.smp_read_mpc_oem void (__cdecl *)(mpc_table *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.mpc_oem_pci_bus void (__cdecl *)(mpc_bus *);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.mpc_oem_bus_info void (__cdecl *)(mpc_bus *, char *);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.find_smp_config void (*)(void);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 x86_init_mpparse.get_smp_config void (__cdecl *)(unsigned int);
//          0040 effalign(8) sda=0 bits=0000 x86_init_mpparse struct packalign=0

00000010 struct x86_init_oem
{
  void (*arch_setup)(void);
  void (*banner)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_oem.arch_setup void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_oem.banner void (*)(void);
//          0010 effalign(8) sda=0 bits=0000 x86_init_oem struct packalign=0

00000118 struct x86_init_ops
{
  x86_init_resources resources;
  x86_init_mpparse mpparse;
  x86_init_irqs irqs;
  x86_init_oem oem;
  x86_init_paging paging;
  x86_init_timers timers;
  x86_init_iommu iommu;
  x86_init_pci pci;
  x86_hyper_init hyper;
  x86_init_acpi acpi;
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 x86_init_ops.resources x86_init_resources;
//  1. 0018 0040 effalign(8) fda=0 bits=0000 x86_init_ops.mpparse x86_init_mpparse;
//  2. 0058 0028 effalign(8) fda=0 bits=0000 x86_init_ops.irqs x86_init_irqs;
//  3. 0080 0010 effalign(8) fda=0 bits=0000 x86_init_ops.oem x86_init_oem;
//  4. 0090 0008 effalign(8) fda=0 bits=0000 x86_init_ops.paging x86_init_paging;
//  5. 0098 0018 effalign(8) fda=0 bits=0000 x86_init_ops.timers x86_init_timers;
//  6. 00B0 0008 effalign(8) fda=0 bits=0000 x86_init_ops.iommu x86_init_iommu;
//  7. 00B8 0020 effalign(8) fda=0 bits=0000 x86_init_ops.pci x86_init_pci;
//  8. 00D8 0028 effalign(8) fda=0 bits=0000 x86_init_ops.hyper x86_hyper_init;
//  9. 0100 0018 effalign(8) fda=0 bits=0000 x86_init_ops.acpi x86_init_acpi;
//          0118 effalign(8) sda=0 bits=0000 x86_init_ops struct packalign=0

00000008 struct x86_init_paging
{
  void (*pagetable_init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_paging.pagetable_init void (*)(void);
//          0008 effalign(8) sda=0 bits=0000 x86_init_paging struct packalign=0

00000020 struct x86_init_pci
{
  int (*arch_init)(void);
  int (*init)(void);
  void (*init_irq)(void);
  void (*fixup_irqs)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_pci.arch_init int (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_pci.init int (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_pci.init_irq void (*)(void);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_init_pci.fixup_irqs void (*)(void);
//          0020 effalign(8) sda=0 bits=0000 x86_init_pci struct packalign=0

00000018 struct x86_init_resources
{
  void (*probe_roms)(void);
  void (*reserve_resources)(void);
  char *(*memory_setup)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_resources.probe_roms void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_resources.reserve_resources void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_resources.memory_setup char *(*)(void);
//          0018 effalign(8) sda=0 bits=0000 x86_init_resources struct packalign=0

00000018 struct x86_init_timers
{
  void (*setup_percpu_clockev)(void);
  void (*timer_init)(void);
  void (*wallclock_init)(void);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_init_timers.setup_percpu_clockev void (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_init_timers.timer_init void (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_init_timers.wallclock_init void (*)(void);
//          0018 effalign(8) sda=0 bits=0000 x86_init_timers struct packalign=0

00000004 struct x86_legacy_devices
{
  int pnpbios;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 x86_legacy_devices.pnpbios int;
//          0004 effalign(4) sda=0 bits=0000 x86_legacy_devices struct packalign=0

00000018 struct x86_legacy_features
{
  x86_legacy_i8042_state i8042;
  int rtc;
  int warm_reset;
  int no_vga;
  int reserve_bios_regions;
  x86_legacy_devices devices;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.i8042 x86_legacy_i8042_state;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.rtc int;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.warm_reset int;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.no_vga int;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.reserve_bios_regions int;
//  5. 0014 0004 effalign(4) fda=0 bits=0000 x86_legacy_features.devices x86_legacy_devices;
//          0018 effalign(4) sda=0 bits=0000 x86_legacy_features struct packalign=0

00000004 enum x86_legacy_i8042_state : unsigned __int32
{
  X86_LEGACY_I8042_PLATFORM_ABSENT = 0x0,
  X86_LEGACY_I8042_FIRMWARE_ABSENT = 0x1,
  X86_LEGACY_I8042_EXPECTED_PRESENT = 0x2,
};
00000020 struct x86_msi_ops
{
  int (__cdecl *setup_msi_irqs)(pci_dev *, int, int);
  void (__cdecl *teardown_msi_irq)(unsigned int);
  void (__cdecl *teardown_msi_irqs)(pci_dev *);
  void (__cdecl *restore_msi_irqs)(pci_dev *);
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_msi_ops.setup_msi_irqs int (__cdecl *)(pci_dev *, int, int);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_msi_ops.teardown_msi_irq void (__cdecl *)(unsigned int);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_msi_ops.teardown_msi_irqs void (__cdecl *)(pci_dev *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_msi_ops.restore_msi_irqs void (__cdecl *)(pci_dev *);
//          0020 effalign(8) sda=0 bits=0000 x86_msi_ops struct packalign=0

00000080 struct x86_platform_ops
{
  unsigned __int64 (*calibrate_cpu)(void);
  unsigned __int64 (*calibrate_tsc)(void);
  void (__cdecl *get_wallclock)(timespec64 *);
  int (__cdecl *set_wallclock)(const timespec64 *);
  void (*iommu_shutdown)(void);
  bool (__cdecl *is_untracked_pat_range)(u64, u64);
  void (*nmi_init)(void);
  unsigned __int8 (*get_nmi_reason)(void);
  void (*save_sched_clock_state)(void);
  void (*restore_sched_clock_state)(void);
  void (*apic_post_init)(void);
  x86_legacy_features legacy;
  void (*set_legacy_features)(void);
  x86_hyper_runtime hyper;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.calibrate_cpu unsigned __int64 (*)(void);
//  1. 0008 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.calibrate_tsc unsigned __int64 (*)(void);
//  2. 0010 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.get_wallclock void (__cdecl *)(timespec64 *);
//  3. 0018 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.set_wallclock int (__cdecl *)(const timespec64 *);
//  4. 0020 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.iommu_shutdown void (*)(void);
//  5. 0028 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.is_untracked_pat_range bool (__cdecl *)(u64, u64);
//  6. 0030 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.nmi_init void (*)(void);
//  7. 0038 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.get_nmi_reason unsigned __int8 (*)(void);
//  8. 0040 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.save_sched_clock_state void (*)(void);
//  9. 0048 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.restore_sched_clock_state void (*)(void);
// 10. 0050 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.apic_post_init void (*)(void);
// 11. 0058 0018 effalign(4) fda=0 bits=0000 x86_platform_ops.legacy x86_legacy_features;
// 12. 0070 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.set_legacy_features void (*)(void);
// 13. 0078 0008 effalign(8) fda=0 bits=0000 x86_platform_ops.hyper x86_hyper_runtime;
//          0080 effalign(8) sda=0 bits=0000 x86_platform_ops struct packalign=0

00000008 struct xa_limit
{
  u32 max;
  u32 min;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 xa_limit.max u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 xa_limit.min u32;
//          0008 effalign(4) sda=0 bits=0000 xa_limit struct packalign=0

00000004 enum xa_lock_type : unsigned __int32
{
  XA_LOCK_IRQ = 0x1,
  XA_LOCK_BH = 0x2,
};
00000004 typedef unsigned int xa_mark_t;
00000240 struct xa_node
{
  unsigned __int8 shift;
  unsigned __int8 offset;
  unsigned __int8 count;
  unsigned __int8 nr_values;
  xa_node *parent;
  xarray *array;
  union
  {
    list_head private_list;
    callback_head callback_head;
  };
  void *slots[64];
  union
  {
    unsigned __int64 tags[3][1];
    unsigned __int64 marks[3][1];
  };
};
//  0. 0000 0001 effalign(1) fda=0 bits=0000 xa_node.shift unsigned __int8;
//  1. 0001 0001 effalign(1) fda=0 bits=0000 xa_node.offset unsigned __int8;
//  2. 0002 0001 effalign(1) fda=0 bits=0000 xa_node.count unsigned __int8;
//  3. 0003 0001 effalign(1) fda=0 bits=0000 xa_node.nr_values unsigned __int8;
//  4. 0008 0008 effalign(8) fda=0 bits=0000 xa_node.parent xa_node *;
//  5. 0010 0008 effalign(8) fda=0 bits=0000 xa_node.array xarray *;
//  6. 0018 0010 effalign(8) fda=0 bits=0000 xa_node.xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D;
//  7. 0028 0200 effalign(8) fda=0 bits=0000 xa_node.slots void *[64];
//  8. 0228 0018 effalign(8) fda=0 bits=0000 xa_node.xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA;
//          0240 effalign(8) sda=0 bits=0000 xa_node struct packalign=0

00000010 union xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D
{
  list_head private_list;
  callback_head callback_head;
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D.private_list list_head;
//  1. 0000 0010 effalign(8) fda=0 bits=0000 xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D.callback_head callback_head;
//          0010 effalign(8) sda=0 bits=0000 xa_node::$0AC7E56C60BC28EAD49DFF09E8441C8D union packalign=0

00000018 union xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA
{
  unsigned __int64 tags[3][1];
  unsigned __int64 marks[3][1];
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA.tags unsigned __int64[3][1];
//  1. 0000 0018 effalign(8) fda=0 bits=0000 xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA.marks unsigned __int64[3][1];
//          0018 effalign(8) sda=0 bits=0000 xa_node::$5DE74D6E6ADAEA8FEFCDA5D9FE9071AA union packalign=0

00000030 struct xa_state
{
  xarray *xa;
  unsigned __int64 xa_index;
  unsigned __int8 xa_shift;
  unsigned __int8 xa_sibs;
  unsigned __int8 xa_offset;
  unsigned __int8 xa_pad;
  xa_node *xa_node;
  xa_node *xa_alloc;
  xa_update_node_t xa_update;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 xa_state.xa xarray *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 xa_state.xa_index unsigned __int64;
//  2. 0010 0001 effalign(1) fda=0 bits=0000 xa_state.xa_shift unsigned __int8;
//  3. 0011 0001 effalign(1) fda=0 bits=0000 xa_state.xa_sibs unsigned __int8;
//  4. 0012 0001 effalign(1) fda=0 bits=0000 xa_state.xa_offset unsigned __int8;
//  5. 0013 0001 effalign(1) fda=0 bits=0000 xa_state.xa_pad unsigned __int8;
//  6. 0018 0008 effalign(8) fda=0 bits=0000 xa_state.xa_node xa_node *;
//  7. 0020 0008 effalign(8) fda=0 bits=0000 xa_state.xa_alloc xa_node *;
//  8. 0028 0008 effalign(8) fda=0 bits=0000 xa_state.xa_update xa_update_node_t;
//          0030 effalign(8) sda=0 bits=0000 xa_state struct packalign=0

00000008 typedef void (__cdecl *xa_update_node_t)(xa_node *);
00000010 struct xarray
{
  spinlock_t xa_lock;
  gfp_t xa_flags;
  void *xa_head;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 xarray.xa_lock spinlock_t;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 xarray.xa_flags gfp_t;
//  2. 0008 0008 effalign(8) fda=0 bits=0000 xarray.xa_head void *;
//          0010 effalign(8) sda=0 bits=0000 xarray struct packalign=0

FFFFFFFF struct xattr_handler;
00000004 enum xdp_action : unsigned __int32
{
  XDP_ABORTED = 0x0,
  XDP_DROP = 0x1,
  XDP_PASS = 0x2,
  XDP_TX = 0x3,
  XDP_REDIRECT = 0x4,
};
FFFFFFFF struct xdp_buff;
00000014 struct xdp_md
{
  __u32 data;
  __u32 data_end;
  __u32 data_meta;
  __u32 ingress_ifindex;
  __u32 rx_queue_index;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 xdp_md.data __u32;
//  1. 0004 0004 effalign(4) fda=0 bits=0000 xdp_md.data_end __u32;
//  2. 0008 0004 effalign(4) fda=0 bits=0000 xdp_md.data_meta __u32;
//  3. 000C 0004 effalign(4) fda=0 bits=0000 xdp_md.ingress_ifindex __u32;
//  4. 0010 0004 effalign(4) fda=0 bits=0000 xdp_md.rx_queue_index __u32;
//          0014 effalign(4) sda=0 bits=0000 xdp_md struct packalign=0

FFFFFFFF struct xdp_sock;
00000004 enum xfeature : unsigned __int32
{
  XFEATURE_FP = 0x0,
  XFEATURE_SSE = 0x1,
  XFEATURE_YMM = 0x2,
  XFEATURE_BNDREGS = 0x3,
  XFEATURE_BNDCSR = 0x4,
  XFEATURE_OPMASK = 0x5,
  XFEATURE_ZMM_Hi256 = 0x6,
  XFEATURE_Hi16_ZMM = 0x7,
  XFEATURE_PT_UNIMPLEMENTED_SO_FAR = 0x8,
  XFEATURE_PKRU = 0x9,
  XFEATURE_MAX = 0xA,
};
00000004 enum xhlock_context_t : unsigned __int32
{
  XHLOCK_HARD = 0x0,
  XHLOCK_SOFT = 0x1,
  XHLOCK_CTX_NR = 0x2,
};
FFFFFFFF struct xol_area;
00000240 struct __attribute__((packed)) __attribute__((aligned(64))) xregs_state
{
  fxregs_state i387;
  xstate_header header;
};
//  0. 0000 0200 effalign(1) fda=0 bits=0000 xregs_state.i387 fxregs_state;
//  1. 0200 0040 effalign(1) fda=0 bits=0000 xregs_state.header xstate_header;
//          0240 effalign(64) sda=7 bits=0040 xregs_state struct packalign=0

00000040 struct __attribute__((packed)) xstate_header
{
  u64 xfeatures;
  u64 xcomp_bv;
  u64 reserved[6];
};
//  0. 0000 0008 effalign(1) fda=0 bits=0000 xstate_header.xfeatures u64;
//  1. 0008 0008 effalign(1) fda=0 bits=0000 xstate_header.xcomp_bv u64;
//  2. 0010 0030 effalign(1) fda=0 bits=0000 xstate_header.reserved u64[6];
//          0040 effalign(1) sda=0 bits=0040 xstate_header struct packalign=0

00000100 struct __attribute__((packed)) ymmh_struct
{
  reg_128_bit hi_ymm[16];
};
//  0. 0000 0100 effalign(1) fda=0 bits=0000 ymmh_struct.hi_ymm reg_128_bit[16];
//          0100 effalign(1) sda=0 bits=0040 ymmh_struct struct packalign=0

00000020 struct zap_details
{
  address_space *check_mapping;
  unsigned __int64 first_index;
  unsigned __int64 last_index;
  page *single_page;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 zap_details.check_mapping address_space *;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 zap_details.first_index unsigned __int64;
//  2. 0010 0008 effalign(8) fda=0 bits=0000 zap_details.last_index unsigned __int64;
//  3. 0018 0008 effalign(8) fda=0 bits=0000 zap_details.single_page page *;
//          0020 effalign(8) sda=0 bits=0000 zap_details struct packalign=0

00000640 struct __attribute__((aligned(64))) zone
{
  unsigned __int64 _watermark[3];
  unsigned __int64 watermark_boost;
  unsigned __int64 nr_reserved_highatomic;
  __int64 lowmem_reserve[5];
  int node;
  pglist_data *zone_pgdat;
  per_cpu_pageset *pageset;
  unsigned __int64 zone_start_pfn;
  atomic_long_t managed_pages;
  unsigned __int64 spanned_pages;
  unsigned __int64 present_pages;
  const char *name;
  unsigned __int64 nr_isolate_pageblock;
  seqlock_t span_seqlock;
  int initialized;
  free_area free_area[11];
  unsigned __int64 flags;
  spinlock_t lock;
  unsigned __int64 percpu_drift_mark;
  unsigned __int64 compact_cached_free_pfn;
  unsigned __int64 compact_cached_migrate_pfn[2];
  unsigned __int64 compact_init_migrate_pfn;
  unsigned __int64 compact_init_free_pfn;
  unsigned int compact_considered;
  unsigned int compact_defer_shift;
  int compact_order_failed;
  bool compact_blockskip_flush;
  bool contiguous;
  atomic_long_t vm_stat[13];
  atomic_long_t vm_numa_stat[6];
};
//  0. 0000 0018 effalign(8) fda=0 bits=0000 zone._watermark unsigned __int64[3];
//  1. 0018 0008 effalign(8) fda=0 bits=0000 zone.watermark_boost unsigned __int64;
//  2. 0020 0008 effalign(8) fda=0 bits=0000 zone.nr_reserved_highatomic unsigned __int64;
//  3. 0028 0028 effalign(8) fda=0 bits=0000 zone.lowmem_reserve __int64[5];
//  4. 0050 0004 effalign(4) fda=0 bits=0000 zone.node int;
//  5. 0058 0008 effalign(8) fda=0 bits=0000 zone.zone_pgdat pglist_data *;
//  6. 0060 0008 effalign(8) fda=0 bits=0000 zone.pageset per_cpu_pageset *;
//  7. 0068 0008 effalign(8) fda=0 bits=0000 zone.zone_start_pfn unsigned __int64;
//  8. 0070 0008 effalign(8) fda=0 bits=0000 zone.managed_pages atomic_long_t;
//  9. 0078 0008 effalign(8) fda=0 bits=0000 zone.spanned_pages unsigned __int64;
// 10. 0080 0008 effalign(8) fda=0 bits=0000 zone.present_pages unsigned __int64;
// 11. 0088 0008 effalign(8) fda=0 bits=0000 zone.name const char *;
// 12. 0090 0008 effalign(8) fda=0 bits=0000 zone.nr_isolate_pageblock unsigned __int64;
// 13. 0098 0008 effalign(4) fda=0 bits=0000 zone.span_seqlock seqlock_t;
// 14. 00A0 0004 effalign(4) fda=0 bits=0000 zone.initialized int;
// 15. 00A8 0478 effalign(8) fda=0 bits=0000 zone.free_area free_area[11];
// 16. 0520 0008 effalign(8) fda=0 bits=0000 zone.flags unsigned __int64;
// 17. 0528 0004 effalign(4) fda=0 bits=0000 zone.lock spinlock_t;
// 18. 0530 0008 effalign(8) fda=0 bits=0000 zone.percpu_drift_mark unsigned __int64;
// 19. 0538 0008 effalign(8) fda=0 bits=0000 zone.compact_cached_free_pfn unsigned __int64;
// 20. 0540 0010 effalign(8) fda=0 bits=0000 zone.compact_cached_migrate_pfn unsigned __int64[2];
// 21. 0550 0008 effalign(8) fda=0 bits=0000 zone.compact_init_migrate_pfn unsigned __int64;
// 22. 0558 0008 effalign(8) fda=0 bits=0000 zone.compact_init_free_pfn unsigned __int64;
// 23. 0560 0004 effalign(4) fda=0 bits=0000 zone.compact_considered unsigned int;
// 24. 0564 0004 effalign(4) fda=0 bits=0000 zone.compact_defer_shift unsigned int;
// 25. 0568 0004 effalign(4) fda=0 bits=0000 zone.compact_order_failed int;
// 26. 056C 0001 effalign(1) fda=0 bits=0000 zone.compact_blockskip_flush bool;
// 27. 056D 0001 effalign(1) fda=0 bits=0000 zone.contiguous bool;
// 28. 0570 0068 effalign(8) fda=0 bits=0000 zone.vm_stat atomic_long_t[13];
// 29. 05D8 0030 effalign(8) fda=0 bits=0000 zone.vm_numa_stat atomic_long_t[6];
//          0608 unpadded_size
//          0640 effalign(64) sda=7 bits=0000 zone struct packalign=0

00000004 enum zone_flags : unsigned __int32
{
  ZONE_BOOSTED_WATERMARK = 0x0,
};
00000000 struct __attribute__((aligned(64))) zone_padding
{
};
//          0000 effalign(64) sda=7 bits=0000 zone_padding struct packalign=0

00000020 struct zone_reclaim_stat
{
  unsigned __int64 recent_rotated[2];
  unsigned __int64 recent_scanned[2];
};
//  0. 0000 0010 effalign(8) fda=0 bits=0000 zone_reclaim_stat.recent_rotated unsigned __int64[2];
//  1. 0010 0010 effalign(8) fda=0 bits=0000 zone_reclaim_stat.recent_scanned unsigned __int64[2];
//          0020 effalign(8) sda=0 bits=0000 zone_reclaim_stat struct packalign=0

00000004 enum zone_stat_item : unsigned __int32
{
  NR_FREE_PAGES = 0x0,
  NR_ZONE_LRU_BASE = 0x1,
  NR_ZONE_INACTIVE_ANON = 0x1,
  NR_ZONE_ACTIVE_ANON = 0x2,
  NR_ZONE_INACTIVE_FILE = 0x3,
  NR_ZONE_ACTIVE_FILE = 0x4,
  NR_ZONE_UNEVICTABLE = 0x5,
  NR_ZONE_WRITE_PENDING = 0x6,
  NR_MLOCK = 0x7,
  NR_PAGETABLE = 0x8,
  NR_KERNEL_STACK_KB = 0x9,
  NR_BOUNCE = 0xA,
  NR_ZSPAGES = 0xB,
  NR_FREE_CMA_PAGES = 0xC,
  NR_VM_ZONE_STAT_ITEMS = 0xD,
};
00000004 enum zone_type : unsigned __int32
{
  ZONE_DMA = 0x0,
  ZONE_DMA32 = 0x1,
  ZONE_NORMAL = 0x2,
  ZONE_MOVABLE = 0x3,
  ZONE_DEVICE = 0x4,
  __MAX_NR_ZONES = 0x5,
};
00000004 enum zone_watermarks : unsigned __int32
{
  WMARK_MIN = 0x0,
  WMARK_LOW = 0x1,
  WMARK_HIGH = 0x2,
  NR_WMARK = 0x3,
};
00014010 struct zonelist
{
  zoneref _zonerefs[5121];
};
//  0. 0000 14010 effalign(8) fda=0 bits=0000 zonelist._zonerefs zoneref[5121];
//          14010 effalign(8) sda=0 bits=0000 zonelist struct packalign=0

00000010 struct zoneref
{
  zone *zone;
  int zone_idx;
};
//  0. 0000 0008 effalign(8) fda=0 bits=0000 zoneref.zone zone *;
//  1. 0008 0004 effalign(4) fda=0 bits=0000 zoneref.zone_idx int;
//          000C unpadded_size
//          0010 effalign(8) sda=0 bits=0000 zoneref struct packalign=0

00000010 struct zorro_device_id
{
  __u32 id;
  kernel_ulong_t driver_data;
};
//  0. 0000 0004 effalign(4) fda=0 bits=0000 zorro_device_id.id __u32;
//  1. 0008 0008 effalign(8) fda=0 bits=0000 zorro_device_id.driver_data kernel_ulong_t;
//          0010 effalign(8) sda=0 bits=0000 zorro_device_id struct packalign=0


MACROS
CONFIG_IP6_NF_MATCH_AH_MODULE 1
CONFIG_NLS_CODEPAGE_861_MODULE 1
CONFIG_MTD_SPI_NAND_MODULE 1
CONFIG_RING_BUFFER 1
CONFIG_HARDENED_USERCOPY_FALLBACK 1
CONFIG_UWB_HWA_MODULE 1
CONFIG_SND_SOC_WM8804_MODULE 1
CONFIG_NF_CONNTRACK_H323_MODULE 1
CONFIG_HAVE_ARCH_SECCOMP_FILTER 1
CONFIG_IP6_NF_SECURITY_MODULE 1
CONFIG_SND_PROC_FS 1
CONFIG_VFIO_PCI_MMAP 1
CONFIG_SCSI_DMA 1
CONFIG_NETFILTER_FAMILY_BRIDGE 1
CONFIG_TWL6040_CORE 1
CONFIG_VFIO_MDEV_DEVICE_MODULE 1
CONFIG_INTEL_IDLE 1
CONFIG_TOUCHSCREEN_IQS5XX_MODULE 1
CONFIG_TCP_MD5SIG 1
CONFIG_HID_GT683R_MODULE 1
CONFIG_CC_HAS_SANCOV_TRACE_PC 1
CONFIG_MICROCODE 1
CONFIG_ATM_ENI_MODULE 1
CONFIG_SOUNDWIRE_MODULE 1
CONFIG_MMA7455_MODULE 1
CONFIG_VIDEO_EM28XX_V4L2_MODULE 1
CONFIG_TI_DAC5571_MODULE 1
CONFIG_VIDEO_CS3308_MODULE 1
CONFIG_IP_SET_HASH_IPMARK_MODULE 1
CONFIG_VIDEO_ADV7511_MODULE 1
CONFIG_MAX1118_MODULE 1
CONFIG_TOUCHSCREEN_INEXIO_MODULE 1
CONFIG_RTLBTCOEXIST_MODULE 1
CONFIG_BATMAN_ADV_NC 1
CONFIG_NFT_NAT_MODULE 1
CONFIG_DW_WATCHDOG_MODULE 1
CONFIG_RTC_DRV_WM831X_MODULE 1
CONFIG_ZRAM_WRITEBACK 1
CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK 1
CONFIG_TOUCHSCREEN_WM9705 1
CONFIG_INPUT_KEYBOARD 1
CONFIG_SENSORS_ABITUGURU_MODULE 1
CONFIG_INET_TABLE_PERTURB_ORDER 16
CONFIG_ARCH_SUPPORTS_INT128 1
CONFIG_IP_NF_TARGET_SYNPROXY_MODULE 1
CONFIG_MEMORY_ISOLATION 1
CONFIG_SLUB_CPU_PARTIAL 1
CONFIG_USB_C67X00_HCD_MODULE 1
CONFIG_RFS_ACCEL 1
CONFIG_COMEDI_TEST_MODULE 1
CONFIG_SERIAL_8250_RT288X 1
CONFIG_IP_NF_TARGET_REDIRECT_MODULE 1
CONFIG_SERIO_ALTERA_PS2_MODULE 1
CONFIG_DRM_GMA500_MODULE 1
CONFIG_ARCH_WANTS_THP_SWAP 1
CONFIG_CRC32 1
CONFIG_I2C_BOARDINFO 1
CONFIG_ATH9K_HTC_DEBUGFS 1
CONFIG_DWC_XLGMAC_PCI_MODULE 1
CONFIG_TI_ADC12138_MODULE 1
CONFIG_DMI_SYSFS_MODULE 1
CONFIG_SPEAKUP_SYNTH_LTLK_MODULE 1
CONFIG_XEN_PV 1
CONFIG_DRM_VKMS_MODULE 1
CONFIG_CROS_EC_PROTO 1
CONFIG_USB_ALI_M5632 1
CONFIG_NFT_FIB_INET_MODULE 1
CONFIG_DM_SNAPSHOT_MODULE 1
CONFIG_TOUCHSCREEN_WM831X_MODULE 1
CONFIG_IP_VS_MH_MODULE 1
CONFIG_MFD_WM831X_I2C 1
CONFIG_IMA_APPRAISE_BOOTPARAM 1
CONFIG_CAIF_MODULE 1
CONFIG_PNFS_FLEXFILE_LAYOUT_MODULE 1
CONFIG_IR_JVC_DECODER_MODULE 1
CONFIG_X86_MCE 1
CONFIG_PCMCIA_QLOGIC_MODULE 1
CONFIG_SIGNED_PE_FILE_VERIFICATION 1
CONFIG_USB_CONFIGFS_NCM 1
CONFIG_DRM_NOUVEAU_MODULE 1
CONFIG_FSCACHE_MODULE 1
CONFIG_UNICODE 1
CONFIG_COMEDI_USBDUX_MODULE 1
CONFIG_PARPORT_NOT_PC 1
CONFIG_NETFILTER_XT_MATCH_CPU_MODULE 1
CONFIG_DVB_ISL6405_MODULE 1
CONFIG_B43_BCMA_PIO 1
CONFIG_AD7192_MODULE 1
CONFIG_MOUSE_ELAN_I2C_MODULE 1
CONFIG_USB_SNP_CORE_MODULE 1
CONFIG_RTC_DRV_PCF85363_MODULE 1
CONFIG_SENSORS_MAX1668_MODULE 1
CONFIG_BLK_SED_OPAL 1
CONFIG_GPIO_AMD8111_MODULE 1
CONFIG_SUNRPC_SWAP 1
CONFIG_FB_TILEBLITTING 1
CONFIG_TCM_QLA2XXX_MODULE 1
CONFIG_KEY_DH_OPERATIONS 1
CONFIG_IR_MCE_KBD_DECODER_MODULE 1
CONFIG_MFD_RT5033_MODULE 1
CONFIG_HSR_MODULE 1
CONFIG_IXGBE_DCB 1
CONFIG_NET_DSA_TAG_QCA_MODULE 1
CONFIG_CPU_FREQ_GOV_CONSERVATIVE 1
CONFIG_SECCOMP 1
CONFIG_HIGH_RES_TIMERS 1
CONFIG_PCMCIA_AXNET_MODULE 1
CONFIG_COMMON_CLK_WM831X_MODULE 1
CONFIG_BE2NET_LANCER 1
CONFIG_VIDEO_WM8739_MODULE 1
CONFIG_ARCH_HAS_SET_MEMORY 1
CONFIG_DRM_AMD_DC 1
CONFIG_MFD_CROS_EC_MODULE 1
CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG 1024
CONFIG_BLK_DEV_DM 1
CONFIG_RTC_DRV_88PM80X_MODULE 1
CONFIG_BLK_DEV_RSXX_MODULE 1
CONFIG_SND_SOC_INTEL_KBL_RT5660_MACH_MODULE 1
CONFIG_PWM_TWL_MODULE 1
CONFIG_RT2800USB_RT3573 1
CONFIG_VLAN_8021Q_MODULE 1
CONFIG_IP_MULTIPLE_TABLES 1
CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT 1
CONFIG_VFIO_PCI_VGA 1
CONFIG_ACPI_BGRT 1
CONFIG_SND_SOC_PCM1789_MODULE 1
CONFIG_SENSORS_LTC4260_MODULE 1
CONFIG_UEVENT_HELPER 1
CONFIG_CRYPTO_KEYWRAP_MODULE 1
CONFIG_XEN_DOM0 1
CONFIG_FIRMWARE_MEMMAP 1
CONFIG_SSB_SDIOHOST 1
CONFIG_BT_RFCOMM_MODULE 1
CONFIG_FIX_EARLYCON_MEM 1
CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE 1
CONFIG_DEV_APPLETALK_MODULE 1
CONFIG_RAS_CEC 1
CONFIG_INTEL_PUNIT_IPC_MODULE 1
CONFIG_ND_PFN_MODULE 1
CONFIG_CHARGER_LP8727_MODULE 1
CONFIG_SCSI_INITIO_MODULE 1
CONFIG_STK8BA50_MODULE 1
CONFIG_DVB_TDA1004X_MODULE 1
CONFIG_XZ_DEC_IA64 1
CONFIG_REGULATOR_DA9211_MODULE 1
CONFIG_RFD77402_MODULE 1
CONFIG_SND_SOC_SOF_COMETLAKE_H_SUPPORT 1
CONFIG_INPUT_RETU_PWRBUTTON_MODULE 1
CONFIG_TOUCHSCREEN_ELAN 1
CONFIG_JOYSTICK_ADI_MODULE 1
CONFIG_DVB_BCM3510_MODULE 1
CONFIG_INOTIFY_USER 1
CONFIG_SND_SOC_RT286_MODULE 1
CONFIG_WDAT_WDT_MODULE 1
CONFIG_SECURITY_NETWORK_XFRM 1
CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE 1
CONFIG_HDMI 1
CONFIG_SCSI_DH 1
CONFIG_SCSI_LOGGING 1
CONFIG_DRM_I2C_NXP_TDA9950_MODULE 1
CONFIG_SAMPLES 1
CONFIG_SX9500_MODULE 1
CONFIG_FB_CYBER2000_DDC 1
CONFIG_BRIDGE_EBT_T_FILTER_MODULE 1
CONFIG_NETWORK_FILESYSTEMS 1
CONFIG_IRQ_POLL 1
CONFIG_JOYSTICK_IFORCE_232_MODULE 1
CONFIG_B53_SERDES_MODULE 1
CONFIG_GREYBUS_LOOPBACK_MODULE 1
CONFIG_KVM_INTEL_MODULE 1
CONFIG_ASUS_LAPTOP_MODULE 1
CONFIG_NF_FLOW_TABLE_MODULE 1
CONFIG_CRYPTO_MD4_MODULE 1
CONFIG_BCMA_HOST_PCI 1
CONFIG_AD7298_MODULE 1
CONFIG_SATA_AHCI_PLATFORM_MODULE 1
CONFIG_IMA_DEFAULT_HASH_SHA1 1
CONFIG_USB_SI470X_MODULE 1
CONFIG_THERMAL_GOV_BANG_BANG 1
CONFIG_X86_MINIMUM_CPU_FAMILY 64
CONFIG_AD7923_MODULE 1
CONFIG_SND_I2S_HI6210_I2S_MODULE 1
CONFIG_SCSI_BFA_FC_MODULE 1
CONFIG_CPU_FREQ_GOV_ONDEMAND 1
CONFIG_KDB_DEFAULT_ENABLE 0x1
CONFIG_SENSORS_LM95245_MODULE 1
CONFIG_USB_GSPCA_JL2005BCD_MODULE 1
CONFIG_RTC_DRV_MC13XXX_MODULE 1
CONFIG_CM36651_MODULE 1
CONFIG_AMD_PHY_MODULE 1
CONFIG_VIDEO_CX18_ALSA_MODULE 1
CONFIG_BT_HCIBFUSB_MODULE 1
CONFIG_MFD_CS47L24 1
CONFIG_GLOB 1
CONFIG_SND_SOC_CS42L73_MODULE 1
CONFIG_PLX_HERMES_MODULE 1
CONFIG_CRYPTO_AEGIS128_MODULE 1
CONFIG_PARAVIRT_SPINLOCKS 1
CONFIG_CGROUP_DEVICE 1
CONFIG_WL12XX_MODULE 1
CONFIG_X86_TSC 1
CONFIG_104_QUAD_8_MODULE 1
CONFIG_PPP_SYNC_TTY_MODULE 1
CONFIG_ARCH_SUSPEND_POSSIBLE 1
CONFIG_HID_PLANTRONICS_MODULE 1
CONFIG_MFD_TPS65090 1
CONFIG_DA9055_WATCHDOG_MODULE 1
CONFIG_COMPAT_NETLINK_MESSAGES 1
CONFIG_INLINE_WRITE_UNLOCK_IRQ 1
CONFIG_RC_CORE_MODULE 1
CONFIG_TCG_VTPM_PROXY_MODULE 1
CONFIG_USB_G_SERIAL_MODULE 1
CONFIG_CGROUP_WRITEBACK 1
CONFIG_SND_SOC_TPA6130A2_MODULE 1
CONFIG_MISC_ALCOR_PCI_MODULE 1
CONFIG_MAC80211_STA_HASH_MAX_SIZE 0
CONFIG_LEDS_PCA955X_MODULE 1
CONFIG_NLS_MAC_TURKISH_MODULE 1
CONFIG_IXGBE_IPSEC 1
CONFIG_IP_VS_NQ_MODULE 1
CONFIG_DVB_DRXD_MODULE 1
CONFIG_IR_IMON_DECODER_MODULE 1
CONFIG_INFINIBAND_QEDR_MODULE 1
CONFIG_SENSORS_LTC4245_MODULE 1
CONFIG_HAVE_ARCH_MMAP_RND_BITS 1
CONFIG_TCG_TIS_CORE 1
CONFIG_HID_SPEEDLINK_MODULE 1
CONFIG_SPEAKUP_SYNTH_APOLLO_MODULE 1
CONFIG_HIBERNATION 1
CONFIG_BLK_DEV_NBD_MODULE 1
CONFIG_PNPACPI 1
CONFIG_AD7280_MODULE 1
CONFIG_KASAN_STACK 1
CONFIG_USB_SERIAL_NAVMAN_MODULE 1
CONFIG_CPU_FREQ_GOV_ATTR_SET 1
CONFIG_RMI4_F12 1
CONFIG_JOYSTICK_SPACEORB_MODULE 1
CONFIG_ACPI_TAD_MODULE 1
CONFIG_EDAC_I5400_MODULE 1
CONFIG_TCP_CONG_HTCP_MODULE 1
CONFIG_EXT4_FS_POSIX_ACL 1
CONFIG_SERIAL_RP2_MODULE 1
CONFIG_SCSI_DEBUG_MODULE 1
CONFIG_NET_SWITCHDEV 1
CONFIG_PHYLINK_MODULE 1
CONFIG_ZSTD_COMPRESS_MODULE 1
CONFIG_XEN_GRANT_DMA_ALLOC 1
CONFIG_DRM_I915_MODULE 1
CONFIG_BINFMT_MISC_MODULE 1
CONFIG_SENSORS_AD7314_MODULE 1
CONFIG_VME_CA91CX42_MODULE 1
CONFIG_SND_SOC_INTEL_KBL_MODULE 1
CONFIG_SND_SOC_PCM179X_I2C_MODULE 1
CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE 1
CONFIG_REGULATOR_MT6397_MODULE 1
CONFIG_SSB_POSSIBLE 1
CONFIG_HPET_MMAP_DEFAULT 1
CONFIG_NFS_V4_2 1
CONFIG_USBIP_VUDC_MODULE 1
CONFIG_BRIDGE_EBT_T_NAT_MODULE 1
CONFIG_VIDEO_SAA7134_MODULE 1
CONFIG_NF_NAT_SIP_MODULE 1
CONFIG_USB_F_EEM_MODULE 1
CONFIG_SENSORS_W83792D_MODULE 1
CONFIG_SENSORS_INA3221_MODULE 1
CONFIG_MMU_NOTIFIER 1
CONFIG_SYSV68_PARTITION 1
CONFIG_RADIO_SHARK_MODULE 1
CONFIG_ASYMMETRIC_KEY_TYPE 1
CONFIG_VFIO_VIRQFD 1
CONFIG_NET_9P_RDMA_MODULE 1
CONFIG_VHOST_VSOCK_MODULE 1
CONFIG_MOUSE_PS2_ELANTECH_SMBUS 1
CONFIG_TRANSPARENT_HUGEPAGE_MADVISE 1
CONFIG_DRM_RADEON_MODULE 1
CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE 1
CONFIG_COMEDI_NI_PCIMIO_MODULE 1
CONFIG_COMEDI_ADDI_APCI_1032_MODULE 1
CONFIG_TERANETICS_PHY_MODULE 1
CONFIG_NLS_CODEPAGE_855_MODULE 1
CONFIG_SND_SOC_INTEL_BYT_CHT_CX2072X_MACH_MODULE 1
CONFIG_SPI_DYNAMIC 1
CONFIG_ATH9K_COMMON_SPECTRAL 1
CONFIG_MTD_CMDLINE_PARTS_MODULE 1
CONFIG_TMP006_MODULE 1
CONFIG_SECURITY_YAMA 1
CONFIG_VIDEO_SAA7127_MODULE 1
CONFIG_I2C_ISMT_MODULE 1
CONFIG_AD5758_MODULE 1
CONFIG_UHID_MODULE 1
CONFIG_CRYPTO_DEV_ATMEL_ECC_MODULE 1
CONFIG_NETCONSOLE_DYNAMIC 1
CONFIG_EDAC_I5100_MODULE 1
CONFIG_DVB_EC100_MODULE 1
CONFIG_IP_NF_NAT_MODULE 1
CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE 1
CONFIG_GREYBUS_HID_MODULE 1
CONFIG_SIGNATURE 1
CONFIG_RTC_DRV_PCF50633_MODULE 1
CONFIG_HDLC_RAW_MODULE 1
CONFIG_B43LEGACY_LEDS 1
CONFIG_BME680_SPI_MODULE 1
CONFIG_USB_SERIAL_SAFE_MODULE 1
CONFIG_NFC_NCI_UART_MODULE 1
CONFIG_DVB_LGS8GL5_MODULE 1
CONFIG_KEYBOARD_CROS_EC_MODULE 1
CONFIG_INTEL_MEI_HDCP_MODULE 1
CONFIG_BRIDGE_NF_EBTABLES_MODULE 1
CONFIG_HARDLOCKUP_DETECTOR_PERF 1
CONFIG_DVB_LG2160_MODULE 1
CONFIG_MTD_AMD76XROM_MODULE 1
CONFIG_FW_LOADER_COMPRESS 1
CONFIG_USB_OHCI_LITTLE_ENDIAN 1
CONFIG_NET_SCH_FIFO 1
CONFIG_WILC1000_SPI_MODULE 1
CONFIG_REISERFS_FS_MODULE 1
CONFIG_SWPHY 1
CONFIG_STM_SOURCE_CONSOLE_MODULE 1
CONFIG_AURORA_NB8800_MODULE 1
CONFIG_TWL4030_WATCHDOG_MODULE 1
CONFIG_THP_SWAP 1
CONFIG_SATA_NV_MODULE 1
CONFIG_FSNOTIFY 1
CONFIG_ACPI_CONFIGFS_MODULE 1
CONFIG_CRYPTO_RMD128_MODULE 1
CONFIG_LEDS_MAX8997_MODULE 1
CONFIG_BLK_DEV_LOOP_MIN_COUNT 8
CONFIG_STP_MODULE 1
CONFIG_USB_GSPCA_SQ905_MODULE 1
CONFIG_MFD_TPS65910 1
CONFIG_SPI_CADENCE_MODULE 1
CONFIG_DVB_AU8522_MODULE 1
CONFIG_INET6_TUNNEL_MODULE 1
CONFIG_NVDIMM_KEYS 1
CONFIG_REGULATOR_MAX8925_MODULE 1
CONFIG_INTEL_RAPL_MODULE 1
CONFIG_VIDEO_I2C_MODULE 1
CONFIG_SCSI_DC395x_MODULE 1
CONFIG_DVB_M88RS2000_MODULE 1
CONFIG_NF_CONNTRACK_SIP_MODULE 1
CONFIG_STACK_TRACER 1
CONFIG_MEDIA_ATTACH 1
CONFIG_SND_NM256_MODULE 1
CONFIG_UCLAMP_BUCKETS_COUNT 5
CONFIG_CRYPTO_MANAGER_DISABLE_TESTS 1
CONFIG_DMA_VIRT_OPS 1
CONFIG_SENSORS_RM3100_MODULE 1
CONFIG_HIDRAW 1
CONFIG_NET_SCH_FQ_CODEL_MODULE 1
CONFIG_WIL6210_ISR_COR 1
CONFIG_SENSORS_ADM1025_MODULE 1
CONFIG_HAVE_KERNEL_LZMA 1
CONFIG_HID_PRODIKEYS_MODULE 1
CONFIG_BMA180_MODULE 1
CONFIG_NET_TC_SKB_EXT 1
CONFIG_RT2X00_LIB_LEDS 1
CONFIG_ARCH_HAS_FILTER_PGPROT 1
CONFIG_RTL8XXXU_UNTESTED 1
CONFIG_NET_PTP_CLASSIFY 1
CONFIG_UNIX_DIAG_MODULE 1
CONFIG_TSYS02D_MODULE 1
CONFIG_VCNL4000_MODULE 1
CONFIG_SND_SOC_PCM3168A_SPI_MODULE 1
CONFIG_IP_VS_SED_MODULE 1
CONFIG_GENERIC_SMP_IDLE_THREAD 1
CONFIG_HID_COUGAR_MODULE 1
CONFIG_MOUSE_CYAPA_MODULE 1
CONFIG_NET_VENDOR_QUALCOMM 1
CONFIG_DVB_DS3000_MODULE 1
CONFIG_CHARGER_LT3651_MODULE 1
CONFIG_FB_S1D13XXX_MODULE 1
CONFIG_MTD_SST25L_MODULE 1
CONFIG_ARCH_SUPPORTS_NUMA_BALANCING 1
CONFIG_REGULATOR_LP3971_MODULE 1
CONFIG_DM_FLAKEY_MODULE 1
CONFIG_HAVE_COPY_THREAD_TLS 1
CONFIG_VME_USER_MODULE 1
CONFIG_PATA_OPTIDMA_MODULE 1
CONFIG_DYNAMIC_DEBUG 1
CONFIG_MACVTAP_MODULE 1
CONFIG_LEDS_REGULATOR_MODULE 1
CONFIG_CHELSIO_T4VF_MODULE 1
CONFIG_HAVE_MEMORY_PRESENT 1
CONFIG_CPUMASK_OFFSTACK 1
CONFIG_USB_SERIAL_FTDI_SIO_MODULE 1
CONFIG_EXTCON_RT8973A_MODULE 1
CONFIG_NET_VENDOR_EZCHIP 1
CONFIG_BRIDGE_EBT_REDIRECT_MODULE 1
CONFIG_XEN_COMPAT_XENFS 1
CONFIG_XEN_SCSI_BACKEND_MODULE 1
CONFIG_INTEL_TH_PCI_MODULE 1
CONFIG_COMEDI_NI_TIOCMD_MODULE 1
CONFIG_MEDIA_DIGITAL_TV_SUPPORT 1
CONFIG_PSTORE_COMPRESS_DEFAULT "deflate"
CONFIG_8139CP_MODULE 1
CONFIG_LDISC_AUTOLOAD 1
CONFIG_GREYBUS_ES2_MODULE 1
CONFIG_SND_SOC_CROS_EC_CODEC_MODULE 1
CONFIG_SERIAL_8250_RSA 1
CONFIG_MEDIA_TUNER_QM1D1B0004_MODULE 1
CONFIG_FIB_RULES 1
CONFIG_HID_ACRUX_FF 1
CONFIG_CRYPTO_CRCT10DIF 1
CONFIG_W1_SLAVE_DS2408_MODULE 1
CONFIG_USB_CONFIGFS_OBEX 1
CONFIG_RTC_DRV_MCP795_MODULE 1
CONFIG_DVB_FIREDTV_INPUT 1
CONFIG_SND_ES1968_INPUT 1
CONFIG_SCSI_MYRB_MODULE 1
CONFIG_IP_VS_NFCT 1
CONFIG_HID_EMS_FF_MODULE 1
CONFIG_NTB_MSI 1
CONFIG_COMEDI_ADDI_APCI_16XX_MODULE 1
CONFIG_USB_AUTOSUSPEND_DELAY 2
CONFIG_VLAN_8021Q_GVRP 1
CONFIG_IWLWIFI_DEBUGFS 1
CONFIG_IP_SET_HASH_NETIFACE_MODULE 1
CONFIG_IP6_NF_MANGLE_MODULE 1
CONFIG_NET_DSA_TAG_DSA_MODULE 1
CONFIG_MTD_PLATRAM_MODULE 1
CONFIG_SND_SOC_ES8316_MODULE 1
CONFIG_SIOX_BUS_GPIO_MODULE 1
CONFIG_MEDIA_TUNER_SI2157_MODULE 1
CONFIG_SCSI_CONSTANTS 1
CONFIG_HAVE_IRQ_TIME_ACCOUNTING 1
CONFIG_CFAG12864B_MODULE 1
CONFIG_BT_MRVL_SDIO_MODULE 1
CONFIG_NETFILTER_XT_MATCH_REALM_MODULE 1
CONFIG_SFC_FALCON_MODULE 1
CONFIG_BT_HCIBPA10X_MODULE 1
CONFIG_MEGARAID_NEWGEN 1
CONFIG_INTEL_TXT 1
CONFIG_HID_GFRM_MODULE 1
CONFIG_SQUASHFS_XATTR 1
CONFIG_NET_DSA_MICROCHIP_KSZ_COMMON_MODULE 1
CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED 1
CONFIG_IP_VS_RR_MODULE 1
CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH_MODULE 1
CONFIG_IPV6 1
CONFIG_ALTERA_PR_IP_CORE_MODULE 1
CONFIG_USB_SERIAL_QUALCOMM_MODULE 1
CONFIG_HAVE_STACKPROTECTOR 1
CONFIG_MAX1027_MODULE 1
CONFIG_INFINIBAND_HFI1_MODULE 1
CONFIG_VIDEO_S5K6A3_MODULE 1
CONFIG_MT76x02_LIB_MODULE 1
CONFIG_NET_9P_MODULE 1
CONFIG_REGULATOR_TPS62360_MODULE 1
CONFIG_CRYPTO_AEAD 1
CONFIG_USB_GADGET_TARGET_MODULE 1
CONFIG_FB_HECUBA_MODULE 1
CONFIG_AUDIT_ARCH 1
CONFIG_NET_EMATCH_IPT_MODULE 1
CONFIG_SENSORS_W83773G_MODULE 1
CONFIG_COMPAT 1
CONFIG_POWERCAP 1
CONFIG_MAGIC_SYSRQ_SERIAL 1
CONFIG_LIQUIDIO_VF_MODULE 1
CONFIG_BQL 1
CONFIG_ADJD_S311_MODULE 1
CONFIG_INPUT_MOUSEDEV_PSAUX 1
CONFIG_RESET_TI_SYSCON_MODULE 1
CONFIG_HAVE_KERNEL_BZIP2 1
CONFIG_COMEDI_ADDI_APCI_3501_MODULE 1
CONFIG_DEFAULT_TCP_CONG "cubic"
CONFIG_MOST_NET_MODULE 1
CONFIG_USB_EHCI_FSL_MODULE 1
CONFIG_MCP4725_MODULE 1
CONFIG_UEVENT_HELPER_PATH ""
CONFIG_USB_UAS_MODULE 1
CONFIG_U_SERIAL_CONSOLE 1
CONFIG_VIDEO_MT9M001_MODULE 1
CONFIG_ORANGEFS_FS_MODULE 1
CONFIG_NTB_NETDEV_MODULE 1
CONFIG_DEVTMPFS 1
CONFIG_NET_CLS_FLOW_MODULE 1
CONFIG_PROCESSOR_SELECT 1
CONFIG_PCENGINES_APU2_MODULE 1
CONFIG_X86_INTEL_TSX_MODE_OFF 1
CONFIG_TIGON3_HWMON 1
CONFIG_SENSORS_MAX8688_MODULE 1
CONFIG_SENSORS_PC87427_MODULE 1
CONFIG_INPUT_MAX77693_HAPTIC_MODULE 1
CONFIG_SM_FTL_MODULE 1
CONFIG_TI_ADC108S102_MODULE 1
CONFIG_PNFS_FILE_LAYOUT_MODULE 1
CONFIG_MCB_LPC_MODULE 1
CONFIG_QED_SRIOV 1
CONFIG_HSU_DMA_MODULE 1
CONFIG_I82092_MODULE 1
CONFIG_NET_IPVTI_MODULE 1
CONFIG_SCSI_PMCRAID_MODULE 1
CONFIG_NFC_NXP_NCI_MODULE 1
CONFIG_DVB_ISL6423_MODULE 1
CONFIG_FB_S3_DDC 1
CONFIG_USB_STORAGE_USBAT_MODULE 1
CONFIG_REISERFS_FS_POSIX_ACL 1
CONFIG_SND_FIREWIRE_DIGI00X_MODULE 1
CONFIG_INFINIBAND_USER_MEM 1
CONFIG_REGULATOR_ARIZONA_LDO1_MODULE 1
CONFIG_GPIO_MAX7301_MODULE 1
CONFIG_INPUT_88PM80X_ONKEY_MODULE 1
CONFIG_APPLE_GMUX_MODULE 1
CONFIG_YENTA_RICOH 1
CONFIG_SUNRPC_BACKCHANNEL 1
CONFIG_NLS_ISO8859_7_MODULE 1
CONFIG_QEDF_MODULE 1
CONFIG_ANDROID_BINDER_IPC_MODULE 1
CONFIG_UNISYS_VISORNIC_MODULE 1
CONFIG_MOUSE_PS2_SMBUS 1
CONFIG_SND_SOC_TLV320AIC32X4_SPI_MODULE 1
CONFIG_CRYPTO_PCBC_MODULE 1
CONFIG_IP6_NF_TARGET_REJECT_MODULE 1
CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX 16
CONFIG_UPROBES 1
CONFIG_PWM_PCA9685_MODULE 1
CONFIG_IR_SHARP_DECODER_MODULE 1
CONFIG_HID_APPLEIR_MODULE 1
CONFIG_COMEDI_PCL812_MODULE 1
CONFIG_NFC_FDP_MODULE 1
CONFIG_ASYNC_MEMCPY_MODULE 1
CONFIG_RTC_DRV_MAX8998_MODULE 1
CONFIG_ADIS16480_MODULE 1
CONFIG_X86_POWERNOW_K8 1
CONFIG_ARCH_SPARSEMEM_ENABLE 1
CONFIG_V4L_TEST_DRIVERS 1
CONFIG_NFT_OSF_MODULE 1
CONFIG_SC1200_WDT_MODULE 1
CONFIG_NF_NAT_REDIRECT 1
CONFIG_DCDBAS_MODULE 1
CONFIG_CIO_DAC_MODULE 1
CONFIG_RTC_DRV_DS1305_MODULE 1
CONFIG_SFP_MODULE 1
CONFIG_CAIF_SPI_SLAVE_MODULE 1
CONFIG_IR_NEC_DECODER_MODULE 1
CONFIG_HOTPLUG_CPU 1
CONFIG_SECURITY_LOCKDOWN_LSM 1
CONFIG_USB_SERIAL_MOS7840_MODULE 1
CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM 1
CONFIG_INET_DIAG_DESTROY 1
CONFIG_NLS_MAC_CYRILLIC_MODULE 1
CONFIG_USB_SL811_HCD_ISO 1
CONFIG_PM_SLEEP_DEBUG 1
CONFIG_SND_MAESTRO3_INPUT 1
CONFIG_MEDIA_PCI_SUPPORT 1
CONFIG_WLAN 1
CONFIG_EDAC_I10NM_MODULE 1
CONFIG_AFFS_FS_MODULE 1
CONFIG_COMEDI_ADDI_APCI_1516_MODULE 1
CONFIG_ATM_FIRESTREAM_MODULE 1
CONFIG_NFP_MODULE 1
CONFIG_NAMESPACES 1
CONFIG_VIDEO_AK881X_MODULE 1
CONFIG_USB_U_AUDIO_MODULE 1
CONFIG_BLK_RQ_ALLOC_TIME 1
CONFIG_W1_SLAVE_DS2423_MODULE 1
CONFIG_L2TP_DEBUGFS_MODULE 1
CONFIG_XEN_512GB 1
CONFIG_HAVE_CMPXCHG_DOUBLE 1
CONFIG_CROS_EC_SYSFS_MODULE 1
CONFIG_RTC_DRV_ABX80X_MODULE 1
CONFIG_USB_NET_INT51X1_MODULE 1
CONFIG_KGDB_SERIAL_CONSOLE 1
CONFIG_PATA_ATP867X_MODULE 1
CONFIG_ARCH_USE_MEMREMAP_PROT 1
CONFIG_SFI 1
CONFIG_HAVE_ARCH_HUGE_VMAP 1
CONFIG_FM10K_MODULE 1
CONFIG_DW_DMAC_PCI_MODULE 1
CONFIG_IA32_EMULATION 1
CONFIG_SND_SOC_SIGMADSP_MODULE 1
CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY 1
CONFIG_USB_CONFIGFS_MODULE 1
CONFIG_FORTIFY_SOURCE 1
CONFIG_COMEDI_CONTEC_PCI_DIO_MODULE 1
CONFIG_AXP20X_ADC_MODULE 1
CONFIG_BLK_DEV_BSG 1
CONFIG_CRYPTO_ADIANTUM_MODULE 1
CONFIG_LEDS_WM8350_MODULE 1
CONFIG_ENIC_MODULE 1
CONFIG_SCSI_ISCI_MODULE 1
CONFIG_SENSORS_MAX6697_MODULE 1
CONFIG_PATA_SERVERWORKS_MODULE 1
CONFIG_CONNECTOR 1
CONFIG_COMEDI_DAS16M1_MODULE 1
CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_ACPI_MODULE 1
CONFIG_MEDIA_USB_SUPPORT 1
CONFIG_MFD_TPS68470 1
CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE 1
CONFIG_PCIEAER 1
CONFIG_EPIC100_MODULE 1
CONFIG_SCTP_COOKIE_HMAC_SHA1 1
CONFIG_BRIDGE_EBT_ARPREPLY_MODULE 1
CONFIG_BACKLIGHT_APPLE_MODULE 1
CONFIG_B43LEGACY_DMA_AND_PIO_MODE 1
CONFIG_RTC_DRV_SD3078_MODULE 1
CONFIG_MEM_SOFT_DIRTY 1
CONFIG_PARIDE_MODULE 1
CONFIG_KVM_DEBUG_FS 1
CONFIG_INTEGRITY 1
CONFIG_MPL115_MODULE 1
CONFIG_TQMX86_WDT_MODULE 1
CONFIG_DVB_MAX_ADAPTERS 8
CONFIG_SENSORS_SIS5595_MODULE 1
CONFIG_EISA_PCI_EISA 1
CONFIG_MPU3050_I2C_MODULE 1
CONFIG_CRYPTO_AEGIS128_AESNI_SSE2_MODULE 1
CONFIG_CW1200_WLAN_SDIO_MODULE 1
CONFIG_DM_MULTIPATH_QL_MODULE 1
CONFIG_LEGACY_PTYS 1
CONFIG_LIBERTAS_USB_MODULE 1
CONFIG_JFS_FS_MODULE 1
CONFIG_CAN_EMS_USB_MODULE 1
CONFIG_XFRM_IPCOMP_MODULE 1
CONFIG_CRYPTO_DRBG_MENU 1
CONFIG_CRYPTO_RNG2 1
CONFIG_UIO_CIF_MODULE 1
CONFIG_USB_PWC_INPUT_EVDEV 1
CONFIG_MDIO_I2C_MODULE 1
CONFIG_FUSION_FC_MODULE 1
CONFIG_NETFILTER_NETLINK_QUEUE_MODULE 1
CONFIG_MFD_CROS_EC_DEV_MODULE 1
CONFIG_NET_ACT_CSUM_MODULE 1
CONFIG_RTLLIB_CRYPTO_CCMP_MODULE 1
CONFIG_CEPH_LIB_USE_DNS_RESOLVER 1
CONFIG_RTC_DRV_AB3100_MODULE 1
CONFIG_DVB_CXD2880_MODULE 1
CONFIG_THERMAL_WRITABLE_TRIPS 1
CONFIG_SCSI_MPT3SAS_MODULE 1
CONFIG_NFTL_RW 1
CONFIG_MFD_MC13XXX_MODULE 1
CONFIG_NETWORK_PHY_TIMESTAMPING 1
CONFIG_MSDOS_FS_MODULE 1
CONFIG_SENSORS_ISL29028_MODULE 1
CONFIG_COMEDI_DT2811_MODULE 1
CONFIG_USB_U_SERIAL_MODULE 1
CONFIG_GREYBUS_UART_MODULE 1
CONFIG_FB_VGA16_MODULE 1
CONFIG_SCSI_FLASHPOINT 1
CONFIG_NET_CLS_CGROUP_MODULE 1
CONFIG_TUN 1
CONFIG_SND_SOC_ES8328_MODULE 1
CONFIG_MB1232_MODULE 1
CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC 1
CONFIG_IP_VS_FO_MODULE 1
CONFIG_USB_GSPCA_SUNPLUS_MODULE 1
CONFIG_HYPERV_TIMER 1
CONFIG_SND_SOC_SOF_INTEL_ATOM_HIFI_EP_MODULE 1
CONFIG_VZ89X_MODULE 1
CONFIG_COMEDI_DAS6402_MODULE 1
CONFIG_ATM_IDT77252_MODULE 1
CONFIG_DVB_AU8522_V4L_MODULE 1
CONFIG_AD9832_MODULE 1
CONFIG_GREYBUS_BRIDGED_PHY_MODULE 1
CONFIG_IIO_KFIFO_BUF_MODULE 1
CONFIG_ENCLOSURE_SERVICES_MODULE 1
CONFIG_UCSI_ACPI_MODULE 1
CONFIG_IPV6_PIMSM_V2 1
CONFIG_ARCH_ENABLE_THP_MIGRATION 1
CONFIG_USB_XHCI_DBGCAP 1
CONFIG_DVB_USB_DVBSKY_MODULE 1
CONFIG_WIZNET_BUS_ANY 1
CONFIG_BNX2_MODULE 1
CONFIG_LEDS_TRIGGER_DISK 1
CONFIG_CAN_MODULE 1
CONFIG_SND_VX222_MODULE 1
CONFIG_CFG80211_MODULE 1
CONFIG_MACSEC_MODULE 1
CONFIG_CRYPTO_CHACHA20POLY1305_MODULE 1
CONFIG_SSB_BLOCKIO 1
CONFIG_MTD_BLOCK_RO_MODULE 1
CONFIG_CRYPTO_DEV_CHELSIO_MODULE 1
CONFIG_MFD_DA9063 1
CONFIG_EQUALIZER_MODULE 1
CONFIG_SAMPLE_TRACE_PRINTK_MODULE 1
CONFIG_HUAWEI_WMI_MODULE 1
CONFIG_COMEDI_JR3_PCI_MODULE 1
CONFIG_SND_AU8810_MODULE 1
CONFIG_GPIO_LYNXPOINT 1
CONFIG_IP_SET_HASH_NETNET_MODULE 1
CONFIG_SENSORS_MAX6621_MODULE 1
CONFIG_NFT_OBJREF_MODULE 1
CONFIG_NLS_CODEPAGE_1250_MODULE 1
CONFIG_COMEDI_NI_6527_MODULE 1
CONFIG_VFIO_PCI_IGD 1
CONFIG_SND_SOC_AK4118_MODULE 1
CONFIG_DM_CRYPT_MODULE 1
CONFIG_REED_SOLOMON_ENC8 1
CONFIG_REGULATOR_PV88060_MODULE 1
CONFIG_SND_SOC_SOF_OPTIONS_MODULE 1
CONFIG_SERIAL_8250 1
CONFIG_RTC_DRV_ISL12022_MODULE 1
CONFIG_SND_SOC_TSCS454_MODULE 1
CONFIG_RANDOM_TRUST_CPU 1
CONFIG_PWM_CROS_EC_MODULE 1
CONFIG_MLXREG_HOTPLUG_MODULE 1
CONFIG_XEN_GNTDEV_MODULE 1
CONFIG_XZ_DEC_TEST_MODULE 1
CONFIG_SENSORS_W83793_MODULE 1
CONFIG_PI433_MODULE 1
CONFIG_B43LEGACY_PIO 1
CONFIG_LZO_DECOMPRESS 1
CONFIG_USB_EHCI_ROOT_HUB_TT 1
CONFIG_LIBERTAS_THINFIRM_MODULE 1
CONFIG_IP_VS_PROTO_AH 1
CONFIG_SCSI_UFS_CDNS_PLATFORM_MODULE 1
CONFIG_IOMMU_SUPPORT 1
CONFIG_HID_BELKIN_MODULE 1
CONFIG_VIDEO_IR_I2C_MODULE 1
CONFIG_ROMFS_BACKED_BY_BLOCK 1
CONFIG_VFIO_IOMMU_TYPE1 1
CONFIG_DVB_STV0367_MODULE 1
CONFIG_STMMAC_PLATFORM_MODULE 1
CONFIG_LEDS_TRIGGER_CAMERA_MODULE 1
CONFIG_VIDEO_OV2640_MODULE 1
CONFIG_NLS_CODEPAGE_862_MODULE 1
CONFIG_WLAN_VENDOR_CISCO 1
CONFIG_CRAMFS_BLOCKDEV 1
CONFIG_NFSD_MODULE 1
CONFIG_ISDN_DRV_AVMB1_C4_MODULE 1
CONFIG_SENSORS_TSL2550_MODULE 1
CONFIG_ITG3200_MODULE 1
CONFIG_SND_SOC_INTEL_DA7219_MAX98357A_GENERIC_MODULE 1
CONFIG_COMPAT_BINFMT_ELF 1
CONFIG_VFIO_PCI 1
CONFIG_PWM_LPSS 1
CONFIG_X86_DIRECT_GBPAGES 1
CONFIG_VIDEO_IVTV_ALSA_MODULE 1
CONFIG_PATA_MPIIX_MODULE 1
CONFIG_USB_SERIAL_OPTION_MODULE 1
CONFIG_HID_ACRUX_MODULE 1
CONFIG_RD_LZMA 1
CONFIG_USB_GSPCA_SE401_MODULE 1
CONFIG_CRYPTO_SALSA20_MODULE 1
CONFIG_PINCTRL_GEMINILAKE_MODULE 1
CONFIG_USB 1
CONFIG_PATA_SIL680_MODULE 1
CONFIG_ACPI_IPMI_MODULE 1
CONFIG_SND_SOC_RT5651_MODULE 1
CONFIG_CHARGER_MAX8998_MODULE 1
CONFIG_CHARGER_AXP20X_MODULE 1
CONFIG_MMC_SDHCI_PCI_MODULE 1
CONFIG_USB_SPEEDTOUCH_MODULE 1
CONFIG_I2C_XILINX_MODULE 1
CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK 1
CONFIG_REGULATOR_88PM8607_MODULE 1
CONFIG_ALIM7101_WDT_MODULE 1
CONFIG_ACPI_PCI_SLOT 1
CONFIG_PM_WAKELOCKS_GC 1
CONFIG_NFC_MRVL_I2C_MODULE 1
CONFIG_MODULES_USE_ELF_RELA 1
CONFIG_AD5686_MODULE 1
CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT 1
CONFIG_SND_BCD2000_MODULE 1
CONFIG_BTREE 1
CONFIG_CRYPTO_HMAC 1
CONFIG_WLAN_VENDOR_REALTEK 1
CONFIG_BLK_WBT 1
CONFIG_INPUT_ADXL34X_SPI_MODULE 1
CONFIG_ETHERNET 1
CONFIG_PATA_CMD640_PCI_MODULE 1
CONFIG_KXSD9_SPI_MODULE 1
CONFIG_VFIO_NOIOMMU 1
CONFIG_NET_SCH_CODEL_MODULE 1
CONFIG_JFFS2_LZO 1
CONFIG_FRAMEBUFFER_CONSOLE_ROTATION 1
CONFIG_NVME_TARGET_FC_MODULE 1
CONFIG_SND_SOC_PCM3060_I2C_MODULE 1
CONFIG_INPUT_BMA150_MODULE 1
CONFIG_USBIP_VHCI_HC_PORTS 8
CONFIG_USB_GSPCA_JEILINJ_MODULE 1
CONFIG_SCHED_OMIT_FRAME_POINTER 1
CONFIG_HID_LOGITECH_HIDPP_MODULE 1
CONFIG_CRYPTO_SHA3_MODULE 1
CONFIG_RETU_WATCHDOG_MODULE 1
CONFIG_UBIFS_FS_ZSTD 1
CONFIG_BRANCH_PROFILE_NONE 1
CONFIG_SCSI_SCAN_ASYNC 1
CONFIG_VIDEO_IMX274_MODULE 1
CONFIG_SPI_DW_MMIO_MODULE 1
CONFIG_CRC_ITU_T_MODULE 1
CONFIG_NET_DROP_MONITOR 1
CONFIG_SND_HRTIMER_MODULE 1
CONFIG_HAVE_DMA_CONTIGUOUS 1
CONFIG_RAPIDIO_DISC_TIMEOUT 30
CONFIG_DQL 1
CONFIG_VXLAN_MODULE 1
CONFIG_PINCTRL_BROXTON_MODULE 1
CONFIG_PARPORT_PC_PCMCIA_MODULE 1
CONFIG_FRAMEBUFFER_CONSOLE 1
CONFIG_SND_SOC_PCM512x_I2C_MODULE 1
CONFIG_RMI4_F55 1
CONFIG_DM_ZERO_MODULE 1
CONFIG_DVB_DIB8000_MODULE 1
CONFIG_X86_SUPPORTS_MEMORY_FAILURE 1
CONFIG_FPGA_DFL_FME_MGR_MODULE 1
CONFIG_CROS_USBPD_LOGGER_MODULE 1
CONFIG_SND_SEQUENCER_MODULE 1
CONFIG_TCP_CONG_LP_MODULE 1
CONFIG_SONY_FF 1
CONFIG_PINCTRL_BAYTRAIL 1
CONFIG_INPUT_GP2A_MODULE 1
CONFIG_AD5064_MODULE 1
CONFIG_GAMEPORT_EMU10K1_MODULE 1
CONFIG_SOCK_CGROUP_DATA 1
CONFIG_WL1251_SPI_MODULE 1
CONFIG_SND_BEBOB_MODULE 1
CONFIG_COREDUMP 1
CONFIG_NET_FOU_IP_TUNNELS 1
CONFIG_USB_NET_GL620A_MODULE 1
CONFIG_MICREL_KS8995MA_MODULE 1
CONFIG_DVB_LGDT3306A_MODULE 1
CONFIG_COMEDI_ADDI_APCI_1500_MODULE 1
CONFIG_SND_OPL3_LIB_MODULE 1
CONFIG_IP_NF_ARPTABLES_MODULE 1
CONFIG_USB_CONFIGFS_F_TCM 1
CONFIG_REGULATOR_SKY81452_MODULE 1
CONFIG_DVB_ASCOT2E_MODULE 1
CONFIG_DVB_USB_GP8PSK_MODULE 1
CONFIG_USB_SERIAL_GENERIC 1
CONFIG_HID_CHERRY_MODULE 1
CONFIG_PC87413_WDT_MODULE 1
CONFIG_CAN_J1939_MODULE 1
CONFIG_LEDS_LM3532_MODULE 1
CONFIG_SND_SOC_IMX_AUDMUX_MODULE 1
CONFIG_JFFS2_COMPRESSION_OPTIONS 1
CONFIG_CM3323_MODULE 1
CONFIG_BATTERY_MAX17040_MODULE 1
CONFIG_USERIO_MODULE 1
CONFIG_MKISS_MODULE 1
CONFIG_USE_PERCPU_NUMA_NODE_ID 1
CONFIG_NFT_FIB_MODULE 1
CONFIG_HID_SUNPLUS_MODULE 1
CONFIG_DRM_VMWGFX_FBCON 1
CONFIG_INPUT_ADXL34X_MODULE 1
CONFIG_KSZ884X_PCI_MODULE 1
CONFIG_HID_PICOLCD_MODULE 1
CONFIG_BCMA_POSSIBLE 1
CONFIG_USB_CONFIGFS_RNDIS 1
CONFIG_NF_LOG_IPV4_MODULE 1
CONFIG_IEEE802154_MCR20A_MODULE 1
CONFIG_NET_SCH_SFB_MODULE 1
CONFIG_LEDS_LP5521_MODULE 1
CONFIG_NET_VENDOR_CIRRUS 1
CONFIG_FUSION_CTL_MODULE 1
CONFIG_TULIP_MODULE 1
CONFIG_FB_SM750_MODULE 1
CONFIG_AF_RXRPC_MODULE 1
CONFIG_ZRAM_MODULE 1
CONFIG_CRYPTO_CAST5_MODULE 1
CONFIG_VGA_ARB 1
CONFIG_FB_INTEL_I2C 1
CONFIG_SENSORS_CORETEMP_MODULE 1
CONFIG_PARIDE_FIT2_MODULE 1
CONFIG_NF_TABLES_ARP 1
CONFIG_SND_SOC_ACPI_MODULE 1
CONFIG_FB_CARMINE_DRAM_EVAL 1
CONFIG_FB_NVIDIA_BACKLIGHT 1
CONFIG_SND_SOC_MODULE 1
CONFIG_NET_DSA_MV88E6060_MODULE 1
CONFIG_FXAS21002C_I2C_MODULE 1
CONFIG_MAXIM_THERMOCOUPLE_MODULE 1
CONFIG_REGULATOR_TPS51632_MODULE 1
CONFIG_FIREWIRE_SBP2_MODULE 1
CONFIG_MFD_MAX77693 1
CONFIG_SECURITY_TOMOYO_POLICY_LOADER "/sbin/tomoyo-init"
CONFIG_NET_IPGRE_DEMUX_MODULE 1
CONFIG_COMEDI_MULTIQ3_MODULE 1
CONFIG_MEDIA_TUNER_XC5000_MODULE 1
CONFIG_NET_POLL_CONTROLLER 1
CONFIG_PRINTK 1
CONFIG_SPEAKUP_SYNTH_BNS_MODULE 1
CONFIG_6LOWPAN_NHC_ROUTING_MODULE 1
CONFIG_SFC_MODULE 1
CONFIG_PHANTOM_MODULE 1
CONFIG_HTC_I2CPLD 1
CONFIG_SERIAL_8250_FINTEK 1
CONFIG_PINCTRL_CANNONLAKE_MODULE 1
CONFIG_BMC150_ACCEL_MODULE 1
CONFIG_FORCEDETH_MODULE 1
CONFIG_ACPI_LPIT 1
CONFIG_COMEDI_DAS08_CS_MODULE 1
CONFIG_FB_SYS_FILLRECT_MODULE 1
CONFIG_TIMERFD 1
CONFIG_SPI_AXI_SPI_ENGINE_MODULE 1
CONFIG_HID_THRUSTMASTER_MODULE 1
CONFIG_SND_SOC_RK3328_MODULE 1
CONFIG_VIDEO_SECO_RC 1
CONFIG_IPMI_PLAT_DATA 1
CONFIG_USB_DYNAMIC_MINORS 1
CONFIG_SENSORS_MAX16065_MODULE 1
CONFIG_TOUCHSCREEN_CYTTSP_I2C_MODULE 1
CONFIG_SENSORS_I5K_AMB_MODULE 1
CONFIG_DNS_RESOLVER 1
CONFIG_B53_MMAP_DRIVER_MODULE 1
CONFIG_ITCO_VENDOR_SUPPORT 1
CONFIG_TRACEPOINTS 1
CONFIG_B43_PHY_LP 1
CONFIG_MTD_CFI_I2 1
CONFIG_IKHEADERS_MODULE 1
CONFIG_CRYPTO_AUTHENC_MODULE 1
CONFIG_AT803X_PHY_MODULE 1
CONFIG_DVB_SP8870_MODULE 1
CONFIG_I6300ESB_WDT_MODULE 1
CONFIG_GPIO_ML_IOH_MODULE 1
CONFIG_YENTA_MODULE 1
CONFIG_USB_GPIO_VBUS_MODULE 1
CONFIG_W1_MASTER_DS2482_MODULE 1
CONFIG_JOYSTICK_SIDEWINDER_MODULE 1
CONFIG_BLK_DEV_SKD_MODULE 1
CONFIG_NET_EMATCH_STACK 32
CONFIG_SRF04_MODULE 1
CONFIG_CARL9170_LEDS 1
CONFIG_VIDEO_V4L2_SUBDEV_API 1
CONFIG_UCLAMP_TASK_GROUP 1
CONFIG_ATL1E_MODULE 1
CONFIG_USB_STORAGE_ENE_UB6250_MODULE 1
CONFIG_LEDS_TRIGGER_ACTIVITY_MODULE 1
CONFIG_DVB_DDBRIDGE_MODULE 1
CONFIG_NLS_MAC_CENTEURO_MODULE 1
CONFIG_BRCMFMAC_SDIO 1
CONFIG_BOUNCE 1
CONFIG_ARCH_HAS_SYSCALL_WRAPPER 1
CONFIG_LEDS_DA903X_MODULE 1
CONFIG_DWMAC_GENERIC_MODULE 1
CONFIG_RDS_RDMA_MODULE 1
CONFIG_AD5592R_MODULE 1
CONFIG_NUMA_BALANCING 1
CONFIG_I2C_DESIGNWARE_BAYTRAIL 1
CONFIG_THINKPAD_ACPI_MODULE 1
CONFIG_P54_COMMON_MODULE 1
CONFIG_COMPAT_32BIT_TIME 1
CONFIG_SECURITY_APPARMOR_HASH 1
CONFIG_SHMEM 1
CONFIG_MTD_MODULE 1
CONFIG_MIGRATION 1
CONFIG_HAVE_ARCH_JUMP_LABEL 1
CONFIG_LEDS_PCA9532_GPIO 1
CONFIG_COMEDI_C6XDIGIO_MODULE 1
CONFIG_BUILD_SALT ""
CONFIG_MMC_BLOCK_MINORS 8
CONFIG_SND_XEN_FRONTEND_MODULE 1
CONFIG_IIO_SSP_SENSORS_COMMONS_MODULE 1
CONFIG_USB_HSO_MODULE 1
CONFIG_HID_PRIMAX_MODULE 1
CONFIG_SND_SOC_SOF_COFFEELAKE_MODULE 1
CONFIG_HAVE_ARCH_PREL32_RELOCATIONS 1
CONFIG_DECOMPRESS_LZMA 1
CONFIG_SYSTEM_REVOCATION_LIST 1
CONFIG_PCI_IOV 1
CONFIG_WATCHDOG_SYSFS 1
CONFIG_SENSORS_IIO_HWMON_MODULE 1
CONFIG_HAVE_KVM_EVENTFD 1
CONFIG_SND_SOC_WM8776_MODULE 1
CONFIG_GPIO_VIPERBOARD_MODULE 1
CONFIG_QED_LL2 1
CONFIG_DEVTMPFS_MOUNT 1
CONFIG_PM_DEVFREQ_EVENT 1
CONFIG_SND_HDA_DSP_LOADER 1
CONFIG_SENSORS_AMC6821_MODULE 1
CONFIG_MFD_SI476X_CORE_MODULE 1
CONFIG_USB_IPHETH_MODULE 1
CONFIG_IXGBEVF_IPSEC 1
CONFIG_TOUCHSCREEN_TI_AM335X_TSC_MODULE 1
CONFIG_NLS_CODEPAGE_850_MODULE 1
CONFIG_DVB_CX22700_MODULE 1
CONFIG_SOCK_VALIDATE_XMIT 1
CONFIG_DNOTIFY 1
CONFIG_ACRN_GUEST 1
CONFIG_COMEDI_DAS800_MODULE 1
CONFIG_CRYPTO_CTS 1
CONFIG_STAGING_APEX_DRIVER_MODULE 1
CONFIG_KEYBOARD_LM8333_MODULE 1
CONFIG_NET_DSA_MICROCHIP_KSZ9477_MODULE 1
CONFIG_DRM_AMD_DC_DCN2_1 1
CONFIG_SND_USB_PODHD_MODULE 1
CONFIG_DVB_USB_UMT_010_MODULE 1
CONFIG_SUNGEM_PHY_MODULE 1
CONFIG_EDD 1
CONFIG_JOYSTICK_DB9_MODULE 1
CONFIG_EFI_CUSTOM_SSDT_OVERLAYS 1
CONFIG_IMA_TRUSTED_KEYRING 1
CONFIG_RTC_DRV_R9701_MODULE 1
CONFIG_NFC_S3FWRN5_I2C_MODULE 1
CONFIG_THERMAL_STATISTICS 1
CONFIG_SCSI_UFSHCD_MODULE 1
CONFIG_INPUT_MOUSEDEV 1
CONFIG_GENERIC_NET_UTILS 1
CONFIG_IPV6_ILA_MODULE 1
CONFIG_FB_RADEON_BACKLIGHT 1
CONFIG_LIBERTAS_CS_MODULE 1
CONFIG_REGULATOR_MC13XXX_CORE_MODULE 1
CONFIG_INPUT_WM831X_ON_MODULE 1
CONFIG_TOUCHSCREEN_EKTF2127_MODULE 1
CONFIG_ATA 1
CONFIG_KEYBOARD_SUNKBD_MODULE 1
CONFIG_SND_SOC_CS42XX8_MODULE 1
CONFIG_RTC_DRV_PALMAS_MODULE 1
CONFIG_SENSORS_TPS40422_MODULE 1
CONFIG_GPIO_MAX730X_MODULE 1
CONFIG_USB_ROLE_SWITCH_MODULE 1
CONFIG_MFD_WM8994_MODULE 1
CONFIG_PCMCIA_3C589_MODULE 1
CONFIG_CRYPTO_DES_MODULE 1
CONFIG_RTW88_PCI_MODULE 1
CONFIG_TOUCHSCREEN_WM9712 1
CONFIG_GPIOLIB_FASTPATH_LIMIT 512
CONFIG_CEPH_LIB_MODULE 1
CONFIG_INTEL_SPEED_SELECT_INTERFACE_MODULE 1
CONFIG_REMOTEPROC 1
CONFIG_GPIO_LP3943_MODULE 1
CONFIG_STM_MODULE 1
CONFIG_COMEDI_MF6X4_MODULE 1
CONFIG_SND_SOC_COMPRESS 1
CONFIG_ND_BTT_MODULE 1
CONFIG_XEN_MCE_LOG 1
CONFIG_NLS_CODEPAGE_437 1
CONFIG_HAVE_ARCH_SOFT_DIRTY 1
CONFIG_SND_SOC_INNO_RK3036_MODULE 1
CONFIG_HYPERV_KEYBOARD_MODULE 1
CONFIG_EFI_RCI2_TABLE 1
CONFIG_INTEL_TH_GTH_MODULE 1
CONFIG_BACKLIGHT_DA9052_MODULE 1
CONFIG_NATSEMI_MODULE 1
CONFIG_ARCH_PROC_KCORE_TEXT 1
CONFIG_NET_CLS_U32_MODULE 1
CONFIG_SND_SOC_SOF_INTEL_ACPI_MODULE 1
CONFIG_NETFILTER_NETLINK_GLUE_CT 1
CONFIG_MISDN_MODULE 1
CONFIG_EXPORTFS 1
CONFIG_MTD_UBI_WL_THRESHOLD 4096
CONFIG_BMC150_MAGN_I2C_MODULE 1
CONFIG_RTC_DRV_MAX8907_MODULE 1
CONFIG_AD525X_DPOT_I2C_MODULE 1
CONFIG_MMC_RICOH_MMC 1
CONFIG_HID_SENSOR_HUB_MODULE 1
CONFIG_SND_MIXER_OSS_MODULE 1
CONFIG_TOUCHSCREEN_PENMOUNT_MODULE 1
CONFIG_IP6_NF_MATCH_MH_MODULE 1
CONFIG_IP_MROUTE_COMMON 1
CONFIG_SENSORS_PXE1610_MODULE 1
CONFIG_NET_INGRESS 1
CONFIG_DVB_S921_MODULE 1
CONFIG_MSI_WMI_MODULE 1
CONFIG_IT87_WDT_MODULE 1
CONFIG_LRU_CACHE_MODULE 1
CONFIG_SCSI_CXGB3_ISCSI_MODULE 1
CONFIG_HAVE_FUNCTION_ERROR_INJECTION 1
CONFIG_REGULATOR_LP3972_MODULE 1
CONFIG_SND_DARLA24_MODULE 1
CONFIG_SENSORS_MAX1619_MODULE 1
CONFIG_IPW2200_MONITOR 1
CONFIG_DVB_AF9013_MODULE 1
CONFIG_PCMCIA_SYM53C500_MODULE 1
CONFIG_OLD_SIGSUSPEND3 1
CONFIG_SERIO 1
CONFIG_DVB_USB_DTV5100_MODULE 1
CONFIG_SCHEDSTATS 1
CONFIG_TYPEC_UCSI_MODULE 1
CONFIG_IBMASR_MODULE 1
CONFIG_INPUT_MOUSE 1
CONFIG_RTLWIFI_PCI_MODULE 1
CONFIG_INFINIBAND_ISER_MODULE 1
CONFIG_HOTPLUG_SMT 1
CONFIG_FB_SYS_IMAGEBLIT_MODULE 1
CONFIG_VIDEO_TVEEPROM_MODULE 1
CONFIG_X86 1
CONFIG_PPS_CLIENT_PARPORT_MODULE 1
CONFIG_VIDEO_LM3646_MODULE 1
CONFIG_DEFXX_MODULE 1
CONFIG_SUNRPC_GSS_MODULE 1
CONFIG_HID_LED_MODULE 1
CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
CONFIG_TYPHOON_MODULE 1
CONFIG_TIGON3_MODULE 1
CONFIG_THUNDERBOLT_MODULE 1
CONFIG_CRYPTO_CAST5_AVX_X86_64_MODULE 1
CONFIG_SENSORS_LM90_MODULE 1
CONFIG_XILINX_XADC_MODULE 1
CONFIG_NETCONSOLE_MODULE 1
CONFIG_RTC_INTF_SYSFS 1
CONFIG_CHARGER_BQ24257_MODULE 1
CONFIG_MMC_SDHCI_ACPI_MODULE 1
CONFIG_BCMA_DRIVER_GPIO 1
CONFIG_SND_SOC_SPDIF_MODULE 1
CONFIG_RTC_DRV_RS5C372_MODULE 1
CONFIG_QED_MODULE 1
CONFIG_NET_EMATCH_U32_MODULE 1
CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE 1
CONFIG_CPU_FREQ_GOV_COMMON 1
CONFIG_BLK_DEV_INITRD 1
CONFIG_USB_EMI62_MODULE 1
CONFIG_B43_PHY_N 1
CONFIG_SCSI_IPS_MODULE 1
CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE 1
CONFIG_X86_MCE_AMD 1
CONFIG_DM_BUFIO_MODULE 1
CONFIG_I2C_ALGOPCA_MODULE 1
CONFIG_CAN_GS_USB_MODULE 1
CONFIG_BT_ATH3K_MODULE 1
CONFIG_LEDS_TRIGGER_TIMER_MODULE 1
CONFIG_MCB_PCI_MODULE 1
CONFIG_DRM_VIRTIO_GPU_MODULE 1
CONFIG_COMMON_CLK_PALMAS_MODULE 1
CONFIG_RTC_DRV_M48T59_MODULE 1
CONFIG_SND_SOC_WM8510_MODULE 1
CONFIG_RT2800_LIB_MODULE 1
CONFIG_EXTCON_ADC_JACK_MODULE 1
CONFIG_DELL_WMI_LED_MODULE 1
CONFIG_X86_X2APIC 1
CONFIG_SND_SOC_TLV320AIC3X_MODULE 1
CONFIG_FB_VESA 1
CONFIG_DEFAULT_SECURITY_APPARMOR 1
CONFIG_NFS_DEBUG 1
CONFIG_AD7949_MODULE 1
CONFIG_CRYPTO_BLOWFISH_COMMON_MODULE 1
CONFIG_USB_RAREMONO_MODULE 1
CONFIG_BT_INTEL_MODULE 1
CONFIG_CRC4_MODULE 1
CONFIG_REGULATOR_WM831X_MODULE 1
CONFIG_REGULATOR_TPS65090_MODULE 1
CONFIG_FUSION_LAN_MODULE 1
CONFIG_DRM_BOCHS_MODULE 1
CONFIG_NF_FLOW_TABLE_IPV4_MODULE 1
CONFIG_MTD_NAND_PLATFORM_MODULE 1
CONFIG_DVB_USB_DW2102_MODULE 1
CONFIG_CRYPTO_DRBG_HASH 1
CONFIG_PATA_PCMCIA_MODULE 1
CONFIG_NF_CONNTRACK_SANE_MODULE 1
CONFIG_SERIO_PARKBD_MODULE 1
CONFIG_GPIO_PCF857X_MODULE 1
CONFIG_SND_OSSEMUL 1
CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL_MODULE 1
CONFIG_ARCH_CLOCKSOURCE_DATA 1
CONFIG_BACKLIGHT_SAHARA_MODULE 1
CONFIG_TOUCHSCREEN_TSC2004_MODULE 1
CONFIG_SND_SOC_ADAU_UTILS_MODULE 1
CONFIG_TOUCHSCREEN_SURFACE3_SPI_MODULE 1
CONFIG_IBM_RTL_MODULE 1
CONFIG_USB_SERIAL_MOS7720_MODULE 1
CONFIG_XILLYBUS_MODULE 1
CONFIG_SERIAL_DEV_BUS 1
CONFIG_PREEMPT_NOTIFIERS 1
CONFIG_NET_DSA_TAG_EDSA_MODULE 1
CONFIG_XEN_PVHVM 1
CONFIG_FB_ARC_MODULE 1
CONFIG_NF_CT_PROTO_DCCP 1
CONFIG_ZLIB_INFLATE 1
CONFIG_USB_FUNCTIONFS_MODULE 1
CONFIG_RTC_DRV_V3020_MODULE 1
CONFIG_LEDS_LM36274_MODULE 1
CONFIG_NET_VENDOR_SYNOPSYS 1
CONFIG_DVB_TUA6100_MODULE 1
CONFIG_SENSORS_SHTC1_MODULE 1
CONFIG_NFT_FLOW_OFFLOAD_MODULE 1
CONFIG_KVM_ASYNC_PF 1
CONFIG_BMP280_MODULE 1
CONFIG_CRC_T10DIF 1
CONFIG_EXTCON_USBC_CROS_EC_MODULE 1
CONFIG_AD7746_MODULE 1
CONFIG_NF_CONNTRACK_BRIDGE_MODULE 1
CONFIG_MMA8452_MODULE 1
CONFIG_THERMAL_GOV_FAIR_SHARE 1
CONFIG_ENCRYPTED_KEYS 1
CONFIG_MEDIA_TUNER_QT1010_MODULE 1
CONFIG_DVB_DYNAMIC_MINORS 1
CONFIG_GPIO_WM831X_MODULE 1
CONFIG_SSB_PCIHOST_POSSIBLE 1
CONFIG_LCD_LMS283GF05_MODULE 1
CONFIG_HWMON 1
CONFIG_AD5791_MODULE 1
CONFIG_SND_SOC_NAU8824_MODULE 1
CONFIG_INTEL_GTT 1
CONFIG_RTC_DRV_PCF85063_MODULE 1
CONFIG_NET_VENDOR_DLINK 1
CONFIG_CRYPTO_TWOFISH_COMMON_MODULE 1
CONFIG_DLCI_MAX 8
CONFIG_AUDITSYSCALL 1
CONFIG_BT_HCIUART_3WIRE 1
CONFIG_USB_PHY 1
CONFIG_MANAGER_SBS_MODULE 1
CONFIG_X86_ACPI_CPUFREQ_CPB 1
CONFIG_NLS_ISO8859_2_MODULE 1
CONFIG_MFD_DA9052_I2C 1
CONFIG_QEDE_MODULE 1
CONFIG_STAGING_GASKET_FRAMEWORK_MODULE 1
CONFIG_SENSORS_LM63_MODULE 1
CONFIG_RC_DEVICES 1
CONFIG_XDP_SOCKETS_DIAG_MODULE 1
CONFIG_CRYPTO_CRC32_PCLMUL_MODULE 1
CONFIG_USB_VIDEO_CLASS_MODULE 1
CONFIG_EXTCON_INTEL_CHT_WC_MODULE 1
CONFIG_CLKBLD_I8253 1
CONFIG_ATM_NICSTAR_MODULE 1
CONFIG_MCP4131_MODULE 1
CONFIG_FB_ATY_GX 1
CONFIG_RTC_INTF_PROC 1
CONFIG_HID_PICOLCD_FB 1
CONFIG_IR_RCMM_DECODER_MODULE 1
CONFIG_USB_SERIAL_TI_MODULE 1
CONFIG_BCMGENET_MODULE 1
CONFIG_NET_SCH_CBQ_MODULE 1
CONFIG_KEXEC_SIG 1
CONFIG_VIDEO_VP27SMPX_MODULE 1
CONFIG_PM_CLK 1
CONFIG_USB_CONFIGFS_F_HID 1
CONFIG_ARCH_USE_BUILTIN_BSWAP 1
CONFIG_SND_SOC_INTEL_SKYLAKE_COMMON_MODULE 1
CONFIG_UNISYS_VISORHBA_MODULE 1
CONFIG_SENSORS_LTC2990_MODULE 1
CONFIG_PERF_EVENTS_INTEL_RAPL_MODULE 1
CONFIG_USB_DWC2_PCI_MODULE 1
CONFIG_USB_SERIAL_MOS7715_PARPORT 1
CONFIG_CRYPTO_SERPENT_MODULE 1
CONFIG_KPC2000_I2C_MODULE 1
CONFIG_DVB_SI2168_MODULE 1
CONFIG_CRYPTO_OFB_MODULE 1
CONFIG_CPU_IDLE_GOV_MENU 1
CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL 1
CONFIG_USB_EHSET_TEST_FIXTURE_MODULE 1
CONFIG_MTD_PCI_MODULE 1
CONFIG_SERIAL_8250_LPSS_MODULE 1
CONFIG_ACPI_FAN 1
CONFIG_HYSDN_CAPI 1
CONFIG_SND_FM801_MODULE 1
CONFIG_MOUSE_PS2_SENTELIC 1
CONFIG_RTC_DRV_MAX8925_MODULE 1
CONFIG_FB_MATROX_MYSTIQUE 1
CONFIG_VIDEO_CS5345_MODULE 1
CONFIG_SECURITY_APPARMOR 1
CONFIG_RTC_DRV_RX8010_MODULE 1
CONFIG_DP83867_PHY_MODULE 1
CONFIG_STACKTRACE_SUPPORT 1
CONFIG_B44_PCI_AUTOSELECT 1
CONFIG_DVB_USB_AF9035_MODULE 1
CONFIG_COMEDI_AMPLC_PCI224_MODULE 1
CONFIG_COMEDI_NI_TIO_MODULE 1
CONFIG_MFD_TI_LP873X_MODULE 1
CONFIG_SERIAL_MAX3100_MODULE 1
CONFIG_LEDS_LP8788_MODULE 1
CONFIG_SENSORS_EMC1403_MODULE 1
CONFIG_MLXFW_MODULE 1
CONFIG_RESET_CONTROLLER 1
CONFIG_BNA_MODULE 1
CONFIG_MAXSMP 1
CONFIG_OUTPUT_FORMAT "elf64-x86-64"
CONFIG_I2C_MUX_LTC4306_MODULE 1
CONFIG_VIDEO_M52790_MODULE 1
CONFIG_CRYPTO_AES_TI_MODULE 1
CONFIG_ACPI 1
CONFIG_HTS221_SPI_MODULE 1
CONFIG_SCSI_SYM53C8XX_2_MODULE 1
CONFIG_SCSI_CXGB4_ISCSI_MODULE 1
CONFIG_TABLET_USB_PEGASUS_MODULE 1
CONFIG_IP_SET_HASH_IPMAC_MODULE 1
CONFIG_SENSORS_SHT15_MODULE 1
CONFIG_USB_UHCI_HCD 1
CONFIG_NVRAM_MODULE 1
CONFIG_INFINIBAND_VIRT_DMA 1
CONFIG_USB_ISP1760_MODULE 1
CONFIG_CHARGER_BQ24735_MODULE 1
CONFIG_LOCKD_MODULE 1
CONFIG_LEDS_INTEL_SS4200_MODULE 1
CONFIG_DRM_KMS_FB_HELPER 1
CONFIG_RTW88_DEBUGFS 1
CONFIG_DM_WRITECACHE_MODULE 1
CONFIG_USB_F_FS_MODULE 1
CONFIG_USB_CHIPIDEA_UDC 1
CONFIG_DVB_FIREDTV_MODULE 1
CONFIG_DVB_S5H1411_MODULE 1
CONFIG_NF_CT_NETLINK_TIMEOUT_MODULE 1
CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC 1
CONFIG_SOUND_OSS_CORE 1
CONFIG_PCIE_DW_HOST 1
CONFIG_AIC79XX_REG_PRETTY_PRINT 1
CONFIG_CRYPTO_LIB_ARC4_MODULE 1
CONFIG_CRYPTO_LIB_AES 1
CONFIG_TI_ADC0832_MODULE 1
CONFIG_RT2800USB_RT35XX 1
CONFIG_FB_SAVAGE_MODULE 1
CONFIG_LIBERTAS_MODULE 1
CONFIG_HPET_MMAP 1
CONFIG_WLAN_VENDOR_RALINK 1
CONFIG_NTB_PINGPONG_MODULE 1
CONFIG_MT7603E_MODULE 1
CONFIG_USB_GSPCA_TV8532_MODULE 1
CONFIG_CRYPTO_KPP2 1
CONFIG_IO_DELAY_0XED 1
CONFIG_LTE_GDM724X_MODULE 1
CONFIG_DRM_VMWGFX_MODULE 1
CONFIG_NET_VENDOR_MICROCHIP 1
CONFIG_JFFS2_FS_MODULE 1
CONFIG_STE10XP_MODULE 1
CONFIG_NFT_REJECT_IPV6_MODULE 1
CONFIG_HID_SAITEK_MODULE 1
CONFIG_SND_SOC_WM8750_MODULE 1
CONFIG_RTC_DRV_MT6397_MODULE 1
CONFIG_CASSINI_MODULE 1
CONFIG_USB_WHCI_HCD_MODULE 1
CONFIG_VIDEO_CROS_EC_CEC_MODULE 1
CONFIG_SND_SOC_RT5660_MODULE 1
CONFIG_PAGE_POISONING_NO_SANITY 1
CONFIG_SCSI_DH_ALUA_MODULE 1
CONFIG_MTRR 1
CONFIG_USB_G_NCM_MODULE 1
CONFIG_ADIS16203_MODULE 1
CONFIG_MFD_MC13XXX_I2C_MODULE 1
CONFIG_BT_RFCOMM_TTY 1
CONFIG_LIBFCOE_MODULE 1
CONFIG_NET_UDP_TUNNEL_MODULE 1
CONFIG_INTEGRITY_SIGNATURE 1
CONFIG_INPUT_MAX8997_HAPTIC_MODULE 1
CONFIG_RPCSEC_GSS_KRB5_MODULE 1
CONFIG_CRYPTO_ECC_MODULE 1
CONFIG_VIDEOBUF_VMALLOC_MODULE 1
CONFIG_RTC_DRV_LP8788_MODULE 1
CONFIG_MTD_CFI_UTIL_MODULE 1
CONFIG_NO_HZ_IDLE 1
CONFIG_USB_ISP1761_UDC 1
CONFIG_SND_SOC_CS4271_I2C_MODULE 1
CONFIG_DEV_PAGEMAP_OPS 1
CONFIG_NLS_MAC_ROMANIAN_MODULE 1
CONFIG_SND_LX6464ES_MODULE 1
CONFIG_NET_VENDOR_ADAPTEC 1
CONFIG_CFG80211_REQUIRE_SIGNED_REGDB 1
CONFIG_SENSORS_PCF8591_MODULE 1
CONFIG_DVB_STV0299_MODULE 1
CONFIG_IIO_CROS_EC_ACCEL_LEGACY_MODULE 1
CONFIG_MOUSE_PS2_BYD 1
CONFIG_IPW2200_RADIOTAP 1
CONFIG_SSB_B43_PCI_BRIDGE 1
CONFIG_ACER_WMI_MODULE 1
CONFIG_KXSD9_MODULE 1
CONFIG_CHARGER_TWL4030_MODULE 1
CONFIG_USB_AN2720 1
CONFIG_F2FS_STAT_FS 1
CONFIG_SENSORS_UCD9200_MODULE 1
CONFIG_MIC_COSM_MODULE 1
CONFIG_EXTCON_INTEL_INT3496_MODULE 1
CONFIG_MLX4_DEBUG 1
CONFIG_BSD_PROCESS_ACCT 1
CONFIG_NETFILTER_XT_MATCH_STRING_MODULE 1
CONFIG_SSB_DRIVER_PCICORE 1
CONFIG_INPUT_TABLET 1
CONFIG_88EU_AP_MODE 1
CONFIG_HID_SENSOR_IIO_TRIGGER_MODULE 1
CONFIG_IIO_CROS_EC_SENSORS_LID_ANGLE_MODULE 1
CONFIG_MEDIA_TUNER_MAX2165_MODULE 1
CONFIG_MDIO_MODULE 1
CONFIG_N_HDLC_MODULE 1
CONFIG_SND_SOC_SOF_ELKHARTLAKE_SUPPORT 1
CONFIG_MTD_CFI_INTELEXT_MODULE 1
CONFIG_CRYPTO_DRBG_HMAC 1
CONFIG_ATM_LANAI_MODULE 1
CONFIG_MISDN_HDLC_MODULE 1
CONFIG_SND_SOC_GTM601_MODULE 1
CONFIG_DRM_BRIDGE 1
CONFIG_LLC2_MODULE 1
CONFIG_IR_WINBOND_CIR_MODULE 1
CONFIG_HPET_EMULATE_RTC 1
CONFIG_USB_F_SERIAL_MODULE 1
CONFIG_X86_MPPARSE 1
CONFIG_RAVE_SP_CORE_MODULE 1
CONFIG_BNXT_MODULE 1
CONFIG_NET_VENDOR_SILAN 1
CONFIG_SENSORS_UCD9000_MODULE 1
CONFIG_SND_OXYGEN_LIB_MODULE 1
CONFIG_US5182D_MODULE 1
CONFIG_PINCTRL_CS47L90 1
CONFIG_SND_SOC_MAX98357A_MODULE 1
CONFIG_DLM_MODULE 1
CONFIG_SERIAL_ARC_MODULE 1
CONFIG_STK8312_MODULE 1
CONFIG_DRM_ANALOGIX_ANX78XX_MODULE 1
CONFIG_CAN_CC770_MODULE 1
CONFIG_NETFILTER_XT_MATCH_BPF_MODULE 1
CONFIG_TOUCHSCREEN_USB_GOTOP 1
CONFIG_EEEPC_LAPTOP_MODULE 1
CONFIG_HID_ACCUTOUCH_MODULE 1
CONFIG_BT_6LOWPAN_MODULE 1
CONFIG_USB_STORAGE_MODULE 1
CONFIG_GPIO_LP873X_MODULE 1
CONFIG_MAG3110_MODULE 1
CONFIG_HMC6352_MODULE 1
CONFIG_NET_VENDOR_BROADCOM 1
CONFIG_SERIAL_FSL_LPUART_MODULE 1
CONFIG_DVB_USB_PCTV452E_MODULE 1
CONFIG_JOYSTICK_PSXPAD_SPI_FF 1
CONFIG_DVB_VES1820_MODULE 1
CONFIG_GENERIC_CPU_AUTOPROBE 1
CONFIG_BAYCOM_SER_HDX_MODULE 1
CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE 1
CONFIG_CRYPTO_SEED_MODULE 1
CONFIG_SCHED_MC 1
CONFIG_DELL_RBU_MODULE 1
CONFIG_ALTERA_MBOX_MODULE 1
CONFIG_SCSI_SAS_ATA 1
CONFIG_AD7266_MODULE 1
CONFIG_COMEDI_NI_LABPC_PCI_MODULE 1
CONFIG_SECONDARY_TRUSTED_KEYRING 1
CONFIG_BATTERY_DS2782_MODULE 1
CONFIG_DEV_DAX_PMEM_MODULE 1
CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
CONFIG_GPIO_ICH_MODULE 1
CONFIG_EFI 1
CONFIG_RATIONAL 1
CONFIG_I2C_MUX_MODULE 1
CONFIG_LMP91000_MODULE 1
CONFIG_NVME_TARGET_LOOP_MODULE 1
CONFIG_SATA_MV_MODULE 1
CONFIG_DVB_TS2020_MODULE 1
CONFIG_MFD_AHC1EC0_MODULE 1
CONFIG_AGP_AMD64 1
CONFIG_WLAN_VENDOR_INTEL 1
CONFIG_HAVE_SETUP_PER_CPU_AREA 1
CONFIG_TI_DAC082S085_MODULE 1
CONFIG_CHARGER_ISP1704_MODULE 1
CONFIG_DRM_I915_USERPTR 1
CONFIG_SPI_SLAVE_TIME_MODULE 1
CONFIG_SYSTEM_TRUSTED_KEYRING 1
CONFIG_MEDIA_TUNER_QM1D1C0042_MODULE 1
CONFIG_WATCHDOG_CORE 1
CONFIG_SND_SOC_FSL_SPDIF_MODULE 1
CONFIG_USB_SERIAL_SIMPLE_MODULE 1
CONFIG_GENERIC_EARLY_IOREMAP 1
CONFIG_DVB_TUNER_DIB0090_MODULE 1
CONFIG_PCI_XEN 1
CONFIG_SND_USB_AUDIO_MODULE 1
CONFIG_LCD_AMS369FG06_MODULE 1
CONFIG_TOUCHSCREEN_EGALAX_SERIAL_MODULE 1
CONFIG_IEEE802154_ATUSB_MODULE 1
CONFIG_ARCNET_CAP_MODULE 1
CONFIG_VIDEO_CX231XX_MODULE 1
CONFIG_NULL_TTY_MODULE 1
CONFIG_SPEAKUP_SYNTH_TXPRT_MODULE 1
CONFIG_SENSORS_MAX31790_MODULE 1
CONFIG_X25_MODULE 1
CONFIG_NET_L3_MASTER_DEV 1
CONFIG_HID_SENSOR_INCLINOMETER_3D_MODULE 1
CONFIG_SENSORS_FTSTEUTATES_MODULE 1
CONFIG_TCP_CONG_YEAH_MODULE 1
CONFIG_SND_SOC_INTEL_SOF_RT5682_MACH_MODULE 1
CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE 1
CONFIG_CS89x0_PLATFORM 1
CONFIG_IEEE802154_MODULE 1
CONFIG_DA9063_WATCHDOG_MODULE 1
CONFIG_HID_SENSOR_CUSTOM_SENSOR_MODULE 1
CONFIG_SCSI_QLA_FC_MODULE 1
CONFIG_VMAP_STACK 1
CONFIG_TELCLOCK_MODULE 1
CONFIG_I40EVF_MODULE 1
CONFIG_ASHMEM_MODULE 1
CONFIG_COMEDI_AMPLC_PC263_ISA_MODULE 1
CONFIG_BE2NET_BE2 1
CONFIG_BMG160_SPI_MODULE 1
CONFIG_HAVE_IDE 1
CONFIG_BLOCK 1
CONFIG_IP_VS_LC_MODULE 1
CONFIG_ARCH_STACKWALK 1
CONFIG_USB_DWC3_PCI_MODULE 1
CONFIG_HID_APPLE_MODULE 1
CONFIG_DVB_DIB9000_MODULE 1
CONFIG_BNXT_FLOWER_OFFLOAD 1
CONFIG_CRYPTO_SERPENT_AVX2_X86_64_MODULE 1
CONFIG_STREAM_PARSER 1
CONFIG_MEDIA_TUNER_TDA827X_MODULE 1
CONFIG_VMXNET3_MODULE 1
CONFIG_INIT_ENV_ARG_LIMIT 32
CONFIG_IP_NF_ARP_MANGLE_MODULE 1
CONFIG_USB_WUSB_MODULE 1
CONFIG_DVB_USB_MODULE 1
CONFIG_P54_LEDS 1
CONFIG_MOST_CDEV_MODULE 1
CONFIG_RTC_DRV_88PM860X_MODULE 1
CONFIG_SENSORS_MAX34440_MODULE 1
CONFIG_SENSORS_G760A_MODULE 1
CONFIG_RDS_MODULE 1
CONFIG_AK09911_MODULE 1
CONFIG_DVB_ATBM8830_MODULE 1
CONFIG_PATA_EFAR_MODULE 1
CONFIG_PCI_ENDPOINT_CONFIGFS 1
CONFIG_HOLTEK_FF 1
CONFIG_EXFAT_FS_MODULE 1
CONFIG_EEPROM_93XX46_MODULE 1
CONFIG_SND_SOC_INTEL_SKYLAKE_SSP_CLK_MODULE 1
CONFIG_COMEDI_DYNA_PCI10XX_MODULE 1
CONFIG_ATL2_MODULE 1
CONFIG_USER_NS 1
CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH 1
CONFIG_COMMON_CLK_MAX9485_MODULE 1
CONFIG_CRYPTO_USER_MODULE 1
CONFIG_CHROMEOS_TBMC_MODULE 1
CONFIG_NF_CONNTRACK_PPTP_MODULE 1
CONFIG_CPU_SUP_INTEL 1
CONFIG_TCP_CONG_CDG_MODULE 1
CONFIG_VIDEO_TDA1997X_MODULE 1
CONFIG_DVB_ZL10036_MODULE 1
CONFIG_VIDEO_CX231XX_ALSA_MODULE 1
CONFIG_CHARGER_DA9150_MODULE 1
CONFIG_HFSPLUS_FS_MODULE 1
CONFIG_TMPFS_POSIX_ACL 1
CONFIG_STRICT_KERNEL_RWX 1
CONFIG_SENSORS_ADM9240_MODULE 1
CONFIG_CRYPTO_DEV_CHELSIO_TLS_MODULE 1
CONFIG_VIDEO_CAFE_CCIC_MODULE 1
CONFIG_SND_SOC_INTEL_SKL_RT286_MACH_MODULE 1
CONFIG_SND_USB_UA101_MODULE 1
CONFIG_ACPI_APEI_PCIEAER 1
CONFIG_TOUCHSCREEN_CYTTSP_CORE_MODULE 1
CONFIG_NETLINK_DIAG_MODULE 1
CONFIG_CAN_IFI_CANFD_MODULE 1
CONFIG_BUG 1
CONFIG_KS0108_PORT 0x378
CONFIG_SCSI_AIC7XXX_MODULE 1
CONFIG_CONTEXT_SWITCH_TRACER 1
CONFIG_MAC80211_HAS_RC 1
CONFIG_BATMAN_ADV_BLA 1
CONFIG_KDB_KEYBOARD 1
CONFIG_SND_SOC_SSM2602_SPI_MODULE 1
CONFIG_LOGIWHEELS_FF 1
CONFIG_SENSORS_INA209_MODULE 1
CONFIG_USB_SL811_HCD_MODULE 1
CONFIG_OCFS2_FS_O2CB_MODULE 1
CONFIG_MDIO_GPIO_MODULE 1
CONFIG_VIDEO_DW9807_VCM_MODULE 1
CONFIG_XEN 1
CONFIG_CRYPTO_CAST6_MODULE 1
CONFIG_6LOWPAN_NHC_UDP_MODULE 1
CONFIG_NET_EMATCH_META_MODULE 1
CONFIG_KS8842_MODULE 1
CONFIG_SCSI_IPR_DUMP 1
CONFIG_W1_MASTER_DS1WM_MODULE 1
CONFIG_I40E_DCB 1
CONFIG_GREYBUS_LIGHT_MODULE 1
CONFIG_PANTHERLORD_FF 1
CONFIG_I2C_DIOLAN_U2C_MODULE 1
CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE 1
CONFIG_SND_SOC_INTEL_KBL_DA7219_MAX98357A_MACH_MODULE 1
CONFIG_RC_XBOX_DVD_MODULE 1
CONFIG_PM 1
CONFIG_LTC1660_MODULE 1
CONFIG_SND_CS46XX_NEW_DSP 1
CONFIG_VIDEO_ADV7343_MODULE 1
CONFIG_CAIF_HSI_MODULE 1
CONFIG_MXC6255_MODULE 1
CONFIG_PPS 1
CONFIG_FB_RIVA_BACKLIGHT 1
CONFIG_LEDS_TRIGGER_PATTERN_MODULE 1
CONFIG_GENERIC_ISA_DMA 1
CONFIG_IEEE802154_CA8210_DEBUGFS 1
CONFIG_NFC_PN544_MODULE 1
CONFIG_CHARGER_MAX8903_MODULE 1
CONFIG_USB_LCD_MODULE 1
CONFIG_MEMCG 1
CONFIG_SPI 1
CONFIG_TCS3414_MODULE 1
CONFIG_SENSORS_MENF21BMC_HWMON_MODULE 1
CONFIG_RTC_SYSTOHC_DEVICE "rtc0"
CONFIG_SENSORS_DS620_MODULE 1
CONFIG_EVM_EXTRA_SMACK_XATTRS 1
CONFIG_V4L_MEM2MEM_DRIVERS 1
CONFIG_X86_SPEEDSTEP_CENTRINO 1
CONFIG_MFD_TPS65912_SPI 1
CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT 1
CONFIG_NFT_HASH_MODULE 1
CONFIG_NF_CONNTRACK_IRC_MODULE 1
CONFIG_RENESAS_PHY_MODULE 1
CONFIG_NOUVEAU_DEBUG_DEFAULT 3
CONFIG_BACKLIGHT_AAT2870_MODULE 1
CONFIG_PATA_NS87410_MODULE 1
CONFIG_PCMCIA_SPECTRUM_MODULE 1
CONFIG_L2TP_IP_MODULE 1
CONFIG_RADIO_SI476X_MODULE 1
CONFIG_SECURITY_SAFESETID 1
CONFIG_MTD_REDBOOT_PARTS_MODULE 1
CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
CONFIG_MTD_UBI_FASTMAP 1
CONFIG_SND_SOC_TLV320AIC23_SPI_MODULE 1
CONFIG_SND_SOC_IMG_SPDIF_IN_MODULE 1
CONFIG_NET_FAILOVER_MODULE 1
CONFIG_USB_STV06XX_MODULE 1
CONFIG_PPP_DEFLATE_MODULE 1
CONFIG_USELIB 1
CONFIG_REGULATOR_DA903X_MODULE 1
CONFIG_VGA_SWITCHEROO 1
CONFIG_PSAMPLE_MODULE 1
CONFIG_USB_ISP1301_MODULE 1
CONFIG_TOUCHSCREEN_DA9052_MODULE 1
CONFIG_B53_MDIO_DRIVER_MODULE 1
CONFIG_IRQ_REMAP 1
CONFIG_DVB_PT3_MODULE 1
CONFIG_TEXTSEARCH_KMP_MODULE 1
CONFIG_IO_URING 1
CONFIG_MAX31856_MODULE 1
CONFIG_COMEDI_AMPLC_PC263_PCI_MODULE 1
CONFIG_SND_MAESTRO3_MODULE 1
CONFIG_W1_SLAVE_SMEM_MODULE 1
CONFIG_VT 1
CONFIG_USB_NET_NET1080_MODULE 1
CONFIG_HID_REDRAGON_MODULE 1
CONFIG_STK3310_MODULE 1
CONFIG_SENSORS_F71805F_MODULE 1
CONFIG_SUNRPC_DEBUG 1
CONFIG_HABANA_AI_MODULE 1
CONFIG_AD7124_MODULE 1
CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE 1
CONFIG_INET6_ESP_OFFLOAD_MODULE 1
CONFIG_SND_SOC_IMG_SPDIF_OUT_MODULE 1
CONFIG_CCS811_MODULE 1
CONFIG_HID_TIVO_MODULE 1
CONFIG_HID_ICADE_MODULE 1
CONFIG_PCI_ATS 1
CONFIG_MISDN_IPAC_MODULE 1
CONFIG_PARIDE_KTTI_MODULE 1
CONFIG_F2FS_FS_SECURITY 1
CONFIG_LTC2497_MODULE 1
CONFIG_USB_NET_AQC111_MODULE 1
CONFIG_MACB_MODULE 1
CONFIG_SND_HDA_CODEC_CIRRUS_MODULE 1
CONFIG_GPIO_PCI_IDIO_16_MODULE 1
CONFIG_REGMAP_SPI 1
CONFIG_UNISYSSPAR 1
CONFIG_BT_BREDR 1
CONFIG_DMA_ACPI 1
CONFIG_VIDEO_HEXIUM_GEMINI_MODULE 1
CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED 1
CONFIG_EXTCON_SM5502_MODULE 1
CONFIG_CB710_DEBUG_ASSUMPTIONS 1
CONFIG_INTEL_SOC_PMIC_CHTWC 1
CONFIG_SPLIT_PTLOCK_CPUS 4
CONFIG_LEDS_AS3645A_MODULE 1
CONFIG_USB_R8A66597_MODULE 1
CONFIG_SBITMAP 1
CONFIG_INPUT_DRV2665_HAPTICS_MODULE 1
CONFIG_EDAC_E752X_MODULE 1
CONFIG_GTP_MODULE 1
CONFIG_WATCHDOG_PRETIMEOUT_GOV_SEL_MODULE 1
CONFIG_EXTCON_MAX3355_MODULE 1
CONFIG_MSPRO_BLOCK_MODULE 1
CONFIG_DVB_TUNER_ITD1000_MODULE 1
CONFIG_POWER_SUPPLY 1
CONFIG_DM_PERSISTENT_DATA_MODULE 1
CONFIG_PATA_VIA_MODULE 1
CONFIG_DAVICOM_PHY_MODULE 1
CONFIG_SCSI_UFSHCD_PLATFORM_MODULE 1
CONFIG_SCTP_COOKIE_HMAC_MD5 1
CONFIG_PARAVIRT_XXL 1
CONFIG_CIFS_XATTR 1
CONFIG_CRYPTO_ZSTD_MODULE 1
CONFIG_KEXEC_JUMP 1
CONFIG_SENSORS_ADM1275_MODULE 1
CONFIG_SND_DMAENGINE_PCM_MODULE 1
CONFIG_I2C_PCA_PLATFORM_MODULE 1
CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE 1
CONFIG_SECURITY_SELINUX_BOOTPARAM 1
CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE 1
CONFIG_CAN_8DEV_USB_MODULE 1
CONFIG_HAVE_RCU_TABLE_FREE 1
CONFIG_SND_HDA_INPUT_BEEP 1
CONFIG_WEXT_CORE 1
CONFIG_I2C_DESIGNWARE_CORE 1
CONFIG_USB_GSPCA_MR97310A_MODULE 1
CONFIG_DVB_HOPPER_MODULE 1
CONFIG_GENERIC_IRQ_CHIP 1
CONFIG_ACPI_THERMAL_REL_MODULE 1
CONFIG_NETLABEL 1
CONFIG_VIDEO_WM8775_MODULE 1
CONFIG_CHARGER_SBS_MODULE 1
CONFIG_NLS 1
CONFIG_CALGARY_IOMMU 1
CONFIG_NF_CONNTRACK_TIMEOUT 1
CONFIG_GPIO_SCH311X_MODULE 1
CONFIG_INPUT_PCAP_MODULE 1
CONFIG_SND_SOC_HDAC_HDMI_MODULE 1
CONFIG_INPUT_PALMAS_PWRBUTTON_MODULE 1
CONFIG_V4L2_FLASH_LED_CLASS_MODULE 1
CONFIG_MFD_ARIZONA 1
CONFIG_VIDEO_COBALT_MODULE 1
CONFIG_IP_SET_HASH_IPPORTNET_MODULE 1
CONFIG_SMC_DIAG_MODULE 1
CONFIG_LEDS_APU_MODULE 1
CONFIG_CDROM_PKTCDVD_BUFFERS 8
CONFIG_SCHED_AUTOGROUP 1
CONFIG_XILINX_LL_TEMAC_MODULE 1
CONFIG_COMEDI_PCL730_MODULE 1
CONFIG_GPIO_TPS65912_MODULE 1
CONFIG_SPI_SPIDEV_MODULE 1
CONFIG_EFI_BOOTLOADER_CONTROL_MODULE 1
CONFIG_MEDIA_CAMERA_SUPPORT 1
CONFIG_BT_MTKSDIO_MODULE 1
CONFIG_PRISM2_USB_MODULE 1
CONFIG_ADM8211_MODULE 1
CONFIG_MFD_WM8997 1
CONFIG_HWPOISON_INJECT_MODULE 1
CONFIG_NTB_TOOL_MODULE 1
CONFIG_VME_FAKE_MODULE 1
CONFIG_RTL8188EE_MODULE 1
CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG 1
CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE 1
CONFIG_HID_MAGICMOUSE_MODULE 1
CONFIG_MICROSEMI_PHY_MODULE 1
CONFIG_VIDEO_TW686X_MODULE 1
CONFIG_INTEL_CHT_INT33FE_MODULE 1
CONFIG_NFT_COUNTER_MODULE 1
CONFIG_TI_DAC7311_MODULE 1
CONFIG_SND_SOC_AK4554_MODULE 1
CONFIG_I2C_GPIO_MODULE 1
CONFIG_MFD_CS47L35 1
CONFIG_VIDEO_TDA9840_MODULE 1
CONFIG_INET_UDP_DIAG_MODULE 1
CONFIG_MEDIA_SDR_SUPPORT 1
CONFIG_USB_CONFIGFS_ACM 1
CONFIG_CGROUP_BPF 1
CONFIG_RAPIDIO_ENUM_BASIC_MODULE 1
CONFIG_XEN_SAVE_RESTORE 1
CONFIG_DVB_USB_ZD1301_MODULE 1
CONFIG_TOUCHSCREEN_USB_ETURBO 1
CONFIG_DELL_LAPTOP_MODULE 1
CONFIG_PPPOE_MODULE 1
CONFIG_IPV6_SEG6_HMAC 1
CONFIG_CRYPTO_CRCT10DIF_PCLMUL_MODULE 1
CONFIG_WL1251_SDIO_MODULE 1
CONFIG_GPIO_TQMX86_MODULE 1
CONFIG_PCI_REALLOC_ENABLE_AUTO 1
CONFIG_X86_INTEL_PSTATE 1
CONFIG_SND_LAYLA24_MODULE 1
CONFIG_NFC_PN533_USB_MODULE 1
CONFIG_ZONE_DMA 1
CONFIG_VIDEO_CX25821_MODULE 1
CONFIG_USB_GSPCA_SPCA508_MODULE 1
CONFIG_USB_LEGOTOWER_MODULE 1
CONFIG_LEDS_LP8501_MODULE 1
CONFIG_I2C_ROBOTFUZZ_OSIF_MODULE 1
CONFIG_MTD_DATAFLASH_MODULE 1
CONFIG_DVB_DRX39XYJ_MODULE 1
CONFIG_FB_MB862XX_I2C 1
CONFIG_QLCNIC_HWMON 1
CONFIG_ACPI_I2C_OPREGION 1
CONFIG_DVB_USB_DIBUSB_MC_MODULE 1
CONFIG_I2C_CBUS_GPIO_MODULE 1
CONFIG_DVB_USB_VP702X_MODULE 1
CONFIG_ROCKER_MODULE 1
CONFIG_CAN_CC770_ISA_MODULE 1
CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE 1
CONFIG_GPIO_WM8994_MODULE 1
CONFIG_I2C_SIS5595_MODULE 1
CONFIG_X86_PTDUMP_CORE 1
CONFIG_SND_SEQ_DEVICE_MODULE 1
CONFIG_SUN_PARTITION 1
CONFIG_IP_NF_TARGET_ECN_MODULE 1
CONFIG_PSTORE_DEFLATE_COMPRESS_DEFAULT 1
CONFIG_SND_GINA24_MODULE 1
CONFIG_NFC_NXP_NCI_I2C_MODULE 1
CONFIG_MD_FAULTY_MODULE 1
CONFIG_SYN_COOKIES 1
CONFIG_SENSORS_IR35221_MODULE 1
CONFIG_REED_SOLOMON_DEC8 1
CONFIG_IRQ_WORK 1
CONFIG_ATH9K_MODULE 1
CONFIG_PCI_MSI 1
CONFIG_IP_ADVANCED_ROUTER 1
CONFIG_MISDN_NETJET_MODULE 1
CONFIG_ARCNET_COM20020_CS_MODULE 1
CONFIG_COMEDI_CB_PCIDDA_MODULE 1
CONFIG_DRM_XEN_FRONTEND_MODULE 1
CONFIG_VIDEO_USBVISION_MODULE 1
CONFIG_FB_SYS_COPYAREA_MODULE 1
CONFIG_X86_64_SMP 1
CONFIG_HTU21_MODULE 1
CONFIG_USB_EHCI_PCI 1
CONFIG_XILINX_AXI_EMAC_MODULE 1
CONFIG_PATA_CYPRESS_MODULE 1
CONFIG_CLEANCACHE 1
CONFIG_TYPEC_RT1711H_MODULE 1
CONFIG_SPI_BITBANG_MODULE 1
CONFIG_MEDIA_TUNER_MT2063_MODULE 1
CONFIG_USB_STORAGE_ALAUDA_MODULE 1
CONFIG_NET_VENDOR_FUJITSU 1
CONFIG_JOYSTICK_GRIP_MP_MODULE 1
CONFIG_SPARSEMEM_EXTREME 1
CONFIG_DMARD09_MODULE 1
CONFIG_W1_SLAVE_DS2406_MODULE 1
CONFIG_B44_PCICORE_AUTOSELECT 1
CONFIG_IWLWIFI_MODULE 1
CONFIG_AB3100_OTP_MODULE 1
CONFIG_USB_COMMON 1
CONFIG_CYPRESS_FIRMWARE_MODULE 1
CONFIG_BPF_KPROBE_OVERRIDE 1
CONFIG_SENSORS_ADM1031_MODULE 1
CONFIG_TASK_XACCT 1
CONFIG_ARCNET_1051_MODULE 1
CONFIG_MEDIA_TUNER_TDA18271_MODULE 1
CONFIG_IP_SET_BITMAP_PORT_MODULE 1
CONFIG_IP6_NF_IPTABLES_MODULE 1
CONFIG_LZ4_COMPRESS_MODULE 1
CONFIG_SND_SOC_SIGMADSP_REGMAP_MODULE 1
CONFIG_KVM_VFIO 1
CONFIG_REGULATOR_AB3100_MODULE 1
CONFIG_PHY_QCOM_USB_HSIC_MODULE 1
CONFIG_USB_HSIC_USB3503_MODULE 1
CONFIG_X86_PCC_CPUFREQ 1
CONFIG_QFMT_V1_MODULE 1
CONFIG_DVB_IX2505V_MODULE 1
CONFIG_TOUCHSCREEN_USB_ZYTRONIC 1
CONFIG_ATM_HORIZON_MODULE 1
CONFIG_SND_SONICVIBES_MODULE 1
CONFIG_FIXED_PHY 1
CONFIG_CHELSIO_T4_FCOE 1
CONFIG_DVB_SP2_MODULE 1
CONFIG_GPIO_WS16C48_MODULE 1
CONFIG_GPIO_ACPI 1
CONFIG_MFD_MAX8998 1
CONFIG_ARCH_DEFCONFIG "arch/x86/configs/x86_64_defconfig"
CONFIG_ARCH_HAS_SYNC_CORE_BEFORE_USERMODE 1
CONFIG_SENSORS_TMP103_MODULE 1
CONFIG_NLS_MAC_GAELIC_MODULE 1
CONFIG_CPU_FREQ_GOV_USERSPACE 1
CONFIG_FTRACE_SYSCALLS 1
CONFIG_IMG_ASCII_LCD_MODULE 1
CONFIG_SND_SOC_TSCS42XX_MODULE 1
CONFIG_SND_CA0106_MODULE 1
CONFIG_VIDEO_VIA_CAMERA_MODULE 1
CONFIG_LOG_CPU_MAX_BUF_SHIFT 12
CONFIG_VIDEO_SAA6752HS_MODULE 1
CONFIG_NF_DUP_IPV4_MODULE 1
CONFIG_XEN_PVHVM_SMP 1
CONFIG_BLK_DEV_DM_BUILTIN 1
CONFIG_INTEL_CHTDC_TI_PWRBTN_MODULE 1
CONFIG_RPR0521_MODULE 1
CONFIG_COMEDI_FL512_MODULE 1
CONFIG_USB_SERIAL_IPW_MODULE 1
CONFIG_I2C_PIIX4_MODULE 1
CONFIG_EDAC_I7300_MODULE 1
CONFIG_USB_HCD_SSB_MODULE 1
CONFIG_INTEL_SOC_DTS_THERMAL_MODULE 1
CONFIG_ARCNET_COM20020_PCI_MODULE 1
CONFIG_SERIAL_UARTLITE_MODULE 1
CONFIG_INET_IPCOMP_MODULE 1
CONFIG_SENSORS_FSCHMD_MODULE 1
CONFIG_TASKS_RCU 1
CONFIG_INTEL_RAPL_CORE_MODULE 1
CONFIG_VGA_ARB_MAX_GPUS 16
CONFIG_DVB_USB_DIB0700_MODULE 1
CONFIG_TOUCHSCREEN_FUJITSU_MODULE 1
CONFIG_PCMCIA_MODULE 1
CONFIG_XEN_BLKDEV_BACKEND_MODULE 1
CONFIG_SND_SOC_RT5514_SPI_MODULE 1
CONFIG_GENERIC_PINCONF 1
CONFIG_CAN_PEAK_USB_MODULE 1
CONFIG_BT_HCIBLUECARD_MODULE 1
CONFIG_JFFS2_FS_XATTR 1
CONFIG_XILLYBUS_PCIE_MODULE 1
CONFIG_EVENT_TRACING 1
CONFIG_PAGE_TABLE_ISOLATION 1
CONFIG_MFD_INTEL_LPSS_MODULE 1
CONFIG_SND_ENS1370_MODULE 1
CONFIG_AD7476_MODULE 1
CONFIG_ASYNC_PQ_MODULE 1
CONFIG_HID_KEYTOUCH_MODULE 1
CONFIG_HID_CYPRESS_MODULE 1
CONFIG_N_GSM_MODULE 1
CONFIG_REGULATOR_LM363X_MODULE 1
CONFIG_SG_POOL 1
CONFIG_BRIDGE_EBT_LIMIT_MODULE 1
CONFIG_SURFACE_PRO3_BUTTON_MODULE 1
CONFIG_DRM_KMS_HELPER_MODULE 1
CONFIG_SERIAL_IPOCTAL_MODULE 1
CONFIG_NET_VENDOR_PACKET_ENGINES 1
CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN_MODULE 1
CONFIG_IPW2200_PROMISCUOUS 1
CONFIG_TRACE_SINK_MODULE 1
CONFIG_NF_SOCKET_IPV6_MODULE 1
CONFIG_OCFS2_FS_USERSPACE_CLUSTER_MODULE 1
CONFIG_INTEL_BXTWC_PMIC_TMU_MODULE 1
CONFIG_INIT_ON_ALLOC_DEFAULT_ON 1
CONFIG_HYSDN_MODULE 1
CONFIG_COMEDI_ADL_PCI9111_MODULE 1
CONFIG_ATA_OVER_ETH_MODULE 1
CONFIG_BLK_MQ_PCI 1
CONFIG_SPI_MXIC_MODULE 1
CONFIG_USB_NET_PLUSB_MODULE 1
CONFIG_SND_SOC_TDA7419_MODULE 1
CONFIG_VIDEO_SAA711X_MODULE 1
CONFIG_RTL8192C_COMMON_MODULE 1
CONFIG_REGULATOR_PWM_MODULE 1
CONFIG_MFD_WM831X_SPI 1
CONFIG_SENSORS_LM95234_MODULE 1
CONFIG_ADXL372_MODULE 1
CONFIG_VIDEO_TW9910_MODULE 1
CONFIG_MEN_A21_WDT_MODULE 1
CONFIG_PREEMPT_VOLUNTARY 1
CONFIG_DVB_BUDGET_CORE_MODULE 1
CONFIG_NLS_ISO8859_1_MODULE 1
CONFIG_MFD_WM8400 1
CONFIG_MTD_INTEL_VR_NOR_MODULE 1
CONFIG_TOUCHSCREEN_WDT87XX_I2C_MODULE 1
CONFIG_MACINTOSH_DRIVERS 1
CONFIG_NFC_MODULE 1
CONFIG_ALX_MODULE 1
CONFIG_CIFS_FSCACHE 1
CONFIG_R8169_MODULE 1
CONFIG_MAX30102_MODULE 1
CONFIG_PCI_STUB_MODULE 1
CONFIG_TCP_CONG_HYBLA_MODULE 1
CONFIG_CRYPTO_DRBG_CTR 1
CONFIG_DRM_I2C_NXP_TDA998X_MODULE 1
CONFIG_MMC_CQHCI_MODULE 1
CONFIG_HID_KENSINGTON_MODULE 1
CONFIG_BACKLIGHT_GENERIC_MODULE 1
CONFIG_USB_EHCI_HCD 1
CONFIG_BATTERY_DS2760_MODULE 1
CONFIG_TEXTSEARCH_BM_MODULE 1
CONFIG_SENSORS_HMC5843_I2C_MODULE 1
CONFIG_CHARGER_BQ25890_MODULE 1
CONFIG_FUJITSU_ES_MODULE 1
CONFIG_FS_IOMAP 1
CONFIG_8139TOO_MODULE 1
CONFIG_JFS_SECURITY 1
CONFIG_SND_SOC_TLV320AIC32X4_I2C_MODULE 1
CONFIG_AFS_FSCACHE 1
CONFIG_SND_PDAUDIOCF_MODULE 1
CONFIG_NLS_MAC_INUIT_MODULE 1
CONFIG_PHY_QCOM_USB_HS_MODULE 1
CONFIG_BT_HCIUART_LL 1
CONFIG_HAVE_EISA 1
CONFIG_HID_ZYDACRON_MODULE 1
CONFIG_REGULATOR_LP8755_MODULE 1
CONFIG_PPP_MPPE_MODULE 1
CONFIG_CAN_CALC_BITTIMING 1
CONFIG_HID_SENSOR_ACCEL_3D_MODULE 1
CONFIG_DE2104X_MODULE 1
CONFIG_KXSD9_I2C_MODULE 1
CONFIG_ISA_BUS_API 1
CONFIG_MEMORY_HOTPLUG 1
CONFIG_VMD_MODULE 1
CONFIG_DVB_B2C2_FLEXCOP_MODULE 1
CONFIG_MOST_VIDEO_MODULE 1
CONFIG_USB_NET_SR9700_MODULE 1
CONFIG_HOTPLUG_PCI_ACPI 1
CONFIG_MFD_TQMX86_MODULE 1
CONFIG_SATA_ZPODD 1
CONFIG_HID_CMEDIA_MODULE 1
CONFIG_SND_SOC_WM8960_MODULE 1
CONFIG_RFKILL 1
CONFIG_AD5272_MODULE 1
CONFIG_VIDEO_TVP5150_MODULE 1
CONFIG_MEDIA_TUNER_FC0012_MODULE 1
CONFIG_NETDEVICES 1
CONFIG_ISA_BUS 1
CONFIG_NET_KEY_MODULE 1
CONFIG_VIDEO_ADV7180_MODULE 1
CONFIG_SMS_SIANO_MDTV_MODULE 1
CONFIG_HAVE_CONTEXT_TRACKING 1
CONFIG_SND_SOC_WCD9335_MODULE 1
CONFIG_IP6_NF_TARGET_HL_MODULE 1
CONFIG_DLCI_MODULE 1
CONFIG_NETFILTER_CONNCOUNT_MODULE 1
CONFIG_ATM_IDT77252_USE_SUNI 1
CONFIG_SND_OPL3_LIB_SEQ_MODULE 1
CONFIG_ARCH_HAS_KCOV 1
CONFIG_CGROUP_FREEZER 1
CONFIG_VIDEO_UPD64083_MODULE 1
CONFIG_SERIAL_ALTERA_JTAGUART_MODULE 1
CONFIG_TOUCHSCREEN_MELFAS_MIP4_MODULE 1
CONFIG_HAVE_ARCH_STACKLEAK 1
CONFIG_EVENTFD 1
CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE 1
CONFIG_SPI_DESIGNWARE_MODULE 1
CONFIG_MTD_CK804XROM_MODULE 1
CONFIG_PARIDE_PD_MODULE 1
CONFIG_RTL8192CE_MODULE 1
CONFIG_WAN 1
CONFIG_VLAN_8021Q_MVRP 1
CONFIG_RTL8821AE_MODULE 1
CONFIG_FS_POSIX_ACL 1
CONFIG_IPV6_SIT_MODULE 1
CONFIG_REGULATOR_TPS65912_MODULE 1
CONFIG_QTNFMAC_PCIE_MODULE 1
CONFIG_EEPROM_EE1004_MODULE 1
CONFIG_XFRM 1
CONFIG_SENSORS_K8TEMP_MODULE 1
CONFIG_SND_SOC_BT_SCO_MODULE 1
CONFIG_ASYNC_TX_DMA 1
CONFIG_COMEDI_DAS16_MODULE 1
CONFIG_CAIF_USB_MODULE 1
CONFIG_ARCH_HAS_PMEM_API 1
CONFIG_USB_F_UAC2_MODULE 1
CONFIG_DM_UNSTRIPED_MODULE 1
CONFIG_HAVE_KPROBES_ON_FTRACE 1
CONFIG_REGULATOR_PV88090_MODULE 1
CONFIG_IP_SET_HASH_IP_MODULE 1
CONFIG_TINYDRM_ST7586_MODULE 1
CONFIG_YENTA_TOSHIBA 1
CONFIG_USB_MR800_MODULE 1
CONFIG_JOYSTICK_AS5011_MODULE 1
CONFIG_VIDEO_OV5695_MODULE 1
CONFIG_AIRO_MODULE 1
CONFIG_MTD_NETtel_MODULE 1
CONFIG_MFD_VX855_MODULE 1
CONFIG_SERIAL_8250_CONSOLE 1
CONFIG_IPV6_MULTIPLE_TABLES 1
CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
CONFIG_USB_SERIAL_WHITEHEAT_MODULE 1
CONFIG_NET_CLS_ROUTE4_MODULE 1
CONFIG_VIDEO_TVP514X_MODULE 1
CONFIG_JUMP_LABEL 1
CONFIG_HID_UDRAW_PS3_MODULE 1
CONFIG_PCMCIA_FMVJ18X_MODULE 1
CONFIG_KEYBOARD_QT1070_MODULE 1
CONFIG_MFD_KEMPLD_MODULE 1
CONFIG_USB_NET2272_MODULE 1
CONFIG_OVERLAY_FS_MODULE 1
CONFIG_IP_SET_HASH_NETPORT_MODULE 1
CONFIG_CIFS_ALLOW_INSECURE_LEGACY 1
CONFIG_TCG_INFINEON_MODULE 1
CONFIG_ATH9K_HTC_MODULE 1
CONFIG_IP_VS_DH_MODULE 1
CONFIG_SND_SOC_WM8753_MODULE 1
CONFIG_GPIO_XILINX 1
CONFIG_BRCMFMAC_PROTO_MSGBUF 1
CONFIG_AX25_DAMA_SLAVE 1
CONFIG_AD5380_MODULE 1
CONFIG_RT2800PCI_RT3290 1
CONFIG_VIDEO_MEM2MEM_DEINTERLACE_MODULE 1
CONFIG_RADIO_WL128X_MODULE 1
CONFIG_COMMON_CLK_CS2000_CP_MODULE 1
CONFIG_DA311_MODULE 1
CONFIG_IP_NF_TARGET_MASQUERADE_MODULE 1
CONFIG_AIC79XX_RESET_DELAY_MS 5000
CONFIG_UIO_HV_GENERIC_MODULE 1
CONFIG_ARCNET_COM20020_MODULE 1
CONFIG_TORTURE_TEST_MODULE 1
CONFIG_MFD_AAT2870_CORE 1
CONFIG_HAVE_EBPF_JIT 1
CONFIG_NF_CONNTRACK_BROADCAST_MODULE 1
CONFIG_NET_DSA_MICROCHIP_KSZ8795_SPI_MODULE 1
CONFIG_ARCH_HAS_KEXEC_PURGATORY 1
CONFIG_CRYPTO_LZ4_MODULE 1
CONFIG_ECRYPT_FS 1
CONFIG_NFT_FWD_NETDEV_MODULE 1
CONFIG_PROC_PAGE_MONITOR 1
CONFIG_USB_CONFIGFS_ECM 1
CONFIG_MFD_MAX8907_MODULE 1
CONFIG_SERIAL_8250_EXTENDED 1
CONFIG_GAMEPORT_FM801_MODULE 1
CONFIG_NETFILTER_XT_TARGET_MASQUERADE_MODULE 1
CONFIG_RTC_DRV_MAX6916_MODULE 1
CONFIG_JOYSTICK_MAGELLAN_MODULE 1
CONFIG_AD7887_MODULE 1
CONFIG_AD7780_MODULE 1
CONFIG_FTL_MODULE 1
CONFIG_IGB_HWMON 1
CONFIG_DM_CACHE_MODULE 1
CONFIG_MEDIA_TUNER_R820T_MODULE 1
CONFIG_MTD_SPI_NOR_USE_4K_SECTORS 1
CONFIG_TYPEC_DP_ALTMODE_MODULE 1
CONFIG_MOST_I2C_MODULE 1
CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
CONFIG_BPF 1
CONFIG_9P_FS_POSIX_ACL 1
CONFIG_STM_SOURCE_HEARTBEAT_MODULE 1
CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
CONFIG_VIDEO_SH_VEU_MODULE 1
CONFIG_SENSORS_ADM1021_MODULE 1
CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK 1
CONFIG_C2PORT_MODULE 1
CONFIG_EVM_ATTR_FSUUID 1
CONFIG_DM_DELAY_MODULE 1
CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE 1
CONFIG_X86_CMOV 1
CONFIG_USB_SERIAL_CH341_MODULE 1
CONFIG_HID_SENSOR_IIO_COMMON_MODULE 1
CONFIG_USB_FTDI_ELAN_MODULE 1
CONFIG_NET_DSA_TAG_SJA1105_MODULE 1
CONFIG_ACPI_HOTPLUG_CPU 1
CONFIG_XILINX_SDFEC_MODULE 1
CONFIG_PM_TRACE_RTC 1
CONFIG_RD_LZO 1
CONFIG_COMEDI_ADDI_APCI_1564_MODULE 1
CONFIG_USB_RAINSHADOW_CEC_MODULE 1
CONFIG_JFFS2_FS_SECURITY 1
CONFIG_USB_G_NOKIA_MODULE 1
CONFIG_IP_SET_HASH_IPPORT_MODULE 1
CONFIG_CRYPTO_NHPOLY1305_SSE2_MODULE 1
CONFIG_CAIF_TTY_MODULE 1
CONFIG_KPROBE_EVENTS 1
CONFIG_SENSORS_SHT21_MODULE 1
CONFIG_USB_IOWARRIOR_MODULE 1
CONFIG_SND_HDSP_MODULE 1
CONFIG_BATTERY_DA9052_MODULE 1
CONFIG_SERIO_CT82C710_MODULE 1
CONFIG_OPENVSWITCH_GENEVE_MODULE 1
CONFIG_MLX4_CORE_GEN2 1
CONFIG_USBPCWATCHDOG_MODULE 1
CONFIG_CAN_KVASER_PCIEFD_MODULE 1
CONFIG_MODULE_SIG_ALL 1
CONFIG_USB_EZUSB_FX2_MODULE 1
CONFIG_SND_USB_TONEPORT_MODULE 1
CONFIG_WIMAX_I2400M_USB_MODULE 1
CONFIG_SND_USB_USX2Y_MODULE 1
CONFIG_SCSI_SPI_ATTRS_MODULE 1
CONFIG_PARIDE_EPATC8 1
CONFIG_FB_CYBER2000_MODULE 1
CONFIG_BCMA_DRIVER_GMAC_CMN 1
CONFIG_RTL8XXXU_MODULE 1
CONFIG_GREENASIA_FF 1
CONFIG_MFD_CS47L92 1
CONFIG_PINCTRL_CEDARFORK_MODULE 1
CONFIG_SCSI_HPSA_MODULE 1
CONFIG_MICROCODE_AMD 1
CONFIG_XEN_GNTDEV_DMABUF 1
CONFIG_SPEAKUP_SYNTH_ACNTSA_MODULE 1
CONFIG_SND_SOC_IMG_I2S_IN_MODULE 1
CONFIG_RAPIDIO_TSI721_MODULE 1
CONFIG_SND_KORG1212_MODULE 1
CONFIG_SENSORS_VIA_CPUTEMP_MODULE 1
CONFIG_MLX5_EN_ARFS 1
CONFIG_NF_CONNTRACK_SECMARK 1
CONFIG_ISDN_DRV_GIGASET_MODULE 1
CONFIG_GP2AP020A00F_MODULE 1
CONFIG_CHELSIO_T3_MODULE 1
CONFIG_VIDEO_OV7640_MODULE 1
CONFIG_INSTRUCTION_DECODER 1
CONFIG_CRYPTO_SHA512 1
CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC_MODULE 1
CONFIG_PHONET_MODULE 1
CONFIG_MWIFIEX_PCIE_MODULE 1
CONFIG_CAN_C_CAN_PCI_MODULE 1
CONFIG_CAN_VXCAN_MODULE 1
CONFIG_TRUSTED_KEYS 1
CONFIG_SND_SOC_AC97_BUS 1
CONFIG_VIDEO_SECO_CEC_MODULE 1
CONFIG_BACKLIGHT_CLASS_DEVICE 1
CONFIG_CC_HAS_ASM_INLINE 1
CONFIG_B43_HWRNG 1
CONFIG_VHOST_MODULE 1
CONFIG_USB_M5602_MODULE 1
CONFIG_RT2X00_LIB_USB_MODULE 1
CONFIG_UIO_MF624_MODULE 1
CONFIG_SND_SOC_SOF_HDA_LINK 1
CONFIG_WM8350_POWER_MODULE 1
CONFIG_SPI_DLN2_MODULE 1
CONFIG_INPUT_CMA3000_I2C_MODULE 1
CONFIG_CRYPTO_NULL 1
CONFIG_INTEL_WMI_THUNDERBOLT_MODULE 1
CONFIG_DVB_USB_AF9005_REMOTE_MODULE 1
CONFIG_B43_PHY_G 1
CONFIG_NET_VENDOR_SEEQ 1
CONFIG_NF_DEFRAG_IPV4_MODULE 1
CONFIG_USER_RETURN_NOTIFIER 1
CONFIG_RTC_DRV_AM1805_MODULE 1
CONFIG_INTEL_IOMMU_FLOPPY_WA 1
CONFIG_BT_QCA_MODULE 1
CONFIG_USB_IDMOUSE_MODULE 1
CONFIG_SELECT_MEMORY_MODEL 1
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64_MODULE 1
CONFIG_SND_FIREWIRE_TASCAM_MODULE 1
CONFIG_MISDN_INFINEON_MODULE 1
CONFIG_HID_LCPOWER_MODULE 1
CONFIG_IEEE802154_HWSIM_MODULE 1
CONFIG_VIRTIO_CONSOLE 1
CONFIG_MOUSE_ELAN_I2C_SMBUS 1
CONFIG_ARCH_CLOCKSOURCE_INIT 1
CONFIG_NFC_MRVL_MODULE 1
CONFIG_ACPI_APEI_EINJ_MODULE 1
CONFIG_PVH 1
CONFIG_STM_PROTO_BASIC_MODULE 1
CONFIG_PERSISTENT_KEYRINGS 1
CONFIG_MLX5_TLS 1
CONFIG_NET_ACT_CONNMARK_MODULE 1
CONFIG_BFS_FS_MODULE 1
CONFIG_FS_ENCRYPTION 1
CONFIG_SND_ES1938_MODULE 1
CONFIG_PM_DEBUG 1
CONFIG_VIDEO_TW9906_MODULE 1
CONFIG_DVB_BUDGET_AV_MODULE 1
CONFIG_IPV6_ROUTE_INFO 1
CONFIG_MFD_WM8350_I2C 1
CONFIG_NETFILTER_ADVANCED 1
CONFIG_CRYPTO_DEFLATE 1
CONFIG_GENERIC_STRNLEN_USER 1
CONFIG_MFD_WM8350 1
CONFIG_NFT_DUP_NETDEV_MODULE 1
CONFIG_USB_APPLEDISPLAY_MODULE 1
CONFIG_USB_SERIAL_KLSI_MODULE 1
CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE 1
CONFIG_RTC_DRV_DA9063_MODULE 1
CONFIG_IGB_MODULE 1
CONFIG_MTD_CFI_MODULE 1
CONFIG_COMEDI_USBDUXSIGMA_MODULE 1
CONFIG_QCOM_VADC_COMMON_MODULE 1
CONFIG_AD7768_1_MODULE 1
CONFIG_RPMSG_VIRTIO_MODULE 1
CONFIG_NETFILTER_XT_MATCH_IPCOMP_MODULE 1
CONFIG_IPV6_ROUTER_PREF 1
CONFIG_JFFS2_FS_DEBUG 0
CONFIG_BT_HCIBTSDIO_MODULE 1
CONFIG_DRM_QXL_MODULE 1
CONFIG_WLAN_VENDOR_RSI 1
CONFIG_SLIP_COMPRESSED 1
CONFIG_CRYPTO_JITTERENTROPY 1
CONFIG_JOYSTICK_PSXPAD_SPI_MODULE 1
CONFIG_NTB_INTEL_MODULE 1
CONFIG_SND_VX_LIB_MODULE 1
CONFIG_ATM_MPOA_MODULE 1
CONFIG_TYPEC_MODULE 1
CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION 1
CONFIG_CHARGER_WILCO_MODULE 1
CONFIG_NETFILTER_XT_MATCH_L2TP_MODULE 1
CONFIG_BT_HCIUART_SERDEV 1
CONFIG_INPUT_ARIZONA_HAPTICS_MODULE 1
CONFIG_DM_SWITCH_MODULE 1
CONFIG_ROCKETPORT_MODULE 1
CONFIG_CRYPTO_GCM 1
CONFIG_SND_INDIGOIO_MODULE 1
CONFIG_NE2K_PCI_MODULE 1
CONFIG_VIDEO_OV2680_MODULE 1
CONFIG_MOUSE_SYNAPTICS_USB_MODULE 1
CONFIG_NETFILTER_NETLINK_LOG_MODULE 1
CONFIG_HAVE_DYNAMIC_FTRACE 1
CONFIG_PWM_LPSS_PCI 1
CONFIG_CDROM 1
CONFIG_PINCTRL_CHERRYVIEW 1
CONFIG_NLS_ISO8859_14_MODULE 1
CONFIG_DS1803_MODULE 1
CONFIG_MTD_PHRAM_MODULE 1
CONFIG_MAGIC_SYSRQ 1
CONFIG_MFD_88PM860X 1
CONFIG_CROS_EC_CHARDEV_MODULE 1
CONFIG_VOP_MODULE 1
CONFIG_USB_CONFIGFS_F_FS 1
CONFIG_E100_MODULE 1
CONFIG_REGULATOR_TPS6586X_MODULE 1
CONFIG_THERMAL_EMULATION 1
CONFIG_MDIO_THUNDER_MODULE 1
CONFIG_DMI 1
CONFIG_IPV6_SIT_6RD 1
CONFIG_SND_SOC_NAU8540_MODULE 1
CONFIG_WIL6210_TRACING 1
CONFIG_PARPORT_SERIAL_MODULE 1
CONFIG_SND_DICE_MODULE 1
CONFIG_CRYPTO_KPP 1
CONFIG_PNFS_BLOCK_MODULE 1
CONFIG_NET_VENDOR_RDC 1
CONFIG_MACHZ_WDT_MODULE 1
CONFIG_PGTABLE_LEVELS 4
CONFIG_CPUSETS 1
CONFIG_NETFILTER_XT_MATCH_MARK_MODULE 1
CONFIG_FB_MATROX_MODULE 1
CONFIG_ISDN 1
CONFIG_VIDEO_PVRUSB2_SYSFS 1
CONFIG_ATLAS_PH_SENSOR_MODULE 1
CONFIG_FUNCTION_PROFILER 1
CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
CONFIG_NVME_MULTIPATH 1
CONFIG_RMI4_F03_SERIO_MODULE 1
CONFIG_SPARSE_IRQ 1
CONFIG_MMA7455_I2C_MODULE 1
CONFIG_COMEDI_AMPLC_PC236_MODULE 1
CONFIG_DVB_LGS8GXX_MODULE 1
CONFIG_IR_SERIAL_TRANSMITTER 1
CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE 1
CONFIG_INPUT_IDEAPAD_SLIDEBAR_MODULE 1
CONFIG_GREYBUS_MODULE 1
CONFIG_SSFDC_MODULE 1
CONFIG_IP_NF_MANGLE_MODULE 1
CONFIG_LEDS_USER_MODULE 1
CONFIG_TIFM_7XX1_MODULE 1
CONFIG_USB_MASS_STORAGE_MODULE 1
CONFIG_SCSI_UFS_DWC_TC_PCI_MODULE 1
CONFIG_HID_PICOLCD_LEDS 1
CONFIG_COMEDI_CB_DAS16_CS_MODULE 1
CONFIG_RTC_DRV_DS1286_MODULE 1
CONFIG_FCOE_FNIC_MODULE 1
CONFIG_INTEL_SMARTCONNECT_MODULE 1
CONFIG_ATH10K_DEBUGFS 1
CONFIG_BCM_KONA_USB2_PHY_MODULE 1
CONFIG_MOXA_INTELLIO_MODULE 1
CONFIG_TOUCHSCREEN_MCS5000_MODULE 1
CONFIG_DVB_VES1X93_MODULE 1
CONFIG_SECURITY_PERF_EVENTS_RESTRICT 1
CONFIG_DRM_UDL_MODULE 1
CONFIG_SECURITYFS 1
CONFIG_LIBERTAS_MESH 1
CONFIG_RTC_DRV_S5M_MODULE 1
CONFIG_VIDEO_FB_IVTV_FORCE_PAT 1
CONFIG_RCU_STALL_COMMON 1
CONFIG_COMEDI_NI_PCIDIO_MODULE 1
CONFIG_BT_DEBUGFS 1
CONFIG_CPU_SUP_AMD 1
CONFIG_SND_SOC_SIRF_AUDIO_CODEC_MODULE 1
CONFIG_MFD_INTEL_QUARK_I2C_GPIO_MODULE 1
CONFIG_BRIDGE_EBT_VLAN_MODULE 1
CONFIG_PCIEPORTBUS 1
CONFIG_MEDIA_SUPPORT_MODULE 1
CONFIG_NFT_FIB_IPV6_MODULE 1
CONFIG_SENSORS_F75375S_MODULE 1
CONFIG_DEBUG_BUGVERBOSE 1
CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK 1
CONFIG_VIDEO_ST_MIPID02_MODULE 1
CONFIG_ACPI_CUSTOM_DSDT_FILE ""
CONFIG_IP_NF_FILTER_MODULE 1
CONFIG_BH1780_MODULE 1
CONFIG_HID_ZEROPLUS_MODULE 1
CONFIG_REED_SOLOMON_DEC16 1
CONFIG_SND_SOC_SOF_MERRIFIELD_MODULE 1
CONFIG_DYNAMIC_MEMORY_LAYOUT 1
CONFIG_SND_SST_IPC_PCI_MODULE 1
CONFIG_SENSORS_MC13783_ADC_MODULE 1
CONFIG_DM_INTEGRITY_MODULE 1
CONFIG_SATA_SX4_MODULE 1
CONFIG_MAC802154_MODULE 1
CONFIG_IBM_ASM_MODULE 1
CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE 1
CONFIG_BRIDGE_EBT_PKTTYPE_MODULE 1
CONFIG_HID_SENSOR_GYRO_3D_MODULE 1
CONFIG_COMEDI_8255_SA_MODULE 1
CONFIG_AFE4403_MODULE 1
CONFIG_MODULES_TREE_LOOKUP 1
CONFIG_FAT_FS 1
CONFIG_SND_HDA_CODEC_CA0132_MODULE 1
CONFIG_FCOE_MODULE 1
CONFIG_CAN_SJA1000_MODULE 1
CONFIG_AUFS_BDEV_LOOP 1
CONFIG_SND_HDA_INTEL_MODULE 1
CONFIG_CRYPTO_DEV_QAT_DH895xCCVF_MODULE 1
CONFIG_BLK_DEBUG_FS_ZONED 1
CONFIG_ACPI_ADXL 1
CONFIG_TEXTSEARCH_FSM_MODULE 1
CONFIG_USB_HSIC_USB4604_MODULE 1
CONFIG_MISDN_DSP_MODULE 1
CONFIG_SENSORS_LM75_MODULE 1
CONFIG_PANEL_PROFILE 5
CONFIG_INFINIBAND_CXGB4_MODULE 1
CONFIG_DVB_STV0910_MODULE 1
CONFIG_LSI_ET1011C_PHY_MODULE 1
CONFIG_SND_SOC_RT5616_MODULE 1
CONFIG_IP6_NF_RAW_MODULE 1
CONFIG_SPEAKUP_SYNTH_SOFT_MODULE 1
CONFIG_DVB_USB_EC168_MODULE 1
CONFIG_USB_ZD1201_MODULE 1
CONFIG_RTC_DRV_DS1742_MODULE 1
CONFIG_NVMEM 1
CONFIG_INET_TUNNEL_MODULE 1
CONFIG_X86_INTERNODE_CACHE_SHIFT 6
CONFIG_BMA220_MODULE 1
CONFIG_EXFAT_DISCARD 1
CONFIG_CRYPTO_SERPENT_SSE2_X86_64_MODULE 1
CONFIG_NF_LOG_ARP_MODULE 1
CONFIG_CRYPTO_DEV_PADLOCK 1
CONFIG_SENSORS_PMBUS_MODULE 1
CONFIG_MT76x0_COMMON_MODULE 1
CONFIG_EEPROM_93CX6_MODULE 1
CONFIG_GPIO_WM8350_MODULE 1
CONFIG_IEEE802154_CA8210_MODULE 1
CONFIG_NET_9P_VIRTIO_MODULE 1
CONFIG_NET_ACT_SKBMOD_MODULE 1
CONFIG_PINCONF 1
CONFIG_MFD_DA9052_SPI 1
CONFIG_X86_CHECK_BIOS_CORRUPTION 1
CONFIG_IIO_ST_LSM6DSX_I2C_MODULE 1
CONFIG_NET_DSA_SMSC_LAN9303_I2C_MODULE 1
CONFIG_MLX4_CORE_MODULE 1
CONFIG_GPIO_MENZ127_MODULE 1
CONFIG_DW_I3C_MASTER_MODULE 1
CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK -1
CONFIG_SND_MIA_MODULE 1
CONFIG_GENERIC_CLOCKEVENTS 1
CONFIG_ROMFS_FS_MODULE 1
CONFIG_OID_REGISTRY 1
CONFIG_MFD_88PM805_MODULE 1
CONFIG_SGI_GRU_MODULE 1
CONFIG_PHY_PXA_28NM_HSIC_MODULE 1
CONFIG_DVB_USB_DTT200U_MODULE 1
CONFIG_CIFS_UPCALL 1
CONFIG_GREYBUS_VIBRATOR_MODULE 1
CONFIG_THUNDER_NIC_PF_MODULE 1
CONFIG_RADIO_TEA575X_MODULE 1
CONFIG_PARIDE_EPIA_MODULE 1
CONFIG_LIB80211_MODULE 1
CONFIG_INTEGRITY_PLATFORM_KEYRING 1
CONFIG_MEDIA_CEC_SUPPORT 1
CONFIG_MFD_CORE 1
CONFIG_HAVE_KERNEL_XZ 1
CONFIG_COMEDI_AMPLC_PC236_ISA_MODULE 1
CONFIG_USB_CXACRU_MODULE 1
CONFIG_DRM_GMA3600 1
CONFIG_X86_PKG_TEMP_THERMAL_MODULE 1
CONFIG_RAID_ATTRS_MODULE 1
CONFIG_RFKILL_LEDS 1
CONFIG_BT_HCIBTUSB_BCM 1
CONFIG_CONSOLE_TRANSLATIONS 1
CONFIG_PATA_CMD64X_MODULE 1
CONFIG_KEYBOARD_TM2_TOUCHKEY_MODULE 1
CONFIG_MTD_CFI_STAA_MODULE 1
CONFIG_ARCH_SUPPORTS_ATOMIC_RMW 1
CONFIG_TCG_CRB 1
CONFIG_REGULATOR_AD5398_MODULE 1
CONFIG_USB_F_UVC_MODULE 1
CONFIG_RAID6_PQ_MODULE 1
CONFIG_SBC_FITPC2_WATCHDOG_MODULE 1
CONFIG_HW_RANDOM_TIMERIOMEM_MODULE 1
CONFIG_ST_UVIS25_SPI_MODULE 1
CONFIG_NET_IPGRE_MODULE 1
CONFIG_ADT7316_MODULE 1
CONFIG_LIBERTAS_SDIO_MODULE 1
CONFIG_MDIO_MSCC_MIIM_MODULE 1
CONFIG_CRYPTO_DEV_QAT_MODULE 1
CONFIG_FUSION 1
CONFIG_MTDRAM_TOTAL_SIZE 4096
CONFIG_TINYDRM_ST7735R_MODULE 1
CONFIG_VIDEO_TEA6420_MODULE 1
CONFIG_IPV6_SEG6_BPF 1
CONFIG_SWIOTLB_XEN 1
CONFIG_DM_INIT 1
CONFIG_BRIDGE_EBT_IP6_MODULE 1
CONFIG_NF_NAT_SNMP_BASIC_MODULE 1
CONFIG_SND_X86 1
CONFIG_PCMCIA_LOAD_CIS 1
CONFIG_NFT_FIB_NETDEV_MODULE 1
CONFIG_XEN_SYMS 1
CONFIG_SERIAL_EARLYCON 1
CONFIG_VIDEO_OV9640_MODULE 1
CONFIG_CLS_U32_MARK 1
CONFIG_DVB_CX24120_MODULE 1
CONFIG_NET_VENDOR_NI 1
CONFIG_SND_ICE1712_MODULE 1
CONFIG_BACKLIGHT_MAX8925_MODULE 1
CONFIG_CRYPTO_AKCIPHER 1
CONFIG_LIBERTAS_SPI_MODULE 1
CONFIG_SCSI_ACARD_MODULE 1
CONFIG_EROFS_FS_ZIP 1
CONFIG_SND_SOC_SIGMADSP_I2C_MODULE 1
CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE 1
CONFIG_ACPI_CPU_FREQ_PSS 1
CONFIG_CPU_FREQ 1
CONFIG_USB_OHCI_HCD 1
CONFIG_VIA_RHINE_MODULE 1
CONFIG_USB_GSPCA_MODULE 1
CONFIG_HOSTAP_FIRMWARE 1
CONFIG_VHOST_RING_MODULE 1
CONFIG_NR_CPUS_DEFAULT 8192
CONFIG_DVB_DUMMY_FE_MODULE 1
CONFIG_DM_MIRROR_MODULE 1
CONFIG_CRYPTO_BLOWFISH_MODULE 1
CONFIG_FB_SIS_MODULE 1
CONFIG_ARCH_CPUIDLE_HALTPOLL 1
CONFIG_DUMMY_CONSOLE 1
CONFIG_MLXSW_CORE_HWMON 1
CONFIG_AIC7XXX_DEBUG_MASK 0
CONFIG_SENSORS_LTC3815_MODULE 1
CONFIG_SCSI_GDTH_MODULE 1
CONFIG_CROS_EC_DEBUGFS_MODULE 1
CONFIG_USB_F_TCM_MODULE 1
CONFIG_USB_PCI 1
CONFIG_COMEDI_DAS08_PCI_MODULE 1
CONFIG_NLS_ASCII_MODULE 1
CONFIG_RFKILL_GPIO_MODULE 1
CONFIG_REGULATOR_DA9055_MODULE 1
CONFIG_USB_G_PRINTER_MODULE 1
CONFIG_B43_MODULE 1
CONFIG_FPGA_MGR_ALTERA_CVP_MODULE 1
CONFIG_JOYSTICK_GRIP_MODULE 1
CONFIG_BAYCOM_SER_FDX_MODULE 1
CONFIG_MEDIA_ALTERA_CI_MODULE 1
CONFIG_TIPC_DIAG_MODULE 1
CONFIG_NF_REJECT_IPV4_MODULE 1
CONFIG_RTC_DRV_M41T94_MODULE 1
CONFIG_AD_SIGMA_DELTA_MODULE 1
CONFIG_WIMAX_DEBUG_LEVEL 8
CONFIG_RANDOMIZE_MEMORY 1
CONFIG_ARCH_MMAP_RND_BITS_MAX 32
CONFIG_SND_SOC_FSL_SSI_MODULE 1
CONFIG_BPF_EVENTS 1
CONFIG_USB_LAN78XX_MODULE 1
CONFIG_NFT_CONNLIMIT_MODULE 1
CONFIG_GREYBUS_I2C_MODULE 1
CONFIG_VIDEO_HEXIUM_ORION_MODULE 1
CONFIG_CRYPTO_NHPOLY1305_MODULE 1
CONFIG_IIO_CROS_EC_SENSORS_MODULE 1
CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE 1
CONFIG_BACKLIGHT_GPIO_MODULE 1
CONFIG_INTEL_MEI_ME_MODULE 1
CONFIG_INFINIBAND_QIB_MODULE 1
CONFIG_BT_HCIBTUSB_MTK 1
CONFIG_6LOWPAN_NHC_MOBILITY_MODULE 1
CONFIG_LAPBETHER_MODULE 1
CONFIG_USB_SI4713_MODULE 1
CONFIG_SATA_SVW_MODULE 1
CONFIG_MAX11100_MODULE 1
CONFIG_VIDEO_RJ54N1_MODULE 1
CONFIG_TRACE_IRQFLAGS_SUPPORT 1
CONFIG_AD5360_MODULE 1
CONFIG_IEEE802154_MRF24J40_MODULE 1
CONFIG_MTD_NAND_CORE_MODULE 1
CONFIG_MFD_SYSCON 1
CONFIG_SND_SOC_TAS5720_MODULE 1
CONFIG_MTD_PHYSMAP_MODULE 1
CONFIG_MS5611_SPI_MODULE 1
CONFIG_NFS_V3_ACL 1
CONFIG_HDLC_X25_MODULE 1
CONFIG_IPV6_SEG6_LWTUNNEL 1
CONFIG_CHARGER_GPIO_MODULE 1
CONFIG_INPUT_GPIO_DECODER_MODULE 1
CONFIG_INFTL_MODULE 1
CONFIG_NFT_NUMGEN_MODULE 1
CONFIG_GAMEPORT_L4_MODULE 1
CONFIG_SENSORS_ADT7462_MODULE 1
CONFIG_DETECT_HUNG_TASK 1
CONFIG_PARIDE_FRIQ_MODULE 1
CONFIG_REGULATOR_MAX14577_MODULE 1
CONFIG_SENSORS_NCT7802_MODULE 1
CONFIG_CAN_MCP251X_MODULE 1
CONFIG_CRYPTO_CCM_MODULE 1
CONFIG_TCP_CONG_ADVANCED 1
CONFIG_NET_CLS_RSVP6_MODULE 1
CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT 1
CONFIG_USB_NET_CDC_SUBSET_MODULE 1
CONFIG_BT_RTL_MODULE 1
CONFIG_MMA9551_CORE_MODULE 1
CONFIG_VIDEO_VIMC_MODULE 1
CONFIG_KVM_GUEST 1
CONFIG_DRM_KMS_CMA_HELPER 1
CONFIG_GS_FPGABOOT_MODULE 1
CONFIG_QFMT_V2_MODULE 1
CONFIG_USB_S2255_MODULE 1
CONFIG_INET_DCCP_DIAG_MODULE 1
CONFIG_TAP_MODULE 1
CONFIG_ARCNET_COM90xxIO_MODULE 1
CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE 1
CONFIG_ATH9K_HW_MODULE 1
CONFIG_BLK_CGROUP 1
CONFIG_USB_SERIAL_MCT_U232_MODULE 1
CONFIG_UIO_PDRV_GENIRQ_MODULE 1
CONFIG_BT_HCIBT3C_MODULE 1
CONFIG_LEDS_TRIGGERS 1
CONFIG_NET_FOU_MODULE 1
CONFIG_WIMAX_I2400M_DEBUG_LEVEL 8
CONFIG_CRYPTO_RNG 1
CONFIG_SND_SOC_SOF_HDA_ALWAYS_ENABLE_DMI_L1 1
CONFIG_USB_SERIAL_GARMIN_MODULE 1
CONFIG_W1_MASTER_GPIO_MODULE 1
CONFIG_RAW_DRIVER_MODULE 1
CONFIG_MTD_ESB2ROM_MODULE 1
CONFIG_XFS_QUOTA 1
CONFIG_COMEDI_ISA_DRIVERS 1
CONFIG_JOYSTICK_COBRA_MODULE 1
CONFIG_ATH10K_MODULE 1
CONFIG_SECURITY_SMACK 1
CONFIG_NET_SCH_ATM_MODULE 1
CONFIG_DRM_AMDGPU_CIK 1
CONFIG_WINBOND_840_MODULE 1
CONFIG_TOUCHSCREEN_CYTTSP_SPI_MODULE 1
CONFIG_TI_TLC4541_MODULE 1
CONFIG_SCSI_3W_9XXX_MODULE 1
CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN 8
CONFIG_VIDEO_KS0127_MODULE 1
CONFIG_MVMDIO_MODULE 1
CONFIG_HWLAT_TRACER 1
CONFIG_SENSORS_IRPS5401_MODULE 1
CONFIG_SND_USB 1
CONFIG_LOGIG940_FF 1
CONFIG_VIDEOBUF2_MEMOPS_MODULE 1
CONFIG_RTC_DRV_DS3232_HWMON 1
CONFIG_RD_GZIP 1
CONFIG_CRYPTO_DEV_SAFEXCEL_MODULE 1
CONFIG_TOUCHSCREEN_USB_E2I 1
CONFIG_ARCH_HAS_CPU_RELAX 1
CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
CONFIG_BLK_PM 1
CONFIG_BCMA_HOST_PCI_POSSIBLE 1
CONFIG_SND_SOC_TFA9879_MODULE 1
CONFIG_SENSORS_LTC4261_MODULE 1
CONFIG_MMC_SDRICOH_CS_MODULE 1
CONFIG_COMEDI_ADV_PCI1720_MODULE 1
CONFIG_MISDN_W6692_MODULE 1
CONFIG_USB_SERIAL_KEYSPAN_MODULE 1
CONFIG_THRUSTMASTER_FF 1
CONFIG_MDIO_BUS 1
CONFIG_TREE_RCU 1
CONFIG_PWM_SYSFS 1
CONFIG_SOC_TI 1
CONFIG_GNSS_MODULE 1
CONFIG_ALLOW_DEV_COREDUMP 1
CONFIG_I2C_MUX_GPIO_MODULE 1
CONFIG_SWIOTLB 1
CONFIG_SND_SOC_NAU8822_MODULE 1
CONFIG_SND_USB_CAIAQ_MODULE 1
CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE 1
CONFIG_EXT4_FS_SECURITY 1
CONFIG_SPEAKUP_SYNTH_DUMMY_MODULE 1
CONFIG_ATH9K_HWRNG 1
CONFIG_GRO_CELLS 1
CONFIG_SECURITY_APPARMOR_HASH_DEFAULT 1
CONFIG_SCSI_MVUMI_MODULE 1
CONFIG_DVB_S5H1432_MODULE 1
CONFIG_NET_TEAM_MODE_ACTIVEBACKUP_MODULE 1
CONFIG_9P_FS_SECURITY 1
CONFIG_IR_XMP_DECODER_MODULE 1
CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN 1
CONFIG_LV0104CS_MODULE 1
CONFIG_BEFS_FS_MODULE 1
CONFIG_SND_ALI5451_MODULE 1
CONFIG_PCI_MSI_IRQ_DOMAIN 1
CONFIG_INFINIBAND_USER_MAD_MODULE 1
CONFIG_GENERIC_ADC_THERMAL_MODULE 1
CONFIG_HID_ROCCAT_MODULE 1
CONFIG_NET_VENDOR_HP 1
CONFIG_F71808E_WDT_MODULE 1
CONFIG_HID_SENSOR_TEMP_MODULE 1
CONFIG_MTD_HYPERBUS_MODULE 1
CONFIG_CRYPTO_MD5 1
CONFIG_IMA_DEFAULT_TEMPLATE "ima-ng"
CONFIG_VIDEO_CS53L32A_MODULE 1
CONFIG_IR_REDRAT3_MODULE 1
CONFIG_USB_GSPCA_VICAM_MODULE 1
CONFIG_TOUCHSCREEN_AD7879_SPI_MODULE 1
CONFIG_PCMCIA_HERMES_MODULE 1
CONFIG_TRANSPARENT_HUGEPAGE 1
CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE 1
CONFIG_USB_F_SS_LB_MODULE 1
CONFIG_ISCSI_TCP_MODULE 1
CONFIG_ATA_ACPI 1
CONFIG_NFSD_V3 1
CONFIG_NET_SCH_SKBPRIO_MODULE 1
CONFIG_PATA_ALI_MODULE 1
CONFIG_NET_DSA_MV88E6XXX_GLOBAL2 1
CONFIG_X86_EXTENDED_PLATFORM 1
CONFIG_GPIO_JANZ_TTL_MODULE 1
CONFIG_CRYPTO_DEV_ATMEL_I2C_MODULE 1
CONFIG_XEN_FRONT_PGDIR_SHBUF_MODULE 1
CONFIG_USB_CHIPIDEA_MODULE 1
CONFIG_MFD_WL1273_CORE_MODULE 1
CONFIG_RT2800USB_RT53XX 1
CONFIG_NET_VENDOR_CORTINA 1
CONFIG_NOA1305_MODULE 1
CONFIG_SND_ECHO3G_MODULE 1
CONFIG_MEDIA_TUNER_FC0011_MODULE 1
CONFIG_ACPI_PROCESSOR 1
CONFIG_DVB_TDA10023_MODULE 1
CONFIG_MEDIA_TUNER_TEA5767_MODULE 1
CONFIG_BATMAN_ADV_MODULE 1
CONFIG_ELFCORE 1
CONFIG_REGULATOR_BD9571MWV_MODULE 1
CONFIG_CS89x0_MODULE 1
CONFIG_ISDN_DRV_AVMB1_AVM_CS_MODULE 1
CONFIG_HAVE_KVM 1
CONFIG_SND_FIREWIRE 1
CONFIG_PAGE_POISONING 1
CONFIG_EDAC_SKX_MODULE 1
CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER 1
CONFIG_COMEDI_PCMDA12_MODULE 1
CONFIG_SND_SOC_AMD_ACP3x_MODULE 1
CONFIG_PCCARD_MODULE 1
CONFIG_USB_GSPCA_OV519_MODULE 1
CONFIG_DM_LOG_WRITES_MODULE 1
CONFIG_INIT_STACK_NONE 1
CONFIG_BINFMT_ELF 1
CONFIG_RTC_DRV_RX4581_MODULE 1
CONFIG_SND_SOC_CS4349_MODULE 1
CONFIG_NET_CLS_FLOWER_MODULE 1
CONFIG_SCSI_PROC_FS 1
CONFIG_RMI4_F11 1
CONFIG_PARIDE_PG_MODULE 1
CONFIG_I2C_HID_MODULE 1
CONFIG_MD_RAID456_MODULE 1
CONFIG_REGULATOR_PCF50633_MODULE 1
CONFIG_IIO_TRIGGER 1
CONFIG_JOYSTICK_IFORCE_USB_MODULE 1
CONFIG_SCHED_TRACER 1
CONFIG_RTS5208_MODULE 1
CONFIG_CICADA_PHY_MODULE 1
CONFIG_JOYSTICK_STINGER_MODULE 1
CONFIG_HAVE_PERF_REGS 1
CONFIG_PINCTRL_DENVERTON_MODULE 1
CONFIG_CIFS_DEBUG 1
CONFIG_LEDS_LP55XX_COMMON_MODULE 1
CONFIG_DRM_I915_USERFAULT_AUTOSUSPEND 250
CONFIG_MEDIA_ANALOG_TV_SUPPORT 1
CONFIG_IP_PIMSM_V1 1
CONFIG_HAVE_KVM_MSI 1
CONFIG_BCACHE_MODULE 1
CONFIG_INET6_AH_MODULE 1
CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT 1
CONFIG_SENSORS_MAX197_MODULE 1
CONFIG_RAPIDIO_CHMAN_MODULE 1
CONFIG_TARGET_CORE_MODULE 1
CONFIG_AUFS_FS_MODULE 1
CONFIG_HID_XINMO_MODULE 1
CONFIG_INFINIBAND_BNXT_RE_MODULE 1
CONFIG_NFS_V4_SECURITY_LABEL 1
CONFIG_USB_SERIAL_MODULE 1
CONFIG_VIDEO_CX88_ALSA_MODULE 1
CONFIG_NET_VENDOR_ALTEON 1
CONFIG_NFT_DUP_IPV4_MODULE 1
CONFIG_SENSORS_GL518SM_MODULE 1
CONFIG_MLX5_CORE_IPOIB 1
CONFIG_USB_MON_MODULE 1
CONFIG_COMEDI_CB_PCIMDAS_MODULE 1
CONFIG_NTB_IDT_MODULE 1
CONFIG_VGASTATE_MODULE 1
CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE 1
CONFIG_LCD_L4F00242T03_MODULE 1
CONFIG_XEN_PVCALLS_FRONTEND_MODULE 1
CONFIG_NET_VENDOR_RENESAS 1
CONFIG_VIDEO_SAA717X_MODULE 1
CONFIG_VIDEO_ET8EK8_MODULE 1
CONFIG_KEYS 1
CONFIG_XEN_PV_SMP 1
CONFIG_REGULATOR_TPS6507X_MODULE 1
CONFIG_BE2ISCSI_MODULE 1
CONFIG_NET_SCH_ETF_MODULE 1
CONFIG_INET_XFRM_TUNNEL_MODULE 1
CONFIG_RTC_DRV_FM3130_MODULE 1
CONFIG_SND_SOC_MAX9860_MODULE 1
CONFIG_RMI4_2D_SENSOR 1
CONFIG_ACPI_PROCESSOR_CSTATE 1
CONFIG_TMP007_MODULE 1
CONFIG_XEN_EFI 1
CONFIG_IPMI_POWEROFF_MODULE 1
CONFIG_SND_VMASTER 1
CONFIG_NETFILTER_XT_MARK_MODULE 1
CONFIG_NETFILTER_XTABLES_MODULE 1
CONFIG_DRM_PANEL_ORIENTATION_QUIRKS 1
CONFIG_IP_VS_LBLC_MODULE 1
CONFIG_SYSTEM_BLACKLIST_KEYRING 1
CONFIG_HAVE_KVM_IRQ_BYPASS 1
CONFIG_BLK_DEV_NULL_BLK_MODULE 1
CONFIG_DP83640_PHY_MODULE 1
CONFIG_SOFTLOCKUP_DETECTOR 1
CONFIG_NFC_PN533_I2C_MODULE 1
CONFIG_USB_ISP1760_HCD 1
CONFIG_MFD_AXP20X_I2C_MODULE 1
CONFIG_DVB_USB_OPERA1_MODULE 1
CONFIG_SENSORS_INSPUR_IPSPS_MODULE 1
CONFIG_CRYPTO_ECHAINIV_MODULE 1
CONFIG_HAVE_ARCH_AUDITSYSCALL 1
CONFIG_LEDS_BD2802_MODULE 1
CONFIG_TOUCHSCREEN_MC13783_MODULE 1
CONFIG_VIDEO_CADENCE_CSI2TX_MODULE 1
CONFIG_KEYBOARD_STOWAWAY_MODULE 1
CONFIG_WILCO_EC_DEBUGFS_MODULE 1
CONFIG_FB_RIVA_MODULE 1
CONFIG_ATM_HE_MODULE 1
CONFIG_POWER_AVS 1
CONFIG_GNSS_SIRF_SERIAL_MODULE 1
CONFIG_IPMI_SI_MODULE 1
CONFIG_TI_ADS1015_MODULE 1
CONFIG_VIRTIO_PMEM_MODULE 1
CONFIG_USB_STORAGE_DATAFAB_MODULE 1
CONFIG_DVB_USB_AF9005_MODULE 1
CONFIG_MFD_RC5T583 1
CONFIG_TCP_CONG_VEGAS_MODULE 1
CONFIG_LEDS_88PM860X_MODULE 1
CONFIG_CRYPTO_USER_API_HASH_MODULE 1
CONFIG_SENSORS_IBMPEX_MODULE 1
CONFIG_NET_SCH_TAPRIO_MODULE 1
CONFIG_BOOT_PRINTK_DELAY 1
CONFIG_CHARGER_88PM860X_MODULE 1
CONFIG_IWLMVM_MODULE 1
CONFIG_SENSORS_ADM1026_MODULE 1
CONFIG_PATA_NINJA32_MODULE 1
CONFIG_SND_SOC_AMD_RENOIR_MACH_MODULE 1
CONFIG_SENSORS_ADT7470_MODULE 1
CONFIG_CRYPTO_DEV_CCP_DD_MODULE 1
CONFIG_PM_SLEEP_SMP 1
CONFIG_SPI_PXA2XX_PCI_MODULE 1
CONFIG_FB_PM3_MODULE 1
CONFIG_VIDEO_OV7740_MODULE 1
CONFIG_X86_16BIT 1
CONFIG_CRYPTO_HW 1
CONFIG_USB_EG20T_MODULE 1
CONFIG_USB_STORAGE_KARMA_MODULE 1
CONFIG_TTPCI_EEPROM_MODULE 1
CONFIG_TOUCHSCREEN_CYTTSP4_SPI_MODULE 1
CONFIG_NTB_PERF_MODULE 1
CONFIG_TEHUTI_MODULE 1
CONFIG_PUNIT_ATOM_DEBUG_MODULE 1
CONFIG_THUNDERBOLT_NET_MODULE 1
CONFIG_SIS900_MODULE 1
CONFIG_IIO_ST_MAGN_SPI_3AXIS_MODULE 1
CONFIG_TYPEC_MUX_PI3USB30532_MODULE 1
CONFIG_PCSPKR_PLATFORM 1
CONFIG_INFINIBAND_EFA_MODULE 1
CONFIG_LEDS_LP3952_MODULE 1
CONFIG_HAVE_LIVEPATCH 1
CONFIG_MEGARAID_LEGACY_MODULE 1
CONFIG_CRYPTO_POLY1305_X86_64_MODULE 1
CONFIG_DVB_AV7110_IR 1
CONFIG_CARDBUS 1
CONFIG_ATH9K_AHB 1
CONFIG_SENSORS_ISL29018_MODULE 1
CONFIG_RTC_DRV_DS1307_CENTURY 1
CONFIG_IIO_SSP_SENSORHUB_MODULE 1
CONFIG_HID_GREENASIA_MODULE 1
CONFIG_ORINOCO_USB_MODULE 1
CONFIG_PROC_VMCORE_DEVICE_DUMP 1
CONFIG_TOUCHSCREEN_ILI210X_MODULE 1
CONFIG_XEN_ACPI_PROCESSOR 1
CONFIG_SND_SOC_INTEL_SKL_MODULE 1
CONFIG_INTEGRITY_ASYMMETRIC_KEYS 1
CONFIG_HWSPINLOCK 1
CONFIG_SERIAL_RP2_NR_UARTS 32
CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE 0x01b6
CONFIG_BACKLIGHT_DA903X_MODULE 1
CONFIG_CPU_IDLE_GOV_HALTPOLL 1
CONFIG_KALLSYMS_ABSOLUTE_PERCPU 1
CONFIG_INTEL_POWERCLAMP_MODULE 1
CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB 2048
CONFIG_BIG_KEYS 1
CONFIG_NFC_ST21NFCA_I2C_MODULE 1
CONFIG_KEYBOARD_ADP5520_MODULE 1
CONFIG_SND_SOC_FSL_ESAI_MODULE 1
CONFIG_SMS_USB_DRV_MODULE 1
CONFIG_ACPI_AC 1
CONFIG_TLS_MODULE 1
CONFIG_ACPI_HOTPLUG_IOAPIC 1
CONFIG_HID_STEELSERIES_MODULE 1
CONFIG_JFFS2_FS_WRITEBUFFER 1
CONFIG_BMI160_SPI_MODULE 1
CONFIG_ADXL372_I2C_MODULE 1
CONFIG_SPI_MASTER 1
CONFIG_USB_SERIAL_OPTICON_MODULE 1
CONFIG_RTL8180_MODULE 1
CONFIG_DS4424_MODULE 1
CONFIG_LWTUNNEL 1
CONFIG_IEEE802154_AT86RF230_MODULE 1
CONFIG_REGULATOR_ARIZONA_MICSUPP_MODULE 1
CONFIG_AD5504_MODULE 1
CONFIG_REGMAP_SLIMBUS_MODULE 1
CONFIG_SERIAL_SC16IS7XX_I2C 1
CONFIG_DVB_TC90522_MODULE 1
CONFIG_W1_MASTER_SGI_MODULE 1
CONFIG_HID_CREATIVE_SB0540_MODULE 1
CONFIG_DVB_NXT200X_MODULE 1
CONFIG_SENSORS_LM87_MODULE 1
CONFIG_SND_SST_IPC_ACPI_MODULE 1
CONFIG_PALMAS_GPADC_MODULE 1
CONFIG_BLK_DEV_THROTTLING 1
CONFIG_VT_HW_CONSOLE_BINDING 1
CONFIG_AIX_PARTITION 1
CONFIG_GPIO_104_IDIO_16_MODULE 1
CONFIG_NET_TEAM_MODE_BROADCAST_MODULE 1
CONFIG_MPLS 1
CONFIG_NF_TABLES_NETDEV 1
CONFIG_CHARGER_SMB347_MODULE 1
CONFIG_NFC_S3FWRN5_MODULE 1
CONFIG_VIDEO_TW9903_MODULE 1
CONFIG_ATH9K_CHANNEL_CONTEXT 1
CONFIG_NET_ACT_GACT_MODULE 1
CONFIG_COPS_MODULE 1
CONFIG_SLIP_MODE_SLIP6 1
CONFIG_RTL8192E_MODULE 1
CONFIG_HID_GYRATION_MODULE 1
CONFIG_PA12203001_MODULE 1
CONFIG_VIDEO_ADP1653_MODULE 1
CONFIG_SND_SOC_AK4642_MODULE 1
CONFIG_GPIO_WHISKEY_COVE_MODULE 1
CONFIG_SRAM 1
CONFIG_USB_WDM_MODULE 1
CONFIG_PATA_TOSHIBA_MODULE 1
CONFIG_BT_HCIBCM203X_MODULE 1
CONFIG_REGULATOR_WM8400_MODULE 1
CONFIG_THERMAL_HWMON 1
CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE 1
CONFIG_DM_CLONE_MODULE 1
CONFIG_SND_SOC_PCM186X_I2C_MODULE 1
CONFIG_VIDEO_S5C73M3_MODULE 1
CONFIG_RAVE_SP_WATCHDOG_MODULE 1
CONFIG_I2C_MUX_PCA9541_MODULE 1
CONFIG_MAX1363_MODULE 1
CONFIG_SND_USB_HIFACE_MODULE 1
CONFIG_VIDEO_EM28XX_DVB_MODULE 1
CONFIG_USB_SERIAL_KOBIL_SCT_MODULE 1
CONFIG_HDLC_FR_MODULE 1
CONFIG_USB_SERIAL_UPD78F0730_MODULE 1
CONFIG_CRYPTO_STREEBOG_MODULE 1
CONFIG_FB_ATY128_BACKLIGHT 1
CONFIG_USB_GSPCA_TOUPTEK_MODULE 1
CONFIG_GENEVE_MODULE 1
CONFIG_XZ_DEC_X86 1
CONFIG_MFD_CS47L90 1
CONFIG_MTD_RAW_NAND_MODULE 1
CONFIG_MLX5_INFINIBAND_MODULE 1
CONFIG_RMI4_SPI_MODULE 1
CONFIG_MAC80211_LEDS 1
CONFIG_ARCH_HAS_CPU_FINALIZE_INIT 1
CONFIG_INPUT_JOYDEV_MODULE 1
CONFIG_FB_MATROX_MAVEN_MODULE 1
CONFIG_VIDEO_OV2685_MODULE 1
CONFIG_KEYBOARD_LKKBD_MODULE 1
CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE 1
CONFIG_HIBERNATE_CALLBACKS 1
CONFIG_MEN_Z188_ADC_MODULE 1
CONFIG_LEDS_MC13783_MODULE 1
CONFIG_SERIAL_8250_DW_MODULE 1
CONFIG_SND_SOC_CS42L56_MODULE 1
CONFIG_IP_DCCP_MODULE 1
CONFIG_LIBIPW_MODULE 1
CONFIG_FIREWIRE_OHCI_MODULE 1
CONFIG_ATH10K_USB_MODULE 1
CONFIG_EISA 1
CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS 0
CONFIG_CONSOLE_LOGLEVEL_QUIET 4
CONFIG_COMMON_CLK_S2MPS11_MODULE 1
CONFIG_USB_ACM_MODULE 1
CONFIG_COMEDI_ADL_PCI9118_MODULE 1
CONFIG_USB_RTL8150_MODULE 1
CONFIG_NVME_CORE_MODULE 1
CONFIG_INTEL_TURBO_MAX_3 1
CONFIG_GPIO_MAX7300_MODULE 1
CONFIG_USB_MSI2500_MODULE 1
CONFIG_TI_DAC7612_MODULE 1
CONFIG_CRC16 1
CONFIG_BACKLIGHT_SKY81452_MODULE 1
CONFIG_USB_NET_AX8817X_MODULE 1
CONFIG_SND_EMU10K1_MODULE 1
CONFIG_GENERIC_CALIBRATE_DELAY 1
CONFIG_CRYPTO_GF128MUL 1
CONFIG_UPROBE_EVENTS 1
CONFIG_NLS_ISO8859_6_MODULE 1
CONFIG_NET_CLS 1
CONFIG_PSTORE_DEFLATE_COMPRESS 1
CONFIG_ADF4350_MODULE 1
CONFIG_XFS_RT 1
CONFIG_SI7005_MODULE 1
CONFIG_COMEDI_S626_MODULE 1
CONFIG_SND_INDIGO_MODULE 1
CONFIG_SND_SOC_PCM1789_I2C_MODULE 1
CONFIG_AX25_MODULE 1
CONFIG_SND_YMFPCI_MODULE 1
CONFIG_TMPFS 1
CONFIG_MFD_LM3533_MODULE 1
CONFIG_HP206C_MODULE 1
CONFIG_HOSTAP_MODULE 1
CONFIG_NFT_CT_MODULE 1
CONFIG_NET_VENDOR_NETERION 1
CONFIG_CADENCE_WATCHDOG_MODULE 1
CONFIG_USB_OHCI_HCD_PLATFORM 1
CONFIG_SND_SOC_WM8711_MODULE 1
CONFIG_VIDEO_EM28XX_MODULE 1
CONFIG_NLS_CODEPAGE_936_MODULE 1
CONFIG_HAMACHI_MODULE 1
CONFIG_EXTCON_ARIZONA_MODULE 1
CONFIG_ET131X_MODULE 1
CONFIG_SURFACE_3_BUTTON_MODULE 1
CONFIG_IR_ITE_CIR_MODULE 1
CONFIG_WCN36XX_MODULE 1
CONFIG_FPGA_REGION_MODULE 1
CONFIG_DVB_BUDGET_MODULE 1
CONFIG_FUTEX 1
CONFIG_IP_VS_MH_TAB_INDEX 12
CONFIG_CRYPTO_ANUBIS_MODULE 1
CONFIG_COMEDI_NI_AT_A2150_MODULE 1
CONFIG_DRM_VRAM_HELPER_MODULE 1
CONFIG_COMEDI_NI_LABPC_ISA_MODULE 1
CONFIG_VIRTIO_PCI 1
CONFIG_TCP_CONG_NV_MODULE 1
CONFIG_HID_SENSOR_ALS_MODULE 1
CONFIG_UNIX_SCM 1
CONFIG_MCP320X_MODULE 1
CONFIG_MISDN_HFCMULTI_MODULE 1
CONFIG_MMC_SPI_MODULE 1
CONFIG_CONSOLE_LOGLEVEL_DEFAULT 7
CONFIG_QCOM_HIDMA_MODULE 1
CONFIG_MWAVE_MODULE 1
CONFIG_PCMCIA_3C574_MODULE 1
CONFIG_USB_GSPCA_SQ930X_MODULE 1
CONFIG_RTL8192SE_MODULE 1
CONFIG_JOYSTICK_SPACEBALL_MODULE 1
CONFIG_REGMAP_I2C 1
CONFIG_AD5449_MODULE 1
CONFIG_ZPA2326_MODULE 1
CONFIG_ARCH_HAS_FAST_MULTIPLIER 1
CONFIG_INPUT_MATRIXKMAP_MODULE 1
CONFIG_ATH9K_DEBUGFS 1
CONFIG_MFD_BCM590XX_MODULE 1
CONFIG_DVB_CXD2099_MODULE 1
CONFIG_NET_VENDOR_REALTEK 1
CONFIG_VIDEO_VIVID_CEC 1
CONFIG_MFD_SM501_GPIO 1
CONFIG_DVB_DM1105_MODULE 1
CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG 1
CONFIG_MFD_RDC321X_MODULE 1
CONFIG_AD5421_MODULE 1
CONFIG_JOYSTICK_XPAD_FF 1
CONFIG_COMMON_CLK_SI544_MODULE 1
CONFIG_SCSI_AHA1740_MODULE 1
CONFIG_NETFILTER_XT_TARGET_HL_MODULE 1
CONFIG_REGULATOR_LP8788_MODULE 1
CONFIG_MEGARAID_SAS_MODULE 1
CONFIG_PATA_HPT3X2N_MODULE 1
CONFIG_INTEL_TH_MODULE 1
CONFIG_DVB_CORE_MODULE 1
CONFIG_NFSD_V2_ACL 1
CONFIG_COMEDI_ME_DAQ_MODULE 1
CONFIG_SDR_PLATFORM_DRIVERS 1
CONFIG_CAN_JANZ_ICAN3_MODULE 1
CONFIG_USB_NET2280_MODULE 1
CONFIG_PLUGIN_HOSTCC ""
CONFIG_ISL29003_MODULE 1
CONFIG_CRYPTO_USER_API_MODULE 1
CONFIG_RTC_HCTOSYS 1
CONFIG_I2C_OCORES_MODULE 1
CONFIG_NAU7802_MODULE 1
CONFIG_DRM_I915_CAPTURE_ERROR 1
CONFIG_SECURITY_NETWORK 1
CONFIG_SND_SOC_SOF_INTEL_HIFI_EP_IPC_MODULE 1
CONFIG_DRM_VBOXVIDEO_MODULE 1
CONFIG_SERIAL_CORE_CONSOLE 1
CONFIG_INTEL_XWAY_PHY_MODULE 1
CONFIG_HOTPLUG_PCI_CPCI 1
CONFIG_ACPI_CPPC_LIB 1
CONFIG_HUGETLB_PAGE 1
CONFIG_MTD_SM_COMMON_MODULE 1
CONFIG_HW_RANDOM_TPM 1
CONFIG_SENSORS_XGENE_MODULE 1
CONFIG_CIFS_WEAK_PW_HASH 1
CONFIG_DVB_SMIPCIE_MODULE 1
CONFIG_TOUCHSCREEN_GUNZE_MODULE 1
CONFIG_NFC_ST_NCI_SPI_MODULE 1
CONFIG_SENSORS_LM78_MODULE 1
CONFIG_SCSI_UFS_DWC_TC_PLATFORM_MODULE 1
CONFIG_NET_VENDOR_EMULEX 1
CONFIG_WIZNET_W5100_MODULE 1
CONFIG_REGMAP_IRQ 1
CONFIG_SENSORS_K10TEMP_MODULE 1
CONFIG_USB_HID_MODULE 1
CONFIG_DVB_USB_AF9015_MODULE 1
CONFIG_ISI_MODULE 1
CONFIG_DELL_SMBIOS_MODULE 1
CONFIG_FPGA_MODULE 1
CONFIG_MLX5_EN_IPSEC 1
CONFIG_UBIFS_FS_MODULE 1
CONFIG_DRM_AMDGPU_SI 1
CONFIG_PARIDE_PT_MODULE 1
CONFIG_RTL8192CU_MODULE 1
CONFIG_ATM_DRIVERS 1
CONFIG_MELLANOX_PLATFORM 1
CONFIG_CRYPTO_TGR192_MODULE 1
CONFIG_BLK_DEV_RBD_MODULE 1
CONFIG_SENSORS_HMC5843_MODULE 1
CONFIG_SERIO_PS2MULT_MODULE 1
CONFIG_VSOCKETS_DIAG_MODULE 1
CONFIG_REGULATOR_TPS6105X_MODULE 1
CONFIG_USER_STACKTRACE_SUPPORT 1
CONFIG_ANDROID 1
CONFIG_MEGARAID_MAILBOX_MODULE 1
CONFIG_CAN_UCAN_MODULE 1
CONFIG_LANMEDIA_MODULE 1
CONFIG_NF_TABLES_MODULE 1
CONFIG_BATMAN_ADV_MCAST 1
CONFIG_IT8712F_WDT_MODULE 1
CONFIG_SLUB_DEBUG 1
CONFIG_RTC_DRV_M41T80_WDT 1
CONFIG_OBJAGG_MODULE 1
CONFIG_WIZNET_W5300_MODULE 1
CONFIG_COMEDI_NI_670X_MODULE 1
CONFIG_BLK_DEV_MD 1
CONFIG_UCS2_STRING 1
CONFIG_MMC_VUB300_MODULE 1
CONFIG_USB_SERIAL_AIRCABLE_MODULE 1
CONFIG_IP_SET_BITMAP_IP_MODULE 1
CONFIG_FIELDBUS_DEV_MODULE 1
CONFIG_GPIO_VX855_MODULE 1
CONFIG_MAC_EMUMOUSEBTN_MODULE 1
CONFIG_RAPIDIO_CPS_XX_MODULE 1
CONFIG_IMA_APPRAISE_MODSIG 1
CONFIG_MMC_MTK_MODULE 1
CONFIG_SND_SOC_WM8978_MODULE 1
CONFIG_SND_SOC_AMD_CZ_DA7219MX98357_MACH_MODULE 1
CONFIG_SND_SOC_SOF_HDA_COMMON_HDMI_CODEC 1
CONFIG_DECNET_NF_GRABULATOR_MODULE 1
CONFIG_BNXT_DCB 1
CONFIG_HIST_TRIGGERS 1
CONFIG_MTD_SBC_GXX_MODULE 1
CONFIG_NFC_NCI_SPI_MODULE 1
CONFIG_USB_F_RNDIS_MODULE 1
CONFIG_NET_SCH_INGRESS_MODULE 1
CONFIG_BCMA_MODULE 1
CONFIG_DMADEVICES 1
CONFIG_XENFS_MODULE 1
CONFIG_UBSAN_ALIGNMENT 1
CONFIG_AXP288_CHARGER_MODULE 1
CONFIG_SCA3000_MODULE 1
CONFIG_ATH10K_SDIO_MODULE 1
CONFIG_CORTINA_PHY_MODULE 1
CONFIG_SCSI_AACRAID_MODULE 1
CONFIG_SND_SOC_INTEL_KBL_DA7219_MAX98927_MACH_MODULE 1
CONFIG_VIDEO_AK7375_MODULE 1
CONFIG_MISDN_HFCUSB_MODULE 1
CONFIG_ACPI_APEI_MEMORY_FAILURE 1
CONFIG_BACKLIGHT_LM3639_MODULE 1
CONFIG_NF_CONNTRACK_EVENTS 1
CONFIG_MOUSE_PS2_ELANTECH 1
CONFIG_MFD_DA9062_MODULE 1
CONFIG_PINCTRL 1
CONFIG_HID_SENSOR_DEVICE_ROTATION_MODULE 1
CONFIG_IPV6_NDISC_NODETYPE 1
CONFIG_HFS_FS_MODULE 1
CONFIG_INTEL_VBTN_MODULE 1
CONFIG_SND_SOC_WM8985_MODULE 1
CONFIG_RTC_DRV_MSM6242_MODULE 1
CONFIG_DVB_USB_TECHNISAT_USB2_MODULE 1
CONFIG_PCI_LABEL 1
CONFIG_NLS_CODEPAGE_1251_MODULE 1
CONFIG_USB_F_MIDI_MODULE 1
CONFIG_EDAC_X38_MODULE 1
CONFIG_FANOTIFY 1
CONFIG_MEDIA_TUNER_MXL301RF_MODULE 1
CONFIG_SPI_BUTTERFLY_MODULE 1
CONFIG_SONYPI_COMPAT 1
CONFIG_IP_VS_PROTO_SCTP 1
CONFIG_SP5100_TCO_MODULE 1
CONFIG_WIL6210_DEBUGFS 1
CONFIG_GREYBUS_PWM_MODULE 1
CONFIG_NETFILTER_XT_MATCH_CONNLABEL_MODULE 1
CONFIG_SGETMASK_SYSCALL 1
CONFIG_AD5696_I2C_MODULE 1
CONFIG_SATA_SIL_MODULE 1
CONFIG_ALTERA_STAPL_MODULE 1
CONFIG_USERFAULTFD 1
CONFIG_CGROUP_SCHED 1
CONFIG_SND_HDA_RECONFIG 1
CONFIG_VIDEO_ADV7842_MODULE 1
CONFIG_QUEUED_RWLOCKS 1
CONFIG_SYSVIPC 1
CONFIG_COMEDI_NI_LABPC_CS_MODULE 1
CONFIG_W1_SLAVE_DS250X_MODULE 1
CONFIG_HOSTAP_PLX_MODULE 1
CONFIG_RAID6_PQ_BENCHMARK 1
CONFIG_ARCH_HAS_GIGANTIC_PAGE 1
CONFIG_USB_CONFIGFS_ECM_SUBSET 1
CONFIG_MTD_UBI_BLOCK 1
CONFIG_HAVE_DEBUG_KMEMLEAK 1
CONFIG_JOYSTICK_INTERACT_MODULE 1
CONFIG_SMSC911X_MODULE 1
CONFIG_GPIO_MAX3191X_MODULE 1
CONFIG_COMEDI_DT282X_MODULE 1
CONFIG_DVB_TDA10071_MODULE 1
CONFIG_HDLC_CISCO_MODULE 1
CONFIG_SQUASHFS_ZSTD 1
CONFIG_MLX4_INFINIBAND_MODULE 1
CONFIG_DVB_OR51211_MODULE 1
CONFIG_RT2X00_MODULE 1
CONFIG_NLS_CODEPAGE_863_MODULE 1
CONFIG_SND_DESIGNWARE_I2S_MODULE 1
CONFIG_SENSORS_ADT7X10_MODULE 1
CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT 13
CONFIG_USB_G_HID_MODULE 1
CONFIG_KEYBOARD_GPIO_MODULE 1
CONFIG_NF_CONNTRACK_FTP_MODULE 1
CONFIG_FPGA_BRIDGE_MODULE 1
CONFIG_NFC_MRVL_UART_MODULE 1
CONFIG_CHELSIO_T4_MODULE 1
CONFIG_MODULES 1
CONFIG_RPMSG_MODULE 1
CONFIG_IP_NF_MATCH_ECN_MODULE 1
CONFIG_USB_CONFIGFS_PHONET 1
CONFIG_DWC_XLGMAC_MODULE 1
CONFIG_REGULATOR_MAX8660_MODULE 1
CONFIG_USB_GADGET_MODULE 1
CONFIG_EEPROM_LEGACY_MODULE 1
CONFIG_FB_IMSTT 1
CONFIG_USB_GSPCA_SPCA506_MODULE 1
CONFIG_CAN_CC770_PLATFORM_MODULE 1
CONFIG_PATA_ARTOP_MODULE 1
CONFIG_KEYBOARD_NEWTON_MODULE 1
CONFIG_HARDLOCKUP_DETECTOR 1
CONFIG_VIDEO_CX88_DVB_MODULE 1
CONFIG_GPIO_DA9055_MODULE 1
CONFIG_MQ_IOSCHED_DEADLINE 1
CONFIG_VIDEO_EM28XX_ALSA_MODULE 1
CONFIG_MEDIA_TUNER_MXL5005S_MODULE 1
CONFIG_INPUT_TWL4030_VIBRA_MODULE 1
CONFIG_USB_HIDDEV 1
CONFIG_IOMMU_IOVA 1
CONFIG_INFINIBAND_IPOIB_MODULE 1
CONFIG_DUMMY_CONSOLE_COLUMNS 80
CONFIG_SENSORS_APDS990X_MODULE 1
CONFIG_USB_ETH_RNDIS 1
CONFIG_AD7606_IFACE_PARALLEL_MODULE 1
CONFIG_DVB_SI21XX_MODULE 1
CONFIG_XXHASH 1
CONFIG_PATA_WINBOND_MODULE 1
CONFIG_SOUND_MODULE 1
CONFIG_NFT_MASQ_MODULE 1
CONFIG_COMEDI_RTI802_MODULE 1
CONFIG_SPS30_MODULE 1
CONFIG_NFT_QUOTA_MODULE 1
CONFIG_TOUCHSCREEN_AUO_PIXCIR_MODULE 1
CONFIG_JOLIET 1
CONFIG_SERIAL_SC16IS7XX_MODULE 1
CONFIG_DVB_USB_VP7045_MODULE 1
CONFIG_USB_NET2272_DMA 1
CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE 1
CONFIG_KPROBES_ON_FTRACE 1
CONFIG_BNX2X_MODULE 1
CONFIG_MEDIA_TUNER_TDA9887_MODULE 1
CONFIG_ADVANTECH_WDT_MODULE 1
CONFIG_CRYPTO_TEA_MODULE 1
CONFIG_AD5624R_SPI_MODULE 1
CONFIG_ARCH_HIBERNATION_POSSIBLE 1
CONFIG_SND_SOC_SI476X_MODULE 1
CONFIG_DVB_USB_LME2510_MODULE 1
CONFIG_PROC_CHILDREN 1
CONFIG_PDC_ADMA_MODULE 1
CONFIG_SND_VXPOCKET_MODULE 1
CONFIG_SND_USB_LINE6_MODULE 1
CONFIG_UNIX 1
CONFIG_USB_CATC_MODULE 1
CONFIG_USB_NET_DRIVERS_MODULE 1
CONFIG_FPGA_DFL_PCI_MODULE 1
CONFIG_VIDEO_CADENCE_CSI2RX_MODULE 1
CONFIG_CC_CAN_LINK 1
CONFIG_QNX6FS_FS_MODULE 1
CONFIG_SCSI_FDOMAIN_PCI_MODULE 1
CONFIG_AXP20X_POWER_MODULE 1
CONFIG_NO_HZ_COMMON 1
CONFIG_MINIX_FS_MODULE 1
CONFIG_DRM_MIPI_DSI 1
CONFIG_BRCMSMAC_MODULE 1
CONFIG_XEN_DEV_EVTCHN_MODULE 1
CONFIG_HAVE_CLK 1
CONFIG_CRYPTO_HASH2 1
CONFIG_MMC_SDHCI_F_SDH30_MODULE 1
CONFIG_CARL9170_MODULE 1
CONFIG_DW_EDMA_PCIE_MODULE 1
CONFIG_SND_HDA_CODEC_CONEXANT_MODULE 1
CONFIG_RMI4_F54 1
CONFIG_CRYPTO_LZ4HC_MODULE 1
CONFIG_SND_SOC_SOF_ICELAKE_MODULE 1
CONFIG_DVB_CX24117_MODULE 1
CONFIG_THERMAL_GOV_STEP_WISE 1
CONFIG_SND_RME9652_MODULE 1
CONFIG_MTD_ABSENT_MODULE 1
CONFIG_TOUCHSCREEN_88PM860X_MODULE 1
CONFIG_DEFAULT_HOSTNAME "(none)"
CONFIG_SRCU 1
CONFIG_COMMON_CLK_SI5351_MODULE 1
CONFIG_NLS_KOI8_R_MODULE 1
CONFIG_SENSORS_ADT7410_MODULE 1
CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS 2
CONFIG_THUNDER_NIC_VF_MODULE 1
CONFIG_IP_SET_HASH_NETPORTNET_MODULE 1
CONFIG_USB_GSPCA_SONIXB_MODULE 1
CONFIG_DVB_USB_RTL28XXU_MODULE 1
CONFIG_CARDMAN_4040_MODULE 1
CONFIG_MMC_REALTEK_PCI_MODULE 1
CONFIG_USB_STORAGE_ISD200_MODULE 1
CONFIG_CPU_FREQ_GOV_POWERSAVE 1
CONFIG_USB_GSPCA_OV534_9_MODULE 1
CONFIG_RIONET_MODULE 1
CONFIG_NFS_FS_MODULE 1
CONFIG_CRYPTO_TWOFISH_X86_64_MODULE 1
CONFIG_USB_NET_SMSC95XX_MODULE 1
CONFIG_CRASH_DUMP 1
CONFIG_MEMBARRIER 1
CONFIG_FB_SM712_MODULE 1
CONFIG_CEC_CORE 1
CONFIG_MLX_WDT_MODULE 1
CONFIG_LEDS_LM3533_MODULE 1
CONFIG_SND_SOC_ZX_AUD96P22_MODULE 1
CONFIG_INFINIBAND_ADDR_TRANS 1
CONFIG_BLK_DEV_IO_TRACE 1
CONFIG_VIDEO_ADV7511_CEC 1
CONFIG_XPS 1
CONFIG_RCU_PERF_TEST_MODULE 1
CONFIG_CRYPTO_DEV_QAT_DH895xCC_MODULE 1
CONFIG_COMEDI_8255_PCI_MODULE 1
CONFIG_NET_ACT_SKBEDIT_MODULE 1
CONFIG_COMEDI_ADV_PCI1723_MODULE 1
CONFIG_INET_ESP_MODULE 1
CONFIG_SECURITY_SELINUX_DEVELOP 1
CONFIG_SGL_ALLOC 1
CONFIG_AD7816_MODULE 1
CONFIG_HPET_TIMER 1
CONFIG_LCD_TDO24M_MODULE 1
CONFIG_LZ4_DECOMPRESS 1
CONFIG_INPUT_GPIO_BEEPER_MODULE 1
CONFIG_NFC_HCI_MODULE 1
CONFIG_GPIO_MAX732X_MODULE 1
CONFIG_HSI_MODULE 1
CONFIG_NF_TPROXY_IPV6_MODULE 1
CONFIG_NF_CONNTRACK_ZONES 1
CONFIG_DP83848_PHY_MODULE 1
CONFIG_EFI_RUNTIME_MAP 1
CONFIG_FONT_SUPPORT 1
CONFIG_ADVISE_SYSCALLS 1
CONFIG_MD 1
CONFIG_CROS_EC_I2C_MODULE 1
CONFIG_CRYPTO_ALGAPI 1
CONFIG_FDDI 1
CONFIG_IR_SERIAL_MODULE 1
CONFIG_SENSORS_VT8231_MODULE 1
CONFIG_DVB_BUDGET_CI_MODULE 1
CONFIG_PARIDE_FIT3_MODULE 1
CONFIG_COMEDI_KE_COUNTER_MODULE 1
CONFIG_EDAC_I3200_MODULE 1
CONFIG_RTW88_CORE_MODULE 1
CONFIG_SLUB_MEMCG_SYSFS_ON 1
CONFIG_CEPH_FSCACHE 1
CONFIG_INPUT_KXTJ9_MODULE 1
CONFIG_VIDEO_ADV7604_MODULE 1
CONFIG_DYNAMIC_PHYSICAL_MASK 1
CONFIG_SND_SEQ_MIDI_EMUL_MODULE 1
CONFIG_BSD_PROCESS_ACCT_V3 1
CONFIG_MODULE_SIG_FORMAT 1
CONFIG_NET_VENDOR_WIZNET 1
CONFIG_SCSI_DMX3191D_MODULE 1
CONFIG_FONTS 1
CONFIG_MMC_ALCOR_MODULE 1
CONFIG_USB_G_DBGP_MODULE 1
CONFIG_BRIDGE_MODULE 1
CONFIG_MEDIA_TUNER_MODULE 1
CONFIG_NETFILTER_XT_MATCH_CGROUP_MODULE 1
CONFIG_TABLET_USB_GTCO_MODULE 1
CONFIG_AD2S90_MODULE 1
CONFIG_RAPIDIO_TSI57X_MODULE 1
CONFIG_MLXSW_I2C_MODULE 1
CONFIG_USB_CYPRESS_CY7C63_MODULE 1
CONFIG_OPT3001_MODULE 1
CONFIG_EEPROM_AT25_MODULE 1
CONFIG_SERIAL_8250_MID_MODULE 1
CONFIG_RD_BZIP2 1
CONFIG_REGULATOR_SLG51000_MODULE 1
CONFIG_MFD_VIPERBOARD_MODULE 1
CONFIG_WANT_DEV_COREDUMP 1
CONFIG_INPUT_UINPUT 1
CONFIG_SERIAL_ARC_NR_PORTS 1
CONFIG_NETFILTER_XT_TARGET_CHECKSUM_MODULE 1
CONFIG_CHARGER_TPS65090_MODULE 1
CONFIG_SOUNDWIRE_INTEL_MODULE 1
CONFIG_SKB_EXTENSIONS 1
CONFIG_PM_OPP 1
CONFIG_IOSF_MBI_DEBUG 1
CONFIG_UNWINDER_FRAME_POINTER 1
CONFIG_POWER_RESET_RESTART 1
CONFIG_LEDS_TRIGGER_GPIO_MODULE 1
CONFIG_RTLWIFI_USB_MODULE 1
CONFIG_AUFS_BRANCH_MAX_127 1
CONFIG_TCG_ATMEL_MODULE 1
CONFIG_MLX5_ACCEL 1
CONFIG_X86_INTEL_UMIP 1
CONFIG_TINYDRM_MI0283QT_MODULE 1
CONFIG_AFE4404_MODULE 1
CONFIG_DVB_MB86A16_MODULE 1
CONFIG_MEDIA_TUNER_SIMPLE_MODULE 1
CONFIG_SND_OXYGEN_MODULE 1
CONFIG_KEYBOARD_ATKBD 1
CONFIG_SCSI_QLA_ISCSI_MODULE 1
CONFIG_AD5446_MODULE 1
CONFIG_HAVE_MEMBLOCK_NODE_MAP 1
CONFIG_X86_PLATFORM_DEVICES 1
CONFIG_IIO_ST_MAGN_I2C_3AXIS_MODULE 1
CONFIG_LIBNVDIMM 1
CONFIG_NET_IP_TUNNEL_MODULE 1
CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS 1
CONFIG_WANXL_MODULE 1
CONFIG_MTD_CFI_I1 1
CONFIG_NF_NAT_MODULE 1
CONFIG_LEDS_PWM_MODULE 1
CONFIG_W1_SLAVE_DS2780_MODULE 1
CONFIG_MAX_RAW_DEVS 256
CONFIG_UBIFS_FS_ZLIB 1
CONFIG_W83877F_WDT_MODULE 1
CONFIG_WAFER_WDT_MODULE 1
CONFIG_USB_U132_HCD_MODULE 1
CONFIG_VIDEO_UPD64031A_MODULE 1
CONFIG_SYSTEM_REVOCATION_KEYS "debian/canonical-revoked-certs.pem"
CONFIG_BATTERY_88PM860X_MODULE 1
CONFIG_USB_SERIAL_XIRCOM_MODULE 1
CONFIG_CROS_EC_SPI_MODULE 1
CONFIG_BLK_DEV_INTEGRITY 1
CONFIG_DVB_USB_AZ6027_MODULE 1
CONFIG_NET_VENDOR_OKI 1
CONFIG_MOUSE_BCM5974_MODULE 1
CONFIG_CPU_IDLE 1
CONFIG_WLAN_VENDOR_INTERSIL 1
CONFIG_NTB_MODULE 1
CONFIG_BATTERY_RX51_MODULE 1
CONFIG_NFC_ST21NFCA_MODULE 1
CONFIG_IP6_NF_MATCH_RPFILTER_MODULE 1
CONFIG_NF_TABLES_INET 1
CONFIG_NFS_COMMON 1
CONFIG_CHR_DEV_SCH_MODULE 1
CONFIG_6LOWPAN_NHC_IPV6_MODULE 1
CONFIG_REGULATOR 1
CONFIG_SND_SOC_MSM8916_WCD_DIGITAL_MODULE 1
CONFIG_NF_TABLES_IPV6 1
CONFIG_FAIR_GROUP_SCHED 1
CONFIG_SENSORS_HIH6130_MODULE 1
CONFIG_RT2800USB_MODULE 1
CONFIG_HID_MACALLY_MODULE 1
CONFIG_BATTERY_SBS_MODULE 1
CONFIG_CRYPTO_HASH 1
CONFIG_HAVE_STACK_VALIDATION 1
CONFIG_AL3320A_MODULE 1
CONFIG_EFI_PARTITION 1
CONFIG_PROBE_EVENTS 1
CONFIG_SSB_PCMCIAHOST_POSSIBLE 1
CONFIG_NETDEVSIM_MODULE 1
CONFIG_TRACE_CLOCK 1
CONFIG_HID_STEAM_MODULE 1
CONFIG_TCG_TIS_I2C_INFINEON_MODULE 1
CONFIG_SND_HDA_CODEC_HDMI_MODULE 1
CONFIG_BCMA_BLOCKIO 1
CONFIG_MODULE_SIG_HASH "sha512"
CONFIG_TI_ADS7950_MODULE 1
CONFIG_LOG_BUF_SHIFT 18
CONFIG_PATA_IT8213_MODULE 1
CONFIG_MEMORY_HOTREMOVE 1
CONFIG_PM_NOTIFIER_ERROR_INJECT_MODULE 1
CONFIG_RAPIDIO_CPS_GEN2_MODULE 1
CONFIG_SND_CMIPCI_MODULE 1
CONFIG_WLAN_VENDOR_ATH 1
CONFIG_ACPI_DEBUGGER_USER 1
CONFIG_BH1750_MODULE 1
CONFIG_ACPI_WMI_MODULE 1
CONFIG_HPET 1
CONFIG_NLS_CODEPAGE_857_MODULE 1
CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE 1
CONFIG_SND_EMU10K1X_MODULE 1
CONFIG_EXTRA_FIRMWARE ""
CONFIG_NET_CLS_MATCHALL_MODULE 1
CONFIG_TCG_TPM 1
CONFIG_SPI_SLAVE_SYSTEM_CONTROL_MODULE 1
CONFIG_NET_VENDOR_8390 1
CONFIG_MFD_WM5102 1
CONFIG_LEDS_LP5562_MODULE 1
CONFIG_IPV6_MROUTE 1
CONFIG_XEN_PCIDEV_BACKEND_MODULE 1
CONFIG_PROC_EVENTS 1
CONFIG_ACPI_VIDEO_MODULE 1
CONFIG_SENSORS_SHT3x_MODULE 1
CONFIG_VIRT_TO_BUS 1
CONFIG_VFAT_FS 1
CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE 1
CONFIG_MUSB_PIO_ONLY 1
CONFIG_ARCH_SUPPORTS_ACPI 1
CONFIG_IIO_ST_GYRO_SPI_3AXIS_MODULE 1
CONFIG_EDAC_I5000_MODULE 1
CONFIG_NF_FLOW_TABLE_INET_MODULE 1
CONFIG_PID_NS 1
CONFIG_SND_SOC_SOF_COMETLAKE_LP_MODULE 1
CONFIG_SND_SOC_DMIC_MODULE 1
CONFIG_ST_UVIS25_MODULE 1
CONFIG_MD_RAID1_MODULE 1
CONFIG_COMEDI_ADDI_APCI_2200_MODULE 1
CONFIG_BLK_CGROUP_IOCOST 1
CONFIG_REGULATOR_S2MPS11_MODULE 1
CONFIG_CRYPTO_VMAC_MODULE 1
CONFIG_I2C_CHT_WC_MODULE 1
CONFIG_PSI 1
CONFIG_SENSORS_ACPI_POWER_MODULE 1
CONFIG_KEXEC 1
CONFIG_ACPI_CMPC_MODULE 1
CONFIG_IIO_CONFIGFS_MODULE 1
CONFIG_RADIO_TEF6862_MODULE 1
CONFIG_CRC32_SLICEBY8 1
CONFIG_FB_DDC_MODULE 1
CONFIG_MFD_DA9150_MODULE 1
CONFIG_COMEDI_DAS08_MODULE 1
CONFIG_USB_LIBCOMPOSITE_MODULE 1
CONFIG_SCSI_MPT2SAS_MODULE 1
CONFIG_SND_SOC_ADAU1761_I2C_MODULE 1
CONFIG_HVC_XEN 1
CONFIG_SLAB_FREELIST_HARDENED 1
CONFIG_CRYPTO_SM3_MODULE 1
CONFIG_XILINX_VCU_MODULE 1
CONFIG_UWB_WHCI_MODULE 1
CONFIG_TOUCHSCREEN_WM9713 1
CONFIG_FPGA_MGR_ALTERA_PS_SPI_MODULE 1
CONFIG_NET_SCH_FQ_MODULE 1
CONFIG_SND_SOC_INTEL_HASWELL_MACH_MODULE 1
CONFIG_FPGA_MGR_XILINX_SPI_MODULE 1
CONFIG_VIDEO_HDPVR_MODULE 1
CONFIG_XEN_SCRUB_PAGES_DEFAULT 1
CONFIG_MFD_TPS65912 1
CONFIG_ROMFS_ON_BLOCK 1
CONFIG_CRYPTO_CFB_MODULE 1
CONFIG_PEAQ_WMI_MODULE 1
CONFIG_EDAC_AMD64_MODULE 1
CONFIG_NET_SB1000_MODULE 1
CONFIG_GPIO_ARIZONA_MODULE 1
CONFIG_HERMES_CACHE_FW_ON_INIT 1
CONFIG_BLK_DEV_SR 1
CONFIG_CPU_RMAP 1
CONFIG_SND_HWDEP_MODULE 1
CONFIG_MODULE_SIG_SHA512 1
CONFIG_X86_X32 1
CONFIG_INTEL_TH_PTI_MODULE 1
CONFIG_GENERIC_CPU 1
CONFIG_GIGASET_M101_MODULE 1
CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR 1
CONFIG_SND_LAYLA20_MODULE 1
CONFIG_BLK_DEV_LOOP 1
CONFIG_DVB_BT8XX_MODULE 1
CONFIG_IPMI_HANDLER_MODULE 1
CONFIG_LEDS_LM3642_MODULE 1
CONFIG_B44_MODULE 1
CONFIG_AMD_MEM_ENCRYPT 1
CONFIG_DEFAULT_HUNG_TASK_TIMEOUT 120
CONFIG_SYSV_FS_MODULE 1
CONFIG_VIRTIO_PCI_LEGACY 1
CONFIG_ATMEL_MODULE 1
CONFIG_SENSORS_THMC50_MODULE 1
CONFIG_ARCH_HIBERNATION_HEADER 1
CONFIG_HAVE_OPTPROBES 1
CONFIG_HAVE_FENTRY 1
CONFIG_ATM_AMBASSADOR_MODULE 1
CONFIG_L2TP_ETH_MODULE 1
CONFIG_COMEDI_ADDI_WATCHDOG_MODULE 1
CONFIG_PATA_ATIIXP_MODULE 1
CONFIG_I8K_MODULE 1
CONFIG_SCSI_QLOGIC_1280_MODULE 1
CONFIG_SPI_MEM 1
CONFIG_DELL_SMO8800_MODULE 1
CONFIG_HYPERV_UTILS_MODULE 1
CONFIG_SYNCLINK_GT_MODULE 1
CONFIG_INV_MPU6050_SPI_MODULE 1
CONFIG_NF_NAT_IRC_MODULE 1
CONFIG_RAPIDIO_TSI568_MODULE 1
CONFIG_60XX_WDT_MODULE 1
CONFIG_COMMON_CLK_SI5341_MODULE 1
CONFIG_ACPI_HMAT 1
CONFIG_VIDEO_ADV7393_MODULE 1
CONFIG_MEDIA_TUNER_XC2028_MODULE 1
CONFIG_INPUT_MISC 1
CONFIG_SND_COMPRESS_OFFLOAD_MODULE 1
CONFIG_IR_NUVOTON_MODULE 1
CONFIG_SENSORS_SCH5627_MODULE 1
CONFIG_ADIS16080_MODULE 1
CONFIG_I2C_AMD756_MODULE 1
CONFIG_ICE_MODULE 1
CONFIG_UIO_PRUSS_MODULE 1
CONFIG_E1000E_MODULE 1
CONFIG_MFD_LP8788 1
CONFIG_MS5611_MODULE 1
CONFIG_DNET_MODULE 1
CONFIG_VIDEO_TC358743_MODULE 1
CONFIG_MT76x0U_MODULE 1
CONFIG_CRYPTO_CAST6_AVX_X86_64_MODULE 1
CONFIG_DVB_STV0288_MODULE 1
CONFIG_USB_SL811_CS_MODULE 1
CONFIG_MULTIUSER 1
CONFIG_RTC_DRV_PCAP_MODULE 1
CONFIG_SUSPEND 1
CONFIG_SUNRPC_XPRT_RDMA_MODULE 1
CONFIG_SND_SOC_INTEL_SST_ACPI_MODULE 1
CONFIG_CROSS_MEMORY_ATTACH 1
CONFIG_CRYPTO_CBC 1
CONFIG_SENSORS_LM93_MODULE 1
CONFIG_PARIDE_ON20_MODULE 1
CONFIG_LEDS_LM3601X_MODULE 1
CONFIG_BT_CMTP_MODULE 1
CONFIG_VIDEO_IMX214_MODULE 1
CONFIG_SND_SOC_INTEL_APL_MODULE 1
CONFIG_SND_SOC_SOF_TIGERLAKE_MODULE 1
CONFIG_KS0108_DELAY 2
CONFIG_VIDEO_CX88_VP3054_MODULE 1
CONFIG_MEDIA_CONTROLLER 1
CONFIG_NETFILTER_XT_TARGET_HMARK_MODULE 1
CONFIG_INPUT_MMA8450_MODULE 1
CONFIG_MRP_MODULE 1
CONFIG_I8253_LOCK 1
CONFIG_SMSC_SCH311X_WDT_MODULE 1
CONFIG_AK8975_MODULE 1
CONFIG_AIC79XX_CMDS_PER_DEVICE 32
CONFIG_IP6_NF_MATCH_RT_MODULE 1
CONFIG_SCSI_IPR_MODULE 1
CONFIG_SQUASHFS_DECOMP_SINGLE 1
CONFIG_SENSORS_ISL68137_MODULE 1
CONFIG_SERIAL_8250_RUNTIME_UARTS 32
CONFIG_NS83820_MODULE 1
CONFIG_IDLE_INJECT 1
CONFIG_64BIT_TIME 1
CONFIG_CLANG_VERSION 0
CONFIG_TSL4531_MODULE 1
CONFIG_CDNS_I3C_MASTER_MODULE 1
CONFIG_KPROBES 1
CONFIG_FS_MBCACHE 1
CONFIG_XEN_HAVE_VPMU 1
CONFIG_T5403_MODULE 1
CONFIG_SENSORS_JC42_MODULE 1
CONFIG_MD_MULTIPATH_MODULE 1
CONFIG_DS1682_MODULE 1
CONFIG_VIDEO_STK1160_COMMON_MODULE 1
CONFIG_MFD_AS3711 1
CONFIG_GFS2_FS_MODULE 1
CONFIG_MEDIA_TUNER_TUA9001_MODULE 1
CONFIG_RTC_CLASS 1
CONFIG_DVB_TUNER_DIB0070_MODULE 1
CONFIG_DRM_MGAG200_MODULE 1
CONFIG_VIDEO_IPU3_CIO2_MODULE 1
CONFIG_FB_MB862XX_PCI_GDC 1
CONFIG_CRC7_MODULE 1
CONFIG_CRYPTO_RNG_DEFAULT 1
CONFIG_SENSORS_LTC4215_MODULE 1
CONFIG_SLICOSS_MODULE 1
CONFIG_KVM_AMD_MODULE 1
CONFIG_USB_EMI26_MODULE 1
CONFIG_IP_VS_PROTO_ESP 1
CONFIG_PCNET32_MODULE 1
CONFIG_MEDIA_TUNER_IT913X_MODULE 1
CONFIG_MWIFIEX_USB_MODULE 1
CONFIG_SAMSUNG_Q10_MODULE 1
CONFIG_TMPFS_XATTR 1
CONFIG_EXT4_USE_FOR_EXT2 1
CONFIG_EDAC_I82975X_MODULE 1
CONFIG_UBUNTU_ODM_DRIVERS 1
CONFIG_PCMCIA_NMCLAN_MODULE 1
CONFIG_CAN_M_CAN_PLATFORM_MODULE 1
CONFIG_MT76x2_COMMON_MODULE 1
CONFIG_NET_TEAM_MODULE 1
CONFIG_FB_UVESA_MODULE 1
CONFIG_INTEL_BXT_PMIC_THERMAL_MODULE 1
CONFIG_AD5593R_MODULE 1
CONFIG_COPS_TANGENT 1
CONFIG_LCD_ILI922X_MODULE 1
CONFIG_TOUCHSCREEN_TSC2007_MODULE 1
CONFIG_SND_RME96_MODULE 1
CONFIG_DCA_MODULE 1
CONFIG_CAN_KVASER_USB_MODULE 1
CONFIG_I2C_ALI1535_MODULE 1
CONFIG_VOP_BUS_MODULE 1
CONFIG_I2C_I801_MODULE 1
CONFIG_NETFILTER_FAMILY_ARP 1
CONFIG_BLK_DEV_UMEM_MODULE 1
CONFIG_MTD_NAND_CAFE_MODULE 1
CONFIG_BCM_NET_PHYLIB_MODULE 1
CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS 16
CONFIG_ATH10K_SPECTRAL 1
CONFIG_W1_MODULE 1
CONFIG_VIDEO_SAA7134_ALSA_MODULE 1
CONFIG_RT2800PCI_MODULE 1
CONFIG_USB_GSPCA_VC032X_MODULE 1
CONFIG_OPENVSWITCH_GRE_MODULE 1
CONFIG_USB_CONFIGFS_F_UAC1_LEGACY 1
CONFIG_PCMCIA_RAYCS_MODULE 1
CONFIG_V4L2_FWNODE_MODULE 1
CONFIG_IOMMU_HELPER 1
CONFIG_LEDS_TRIGGER_NETDEV_MODULE 1
CONFIG_DVB_ISL6421_MODULE 1
CONFIG_VIDEO_AU0828_RC 1
CONFIG_RTC_DRV_DS1374_MODULE 1
CONFIG_MICROCODE_OLD_INTERFACE 1
CONFIG_AUFS_INO_T_64 1
CONFIG_SENSORS_STTS751_MODULE 1
CONFIG_MLX5_ESWITCH 1
CONFIG_RTC_DRV_BQ4802_MODULE 1
CONFIG_INFINIBAND_OPA_VNIC_MODULE 1
CONFIG_TMD_HERMES_MODULE 1
CONFIG_GREYBUS_BOOTROM_MODULE 1
CONFIG_PATA_ACPI_MODULE 1
CONFIG_GENERIC_TRACER 1
CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS 1
CONFIG_NLS_ISO8859_5_MODULE 1
CONFIG_DRM_VGEM_MODULE 1
CONFIG_IP_VS_WLC_MODULE 1
CONFIG_HAVE_KVM_NO_POLL 1
CONFIG_VIDEO_AD5820_MODULE 1
CONFIG_HAVE_FUNCTION_TRACER 1
CONFIG_GENERIC_PHY 1
CONFIG_MLXSW_SPECTRUM_MODULE 1
CONFIG_CPU_ISOLATION 1
CONFIG_NF_NAT_TFTP_MODULE 1
CONFIG_SCR24X_MODULE 1
CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE 1
CONFIG_NR_CPUS_RANGE_END 8192
CONFIG_CHARGER_MAX14577_MODULE 1
CONFIG_MTD_SPI_NOR_MODULE 1
CONFIG_STACK_VALIDATION 1
CONFIG_CHARGER_MANAGER 1
CONFIG_NET_SCH_NETEM_MODULE 1
CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE 1
CONFIG_USB_STORAGE_REALTEK_MODULE 1
CONFIG_SND_SOC_AC97_CODEC_MODULE 1
CONFIG_CRYPTO_CAMELLIA_MODULE 1
CONFIG_SND_EMU10K1_SEQ_MODULE 1
CONFIG_RTC_DRV_DS1307_MODULE 1
CONFIG_I2C_SIS630_MODULE 1
CONFIG_ARCH_SELECT_MEMORY_MODEL 1
CONFIG_NFSD_V4 1
CONFIG_I2C_SI4713_MODULE 1
CONFIG_ZOPT2201_MODULE 1
CONFIG_TOUCHSCREEN_PROPERTIES 1
CONFIG_AUFS_EXPORT 1
CONFIG_PMBUS_MODULE 1
CONFIG_EFI_MIXED 1
CONFIG_VIDEO_MEYE_MODULE 1
CONFIG_TCP_CONG_ILLINOIS_MODULE 1
CONFIG_ZEROPLUS_FF 1
CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE 1
CONFIG_CRYPTO_MANAGER2 1
CONFIG_INFINIBAND_QIB_DCA 1
CONFIG_USB_GADGET_VBUS_DRAW 2
CONFIG_SATA_DWC_MODULE 1
CONFIG_NFC_MEI_PHY_MODULE 1
CONFIG_ARCH_HAS_PTE_SPECIAL 1
CONFIG_NET_VENDOR_MYRI 1
CONFIG_KEXEC_FILE 1
CONFIG_NF_NAT_MASQUERADE 1
CONFIG_SND_SOC_FSL_MICFIL_MODULE 1
CONFIG_DRAGONRISE_FF 1
CONFIG_CLZ_TAB 1
CONFIG_VIDEO_SMIAPP_MODULE 1
CONFIG_TOUCHSCREEN_USB_3M 1
CONFIG_TOUCHSCREEN_USB_EGALAX 1
CONFIG_TYPEC_FUSB302_MODULE 1
CONFIG_TOUCHSCREEN_SUR40_MODULE 1
CONFIG_BRIDGE_EBT_DNAT_MODULE 1
CONFIG_GENERIC_PCI_IOMAP 1
CONFIG_NETFILTER_XT_TARGET_LOG_MODULE 1
CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS 1
CONFIG_SLUB 1
CONFIG_SENSORS_AD7418_MODULE 1
CONFIG_NET_SCH_HHF_MODULE 1
CONFIG_CONFIGFS_FS 1
CONFIG_CRYPTO_TEST_MODULE 1
CONFIG_MTD_UBI_MODULE 1
CONFIG_MFD_SMSC 1
CONFIG_MODULE_SIG_KEY "certs/signing_key.pem"
CONFIG_GREYBUS_USB_MODULE 1
CONFIG_XZ_DEC_BCJ 1
CONFIG_SLIP_MODULE 1
CONFIG_PM_SLEEP 1
CONFIG_F2FS_FS_XATTR 1
CONFIG_SENSORS_FAM15H_POWER_MODULE 1
CONFIG_I2C 1
CONFIG_MFD_WM5110 1
CONFIG_COMPAL_LAPTOP_MODULE 1
CONFIG_LEDS_TRIGGER_MTD 1
CONFIG_JFFS2_ZLIB 1
CONFIG_SCSI_CHELSIO_FCOE_MODULE 1
CONFIG_PCMCIA_PCNET_MODULE 1
CONFIG_EDAC_DECODE_MCE_MODULE 1
CONFIG_FPGA_DFL_MODULE 1
CONFIG_VIDEO_TC358743_CEC 1
CONFIG_SENSORS_VT1211_MODULE 1
CONFIG_GPIO_AMDPT_MODULE 1
CONFIG_B44_PCI 1
CONFIG_CRYPTO_STATS 1
CONFIG_PPP_MULTILINK 1
CONFIG_INFINIBAND_RDMAVT_MODULE 1
CONFIG_X86_UV 1
CONFIG_SND_SOC_CS35L34_MODULE 1
CONFIG_MTD_ONENAND_GENERIC_MODULE 1
CONFIG_IPACK_BUS_MODULE 1
CONFIG_SND_SOC_INTEL_GLK_RT5682_MAX98357A_MACH_MODULE 1
CONFIG_BINFMT_SCRIPT 1
CONFIG_EFI_STUB 1
CONFIG_SATA_PROMISE_MODULE 1
CONFIG_EISA_NAMES 1
CONFIG_PARPORT_1284 1
CONFIG_MOUSE_PS2_CYPRESS 1
CONFIG_FONT_ACORN_8x8 1
CONFIG_SENSORS_POWR1220_MODULE 1
CONFIG_KPC2000_SPI_MODULE 1
CONFIG_VIDEO_CX25840_MODULE 1
CONFIG_VIDEO_OV5670_MODULE 1
CONFIG_GENERIC_PENDING_IRQ 1
CONFIG_I2C_AMD756_S4882_MODULE 1
CONFIG_PARPORT_PC_MODULE 1
CONFIG_BFQ_GROUP_IOSCHED 1
CONFIG_CAVIUM_PTP_MODULE 1
CONFIG_NET_TEAM_MODE_LOADBALANCE_MODULE 1
CONFIG_DVB_MN88472_MODULE 1
CONFIG_PPS_CLIENT_GPIO_MODULE 1
CONFIG_IIO_SW_TRIGGER_MODULE 1
CONFIG_X86_NEED_RELOCS 1
CONFIG_EARLY_PRINTK_DBGP 1
CONFIG_VIDEO_ADV7175_MODULE 1
CONFIG_SCSI_SRP_ATTRS_MODULE 1
CONFIG_FRAME_POINTER 1
CONFIG_NET_IPGRE_BROADCAST 1
CONFIG_BT_HIDP_MODULE 1
CONFIG_PD6729_MODULE 1
CONFIG_PINCTRL_CS47L15 1
CONFIG_KS8851_MLL_MODULE 1
CONFIG_VIDEO_CX231XX_RC 1
CONFIG_VIDEO_ADV7842_CEC 1
CONFIG_MOUSE_PS2_LOGIPS2PP 1
CONFIG_MFD_BD9571MWV_MODULE 1
CONFIG_TICK_CPU_ACCOUNTING 1
CONFIG_IIO_BUFFER_HW_CONSUMER_MODULE 1
CONFIG_COMEDI_DT2817_MODULE 1
CONFIG_SND_PCXHR_MODULE 1
CONFIG_TINYDRM_HX8357D_MODULE 1
CONFIG_STMMAC_PCI_MODULE 1
CONFIG_UFS_FS_MODULE 1
CONFIG_VM_EVENT_COUNTERS 1
CONFIG_MEDIA_COMMON_OPTIONS 1
CONFIG_NFC_MICROREAD_MODULE 1
CONFIG_HID_MAYFLASH_MODULE 1
CONFIG_TOUCHSCREEN_SX8654_MODULE 1
CONFIG_RELAY 1
CONFIG_AD9834_MODULE 1
CONFIG_IWLDVM_MODULE 1
CONFIG_HAVE_MMIOTRACE_SUPPORT 1
CONFIG_SCHED_STACK_END_CHECK 1
CONFIG_ASUS_NB_WMI_MODULE 1
CONFIG_RMI4_F30 1
CONFIG_USB_GSPCA_FINEPIX_MODULE 1
CONFIG_CRYPTO_ECB 1
CONFIG_SND_SOC_TLV320AIC32X4_MODULE 1
CONFIG_USB_GSPCA_ETOMS_MODULE 1
CONFIG_COPS_DAYNA 1
CONFIG_CRYPTO_SHA512_SSSE3_MODULE 1
CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT 1
CONFIG_REGULATOR_MAX77693_MODULE 1
CONFIG_MFD_PALMAS 1
CONFIG_WLAN_VENDOR_BROADCOM 1
CONFIG_PM_STD_PARTITION ""
CONFIG_SQUASHFS_LZO 1
CONFIG_SND_DYNAMIC_MINORS 1
CONFIG_FUJITSU_LAPTOP_MODULE 1
CONFIG_NET_DSA_MICROCHIP_KSZ9477_SPI_MODULE 1
CONFIG_TCM_FILEIO_MODULE 1
CONFIG_SND_PCM_IEC958 1
CONFIG_NET_VENDOR_XIRCOM 1
CONFIG_GENERIC_FIND_FIRST_BIT 1
CONFIG_MAX5432_MODULE 1
CONFIG_SCSI_STEX_MODULE 1
CONFIG_BT_HCIUART_AG6XX 1
CONFIG_6LOWPAN_NHC_HOP_MODULE 1
CONFIG_VIDEO_MT9T001_MODULE 1
CONFIG_HOTPLUG_PCI_CPCI_ZT5550_MODULE 1
CONFIG_BT_HCIUART_ATH3K 1
CONFIG_NF_CONNTRACK_AMANDA_MODULE 1
CONFIG_SND_ATIIXP_MODEM_MODULE 1
CONFIG_HID_NTI_MODULE 1
CONFIG_DEBUG_FS 1
CONFIG_UNISYS_VISORBUS_MODULE 1
CONFIG_RDMA_RXE_MODULE 1
CONFIG_FEALNX_MODULE 1
CONFIG_ACPI_EXTLOG_MODULE 1
CONFIG_USB_FUNCTIONFS_RNDIS 1
CONFIG_NET_VENDOR_AMD 1
CONFIG_HAVE_KERNEL_LZ4 1
CONFIG_NET_PKTGEN_MODULE 1
CONFIG_HP_WMI_MODULE 1
CONFIG_INTEL_ISH_HID_MODULE 1
CONFIG_MTD_NAND_DENALI_PCI_MODULE 1
CONFIG_USB_SERIAL_EDGEPORT_MODULE 1
CONFIG_DRM_TTM_MODULE 1
CONFIG_BASE_FULL 1
CONFIG_FB_CFB_IMAGEBLIT 1
CONFIG_MAX5487_MODULE 1
CONFIG_ZLIB_DEFLATE 1
CONFIG_NFT_REJECT_INET_MODULE 1
CONFIG_SUNRPC_MODULE 1
CONFIG_SOLARIS_X86_PARTITION 1
CONFIG_MLXSW_CORE_MODULE 1
CONFIG_ARCNET_RAW_MODULE 1
CONFIG_TOUCHSCREEN_TSC2007_IIO 1
CONFIG_PMIC_DA903X 1
CONFIG_SCSI_DH_RDAC_MODULE 1
CONFIG_SENSORS_W83795_MODULE 1
CONFIG_XFRM_INTERFACE_MODULE 1
CONFIG_BATTERY_BQ27XXX_MODULE 1
CONFIG_X86_P4_CLOCKMOD_MODULE 1
CONFIG_SND_SOC_ADAU1761_SPI_MODULE 1
CONFIG_INPUT_ATI_REMOTE2_MODULE 1
CONFIG_CNIC_MODULE 1
CONFIG_ACPI_TABLE_UPGRADE 1
CONFIG_RSI_SDIO_MODULE 1
CONFIG_OSF_PARTITION 1
CONFIG_HID_MALTRON_MODULE 1
CONFIG_ARCH_USES_HIGH_VMA_FLAGS 1
CONFIG_LEDS_TRIGGER_AUDIO_MODULE 1
CONFIG_RSEQ 1
CONFIG_NLS_CODEPAGE_864_MODULE 1
CONFIG_TOUCHSCREEN_CY8CTMG110_MODULE 1
CONFIG_IIO_BUFFER 1
CONFIG_IWL3945_MODULE 1
CONFIG_IP_VS_LBLCR_MODULE 1
CONFIG_GPIO_SYSFS 1
CONFIG_BE2NET_SKYHAWK 1
CONFIG_HP_WIRELESS_MODULE 1
CONFIG_USB_YUREX_MODULE 1
CONFIG_XEN_BACKEND 1
CONFIG_FW_LOADER 1
CONFIG_IIO_SW_DEVICE_MODULE 1
CONFIG_USB_G_DBGP_SERIAL 1
CONFIG_IP6_NF_NAT_MODULE 1
CONFIG_RTC_DRV_WM8350_MODULE 1
CONFIG_LTC2471_MODULE 1
CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING 0xa
CONFIG_SENSORS_ADS7828_MODULE 1
CONFIG_KALLSYMS 1
CONFIG_COMMON_CLK 1
CONFIG_USB_GSPCA_SPCA501_MODULE 1
CONFIG_HOTPLUG_PCI_PCIE 1
CONFIG_BMG160_I2C_MODULE 1
CONFIG_RTC_DRV_RV8803_MODULE 1
CONFIG_STACKPROTECTOR_STRONG 1
CONFIG_PCI 1
CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
CONFIG_CONTIG_ALLOC 1
CONFIG_CRYPTO_XTS 1
CONFIG_SENSORS_ZL6100_MODULE 1
CONFIG_SND_SOC_RL6231_MODULE 1
CONFIG_PWM 1
CONFIG_BATTERY_DS2781_MODULE 1
CONFIG_CHARGER_PCF50633_MODULE 1
CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE 1
CONFIG_SND_SOC_SOF_PROBE_WORK_QUEUE 1
CONFIG_DECOMPRESS_XZ 1
CONFIG_INPUT_MSM_VIBRATOR_MODULE 1
CONFIG_SERIAL_DEV_CTRL_TTYPORT 1
CONFIG_PCI_QUIRKS 1
CONFIG_BT_BCM_MODULE 1
CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE 1
CONFIG_INFINIBAND_USNIC_MODULE 1
CONFIG_MII_MODULE 1
CONFIG_KEYBOARD_TCA8418_MODULE 1
CONFIG_SIGNALFD 1
CONFIG_ADXL372_SPI_MODULE 1
CONFIG_REGULATOR_MAX8997_MODULE 1
CONFIG_NET_CORE 1
CONFIG_MOUSE_PS2_ALPS 1
CONFIG_VIDEO_CPIA2_MODULE 1
CONFIG_KEXEC_CORE 1
CONFIG_HAVE_UNSTABLE_SCHED_CLOCK 1
CONFIG_EXT4_FS 1
CONFIG_MAC80211_DEBUGFS 1
CONFIG_NET_SCH_DRR_MODULE 1
CONFIG_SND_SOC_RT298_MODULE 1
CONFIG_SENSORS_LTC4151_MODULE 1
CONFIG_BRIDGE_EBT_802_3_MODULE 1
CONFIG_DP83TC811_PHY_MODULE 1
CONFIG_DELL_SMBIOS_SMM 1
CONFIG_CPU5_WDT_MODULE 1
CONFIG_INFINIBAND_VMWARE_PVRDMA_MODULE 1
CONFIG_LCD_OTM3225A_MODULE 1
CONFIG_MEMORY_BALLOON 1
CONFIG_COMEDI_NI_65XX_MODULE 1
CONFIG_MMC_USDHI6ROL0_MODULE 1
CONFIG_SERIAL_SC16IS7XX_SPI 1
CONFIG_FB_LE80578_MODULE 1
CONFIG_VIDEO_CX88_BLACKBIRD_MODULE 1
CONFIG_MFD_SEC_CORE 1
CONFIG_SND_SOC_PCM512x_SPI_MODULE 1
CONFIG_HAVE_HW_BREAKPOINT 1
CONFIG_KRETPROBES 1
CONFIG_SND_JACK_INPUT_DEV 1
CONFIG_SCSI_MYRS_MODULE 1
CONFIG_MTD_LPDDR_MODULE 1
CONFIG_CRYPTO_SHA1 1
CONFIG_USB_FOTG210_HCD_MODULE 1
CONFIG_MFD_MT6397_MODULE 1
CONFIG_GPIO_104_DIO_48E_MODULE 1
CONFIG_QUOTACTL_COMPAT 1
CONFIG_HID_PENMOUNT_MODULE 1
CONFIG_IPMI_WATCHDOG_MODULE 1
CONFIG_MD_CLUSTER_MODULE 1
CONFIG_VIDEO_DW9714_MODULE 1
CONFIG_JOYSTICK_JOYDUMP_MODULE 1
CONFIG_INFINIBAND_USER_ACCESS_MODULE 1
CONFIG_NET_DSA_MT7530_MODULE 1
CONFIG_VMWARE_VMCI_MODULE 1
CONFIG_CHELSIO_T4_DCB 1
CONFIG_BPQETHER_MODULE 1
CONFIG_USB_ADUTUX_MODULE 1
CONFIG_BT_HCIUART_NOKIA_MODULE 1
CONFIG_VIDEO_UDA1342_MODULE 1
CONFIG_HSI_BOARDINFO 1
CONFIG_KGDB_LOW_LEVEL_TRAP 1
CONFIG_MT7601U_MODULE 1
CONFIG_CAN_C_CAN_PLATFORM_MODULE 1
CONFIG_ARCH_WANT_GENERAL_HUGETLB 1
CONFIG_SENSORS_SMSC47M192_MODULE 1
CONFIG_ADT7316_SPI_MODULE 1
CONFIG_NLS_KOI8_U_MODULE 1
CONFIG_RADIO_SHARK2_MODULE 1
CONFIG_CRC8_MODULE 1
CONFIG_BLK_DEV_ZONED 1
CONFIG_SND_SOC_CS42L51_MODULE 1
CONFIG_SENSORS_SCH5636_MODULE 1
CONFIG_PKCS7_TEST_KEY_MODULE 1
CONFIG_USB_BELKIN 1
CONFIG_NET_DSA_QCA8K_MODULE 1
CONFIG_SATA_PMP 1
CONFIG_XZ_DEC 1
CONFIG_SMS_SIANO_DEBUGFS 1
CONFIG_IPW2100_MONITOR 1
CONFIG_QLA3XXX_MODULE 1
CONFIG_RTL8192U_MODULE 1
CONFIG_CAN_VCAN_MODULE 1
CONFIG_SBNI_MODULE 1
CONFIG_DPTF_POWER_MODULE 1
CONFIG_GREYBUS_FIRMWARE_MODULE 1
CONFIG_ATH_COMMON_MODULE 1
CONFIG_NET_VENDOR_TI 1
CONFIG_CROS_EC_LPC_MODULE 1
CONFIG_LOCKD_V4 1
CONFIG_SENSORS_LTC2945_MODULE 1
CONFIG_DUMMY_MODULE 1
CONFIG_SND_SOC_AK5558_MODULE 1
CONFIG_MFD_MADERA_I2C_MODULE 1
CONFIG_CODA_FS_MODULE 1
CONFIG_W1_SLAVE_DS2431_MODULE 1
CONFIG_NET_VENDOR_ALACRITECH 1
CONFIG_I2C_MUX_MLXCPLD_MODULE 1
CONFIG_LEDS_LM3530_MODULE 1
CONFIG_DVB_TUNER_CX24113_MODULE 1
CONFIG_BRIDGE_EBT_MARK_T_MODULE 1
CONFIG_WATCHDOG 1
CONFIG_BATTERY_MAX17042_MODULE 1
CONFIG_SCSI_ADVANSYS_MODULE 1
CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE 1
CONFIG_SENSORS_IR38064_MODULE 1
CONFIG_RING_BUFFER_ALLOW_SWAP 1
CONFIG_HAS_IOMEM 1
CONFIG_SND_RAWMIDI_MODULE 1
CONFIG_HOTPLUG_PCI_ACPI_IBM_MODULE 1
CONFIG_MFD_ARIZONA_SPI_MODULE 1
CONFIG_NF_LOG_IPV6_MODULE 1
CONFIG_DE4X5_MODULE 1
CONFIG_IEEE802154_SOCKET_MODULE 1
CONFIG_TRACING_MAP 1
CONFIG_CRYPTO_RSA 1
CONFIG_USB_GSPCA_STK1135_MODULE 1
CONFIG_8139TOO_8129 1
CONFIG_SND_HDA_INPUT_BEEP_MODE 0
CONFIG_VIRT_DRIVERS 1
CONFIG_AUFS_SBILIST 1
CONFIG_VALIDATE_FS_PARSER 1
CONFIG_SENSORS_LTC4222_MODULE 1
CONFIG_COMEDI_PCL724_MODULE 1
CONFIG_IP_VS_OVF_MODULE 1
CONFIG_BT_HCIUART_INTEL 1
CONFIG_IIO_TIGHTLOOP_TRIGGER_MODULE 1
CONFIG_IR_FINTEK_MODULE 1
CONFIG_GENERIC_IRQ_PROBE 1
CONFIG_ATH6KL_USB_MODULE 1
CONFIG_FUSION_LOGGING 1
CONFIG_ABP060MG_MODULE 1
CONFIG_USB_NET_CDC_EEM_MODULE 1
CONFIG_BRCM_TRACING 1
CONFIG_USB_STORAGE_SDDR09_MODULE 1
CONFIG_GPIO_EXAR_MODULE 1
CONFIG_HYPERV_STORAGE_MODULE 1
CONFIG_IP_NF_MATCH_TTL_MODULE 1
CONFIG_KEYBOARD_MCS_MODULE 1
CONFIG_ASYNC_RAID6_RECOV_MODULE 1
CONFIG_SND_SOC_STA32X_MODULE 1
CONFIG_MENZ069_WATCHDOG_MODULE 1
CONFIG_PCI_HYPERV_INTERFACE_MODULE 1
CONFIG_SI7020_MODULE 1
CONFIG_SND_SOC_WM8782_MODULE 1
CONFIG_VIDEOMODE_HELPERS 1
CONFIG_NET_ACT_CTINFO_MODULE 1
CONFIG_CEPH_FS_SECURITY_LABEL 1
CONFIG_QCOM_EMAC_MODULE 1
CONFIG_CRYPTO_ACOMP2 1
CONFIG_PWM_LPSS_PLATFORM 1
CONFIG_EDD_OFF 1
CONFIG_GART_IOMMU 1
CONFIG_CHARGER_RT9455_MODULE 1
CONFIG_SCSI_SYM53C8XX_MAX_TAGS 64
CONFIG_FB_CARMINE_MODULE 1
CONFIG_KEYBOARD_MTK_PMIC_MODULE 1
CONFIG_CW1200_WLAN_SPI_MODULE 1
CONFIG_MTD_NAND_ECC_SW_BCH 1
CONFIG_VIDEO_OV13858_MODULE 1
CONFIG_NFTL_MODULE 1
CONFIG_KEYBOARD_ADC_MODULE 1
CONFIG_PCI_MMCONFIG 1
CONFIG_VSOCKMON_MODULE 1
CONFIG_PM_TRACE 1
CONFIG_SND_SOC_STA350_MODULE 1
CONFIG_VIDEO_OV7251_MODULE 1
CONFIG_SCSI_AM53C974_MODULE 1
CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE 1
CONFIG_HVC_IRQ 1
CONFIG_IAQCORE_MODULE 1
CONFIG_IWLWIFI_DEVICE_TRACING 1
CONFIG_TOUCHSCREEN_CHIPONE_ICN8505_MODULE 1
CONFIG_ATM_ZATM_MODULE 1
CONFIG_ACPI_NFIT_MODULE 1
CONFIG_USB_GADGETFS_MODULE 1
CONFIG_SND_SOC_NAU8810_MODULE 1
CONFIG_SND_RME32_MODULE 1
CONFIG_PROC_KCORE 1
CONFIG_RETPOLINE 1
CONFIG_RTC_DRV_X1205_MODULE 1
CONFIG_MTD_MAP_BANK_WIDTH_1 1
CONFIG_LPC_ICH_MODULE 1
CONFIG_NUMA 1
CONFIG_IP6_NF_MATCH_FRAG_MODULE 1
CONFIG_HDC100X_MODULE 1
CONFIG_LEDS_MT6323_MODULE 1
CONFIG_USB_SERIAL_CYBERJACK_MODULE 1
CONFIG_NET_SCH_PRIO_MODULE 1
CONFIG_ANDROID_BINDER_DEVICES ""
CONFIG_JSA1212_MODULE 1
CONFIG_SCHED_HRTICK 1
CONFIG_TOUCHSCREEN_EXC3000_MODULE 1
CONFIG_SATA_ULI_MODULE 1
CONFIG_DRM_I915_GVT 1
CONFIG_DVB_DRXK_MODULE 1
CONFIG_MMA7455_SPI_MODULE 1
CONFIG_USB_SERIAL_IUU_MODULE 1
CONFIG_VIDEO_GO7007_USB_S2250_BOARD_MODULE 1
CONFIG_EPOLL 1
CONFIG_FB_MATROX_G 1
CONFIG_SCSI_AIC79XX_MODULE 1
CONFIG_NET_IFE_MODULE 1
CONFIG_RADIO_MAXIRADIO_MODULE 1
CONFIG_CRYPTO_LZO 1
CONFIG_SND_PCM_MODULE 1
CONFIG_CRYPTO_TWOFISH_AVX_X86_64_MODULE 1
CONFIG_SND_SOC_SOF_CANNONLAKE_MODULE 1
CONFIG_SND_SOC_AK4458_MODULE 1
CONFIG_TCM_USER2_MODULE 1
CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB 20480
CONFIG_BRIDGE_EBT_SNAT_MODULE 1
CONFIG_SATA_MOBILE_LPM_POLICY 3
CONFIG_TCG_TIS_ST33ZP24_SPI_MODULE 1
CONFIG_SND_AU8820_MODULE 1
CONFIG_RAPIDIO 1
CONFIG_INFINIBAND_OCRDMA_MODULE 1
CONFIG_DA280_MODULE 1
CONFIG_SND_SEQ_MIDI_EVENT_MODULE 1
CONFIG_VIRTIO_FS_MODULE 1
CONFIG_SND_SOC_ES7134_MODULE 1
CONFIG_VIDEO_DT3155_MODULE 1
CONFIG_SDIO_UART_MODULE 1
CONFIG_NFC_MRVL_SPI_MODULE 1
CONFIG_KVM_COMPAT 1
CONFIG_PARTITION_ADVANCED 1
CONFIG_FAILOVER_MODULE 1
CONFIG_EZX_PCAP 1
CONFIG_SENSORS_SCH56XX_COMMON_MODULE 1
CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE 1
CONFIG_ICPLUS_PHY_MODULE 1
CONFIG_CGROUP_HUGETLB 1
CONFIG_UNIXWARE_DISKLABEL 1
CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 1
CONFIG_USB_U_ETHER_MODULE 1
CONFIG_X86_NUMACHIP 1
CONFIG_COMEDI_USBDUXFAST_MODULE 1
CONFIG_REGULATOR_LP872X_MODULE 1
CONFIG_EXTCON_AXP288_MODULE 1
CONFIG_BT_BNEP_MC_FILTER 1
CONFIG_CRYPTO_CRC32_MODULE 1
CONFIG_DRM_I915_SPIN_REQUEST 5
CONFIG_SCSI_ISCSI_ATTRS_MODULE 1
CONFIG_MTD_NAND_DENALI_MODULE 1
CONFIG_HAVE_NET_DSA 1
CONFIG_USB_SERIAL_EMPEG_MODULE 1
CONFIG_KEYBOARD_MAX7359_MODULE 1
CONFIG_IR_SONY_DECODER_MODULE 1
CONFIG_NLS_CODEPAGE_852_MODULE 1
CONFIG_TCG_TIS 1
CONFIG_TOUCHSCREEN_USB_IDEALTEK 1
CONFIG_VIDEO_PVRUSB2_MODULE 1
CONFIG_NET_DSA_TAG_KSZ_MODULE 1
CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE 1
CONFIG_NFS_SWAP 1
CONFIG_USB_ISP116X_HCD_MODULE 1
CONFIG_I2C_ISCH_MODULE 1
CONFIG_USB_NET_RNDIS_HOST_MODULE 1
CONFIG_NET 1
CONFIG_ATARI_PARTITION 1
CONFIG_MS5611_I2C_MODULE 1
CONFIG_SQUASHFS_FILE_DIRECT 1
CONFIG_USB_OHCI_HCD_PCI 1
CONFIG_INPUT_EVDEV 1
CONFIG_INTEL_ISH_FIRMWARE_DOWNLOADER_MODULE 1
CONFIG_SND_JACK 1
CONFIG_AD5933_MODULE 1
CONFIG_IDEAPAD_LAPTOP_MODULE 1
CONFIG_SECURITY_PATH 1
CONFIG_SND_SOC_CX2072X_MODULE 1
CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE 1
CONFIG_B43LEGACY_DMA 1
CONFIG_LIDAR_LITE_V2_MODULE 1
CONFIG_BMP280_SPI_MODULE 1
CONFIG_NCSI_OEM_CMD_GET_MAC 1
CONFIG_ACPI_SLEEP 1
CONFIG_REGULATOR_TPS65132_MODULE 1
CONFIG_REGULATOR_VIRTUAL_CONSUMER_MODULE 1
CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE 1
CONFIG_CRYPTO_WP512_MODULE 1
CONFIG_CFAG12864B_RATE 20
CONFIG_C2PORT_DURAMAR_2150_MODULE 1
CONFIG_CHARLCD_BL_FLASH 1
CONFIG_HID_DRAGONRISE_MODULE 1
CONFIG_X86_ESPFIX64 1
CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE 1
CONFIG_GPIO_RDC321X_MODULE 1
CONFIG_SERIAL_KGDB_NMI 1
CONFIG_VMIVME_7805_MODULE 1
CONFIG_COMEDI_ADQ12B_MODULE 1
CONFIG_VIDEO_BT848_MODULE 1
CONFIG_BLOCK_COMPAT 1
CONFIG_ITCO_WDT_MODULE 1
CONFIG_AMD_XGBE_DCB 1
CONFIG_COMEDI_NI_LABPC_MODULE 1
CONFIG_IR_IGUANA_MODULE 1
CONFIG_CHARGER_LP8788_MODULE 1
CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE 1
CONFIG_SPI_LOOPBACK_TEST_MODULE 1
CONFIG_FW_LOADER_USER_HELPER 1
CONFIG_SND_ALOOP_MODULE 1
CONFIG_ATH9K_STATION_STATISTICS 1
CONFIG_USB_KBD_MODULE 1
CONFIG_HPFS_FS_MODULE 1
CONFIG_VIDEO_APTINA_PLL_MODULE 1
CONFIG_PINMUX 1
CONFIG_USB_LD_MODULE 1
CONFIG_LAN743X_MODULE 1
CONFIG_MTD_GEN_PROBE_MODULE 1
CONFIG_SENSORS_NPCM7XX_MODULE 1
CONFIG_SCSI_UFS_BSG 1
CONFIG_QUOTA_TREE_MODULE 1
CONFIG_FB_VIA_MODULE 1
CONFIG_CAIF_NETDEV_MODULE 1
CONFIG_INPUT_PCSPKR_MODULE 1
CONFIG_IRQ_DOMAIN_HIERARCHY 1
CONFIG_HVC_XEN_FRONTEND 1
CONFIG_DRM_MIPI_DBI_MODULE 1
CONFIG_DVB_AV7110_OSD 1
CONFIG_SERIO_PCIPS2_MODULE 1
CONFIG_MPILIB 1
CONFIG_USB_NET_CDCETHER_MODULE 1
CONFIG_MMA9551_MODULE 1
CONFIG_JOYSTICK_PXRC_MODULE 1
CONFIG_PACKET 1
CONFIG_MODULE_SRCVERSION_ALL 1
CONFIG_FIREWIRE_SERIAL_MODULE 1
CONFIG_RTC_DRV_M48T86_MODULE 1
CONFIG_XFRM_ALGO_MODULE 1
CONFIG_SND_SIMPLE_CARD_UTILS_MODULE 1
CONFIG_NF_CONNTRACK_TIMESTAMP 1
CONFIG_SCIF_MODULE 1
CONFIG_ST_UVIS25_I2C_MODULE 1
CONFIG_RMI4_I2C_MODULE 1
CONFIG_HAVE_CLK_PREPARE 1
CONFIG_VIDEO_CX88_MPEG_MODULE 1
CONFIG_CRYPTO_AKCIPHER2 1
CONFIG_TAHVO_USB_MODULE 1
CONFIG_NODES_SHIFT 10
CONFIG_SENSORS_SMM665_MODULE 1
CONFIG_MWIFIEX_SDIO_MODULE 1
CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE 1
CONFIG_INTEL_IOATDMA_MODULE 1
CONFIG_NET_CLS_BASIC_MODULE 1
CONFIG_AXP288_ADC_MODULE 1
CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE 1
CONFIG_BACKLIGHT_LM3533_MODULE 1
CONFIG_W1_SLAVE_DS2405_MODULE 1
CONFIG_MMC_SDHCI_XENON_MODULE 1
CONFIG_SND_HDA_GENERIC_MODULE 1
CONFIG_AUFS_BR_HFSPLUS 1
CONFIG_AD5764_MODULE 1
CONFIG_I2C_TINY_USB_MODULE 1
CONFIG_NETROM_MODULE 1
CONFIG_MMC35240_MODULE 1
CONFIG_FUSION_SPI_MODULE 1
CONFIG_SND_SOC_SOF_INTEL_PCI_MODULE 1
CONFIG_BTRFS_FS_POSIX_ACL 1
CONFIG_SND_HDA_CORE_MODULE 1
CONFIG_USB_GSPCA_OV534_MODULE 1
CONFIG_KEYBOARD_TCA6416_MODULE 1
CONFIG_COMEDI_DT3000_MODULE 1
CONFIG_FRONTSWAP 1
CONFIG_HTS221_MODULE 1
CONFIG_DVB_USB_GL861_MODULE 1
CONFIG_DRM_I915_GVT_KVMGT_MODULE 1
CONFIG_IMA_APPRAISE 1
CONFIG_ALTERA_MSGDMA_MODULE 1
CONFIG_DUMMY_CONSOLE_ROWS 25
CONFIG_MFD_ARIZONA_I2C_MODULE 1
CONFIG_USB_XHCI_PLATFORM_MODULE 1
CONFIG_SND_SOC_TLV320AIC23_I2C_MODULE 1
CONFIG_NF_CONNTRACK_TFTP_MODULE 1
CONFIG_NFS_V3_MODULE 1
CONFIG_RTC_DRV_MAX6902_MODULE 1
CONFIG_MFD_MAX8997 1
CONFIG_PHY_TUSB1210_MODULE 1
CONFIG_VIDEO_ADV7604_CEC 1
CONFIG_DVB_USB_ANYSEE_MODULE 1
CONFIG_HAVE_KVM_IRQFD 1
CONFIG_NLS_CODEPAGE_949_MODULE 1
CONFIG_DVB_CX24110_MODULE 1
CONFIG_SENSORS_TMP102_MODULE 1
CONFIG_NOP_TRACER 1
CONFIG_LOOPBACK_TARGET_MODULE 1
CONFIG_ISL29020_MODULE 1
CONFIG_SENSORS_TSL2563_MODULE 1
CONFIG_HID_CORSAIR_MODULE 1
CONFIG_PWM_CRC 1
CONFIG_SND_HDA_PATCH_LOADER 1
CONFIG_XEN_XENBUS_FRONTEND 1
CONFIG_NF_FLOW_TABLE_IPV6_MODULE 1
CONFIG_INET 1
CONFIG_CRYPTO_PCRYPT_MODULE 1
CONFIG_HID_SENSOR_PRESS_MODULE 1
CONFIG_COMEDI_CB_PCIMDDA_MODULE 1
CONFIG_IP_ROUTE_VERBOSE 1
CONFIG_XZ_DEC_POWERPC 1
CONFIG_PCMCIA_WL3501_MODULE 1
CONFIG_USB_MAX3421_HCD_MODULE 1
CONFIG_DVB_RTL2832_MODULE 1
CONFIG_INTEL_PCH_THERMAL_MODULE 1
CONFIG_USB_MUSB_HDRC_MODULE 1
CONFIG_VIRTIO_NET_MODULE 1
CONFIG_MEMORY_NOTIFIER_ERROR_INJECT_MODULE 1
CONFIG_TOUCHSCREEN_SIS_I2C_MODULE 1
CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE 1
CONFIG_NET_VENDOR_HUAWEI 1
CONFIG_PREVENT_FIRMWARE_BUILD 1
CONFIG_SERIAL_8250_PNP 1
CONFIG_USB_NET_MCS7830_MODULE 1
CONFIG_VIDEOBUF2_DVB_MODULE 1
CONFIG_RSI_COEX 1
CONFIG_SND_ENS1371_MODULE 1
CONFIG_CRYPTO_TWOFISH_MODULE 1
CONFIG_FREEZER 1
CONFIG_SENSORS_I5500_MODULE 1
CONFIG_USB_F_SUBSET_MODULE 1
CONFIG_FIREWIRE_NET_MODULE 1
CONFIG_HAVE_HARDLOCKUP_DETECTOR_PERF 1
CONFIG_COMEDI_ADV_PCI1724_MODULE 1
CONFIG_W1_SLAVE_DS2413_MODULE 1
CONFIG_USB_TEST_MODULE 1
CONFIG_TOUCHSCREEN_MAX11801_MODULE 1
CONFIG_SND_SOC_WM8737_MODULE 1
CONFIG_ADAPTEC_STARFIRE_MODULE 1
CONFIG_BT_MODULE 1
CONFIG_REGULATOR_BCM590XX_MODULE 1
CONFIG_BT_HCIVHCI_MODULE 1
CONFIG_INPUT_CM109_MODULE 1
CONFIG_AXP288_FUEL_GAUGE_MODULE 1
CONFIG_PCI_DOMAINS 1
CONFIG_EFI_VARS 1
CONFIG_CEC_PLATFORM_DRIVERS 1
CONFIG_MS5637_MODULE 1
CONFIG_REGULATOR_88PM800_MODULE 1
CONFIG_NFT_QUEUE_MODULE 1
CONFIG_LCD_PLATFORM_MODULE 1
CONFIG_DVB_USB_MXL111SF_MODULE 1
CONFIG_SENSORS_IT87_MODULE 1
CONFIG_LPC_SCH_MODULE 1
CONFIG_NET_CLS_ACT 1
CONFIG_MLX90614_MODULE 1
CONFIG_HID_BIGBEN_FF_MODULE 1
CONFIG_REED_SOLOMON_MODULE 1
CONFIG_SCSI_FDOMAIN_MODULE 1
CONFIG_CIFS_DFS_UPCALL 1
CONFIG_EXFAT_DEFAULT_CODEPAGE 437
CONFIG_NET_VENDOR_CHELSIO 1
CONFIG_LZ4HC_COMPRESS_MODULE 1
CONFIG_COMEDI_ADL_PCI6208_MODULE 1
CONFIG_HDLC_RAW_ETH_MODULE 1
CONFIG_COMEDI_MODULE 1
CONFIG_SND_SOC_SOF_BAYTRAIL_SUPPORT 1
CONFIG_PINCTRL_LEWISBURG_MODULE 1
CONFIG_EFIVAR_FS 1
CONFIG_BRIDGE_EBT_BROUTE_MODULE 1
CONFIG_USB_NET_SMSC75XX_MODULE 1
CONFIG_BE2NET_MODULE 1
CONFIG_REGULATOR_TPS80031_MODULE 1
CONFIG_PARPORT_MODULE 1
CONFIG_HAVE_ARCH_VMAP_STACK 1
CONFIG_VORTEX_MODULE 1
CONFIG_IPVTAP_MODULE 1
CONFIG_SPEAKUP_SYNTH_DECTLK_MODULE 1
CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE 1
CONFIG_DEV_DAX_KMEM_MODULE 1
CONFIG_TIPC_MEDIA_UDP 1
CONFIG_SND_SOC_SOF_MERRIFIELD_SUPPORT 1
CONFIG_VMWARE_VMCI_VSOCKETS_MODULE 1
CONFIG_X86_DEBUGCTLMSR 1
CONFIG_HDLC_MODULE 1
CONFIG_NET_CLS_BPF_MODULE 1
CONFIG_ATM_SOLOS_MODULE 1
CONFIG_8139TOO_PIO 1
CONFIG_NET_DSA_TAG_BRCM_PREPEND_MODULE 1
CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN "kernel.org"
CONFIG_IP_SET_MAX 256
CONFIG_HAPPYMEAL_MODULE 1
CONFIG_HID_WACOM_MODULE 1
CONFIG_USB_F_ACM_MODULE 1
CONFIG_QLCNIC_DCB 1
CONFIG_SCIF_BUS_MODULE 1
CONFIG_USB_SERIAL_CP210X_MODULE 1
CONFIG_SND_PCMCIA 1
CONFIG_HMM_MIRROR 1
CONFIG_NET_SCH_SFQ_MODULE 1
CONFIG_RTC_LIB 1
CONFIG_DEVFREQ_GOV_POWERSAVE 1
CONFIG_FW_LOADER_PAGED_BUF 1
CONFIG_NET_SCH_CBS_MODULE 1
CONFIG_NVDIMM_DAX 1
CONFIG_X86_LOCAL_APIC 1
CONFIG_ACER_WIRELESS_MODULE 1
CONFIG_USB_GOKU_MODULE 1
CONFIG_USB_UEAGLEATM_MODULE 1
CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE 1
CONFIG_COMEDI_ADV_PCI1760_MODULE 1
CONFIG_MWL8K_MODULE 1
CONFIG_HAVE_KPROBES 1
CONFIG_NUMA_BALANCING_DEFAULT_ENABLED 1
CONFIG_SND_DESIGNWARE_PCM 1
CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS 1
CONFIG_FB_INTEL_MODULE 1
CONFIG_TPS65010_MODULE 1
CONFIG_IP_ROUTE_CLASSID 1
CONFIG_MOUSE_SYNAPTICS_I2C_MODULE 1
CONFIG_NETFILTER_XT_TARGET_TEE_MODULE 1
CONFIG_SND_USB_VARIAX_MODULE 1
CONFIG_HPWDT_NMI_DECODING 1
CONFIG_ENC28J60_MODULE 1
CONFIG_MOUSE_PS2_TOUCHKIT 1
CONFIG_PWM_LP3943_MODULE 1
CONFIG_USB_SERIAL_XSENS_MT_MODULE 1
CONFIG_VIDEO_CX88_MODULE 1
CONFIG_TOUCHSCREEN_USB_ITM 1
CONFIG_CRYPTO_AES 1
CONFIG_HAVE_GENERIC_VDSO 1
CONFIG_BACKLIGHT_LP855X_MODULE 1
CONFIG_DVB_DIB7000P_MODULE 1
CONFIG_MLX5_EN_TLS 1
CONFIG_GPIOLIB 1
CONFIG_MFD_TI_AM335X_TSCADC_MODULE 1
CONFIG_SSB_MODULE 1
CONFIG_ZONE_DEVICE 1
CONFIG_REGULATOR_ISL6271A_MODULE 1
CONFIG_FUTEX_PI 1
CONFIG_FB_MATROX_I2C_MODULE 1
CONFIG_MTD_NAND_MXIC_MODULE 1
CONFIG_BMC150_ACCEL_SPI_MODULE 1
CONFIG_I2C_STUB_MODULE 1
CONFIG_EXTCON_MAX8997_MODULE 1
CONFIG_DM_BIO_PRISON_MODULE 1
CONFIG_INPUT_DRV2667_HAPTICS_MODULE 1
CONFIG_GENERIC_CPU_VULNERABILITIES 1
CONFIG_VIDEO_MT9T112_MODULE 1
CONFIG_VIDEO_EM28XX_RC_MODULE 1
CONFIG_NFT_LIMIT_MODULE 1
CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES 1
CONFIG_RADIO_TEA5764_MODULE 1
CONFIG_AQTION_MODULE 1
CONFIG_DVB_LNBH25_MODULE 1
CONFIG_KEYS_COMPAT 1
CONFIG_PINCTRL_MCP23S08_MODULE 1
CONFIG_USB_GSPCA_SPCA1528_MODULE 1
CONFIG_LEDS_TLC591XX_MODULE 1
CONFIG_FB_SVGALIB_MODULE 1
CONFIG_BMC150_MAGN_MODULE 1
CONFIG_PARPORT_AX88796_MODULE 1
CONFIG_TI_ADC128S052_MODULE 1
CONFIG_AD2S1210_MODULE 1
CONFIG_HID_PID 1
CONFIG_NV_TCO_MODULE 1
CONFIG_USB_SERIAL_QT2_MODULE 1
CONFIG_SND_SOC_PCM179X_MODULE 1
CONFIG_SMSC9420_MODULE 1
CONFIG_COMEDI_PCI_DRIVERS_MODULE 1
CONFIG_SENSORS_MAX6639_MODULE 1
CONFIG_SND_SOC_SOF_COMETLAKE_H_MODULE 1
CONFIG_AUTOFS_FS_MODULE 1
CONFIG_GAMEPORT_MODULE 1
CONFIG_ISO9660_FS_MODULE 1
CONFIG_NET_ACT_CT_MODULE 1
CONFIG_SKY2_MODULE 1
CONFIG_NETFILTER_XT_NAT_MODULE 1
CONFIG_AD7793_MODULE 1
CONFIG_BT_HCIUART_H4 1
CONFIG_LEDS_NIC78BX_MODULE 1
CONFIG_USB_CONFIGFS_F_MIDI 1
CONFIG_RTC_DRV_DS3232_MODULE 1
CONFIG_SND_SOC_PCM3168A_MODULE 1
CONFIG_REGULATOR_MC13783_MODULE 1
CONFIG_PACKING 1
CONFIG_CROS_KBD_LED_BACKLIGHT_MODULE 1
CONFIG_SND_PCM_ELD 1
CONFIG_XEN_WDT_MODULE 1
CONFIG_DVB_USB_M920X_MODULE 1
CONFIG_MLX5_SW_STEERING 1
CONFIG_UIO_MODULE 1
CONFIG_HID_WALTOP_MODULE 1
CONFIG_BACKLIGHT_LM3630A_MODULE 1
CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR 1
CONFIG_ADIS16136_MODULE 1
CONFIG_GPIO_RC5T583 1
CONFIG_VIDEO_ADV7170_MODULE 1
CONFIG_UIO_DMEM_GENIRQ_MODULE 1
CONFIG_SND_SOC_TAS5086_MODULE 1
CONFIG_NET_VENDOR_AQUANTIA 1
CONFIG_SCSI_VIRTIO_MODULE 1
CONFIG_NF_CONNTRACK_MARK 1
CONFIG_IDLE_PAGE_TRACKING 1
CONFIG_HVC_DRIVER 1
CONFIG_BLK_DEV_PCIESSD_MTIP32XX_MODULE 1
CONFIG_NETFILTER 1
CONFIG_NFT_REJECT_IPV4_MODULE 1
CONFIG_RC_LOOPBACK_MODULE 1
CONFIG_ISDN_DRV_AVMB1_T1PCI_MODULE 1
CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE 1
CONFIG_MODULE_SIG 1
CONFIG_BRIDGE_EBT_AMONG_MODULE 1
CONFIG_COMEDI_DT2814_MODULE 1
CONFIG_VIDEO_VS6624_MODULE 1
CONFIG_B53_MODULE 1
CONFIG_ATH9K_WOW 1
CONFIG_B43_PIO 1
CONFIG_BACKLIGHT_88PM860X_MODULE 1
CONFIG_X86_DEV_DMA_OPS 1
CONFIG_B43_BUSES_BCMA_AND_SSB 1
CONFIG_ADIS16201_MODULE 1
CONFIG_USB_R8A66597_HCD_MODULE 1
CONFIG_REGULATOR_TWL4030_MODULE 1
CONFIG_X86_MSR_MODULE 1
CONFIG_HAVE_ARCH_KASAN 1
CONFIG_LOCK_DOWN_IN_SECURE_BOOT 1
CONFIG_BME680_MODULE 1
CONFIG_NET_VENDOR_SMSC 1
CONFIG_BACKLIGHT_PM8941_WLED_MODULE 1
CONFIG_NETFILTER_NETLINK_ACCT_MODULE 1
CONFIG_COMEDI_8254_MODULE 1
CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE 1
CONFIG_USB_KC2190 1
CONFIG_R6040_MODULE 1
CONFIG_USB_MDC800_MODULE 1
CONFIG_GPIO_AMD_FCH_MODULE 1
CONFIG_AIRO_CS_MODULE 1
CONFIG_6LOWPAN_MODULE 1
CONFIG_VIPERBOARD_ADC_MODULE 1
CONFIG_HWMON_VID_MODULE 1
CONFIG_SERIO_SERPORT_MODULE 1
CONFIG_FB_BOOT_VESA_SUPPORT 1
CONFIG_COMEDI_ME4000_MODULE 1
CONFIG_NLS_CODEPAGE_950_MODULE 1
CONFIG_DVB_STV0297_MODULE 1
CONFIG_DVB_TTUSB_DEC_MODULE 1
CONFIG_LEDS_TRIGGER_ONESHOT_MODULE 1
CONFIG_HAVE_NMI 1
CONFIG_LIRC 1
CONFIG_INPUT_PWM_BEEPER_MODULE 1
CONFIG_SCSI_AIC94XX_MODULE 1
CONFIG_BT_BNEP_MODULE 1
CONFIG_NET_SCH_QFQ_MODULE 1
CONFIG_DVB_TDA826X_MODULE 1
CONFIG_COMEDI_MPC624_MODULE 1
CONFIG_BLK_DEV_RAM_COUNT 16
CONFIG_IXGBEVF_MODULE 1
CONFIG_SND_AC97_POWER_SAVE_DEFAULT 0
CONFIG_TABLET_SERIAL_WACOM4_MODULE 1
CONFIG_THINKPAD_ACPI_DEBUGFACILITIES 1
CONFIG_DVB_NGENE_MODULE 1
CONFIG_RD_XZ 1
CONFIG_IP_MROUTE 1
CONFIG_VIDEO_MXB_MODULE 1
CONFIG_SYSTEM_EXTRA_CERTIFICATE 1
CONFIG_X86_SMAP 1
CONFIG_SND_SOC_TLV320AIC23_MODULE 1
CONFIG_VGA_CONSOLE 1
CONFIG_DEVFREQ_THERMAL 1
CONFIG_CRYPTO_ECDH_MODULE 1
CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS 1
CONFIG_NET_ACT_TUNNEL_KEY_MODULE 1
CONFIG_HID_RMI_MODULE 1
CONFIG_USB_F_UAC1_LEGACY_MODULE 1
CONFIG_ATA_VERBOSE_ERROR 1
CONFIG_ISDN_DRV_AVMB1_B1PCMCIA_MODULE 1
CONFIG_MT76_USB_MODULE 1
CONFIG_XEN_BLKDEV_FRONTEND 1
CONFIG_NF_CONNTRACK_SNMP_MODULE 1
CONFIG_UEFI_CPER_X86 1
CONFIG_CM3232_MODULE 1
CONFIG_GREYBUS_AUDIO_MODULE 1
CONFIG_SND_DRIVERS 1
CONFIG_USB_SERIAL_BELKIN_MODULE 1
CONFIG_W1_MASTER_DS2490_MODULE 1
CONFIG_PRINTK_NMI 1
CONFIG_MEDIA_TUNER_MT2266_MODULE 1
CONFIG_NLS_MAC_GREEK_MODULE 1
CONFIG_NET_FLOW_LIMIT 1
CONFIG_XFS_FS_MODULE 1
CONFIG_SENSORS_DME1737_MODULE 1
CONFIG_INPUT_KEYSPAN_REMOTE_MODULE 1
CONFIG_USB_GSPCA_PAC7302_MODULE 1
CONFIG_PINCTRL_CS47L92 1
CONFIG_LOCKDEP_SUPPORT 1
CONFIG_X86_MCE_INJECT_MODULE 1
CONFIG_TOUCHSCREEN_ELO_MODULE 1
CONFIG_NLS_CODEPAGE_869_MODULE 1
CONFIG_SENSORS_NCT7904_MODULE 1
CONFIG_NET_ACT_MPLS_MODULE 1
CONFIG_SND_AZT3328_MODULE 1
CONFIG_VIDEO_ML86V7667_MODULE 1
CONFIG_NF_LOG_BRIDGE_MODULE 1
CONFIG_SND_AC97_POWER_SAVE 1
CONFIG_NET_SCH_CAKE_MODULE 1
CONFIG_IP6_NF_TARGET_MASQUERADE_MODULE 1
CONFIG_REGULATOR_PALMAS_MODULE 1
CONFIG_NFT_REDIR_MODULE 1
CONFIG_SATA_VIA_MODULE 1
CONFIG_COMEDI_PCMMIO_MODULE 1
CONFIG_ACPI_PROCESSOR_IDLE 1
CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION 1
CONFIG_NO_HZ 1
CONFIG_VIDEO_MT9M032_MODULE 1
CONFIG_INTEL_SOC_PMIC 1
CONFIG_ARCH_WANT_HUGE_PMD_SHARE 1
CONFIG_BMI160_MODULE 1
CONFIG_NFT_TUNNEL_MODULE 1
CONFIG_POSIX_MQUEUE 1
CONFIG_NOUVEAU_DEBUG 5
CONFIG_MLX5_FPGA 1
CONFIG_NETFILTER_INGRESS 1
CONFIG_SND_SOC_TOPOLOGY 1
CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE 1
CONFIG_GPIO_MADERA_MODULE 1
CONFIG_GPIO_DWAPB_MODULE 1
CONFIG_LTC2632_MODULE 1
CONFIG_SND_SOC_SOF_COMETLAKE_LP_SUPPORT 1
CONFIG_REGULATOR_PFUZE100_MODULE 1
CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT 1
CONFIG_FB_PM2_FIFO_DISCONNECT 1
CONFIG_TOUCHSCREEN_STMFTS_MODULE 1
CONFIG_SENSORS_LM83_MODULE 1
CONFIG_USB_NET_CDC_MBIM_MODULE 1
CONFIG_SENSORS_TMP108_MODULE 1
CONFIG_PMC_ATOM 1
CONFIG_MT76x0E_MODULE 1
CONFIG_ACENIC_MODULE 1
CONFIG_ARCH_MIGHT_HAVE_PC_SERIO 1
CONFIG_KPC2000_DMA_MODULE 1
CONFIG_PSTORE_RAM_MODULE 1
CONFIG_COMEDI_PCM3724_MODULE 1
CONFIG_LEDS_BLINKM_MODULE 1
CONFIG_INPUT_PWM_VIBRA_MODULE 1
CONFIG_CPU_FREQ_STAT 1
CONFIG_JFS_STATISTICS 1
CONFIG_COMEDI_NI_DAQ_700_CS_MODULE 1
CONFIG_ISCSI_IBFT_MODULE 1
CONFIG_SPI_PXA2XX_MODULE 1
CONFIG_PCMCIA_SMC91C92_MODULE 1
CONFIG_WILC1000_HW_OOB_INTR 1
CONFIG_BT_HCIDTL1_MODULE 1
CONFIG_TIFM_CORE_MODULE 1
CONFIG_XEN_PRIVCMD_MODULE 1
CONFIG_FXAS21002C_SPI_MODULE 1
CONFIG_FUSION_SAS_MODULE 1
CONFIG_GENERIC_STRNCPY_FROM_USER 1
CONFIG_MTD_BLKDEVS_MODULE 1
CONFIG_GPIO_KEMPLD_MODULE 1
CONFIG_DVB_TDA10086_MODULE 1
CONFIG_HP100_MODULE 1
CONFIG_BLK_DEV_3W_XXXX_RAID_MODULE 1
CONFIG_HAVE_RSEQ 1
CONFIG_MEMSTICK_R592_MODULE 1
CONFIG_NET_SCH_MQPRIO_MODULE 1
CONFIG_NETFILTER_XT_TARGET_NETMAP_MODULE 1
CONFIG_MLX5_CORE_EN_DCB 1
CONFIG_SND_SOC_MAX98088_MODULE 1
CONFIG_HID_ELAN_MODULE 1
CONFIG_VIDEO_VPX3220_MODULE 1
CONFIG_APDS9802ALS_MODULE 1
CONFIG_DVB_NXT6000_MODULE 1
CONFIG_SPMI_MODULE 1
CONFIG_CRYPTO_DEV_NITROX_MODULE 1
CONFIG_MANTIS_CORE_MODULE 1
CONFIG_PATA_MARVELL_MODULE 1
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64_MODULE 1
CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE 1
CONFIG_GPIO_SIOX_MODULE 1
CONFIG_SERIO_GPIO_PS2_MODULE 1
CONFIG_SATA_SIL24_MODULE 1
CONFIG_RTL8723BS_MODULE 1
CONFIG_SMS_SIANO_RC 1
CONFIG_SND_SOC_CS42L52_MODULE 1
CONFIG_CRASH_CORE 1
CONFIG_ISL29125_MODULE 1
CONFIG_NET_VENDOR_DEC 1
CONFIG_MDIO_CAVIUM_MODULE 1
CONFIG_NLS_ISO8859_15_MODULE 1
CONFIG_HID_SENSOR_MAGNETOMETER_3D_MODULE 1
CONFIG_TOUCHSCREEN_EETI_MODULE 1
CONFIG_USB_ROLES_INTEL_XHCI_MODULE 1
CONFIG_SENSORS_VIA686A_MODULE 1
CONFIG_INET6_ESP_MODULE 1
CONFIG_EARLY_PRINTK_USB_XDBC 1
CONFIG_HOSTAP_PCI_MODULE 1
CONFIG_IP_VS_WRR_MODULE 1
CONFIG_INTEL_IOMMU_SVM 1
CONFIG_AUTOFS4_FS_MODULE 1
CONFIG_NET_NSH_MODULE 1
CONFIG_UCSI_CCG_MODULE 1
CONFIG_ATH5K_MODULE 1
CONFIG_VIDEO_FB_IVTV_MODULE 1
CONFIG_ACPI_BUTTON 1
CONFIG_LEDS_LM355x_MODULE 1
CONFIG_ILLEGAL_POINTER_VALUE 0xdead000000000000
CONFIG_CRYPTO_DEV_CCP_CRYPTO_MODULE 1
CONFIG_GENERIC_GETTIMEOFDAY 1
CONFIG_UIO_NETX_MODULE 1
CONFIG_PDA_POWER_MODULE 1
CONFIG_NETFILTER_XT_SET_MODULE 1
CONFIG_NLS_MAC_CROATIAN_MODULE 1
CONFIG_SFC_MTD 1
CONFIG_SND_SOC_MAX98090_MODULE 1
CONFIG_TASKSTATS 1
CONFIG_EXTCON_GPIO_MODULE 1
CONFIG_VIDEO_LM3560_MODULE 1
CONFIG_ARCNET_1201_MODULE 1
CONFIG_NLS_CODEPAGE_932_MODULE 1
CONFIG_INTEL_PMC_IPC_MODULE 1
CONFIG_MCB_MODULE 1
CONFIG_RT2X00_LIB_MMIO_MODULE 1
CONFIG_CRYPTO_CRC32C_INTEL 1
CONFIG_WILC1000_MODULE 1
CONFIG_NLS_MAC_ICELAND_MODULE 1
CONFIG_SND_ATMEL_SOC_MODULE 1
CONFIG_EXFAT_DONT_MOUNT_VFAT 1
CONFIG_MEDIA_SUBDRV_AUTOSELECT 1
CONFIG_TOUCHSCREEN_TSC200X_CORE_MODULE 1
CONFIG_MTD_NAND_ECC_SW_HAMMING_MODULE 1
CONFIG_CAN_PLX_PCI_MODULE 1
CONFIG_VIDEO_GS1662_MODULE 1
CONFIG_SND_SOC_RT5677_SPI_MODULE 1
CONFIG_USB_FUNCTIONFS_GENERIC 1
CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH_MODULE 1
CONFIG_JFS_POSIX_ACL 1
CONFIG_I2C_ALI1563_MODULE 1
CONFIG_NET_VENDOR_PENSANDO 1
CONFIG_IP6_NF_FILTER_MODULE 1
CONFIG_DELL_WMI_DESCRIPTOR_MODULE 1
CONFIG_SYSTEM_DATA_VERIFICATION 1
CONFIG_CRAMFS_MTD 1
CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
CONFIG_EFI_ESRT 1
CONFIG_NEED_DMA_MAP_STATE 1
CONFIG_IIO_TRIGGERED_EVENT_MODULE 1
CONFIG_SND_HDA_MODULE 1
CONFIG_SENSORS_G762_MODULE 1
CONFIG_IIO_MODULE 1
CONFIG_SND_HDA_PREALLOC_SIZE 64
CONFIG_GARP_MODULE 1
CONFIG_PCMCIA_AHA152X_MODULE 1
CONFIG_INPUT_TWL6040_VIBRA_MODULE 1
CONFIG_RT2500USB_MODULE 1
CONFIG_YENTA_ENE_TUNE 1
CONFIG_MOUSE_PS2_LIFEBOOK 1
CONFIG_SERIO_LIBPS2 1
CONFIG_BLK_DEV_DRBD_MODULE 1
CONFIG_IP_VS_PROTO_TCP 1
CONFIG_QED_OOO 1
CONFIG_SND_SOC_SOF_ACPI_MODULE 1
CONFIG_ISCSI_BOOT_SYSFS_MODULE 1
CONFIG_X86_CPUID_MODULE 1
CONFIG_CRYPTO_DEV_QAT_C3XXXVF_MODULE 1
CONFIG_NET_SCH_RED_MODULE 1
CONFIG_PCI_ATMEL_MODULE 1
CONFIG_NETFILTER_XT_MATCH_NFACCT_MODULE 1
CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE 1
CONFIG_KDB_CONTINUE_CATASTROPHIC 0
CONFIG_USB_SERIAL_METRO_MODULE 1
CONFIG_USB_PRINTER_MODULE 1
CONFIG_FONT_8x8 1
CONFIG_SSB_SPROM 1
CONFIG_AUFS_DIRREN 1
CONFIG_SHIFT_FS_MODULE 1
CONFIG_USB_GSPCA_PAC207_MODULE 1
CONFIG_RAPIDIO_RXS_GEN3_MODULE 1
CONFIG_NET_VENDOR_ATHEROS 1
CONFIG_TRANSPARENT_HUGE_PAGECACHE 1
CONFIG_USB_SERIAL_IR_MODULE 1
CONFIG_IIO_CROS_EC_BARO_MODULE 1
CONFIG_SKGE_MODULE 1
CONFIG_FB_SIMPLE 1
CONFIG_COMEDI_DT9812_MODULE 1
CONFIG_REGULATOR_ACT8865_MODULE 1
CONFIG_SND_SOC_AK4104_MODULE 1
CONFIG_INPUT_DA9055_ONKEY_MODULE 1
CONFIG_TCM_PSCSI_MODULE 1
CONFIG_RELOCATABLE 1
CONFIG_DMARD10_MODULE 1
CONFIG_CRYPTO_POLY1305_MODULE 1
CONFIG_QUEUED_SPINLOCKS 1
CONFIG_XOR_BLOCKS_MODULE 1
CONFIG_AD8801_MODULE 1
CONFIG_HID_TWINHAN_MODULE 1
CONFIG_NFS_V4_1_MIGRATION 1
CONFIG_SENSORS_NTC_THERMISTOR_MODULE 1
CONFIG_ADF4371_MODULE 1
CONFIG_SPI_OC_TINY_MODULE 1
CONFIG_AS3935_MODULE 1
CONFIG_MISDN_L1OIP_MODULE 1
CONFIG_DVB_PT1_MODULE 1
CONFIG_NET_VENDOR_SUN 1
CONFIG_DMIID 1
CONFIG_ARCH_HAS_MEM_ENCRYPT 1
CONFIG_PANIC_TIMEOUT 0
CONFIG_ASUS_WMI_MODULE 1
CONFIG_SENSORS_DS1621_MODULE 1
CONFIG_SND_SOC_IMG_PARALLEL_OUT_MODULE 1
CONFIG_PC104 1
CONFIG_MMC_TOSHIBA_PCI_MODULE 1
CONFIG_QUOTA_NETLINK_INTERFACE 1
CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH_MODULE 1
CONFIG_INPUT_JOYSTICK 1
CONFIG_QNX4FS_FS_MODULE 1
CONFIG_NET_ACT_SIMP_MODULE 1
CONFIG_SENSORS_RM3100_I2C_MODULE 1
CONFIG_USB_OXU210HP_HCD_MODULE 1
CONFIG_RT2X00_LIB_MODULE 1
CONFIG_USB_DWC2 1
CONFIG_HID_BATTERY_STRENGTH 1
CONFIG_PM_GENERIC_DOMAINS_SLEEP 1
CONFIG_YAM_MODULE 1
CONFIG_W1_SLAVE_DS28E17_MODULE 1
CONFIG_MACB_PCI_MODULE 1
CONFIG_DM_VERITY_MODULE 1
CONFIG_BT_MTKUART_MODULE 1
CONFIG_NETFILTER_XT_MATCH_ECN_MODULE 1
CONFIG_USB_GSPCA_STV0680_MODULE 1
CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT 1
CONFIG_SYSTEM_BLACKLIST_HASH_LIST ""
CONFIG_TYPEC_TCPM_MODULE 1
CONFIG_ATH9K_PCOEM 1
CONFIG_SND_FM801_TEA575X_BOOL 1
CONFIG_USB_STORAGE_SDDR55_MODULE 1
CONFIG_PPDEV_MODULE 1
CONFIG_KVM_AMD_SEV 1
CONFIG_SND_SOC_CS4271_SPI_MODULE 1
CONFIG_KPC2000 1
CONFIG_SENSORS_TPS53679_MODULE 1
CONFIG_CC_HAS_STACKPROTECTOR_NONE 1
CONFIG_IP_NF_TARGET_TTL_MODULE 1
CONFIG_AMILO_RFKILL_MODULE 1
CONFIG_MSCC_OCELOT_SWITCH_MODULE 1
CONFIG_ISDN_DRV_AVMB1_B1PCI_MODULE 1
CONFIG_LWTUNNEL_BPF 1
CONFIG_CFG80211_DEFAULT_PS 1
CONFIG_SND_SOC_WM8974_MODULE 1
CONFIG_GENERIC_IOMAP 1
CONFIG_BUILD_BIN2C 1
CONFIG_IEEE802154_FAKELB_MODULE 1
CONFIG_USBIP_HOST_MODULE 1
CONFIG_CHARGER_BQ24190_MODULE 1
CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE 1
CONFIG_IIO_ST_PRESS_MODULE 1
CONFIG_COMEDI_ADL_PCI7X3X_MODULE 1
CONFIG_DVB_PLUTO2_MODULE 1
CONFIG_NET_VENDOR_XILINX 1
CONFIG_COMEDI_NI_ROUTING_MODULE 1
CONFIG_RTL8723AE_MODULE 1
CONFIG_DECOMPRESS_LZ4 1
CONFIG_SND_SOC_ADAU7002_MODULE 1
CONFIG_THUNDER_NIC_RGX_MODULE 1
CONFIG_NETFILTER_NETLINK_OSF_MODULE 1
CONFIG_XEN_FBDEV_FRONTEND_MODULE 1
CONFIG_GPIO_DLN2_MODULE 1
CONFIG_SPARSEMEM_MANUAL 1
CONFIG_DVB_AV7110_MODULE 1
CONFIG_IP6_NF_MATCH_SRH_MODULE 1
CONFIG_SENSORS_AHC1EC0_HWMON_MODULE 1
CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK 1
CONFIG_DVB_OR51132_MODULE 1
CONFIG_RT2X00_LIB_FIRMWARE 1
CONFIG_DL2K_MODULE 1
CONFIG_TOUCHSCREEN_MMS114_MODULE 1
CONFIG_VIDEO_V4L2_I2C 1
CONFIG_SXGBE_ETH_MODULE 1
CONFIG_BPF_SYSCALL 1
CONFIG_SMP 1
CONFIG_NET_VENDOR_CADENCE 1
CONFIG_IR_SIR_MODULE 1
CONFIG_FB_KYRO_MODULE 1
CONFIG_DVB_ZL10353_MODULE 1
CONFIG_MFD_INTEL_LPSS_ACPI_MODULE 1
CONFIG_TTY 1
CONFIG_NETFILTER_XT_MATCH_TIME_MODULE 1
CONFIG_IP_VS_MODULE 1
CONFIG_HAVE_KERNEL_GZIP 1
CONFIG_VCNL4035_MODULE 1
CONFIG_TYPEC_TCPCI_MODULE 1
CONFIG_MT76x02_USB_MODULE 1
CONFIG_ZSMALLOC 1
CONFIG_I2C_MLXCPLD_MODULE 1
CONFIG_DM_UEVENT 1
CONFIG_CAN_ESD_USB2_MODULE 1
CONFIG_CAIF_VIRTIO_MODULE 1
CONFIG_USB_MV_UDC_MODULE 1
CONFIG_NET_VENDOR_I825XX 1
CONFIG_MMA7660_MODULE 1
CONFIG_USB_XUSBATM_MODULE 1
CONFIG_PNP 1
CONFIG_RTC_DRV_RP5C01_MODULE 1
CONFIG_EROFS_FS_POSIX_ACL 1
CONFIG_NETFILTER_XT_MATCH_MAC_MODULE 1
CONFIG_I2C_NFORCE2_S4985_MODULE 1
CONFIG_THUNDER_NIC_BGX_MODULE 1
CONFIG_SENSORS_NCT6775_MODULE 1
CONFIG_YELLOWFIN_MODULE 1
CONFIG_TOUCHSCREEN_TPS6507X_MODULE 1
CONFIG_DW_DMAC_CORE_MODULE 1
CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE 1
CONFIG_QED_ISCSI 1
CONFIG_NET_ACT_PEDIT_MODULE 1
CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE 1
CONFIG_VIDEO_BT819_MODULE 1
CONFIG_DVB_ZD1301_DEMOD_MODULE 1
CONFIG_DA9150_GPADC_MODULE 1
CONFIG_XFRM_OFFLOAD 1
CONFIG_TOUCHSCREEN_USB_JASTEC 1
CONFIG_GENERIC_ALLOCATOR 1
CONFIG_OPENVSWITCH_MODULE 1
CONFIG_RTC_DRV_DS1390_MODULE 1
CONFIG_L2TP_MODULE 1
CONFIG_REGULATOR_DA9052_MODULE 1
CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE 1
CONFIG_MMC_SDHCI_IO_ACCESSORS 1
CONFIG_TCP_CONG_WESTWOOD_MODULE 1
CONFIG_RTC_DRV_M41T93_MODULE 1
CONFIG_KALLSYMS_ALL 1
CONFIG_ATM_FORE200E_TX_RETRY 16
CONFIG_HID_AUREAL_MODULE 1
CONFIG_USB_GSPCA_SPCA561_MODULE 1
CONFIG_IPMI_SSIF_MODULE 1
CONFIG_DRM_GM12U320_MODULE 1
CONFIG_GREYBUS_SDIO_MODULE 1
CONFIG_DRM_GMA600 1
CONFIG_SQUASHFS_LZ4 1
CONFIG_DLN2_ADC_MODULE 1
CONFIG_SND_SOC_PCM3168A_I2C_MODULE 1
CONFIG_LIBCRC32C_MODULE 1
CONFIG_KEYBOARD_MATRIX_MODULE 1
CONFIG_RSI_USB_MODULE 1
CONFIG_HAVE_BOOTMEM_INFO_NODE 1
CONFIG_MFD_PCF50633_MODULE 1
CONFIG_GENERIC_BUG 1
CONFIG_CRYPTO_SHA256 1
CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
CONFIG_JOYSTICK_GUILLEMOT_MODULE 1
CONFIG_MLXSW_MINIMAL_MODULE 1
CONFIG_BRIDGE_VLAN_FILTERING 1
CONFIG_VIDEO_AU0828_MODULE 1
CONFIG_WL18XX_MODULE 1
CONFIG_POSIX_TIMERS 1
CONFIG_SND_SOC_SOF_HDA_MODULE 1
CONFIG_INET_TCP_DIAG_MODULE 1
CONFIG_HID_SONY_MODULE 1
CONFIG_VIDEO_PVRUSB2_DVB 1
CONFIG_USB_F_PRINTER_MODULE 1
CONFIG_MEMSTICK_REALTEK_PCI_MODULE 1
CONFIG_PCI_PASID 1
CONFIG_CRYPTO_BLOWFISH_X86_64_MODULE 1
CONFIG_HW_CONSOLE 1
CONFIG_CRYPTO_DEV_NITROX_CNN55XX_MODULE 1
CONFIG_MDIO_BITBANG_MODULE 1
CONFIG_NET_ACT_IPT_MODULE 1
CONFIG_DVB_AS102_MODULE 1
CONFIG_BPF_STREAM_PARSER 1
CONFIG_HAVE_KVM_IRQ_ROUTING 1
CONFIG_LEDS_MLXCPLD_MODULE 1
CONFIG_PARIDE_ON26_MODULE 1
CONFIG_SCSI_BNX2X_FCOE_MODULE 1
CONFIG_MTD_UBI_GLUEBI_MODULE 1
CONFIG_RAS 1
CONFIG_COMMON_CLK_CDCE706_MODULE 1
CONFIG_AD5761_MODULE 1
CONFIG_VIDEO_GO7007_LOADER_MODULE 1
CONFIG_RTC_DRV_DA9052_MODULE 1
CONFIG_USB_ETH_EEM 1
CONFIG_KEYBOARD_TWL4030_MODULE 1
CONFIG_HYPERV_NET_MODULE 1
CONFIG_REGMAP_SPMI_MODULE 1
CONFIG_DEVMEM 1
CONFIG_SMSC_PHY_MODULE 1
CONFIG_BATTERY_MAX1721X_MODULE 1
CONFIG_HP_ACCEL_MODULE 1
CONFIG_MOUSE_PS2_FOCALTECH 1
CONFIG_CAN_EMS_PCI_MODULE 1
CONFIG_SCSI_BNX2_ISCSI_MODULE 1
CONFIG_OMFS_FS_MODULE 1
CONFIG_DRM_DP_CEC 1
CONFIG_TCG_TIS_I2C_NUVOTON_MODULE 1
CONFIG_USB_GSPCA_ZC3XX_MODULE 1
CONFIG_SND_ES1968_MODULE 1
CONFIG_REGULATOR_DA9062_MODULE 1
CONFIG_SND_SPI 1
CONFIG_EUROTECH_WDT_MODULE 1
CONFIG_I2C_DLN2_MODULE 1
CONFIG_MLX5_CORE_MODULE 1
CONFIG_NFT_LOG_MODULE 1
CONFIG_BACKLIGHT_ADP8870_MODULE 1
CONFIG_TOUCHSCREEN_MTOUCH_MODULE 1
CONFIG_BRIDGE_EBT_IP_MODULE 1
CONFIG_PARIDE_EPAT_MODULE 1
CONFIG_HID_MONTEREY_MODULE 1
CONFIG_NET_DSA_MICROCHIP_KSZ9477_I2C_MODULE 1
CONFIG_CGROUP_RDMA 1
CONFIG_FB_UDL_MODULE 1
CONFIG_USB_SERIAL_CYPRESS_M8_MODULE 1
CONFIG_SND_SOC_ES8328_SPI_MODULE 1
CONFIG_FB_NEOMAGIC_MODULE 1
CONFIG_I2C_NVIDIA_GPU_MODULE 1
CONFIG_HID_EZKEY_MODULE 1
CONFIG_SND_SOC_INTEL_SKYLAKE_FAMILY_MODULE 1
CONFIG_PADATA 1
CONFIG_USB_PULSE8_CEC_MODULE 1
CONFIG_THERMAL_GOV_USER_SPACE 1
CONFIG_DVB_S5H1409_MODULE 1
CONFIG_IPW2200_QOS 1
CONFIG_MDIO_BCM_UNIMAC_MODULE 1
CONFIG_SCSI_LOWLEVEL_PCMCIA 1
CONFIG_ATH9K_COMMON_DEBUG 1
CONFIG_EFI_CAPSULE_LOADER_MODULE 1
CONFIG_JFFS2_FS_POSIX_ACL 1
CONFIG_INPUT_DA9052_ONKEY_MODULE 1
CONFIG_DM_THIN_PROVISIONING_MODULE 1
CONFIG_IPMI_DMI_DECODE 1
CONFIG_HAVE_UID16 1
CONFIG_SERIAL_NONSTANDARD 1
CONFIG_RT61PCI_MODULE 1
CONFIG_COMPAT_OLD_SIGACTION 1
CONFIG_PATA_JMICRON_MODULE 1
CONFIG_W1_SLAVE_DS2438_MODULE 1
CONFIG_TOUCHSCREEN_TSC_SERIO_MODULE 1
CONFIG_RTC_NVMEM 1
CONFIG_X86_FEATURE_NAMES 1
CONFIG_JOYSTICK_XPAD_LEDS 1
CONFIG_SENSORS_TC74_MODULE 1
CONFIG_MOST_SOUND_MODULE 1
CONFIG_IPW2100_MODULE 1
CONFIG_SCSI_PPA_MODULE 1
CONFIG_BACKLIGHT_PWM_MODULE 1
CONFIG_BT_MRVL_MODULE 1
CONFIG_QUOTACTL 1
CONFIG_RTC_DRV_RX8581_MODULE 1
CONFIG_V4L2_MEM2MEM_DEV_MODULE 1
CONFIG_FB_SAVAGE_I2C 1
CONFIG_PARAVIRT 1
CONFIG_TWL4030_MADC_MODULE 1
CONFIG_WQ_POWER_EFFICIENT_DEFAULT 1
CONFIG_HP03_MODULE 1
CONFIG_SFC_FALCON_MTD 1
CONFIG_INTEL_MENLOW_MODULE 1
CONFIG_ISDN_CAPI_CAPI20_MODULE 1
CONFIG_CRYPTO_CRYPTD_MODULE 1
CONFIG_LEGACY_VSYSCALL_XONLY 1
CONFIG_NF_SOCKET_IPV4_MODULE 1
CONFIG_JOYSTICK_FSIA6B_MODULE 1
CONFIG_HAVE_IOREMAP_PROT 1
CONFIG_CRYPTO_CHACHA20_X86_64_MODULE 1
CONFIG_RPMSG_QCOM_GLINK_NATIVE_MODULE 1
CONFIG_PHY_CPCAP_USB_MODULE 1
CONFIG_CC_HAS_KASAN_GENERIC 1
CONFIG_CM32181_MODULE 1
CONFIG_DVB_STV6111_MODULE 1
CONFIG_USBIP_VHCI_HCD_MODULE 1
CONFIG_PATA_RZ1000_MODULE 1
CONFIG_BACKLIGHT_ADP8860_MODULE 1
CONFIG_MAX8925_POWER_MODULE 1
CONFIG_CAPI_TRACE 1
CONFIG_DEBUG_KERNEL 1
CONFIG_MTD_RAM_MODULE 1
CONFIG_RTL8192DE_MODULE 1
CONFIG_ACPI_TOSHIBA_MODULE 1
CONFIG_GAMEPORT_NS558_MODULE 1
CONFIG_INV_MPU6050_IIO_MODULE 1
CONFIG_USB_SERIAL_F8153X_MODULE 1
CONFIG_REGULATOR_MT6311_MODULE 1
CONFIG_SENSORS_LTC2978_REGULATOR 1
CONFIG_HID_GOOGLE_HAMMER_MODULE 1
CONFIG_DM_ZONED_MODULE 1
CONFIG_SENSORS_TC654_MODULE 1
CONFIG_VIDEO_CX2341X_MODULE 1
CONFIG_CROS_EC_MODULE 1
CONFIG_I2C_VIPERBOARD_MODULE 1
CONFIG_CHARLCD_MODULE 1
CONFIG_LOCALVERSION ""
CONFIG_REISERFS_FS_SECURITY 1
CONFIG_DVB_STV6110x_MODULE 1
CONFIG_PATA_IT821X_MODULE 1
CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK 1
CONFIG_ACERHDF_MODULE 1
CONFIG_SND_SOC_INTEL_BROADWELL_MACH_MODULE 1
CONFIG_RADIO_ADAPTERS 1
CONFIG_REGULATOR_QCOM_SPMI_MODULE 1
CONFIG_MEMTEST 1
CONFIG_KEYBOARD_XTKBD_MODULE 1
CONFIG_HAVE_PCSPKR_PLATFORM 1
CONFIG_NFS_FSCACHE 1
CONFIG_MAC80211_MESH 1
CONFIG_MMC_WBSD_MODULE 1
CONFIG_USB_GSPCA_TOPRO_MODULE 1
CONFIG_USB_GSPCA_MARS_MODULE 1
CONFIG_CAN_RAW_MODULE 1
CONFIG_AD5686_SPI_MODULE 1
CONFIG_DVB_SI2165_MODULE 1
CONFIG_CRYPTO 1
CONFIG_I2C_MUX_PCA954x_MODULE 1
CONFIG_FB_MATROX_MILLENIUM 1
CONFIG_SENSORS_EMC6W201_MODULE 1
CONFIG_FUNCTION_TRACER 1
CONFIG_CRYPTO_NHPOLY1305_AVX2_MODULE 1
CONFIG_USB_TRANCEVIBRATOR_MODULE 1
CONFIG_SCHED_DEBUG 1
CONFIG_SECURITY_SMACK_APPEND_SIGNALS 1
CONFIG_USB_STKWEBCAM_MODULE 1
CONFIG_NET_VENDOR_BROCADE 1
CONFIG_BTRFS_FS_MODULE 1
CONFIG_BLK_WBT_MQ 1
CONFIG_DEFAULT_MMAP_MIN_ADDR 65536
CONFIG_SYSTEM_TRUSTED_KEYS "debian/canonical-certs.pem"
CONFIG_SND_USB_6FIRE_MODULE 1
CONFIG_PERF_EVENTS_INTEL_UNCORE 1
CONFIG_SND_HDA_HWDEP 1
CONFIG_INPUT_AD714X_I2C_MODULE 1
CONFIG_TOUCHSCREEN_BU21029_MODULE 1
CONFIG_I2C_SIS96X_MODULE 1
CONFIG_INET_RAW_DIAG_MODULE 1
CONFIG_MMC_TIFM_SD_MODULE 1
CONFIG_GFS2_FS_LOCKING_DLM 1
CONFIG_MEDIA_TUNER_TDA18218_MODULE 1
CONFIG_IP_NF_IPTABLES_MODULE 1
CONFIG_ZPA2326_SPI_MODULE 1
CONFIG_MISC_RTSX_USB_MODULE 1
CONFIG_SPI_MTK_QUADSPI_MODULE 1
CONFIG_VSOCKETS_MODULE 1
CONFIG_GPIO_F7188X_MODULE 1
CONFIG_BT_BNEP_PROTO_FILTER 1
CONFIG_DYNAMIC_FTRACE_WITH_REGS 1
CONFIG_NTB_SWITCHTEC_MODULE 1
CONFIG_PCIE_PTM 1
CONFIG_IWLWIFI_LEDS 1
CONFIG_USB_CHIPIDEA_HOST 1
CONFIG_MFD_RETU_MODULE 1
CONFIG_NET_VENDOR_QLOGIC 1
CONFIG_SPI_GPIO_MODULE 1
CONFIG_USB_GSPCA_CPIA1_MODULE 1
CONFIG_PARIDE_PF_MODULE 1
CONFIG_SND_SOC_CS42L42_MODULE 1
CONFIG_HSI_CHAR_MODULE 1
CONFIG_RUNTIME_TESTING_MENU 1
CONFIG_MPLS_IPTUNNEL_MODULE 1
CONFIG_VIDEOBUF2_DMA_CONTIG_MODULE 1
CONFIG_USB_XHCI_HCD 1
CONFIG_VIRTIO 1
CONFIG_REGULATOR_TPS65910_MODULE 1
CONFIG_DEFAULT_CUBIC 1
CONFIG_CAN_KVASER_PCI_MODULE 1
CONFIG_YENTA_TI 1
CONFIG_COMEDI_NI_660X_MODULE 1
CONFIG_SND_SOC_CS35L32_MODULE 1
CONFIG_MFD_SM501_MODULE 1
CONFIG_AD7606_MODULE 1
CONFIG_HID_SAMSUNG_MODULE 1
CONFIG_SPI_XCOMM_MODULE 1
CONFIG_SFC_MCDI_LOGGING 1
CONFIG_PARMAN_MODULE 1
CONFIG_IP_SET_LIST_SET_MODULE 1
CONFIG_TCM_IBLOCK_MODULE 1
CONFIG_IP_PIMSM_V2 1
CONFIG_BACKLIGHT_ARCXCNN_MODULE 1
CONFIG_CFS_BANDWIDTH 1
CONFIG_MCP3911_MODULE 1
CONFIG_WM831X_WATCHDOG_MODULE 1
CONFIG_RTW88_MODULE 1
CONFIG_NET_DSA_TAG_TRAILER_MODULE 1
CONFIG_SND_HDA_CODEC_CA0132_DSP 1
CONFIG_XFRM_STATISTICS 1
CONFIG_GPIO_GENERIC_PLATFORM_MODULE 1
CONFIG_X86_MCE_THRESHOLD 1
CONFIG_MTD_SCB2_FLASH_MODULE 1
CONFIG_VIDEO_TW2804_MODULE 1
CONFIG_VIA_RHINE_MMIO 1
CONFIG_USB_ISIGHTFW_MODULE 1
CONFIG_JME_MODULE 1
CONFIG_USB_LINK_LAYER_TEST_MODULE 1
CONFIG_SND_HDA_CODEC_CMEDIA_MODULE 1
CONFIG_NET_ACT_SAMPLE_MODULE 1
CONFIG_NFC_TRF7970A_MODULE 1
CONFIG_DMA_VIRTUAL_CHANNELS_MODULE 1
CONFIG_SCSI_WD719X_MODULE 1
CONFIG_DVB_PLATFORM_DRIVERS 1
CONFIG_YENTA_O2 1
CONFIG_GENERIC_MSI_IRQ_DOMAIN 1
CONFIG_SND_SEQ_HRTIMER_DEFAULT 1
CONFIG_USB_ARCH_HAS_HCD 1
CONFIG_DVB_DIB3000MC_MODULE 1
CONFIG_STRICT_DEVMEM 1
CONFIG_CACHEFILES_MODULE 1
CONFIG_DVB_MXL5XX_MODULE 1
CONFIG_PATA_OLDPIIX_MODULE 1
CONFIG_I2C_KEMPLD_MODULE 1
CONFIG_NET_REDIRECT 1
CONFIG_GENERIC_IRQ_SHOW 1
CONFIG_TINYDRM_REPAPER_MODULE 1
CONFIG_SND_HDA_CODEC_SI3054_MODULE 1
CONFIG_BACKLIGHT_PCF50633_MODULE 1
CONFIG_LCD_ILI9320_MODULE 1
CONFIG_MFD_MAX8925 1
CONFIG_NVMEM_SYSFS 1
CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE 1
CONFIG_NFC_MICROREAD_I2C_MODULE 1
CONFIG_ARCH_HAS_ELF_RANDOMIZE 1
CONFIG_9P_FS_MODULE 1
CONFIG_HAVE_FUNCTION_ARG_ACCESS_API 1
CONFIG_MD_AUTODETECT 1
CONFIG_ASUS_WIRELESS_MODULE 1
CONFIG_AD7766_MODULE 1
CONFIG_PANIC_ON_OOPS_VALUE 0
CONFIG_JOYSTICK_A3D_MODULE 1
CONFIG_NET_VENDOR_SAMSUNG 1
CONFIG_SND_SOC_CS4270_MODULE 1
CONFIG_SENSORS_ATK0110_MODULE 1
CONFIG_IIO_MS_SENSORS_I2C_MODULE 1
CONFIG_FB_VIA_X_COMPATIBILITY 1
CONFIG_SFC_SRIOV 1
CONFIG_SERIAL_SCCNXP 1
CONFIG_TCP_CONG_HSTCP_MODULE 1
CONFIG_BATTERY_BQ27XXX_I2C_MODULE 1
CONFIG_SCSI_MOD 1
CONFIG_SCSI_SMARTPQI_MODULE 1
CONFIG_KERNEL_LZ4 1
CONFIG_TOUCHSCREEN_ATMEL_MXT_T37 1
CONFIG_SND_SOC_SSM2602_MODULE 1
CONFIG_SCSI_DPT_I2O_MODULE 1
CONFIG_INPUT_88PM860X_ONKEY_MODULE 1
CONFIG_I2C_CROS_EC_TUNNEL_MODULE 1
CONFIG_NET_VENDOR_MICREL 1
CONFIG_CRYPTO_ESSIV_MODULE 1
CONFIG_GIGASET_M105_MODULE 1
CONFIG_FB_PM2_MODULE 1
CONFIG_MFD_CS47L15 1
CONFIG_MPLS_ROUTING_MODULE 1
CONFIG_F2FS_FS_POSIX_ACL 1
CONFIG_FWTTY_MAX_TOTAL_PORTS 64
CONFIG_VIDEOBUF2_DMA_SG_MODULE 1
CONFIG_ARCH_HAS_ADD_PAGES 1
CONFIG_JOYSTICK_ZHENHUA_MODULE 1
CONFIG_NET_VENDOR_AURORA 1
CONFIG_CHELSIO_IPSEC_INLINE 1
CONFIG_USB_SERIAL_SPCP8X5_MODULE 1
CONFIG_BT_HCIRSI_MODULE 1
CONFIG_KEYS_REQUEST_CACHE 1
CONFIG_WILC1000_SDIO_MODULE 1
CONFIG_MAX5481_MODULE 1
CONFIG_HID_ITE_MODULE 1
CONFIG_SND_SOC_AK5386_MODULE 1
CONFIG_TOUCHSCREEN_CYTTSP4_I2C_MODULE 1
CONFIG_HID_SENSOR_PROX_MODULE 1
CONFIG_RC_DECODERS 1
CONFIG_B43_LEDS 1
CONFIG_UBIFS_FS_XATTR 1
CONFIG_P54_USB_MODULE 1
CONFIG_CRYPTO_ECRDSA_MODULE 1
CONFIG_TOUCHSCREEN_MK712_MODULE 1
CONFIG_FB_ATY_MODULE 1
CONFIG_TOUCHSCREEN_CYTTSP4_CORE_MODULE 1
CONFIG_USB_GSPCA_KINECT_MODULE 1
CONFIG_NET_9P_XEN_MODULE 1
CONFIG_SPEAKUP_SYNTH_DECEXT_MODULE 1
CONFIG_USB_SERIAL_WISHBONE_MODULE 1
CONFIG_COMEDI_DAQBOARD2000_MODULE 1
CONFIG_TPS68470_PMIC_OPREGION 1
CONFIG_LEDS_CLASS_FLASH_MODULE 1
CONFIG_USB_NET_HUAWEI_CDC_NCM_MODULE 1
CONFIG_OPROFILE_MODULE 1
CONFIG_SCSI_ESAS2R_MODULE 1
CONFIG_VIDEO_MT9V111_MODULE 1
CONFIG_SND_SOC_INTEL_CML_LP_DA7219_MAX98357A_MACH_MODULE 1
CONFIG_VIDEO_CX25821_ALSA_MODULE 1
CONFIG_GPIO_PISOSR_MODULE 1
CONFIG_CRYPTO_CRC32C 1
CONFIG_SERIAL_CORE 1
CONFIG_IIO_ST_SENSORS_I2C_MODULE 1
CONFIG_FUSE_FS 1
CONFIG_HID_SENSOR_HUMIDITY_MODULE 1
CONFIG_BUILDTIME_EXTABLE_SORT 1
CONFIG_USB_CONFIGFS_SERIAL 1
CONFIG_UID16 1
CONFIG_DW_DMAC_MODULE 1
CONFIG_ETHOC_MODULE 1
CONFIG_SND_SOC_PCM512x_MODULE 1
CONFIG_ACPI_HED 1
CONFIG_HID_MICROSOFT_MODULE 1
CONFIG_EXFAT_DEFAULT_IOCHARSET "utf8"
CONFIG_RTLLIB_MODULE 1
CONFIG_LIVEPATCH 1
CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH_MODULE 1
CONFIG_PCC 1
CONFIG_RTC_DRV_S35390A_MODULE 1
CONFIG_HAVE_KRETPROBES 1
CONFIG_SYSTEM_EXTRA_CERTIFICATE_SIZE 4096
CONFIG_HYPERV_BALLOON_MODULE 1
CONFIG_SCSI_IMM_MODULE 1
CONFIG_SENSORS_LM25066_MODULE 1
CONFIG_ASSOCIATIVE_ARRAY 1
CONFIG_USB_CONFIGFS_F_UVC 1
CONFIG_HSA_AMD 1
CONFIG_AGP_VIA 1
CONFIG_NF_DEFRAG_IPV6_MODULE 1
CONFIG_USB_GSPCA_CONEX_MODULE 1
CONFIG_MICREL_PHY_MODULE 1
CONFIG_DRM_LOAD_EDID_FIRMWARE 1
CONFIG_VIDEO_DEV_MODULE 1
CONFIG_KS0108_MODULE 1
CONFIG_SND_SOC_FSL_AUDMIX_MODULE 1
CONFIG_NFS_V4_MODULE 1
CONFIG_IONIC_MODULE 1
CONFIG_MFD_WM831X 1
CONFIG_PMIC_ADP5520 1
CONFIG_RPMSG_QCOM_GLINK_RPM_MODULE 1
CONFIG_RTC_DRV_TPS80031_MODULE 1
CONFIG_PPP_FILTER 1
CONFIG_DYNAMIC_FTRACE 1
CONFIG_MAILBOX 1
CONFIG_VIDEO_MT9M111_MODULE 1
CONFIG_INPUT_LEDS_MODULE 1
CONFIG_RCU_NEED_SEGCBLIST 1
CONFIG_MTD_SLRAM_MODULE 1
CONFIG_INLINE_READ_UNLOCK 1
CONFIG_PINCTRL_CS47L85 1
CONFIG_DEBUG_WX 1
CONFIG_MTD_ROM_MODULE 1
CONFIG_PATA_PDC2027X_MODULE 1
CONFIG_SENSORS_LTC2978_MODULE 1
CONFIG_HAS_DMA 1
CONFIG_INTEL_IPS_MODULE 1
CONFIG_SND_SOC_CS43130_MODULE 1
CONFIG_NF_CT_PROTO_SCTP 1
CONFIG_EDAC 1
CONFIG_USB_SERIAL_VISOR_MODULE 1
CONFIG_MTD_PMC551_MODULE 1
CONFIG_BROADCOM_PHY_MODULE 1
CONFIG_COMEDI_PCMUIO_MODULE 1
CONFIG_DVB_AS102_FE_MODULE 1
CONFIG_SND_SOC_CS42XX8_I2C_MODULE 1
CONFIG_SCSI 1
CONFIG_LEDS_TRIGGER_PANIC 1
CONFIG_DVB_CXD2841ER_MODULE 1
CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY 0
CONFIG_FB_CFB_FILLRECT 1
CONFIG_RT2800_LIB_MMIO_MODULE 1
CONFIG_VIRT_WIFI_MODULE 1
CONFIG_HYPERV_MODULE 1
CONFIG_AT76C50X_USB_MODULE 1
CONFIG_QCOM_SPMI_IADC_MODULE 1
CONFIG_REGULATOR_WM8994_MODULE 1
CONFIG_FUNCTION_GRAPH_TRACER 1
CONFIG_NF_NAT_PPTP_MODULE 1
CONFIG_HID_VIEWSONIC_MODULE 1
CONFIG_HID_CHICONY_MODULE 1
CONFIG_SENSORS_AS370_MODULE 1
CONFIG_NLS_MAC_ROMAN_MODULE 1
CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST 1
CONFIG_HID_MODULE 1
CONFIG_HW_RANDOM_AMD_MODULE 1
CONFIG_SND_SST_IPC_MODULE 1
CONFIG_LEDS_TI_LMU_COMMON_MODULE 1
CONFIG_AUFS_XATTR 1
CONFIG_VIDEO_VIVID_MODULE 1
CONFIG_RMI4_SMB_MODULE 1
CONFIG_LIBERTAS_THINFIRM_USB_MODULE 1
CONFIG_AMD_XGBE_MODULE 1
CONFIG_CGROUP_NET_PRIO 1
CONFIG_RANDOMIZE_BASE 1
CONFIG_USB_CONFIGFS_F_UAC1 1
CONFIG_USB_DWC3_DUAL_ROLE 1
CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND 1
CONFIG_RANDOM_TRUST_BOOTLOADER 1
CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH_MODULE 1
CONFIG_VIDEO_VICODEC_MODULE 1
CONFIG_ANDROID_BINDERFS_MODULE 1
CONFIG_TLS_DEVICE 1
CONFIG_PWM_TWL_LED_MODULE 1
CONFIG_SLIP_SMART 1
CONFIG_IXGB_MODULE 1
CONFIG_NLS_ISO8859_9_MODULE 1
CONFIG_TOUCHSCREEN_ZFORCE_MODULE 1
CONFIG_NET_ACT_BPF_MODULE 1
CONFIG_HYPERV_IOMMU 1
CONFIG_FIRMWARE_EDID 1
CONFIG_SND_SERIAL_U16550_MODULE 1
CONFIG_AMD_IOMMU_V2_MODULE 1
CONFIG_USB_ARMLINUX 1
CONFIG_I2C_SMBUS_MODULE 1
CONFIG_IP_VS_PE_SIP_MODULE 1
CONFIG_SND_SOC_SOF_TIGERLAKE_SUPPORT 1
CONFIG_MEMSTICK_REALTEK_USB_MODULE 1
CONFIG_PLATFORM_SI4713_MODULE 1
CONFIG_JOYSTICK_GF2K_MODULE 1
CONFIG_RTLWIFI_MODULE 1
CONFIG_MT76_CORE_MODULE 1
CONFIG_LTPC_MODULE 1
CONFIG_TCG_TIS_ST33ZP24_MODULE 1
CONFIG_SND_SOC_INTEL_BXT_RT298_MACH_MODULE 1
CONFIG_LP8788_ADC_MODULE 1
CONFIG_SERIAL_8250_MEN_MCB_MODULE 1
CONFIG_EDAC_GHES 1
CONFIG_CLKDEV_LOOKUP 1
CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE 1
CONFIG_MXM_WMI_MODULE 1
CONFIG_FONT_8x16 1
CONFIG_NET_VENDOR_MELLANOX 1
CONFIG_MAC80211_HWSIM_MODULE 1
CONFIG_DVB_LGDT330X_MODULE 1
CONFIG_INTEL_MIC_X100_DMA_MODULE 1
CONFIG_VIDEO_M5MOLS_MODULE 1
CONFIG_SERIAL_8250_MANY_PORTS 1
CONFIG_VT_CONSOLE_SLEEP 1
CONFIG_LIBFC_MODULE 1
CONFIG_X86_MCE_INTEL 1
CONFIG_X86_64 1
CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG 1
CONFIG_RTC_DRV_CMOS 1
CONFIG_CRYPTO_USER_API_AEAD_MODULE 1
CONFIG_PCI_LOCKLESS_CONFIG 1
CONFIG_PTP_1588_CLOCK 1
CONFIG_NF_DUP_NETDEV_MODULE 1
CONFIG_SND_SOC_MAX98927_MODULE 1
CONFIG_IEEE802154_DRIVERS_MODULE 1
CONFIG_ADFS_FS_MODULE 1
CONFIG_RTC_DRV_RV3029_HWMON 1
CONFIG_TCP_CONG_BBR_MODULE 1
CONFIG_VL53L0X_I2C_MODULE 1
CONFIG_TOUCHSCREEN_USB_IRTOUCH 1
CONFIG_PATA_AMD_MODULE 1
CONFIG_USB_PWC_MODULE 1
CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
CONFIG_SENSORS_AD7414_MODULE 1
CONFIG_MEDIA_TUNER_TDA8290_MODULE 1
CONFIG_COMEDI_ADV_PCI_DIO_MODULE 1
CONFIG_TOUCHSCREEN_USB_PANJIT 1
CONFIG_RT2800PCI_RT53XX 1
CONFIG_BONDING_MODULE 1
CONFIG_PROC_THERMAL_MMIO_RAPL 1
CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER "/sbin/init"
CONFIG_HTS221_I2C_MODULE 1
CONFIG_MLXSW_SPECTRUM_DCB 1
CONFIG_MEDIA_TUNER_TDA18212_MODULE 1
CONFIG_MCP3422_MODULE 1
CONFIG_RTC_DRV_EM3027_MODULE 1
CONFIG_ARCH_HAS_CACHE_LINE_SIZE 1
CONFIG_6LOWPAN_NHC_DEST_MODULE 1
CONFIG_VEML6070_MODULE 1
CONFIG_VIDEO_SAA7134_RC 1
CONFIG_JBD2 1
CONFIG_COMEDI_AMPLC_PC236_PCI_MODULE 1
CONFIG_SENSORS_ASB100_MODULE 1
CONFIG_SND_INTEL8X0_MODULE 1
CONFIG_COMEDI_NI_ATMIO_MODULE 1
CONFIG_PATA_NS87415_MODULE 1
CONFIG_SND_SOC_ADAU1761_MODULE 1
CONFIG_USBIP_CORE_MODULE 1
CONFIG_CAN_M_CAN_TCAN4X5X_MODULE 1
CONFIG_COMEDI_DAC02_MODULE 1
CONFIG_ATH10K_TRACING 1
CONFIG_ATM_BR2684_MODULE 1
CONFIG_SPARSEMEM_VMEMMAP 1
CONFIG_CRYPTO_CAMELLIA_X86_64_MODULE 1
CONFIG_IB700_WDT_MODULE 1
CONFIG_MMC_USHC_MODULE 1
CONFIG_COMEDI_CB_PCIDAS64_MODULE 1
CONFIG_SPI_TLE62X0_MODULE 1
CONFIG_INET6_IPCOMP_MODULE 1
CONFIG_SONY_LAPTOP_MODULE 1
CONFIG_QLCNIC_MODULE 1
CONFIG_MEMCG_KMEM 1
CONFIG_FB_SIS_315 1
CONFIG_TPS6507X_MODULE 1
CONFIG_NET_VENDOR_MARVELL 1
CONFIG_PHYLIB 1
CONFIG_SND_SOC_XILINX_SPDIF_MODULE 1
CONFIG_IGB_DCA 1
CONFIG_NFP_APP_FLOWER 1
CONFIG_SENSORS_IBM_CFFPS_MODULE 1
CONFIG_CRYPTO_SHA1_SSSE3_MODULE 1
CONFIG_REGULATOR_GPIO_MODULE 1
CONFIG_IPV6_TUNNEL_MODULE 1
CONFIG_SENSORS_LM77_MODULE 1
CONFIG_NET_VENDOR_NVIDIA 1
CONFIG_ARCH_MEMORY_PROBE 1
CONFIG_X86_AMD_FREQ_SENSITIVITY_MODULE 1
CONFIG_DVB_TDA665x_MODULE 1
CONFIG_VIDEO_SAA7164_MODULE 1
CONFIG_DRM_AMD_DC_DSC_SUPPORT 1
CONFIG_NFC_MRVL_USB_MODULE 1
CONFIG_NLS_CODEPAGE_874_MODULE 1
CONFIG_FB_CMDLINE 1
CONFIG_SND_SOC_MT6351_MODULE 1
CONFIG_OPTIMIZE_INLINING 1
CONFIG_ULTRIX_PARTITION 1
CONFIG_IRQ_DOMAIN 1
CONFIG_NET_DSA_MODULE 1
CONFIG_VIRTIO_BALLOON 1
CONFIG_HOTPLUG_PCI_CPCI_GENERIC_MODULE 1
CONFIG_IMA 1
CONFIG_LSM_MMAP_MIN_ADDR 0
CONFIG_SCSI_ARCMSR_MODULE 1
CONFIG_SND_SOC_BD28623_MODULE 1
CONFIG_PINCTRL_AMD 1
CONFIG_INTEGRITY_AUDIT 1
CONFIG_COMEDI_AMPLC_DIO200_MODULE 1
CONFIG_PVPANIC_MODULE 1
CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0x0
CONFIG_CAN_PEAK_PCI_MODULE 1
CONFIG_PPS_CLIENT_LDISC_MODULE 1
CONFIG_BLK_CMDLINE_PARSER 1
CONFIG_ARCH_HAS_DEBUG_VIRTUAL 1
CONFIG_KEYBOARD_QT1050_MODULE 1
CONFIG_MTD_ONENAND_2X_PROGRAM 1
CONFIG_MEDIA_TUNER_MT20XX_MODULE 1
CONFIG_NET_TULIP 1
CONFIG_IIO_HRTIMER_TRIGGER_MODULE 1
CONFIG_CRYPTO_DEV_SP_CCP 1
CONFIG_JFFS2_RTIME 1
CONFIG_HAVE_ASM_MODVERSIONS 1
CONFIG_ZX_TDM_MODULE 1
CONFIG_BNXT_HWMON 1
CONFIG_IPC_NS 1
CONFIG_CRYPTO_GLUE_HELPER_X86_MODULE 1
CONFIG_DEVFREQ_GOV_PASSIVE 1
CONFIG_DVB_HORUS3A_MODULE 1
CONFIG_RMI4_F34 1
CONFIG_MISC_FILESYSTEMS 1
CONFIG_ARCH_MMAP_RND_BITS_MIN 28
CONFIG_FTRACE 1
CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE 1
CONFIG_ATP_MODULE 1
CONFIG_X86_THERMAL_VECTOR 1
CONFIG_IP_NF_SECURITY_MODULE 1
CONFIG_IP_NF_RAW_MODULE 1
CONFIG_IP_NF_ARPFILTER_MODULE 1
CONFIG_BACKLIGHT_LP8788_MODULE 1
CONFIG_TOUCHSCREEN_USB_ETT_TC45USB 1
CONFIG_COMPAT_32 1
CONFIG_W1_CON 1
CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE 1
CONFIG_FB_ASILIANT 1
CONFIG_PPPOL2TP_MODULE 1
CONFIG_MLX5_FPGA_IPSEC 1
CONFIG_SYNCLINK_MODULE 1
CONFIG_KEYBOARD_ADP5588_MODULE 1
CONFIG_CLOCKSOURCE_WATCHDOG 1
CONFIG_R8712U_MODULE 1
CONFIG_HID_TOPSEED_MODULE 1
CONFIG_REGULATOR_RC5T583_MODULE 1
CONFIG_B43_PHY_HT 1
CONFIG_PINCTRL_MADERA_MODULE 1
CONFIG_INPUT_RAVE_SP_PWRBUTTON_MODULE 1
CONFIG_FB_VT8623_MODULE 1
CONFIG_AD7606_IFACE_SPI_MODULE 1
CONFIG_SND_SOC_INTEL_KBL_RT5663_RT5514_MAX98927_MACH_MODULE 1
CONFIG_LEDS_DA9052_MODULE 1
CONFIG_LEDS_BRIGHTNESS_HW_CHANGED 1
CONFIG_DECOMPRESS_BZIP2 1
CONFIG_RT2800PCI_RT33XX 1
CONFIG_CORDIC_MODULE 1
CONFIG_ATH9K_RFKILL 1
CONFIG_COMEDI_CB_PCIDAS_MODULE 1
CONFIG_FB_TRIDENT_MODULE 1
CONFIG_REGULATOR_AXP20X_MODULE 1
CONFIG_SENSORS_ADM1029_MODULE 1
CONFIG_IIO_ST_SENSORS_CORE_MODULE 1
CONFIG_KSM 1
CONFIG_ARCH_SUPPORTS_UPROBES 1
CONFIG_EXPORTFS_BLOCK_OPS 1
CONFIG_DRM_DP_AUX_CHARDEV 1
CONFIG_NET_VENDOR_STMICRO 1
CONFIG_EDAC_I3000_MODULE 1
CONFIG_PARPORT_PC_FIFO 1
CONFIG_SHUFFLE_PAGE_ALLOCATOR 1
CONFIG_DECNET_MODULE 1
CONFIG_TOPSTAR_LAPTOP_MODULE 1
CONFIG_AGP_SIS_MODULE 1
CONFIG_NF_NAT_H323_MODULE 1
CONFIG_XZ_DEC_SPARC 1
CONFIG_IMA_LSM_RULES 1
CONFIG_JOYSTICK_TURBOGRAFX_MODULE 1
CONFIG_ARCH_SPARSEMEM_DEFAULT 1
CONFIG_SND_SOC_SOF_XTENSA_MODULE 1
CONFIG_MLXSW_PCI_MODULE 1
CONFIG_COMEDI_DMM32AT_MODULE 1
CONFIG_MOST_MODULE 1
CONFIG_USB_NET_QMI_WWAN_MODULE 1
CONFIG_NET_TEAM_MODE_ROUNDROBIN_MODULE 1
CONFIG_BOARD_TPCI200_MODULE 1
CONFIG_REGULATOR_RT5033_MODULE 1
CONFIG_INPUT_CMA3000_MODULE 1
CONFIG_CEC_NOTIFIER 1
CONFIG_EDAC_IE31200_MODULE 1
CONFIG_IR_ENE_MODULE 1
CONFIG_ALIM1535_WDT_MODULE 1
CONFIG_GIGASET_BASE_MODULE 1
CONFIG_INLINE_READ_UNLOCK_IRQ 1
CONFIG_HID_HYPERV_MOUSE_MODULE 1
CONFIG_GACT_PROB 1
CONFIG_SERIAL_MCTRL_GPIO 1
CONFIG_MISDN_ISAR_MODULE 1
CONFIG_REALTEK_PHY_MODULE 1
CONFIG_PROC_VMCORE 1
CONFIG_HID_A4TECH_MODULE 1
CONFIG_MEDIA_TUNER_MC44S803_MODULE 1
CONFIG_RTC_MC146818_LIB 1
CONFIG_KMX61_MODULE 1
CONFIG_NFC_PN544_MEI_MODULE 1
CONFIG_BT_HCIUART_QCA 1
CONFIG_NLS_CODEPAGE_860_MODULE 1
CONFIG_INTEL_MEI_WDT_MODULE 1
CONFIG_GPIO_TPIC2810_MODULE 1
CONFIG_NET_DSA_TAG_GSWIP_MODULE 1
CONFIG_IIO_ST_LSM6DSX_I3C_MODULE 1
CONFIG_AD799X_MODULE 1
CONFIG_SND_MONA_MODULE 1
CONFIG_NETFILTER_XT_MATCH_ESP_MODULE 1
CONFIG_NIU_MODULE 1
CONFIG_AD8366_MODULE 1
CONFIG_MOUSE_PS2_VMMOUSE 1
CONFIG_IP_NF_TARGET_NETMAP_MODULE 1
CONFIG_DST_CACHE 1
CONFIG_USB_GSPCA_SPCA505_MODULE 1
CONFIG_NF_REJECT_IPV6_MODULE 1
CONFIG_RCU_CPU_STALL_TIMEOUT 60
CONFIG_FPGA_MGR_MACHXO2_SPI_MODULE 1
CONFIG_BACKLIGHT_ADP5520_MODULE 1
CONFIG_USB_GSPCA_SQ905C_MODULE 1
CONFIG_842_COMPRESS_MODULE 1
CONFIG_SATA_VITESSE_MODULE 1
CONFIG_USB_ZR364XX_MODULE 1
CONFIG_NET_DSA_MV88E6XXX_MODULE 1
CONFIG_CHECKPOINT_RESTORE 1
CONFIG_PRINTER_MODULE 1
CONFIG_RTC_DRV_ISL1208_MODULE 1
CONFIG_MFD_MENF21BMC_MODULE 1
CONFIG_SND_SOC_CS4265_MODULE 1
CONFIG_SND_VERBOSE_PROCFS 1
CONFIG_SENSORS_HMC5843_SPI_MODULE 1
CONFIG_SND_FIREWIRE_LIB_MODULE 1
CONFIG_INT340X_THERMAL_MODULE 1
CONFIG_DA9052_WATCHDOG_MODULE 1
CONFIG_CFG80211_DEBUGFS 1
CONFIG_TYPEC_TPS6598X_MODULE 1
CONFIG_GNSS_MTK_SERIAL_MODULE 1
CONFIG_BT_HCIUART_BCM 1
CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES 1
CONFIG_MAX9611_MODULE 1
CONFIG_LAPB_MODULE 1
CONFIG_IIO_ST_GYRO_3AXIS_MODULE 1
CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY 2048
CONFIG_IP_ROUTE_MULTIPATH 1
CONFIG_FPGA_DFL_FME_REGION_MODULE 1
CONFIG_AM2315_MODULE 1
CONFIG_RTC_DRV_PCF2123_MODULE 1
CONFIG_INTEL_MIC_CARD_MODULE 1
CONFIG_DVB_LNBP21_MODULE 1
CONFIG_XEN_NETDEV_FRONTEND 1
CONFIG_DVB_TDA10048_MODULE 1
CONFIG_INPUT_FF_MEMLESS_MODULE 1
CONFIG_PARAVIRT_CLOCK 1
CONFIG_SND_SOC_FSL_SAI_MODULE 1
CONFIG_USB_CONFIGFS_F_PRINTER 1
CONFIG_SENSORS_W83627HF_MODULE 1
CONFIG_CHR_DEV_SG 1
CONFIG_USB_CDC_PHONET_MODULE 1
CONFIG_IP_SET_HASH_NET_MODULE 1
CONFIG_SECTION_MISMATCH_WARN_ONLY 1
CONFIG_NET_SCH_DSMARK_MODULE 1
CONFIG_SND_AD1889_MODULE 1
CONFIG_NET_DSA_SMSC_LAN9303_MDIO_MODULE 1
CONFIG_MISC_RTSX_MODULE 1
CONFIG_SND_SOC_SSM2305_MODULE 1
CONFIG_SSB_DRIVER_PCICORE_POSSIBLE 1
CONFIG_MISDN_AVMFRITZ_MODULE 1
CONFIG_MDIO_DEVICE 1
CONFIG_X86_RESERVE_LOW 64
CONFIG_SMS_SDIO_DRV_MODULE 1
CONFIG_NFSD_PNFS 1
CONFIG_NEED_SG_DMA_LENGTH 1
CONFIG_INPUT_AXP20X_PEK_MODULE 1
CONFIG_SND_MPU401_MODULE 1
CONFIG_DVB_CX24116_MODULE 1
CONFIG_POWER_RESET 1
CONFIG_CRYPTO_XCBC_MODULE 1
CONFIG_CRYPTO_DEV_ATMEL_SHA204A_MODULE 1
CONFIG_NF_NAT_AMANDA_MODULE 1
CONFIG_IPW2200_MODULE 1
CONFIG_BRIDGE_EBT_MARK_MODULE 1
CONFIG_KEYBOARD_QT2160_MODULE 1
CONFIG_SENSORS_ADT7411_MODULE 1
CONFIG_IXGBE_DCA 1
CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE 1
CONFIG_VIDEO_OV5647_MODULE 1
CONFIG_MACVLAN_MODULE 1
CONFIG_FWTTY_MAX_CARD_PORTS 32
CONFIG_TPS6105X_MODULE 1
CONFIG_TI_ADC084S021_MODULE 1
CONFIG_PATA_PDC_OLD_MODULE 1
CONFIG_L2TP_V3 1
CONFIG_I2C_MUX_REG_MODULE 1
CONFIG_RTL8723_COMMON_MODULE 1
CONFIG_CHELSIO_T1_1G 1
CONFIG_BPF_JIT 1
CONFIG_INV_MPU6050_I2C_MODULE 1
CONFIG_IIO_INTERRUPT_TRIGGER_MODULE 1
CONFIG_MMCONF_FAM10H 1
CONFIG_SENSORS_INA2XX_MODULE 1
CONFIG_WLCORE_SDIO_MODULE 1
CONFIG_FB_ARK_MODULE 1
CONFIG_JOYSTICK_IFORCE_MODULE 1
CONFIG_PCIEASPM_DEFAULT 1
CONFIG_SND_SOC_WM8524_MODULE 1
CONFIG_PROFILING 1
CONFIG_PCF50633_ADC_MODULE 1
CONFIG_INTERVAL_TREE 1
CONFIG_ARCNET_MODULE 1
CONFIG_SND_SOC_WM8731_MODULE 1
CONFIG_IOSF_MBI 1
CONFIG_I2C_ALI15X3_MODULE 1
CONFIG_SENSORS_MAX31785_MODULE 1
CONFIG_NET_VENDOR_AMAZON 1
CONFIG_SPARSEMEM 1
CONFIG_W1_SLAVE_DS2805_MODULE 1
CONFIG_LEDS_LP5523_MODULE 1
CONFIG_REGULATOR_FAN53555_MODULE 1
CONFIG_NVME_FC_MODULE 1
CONFIG_COMEDI_ADDI_APCI_2032_MODULE 1
CONFIG_CRYPTO_ARC4_MODULE 1
CONFIG_DRM_GEM_SHMEM_HELPER 1
CONFIG_REGULATOR_DA9210_MODULE 1
CONFIG_ARCH_HAS_FORCE_DMA_UNENCRYPTED 1
CONFIG_SND_SOC_SOF_GEMINILAKE_SUPPORT 1
CONFIG_HD44780_MODULE 1
CONFIG_INPUT_REGULATOR_HAPTIC_MODULE 1
CONFIG_CAN_MCBA_USB_MODULE 1
CONFIG_IEEE802154_6LOWPAN_MODULE 1
CONFIG_VHOST_NET_MODULE 1
CONFIG_VIDEO_TEA6415C_MODULE 1
CONFIG_WLAN_VENDOR_ATMEL 1
CONFIG_SENSORS_ASPEED_MODULE 1
CONFIG_SND_SOC_AMD_CZ_RT5645_MACH_MODULE 1
CONFIG_AHC1EC0_WDT_MODULE 1
CONFIG_DVB_STV0900_MODULE 1
CONFIG_I2C_NFORCE2_MODULE 1
CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE 1
CONFIG_USB_GL860_MODULE 1
CONFIG_GRACE_PERIOD_MODULE 1
CONFIG_SLHC 1
CONFIG_R8188EU_MODULE 1
CONFIG_NET_VENDOR_TEHUTI 1
CONFIG_QED_RDMA 1
CONFIG_REGULATOR_LTC3589_MODULE 1
CONFIG_SCSI_UFSHCD_PCI_MODULE 1
CONFIG_SND_ALS300_MODULE 1
CONFIG_ADT7316_I2C_MODULE 1
CONFIG_ALTERA_TSE_MODULE 1
CONFIG_KEYBOARD_GPIO_POLLED_MODULE 1
CONFIG_E1000E_HWTS 1
CONFIG_CRYPTO_MANAGER 1
CONFIG_PHY_SAMSUNG_USB2_MODULE 1
CONFIG_INTEL_MEI_TXE_MODULE 1
CONFIG_SCSI_IPR_TRACE 1
CONFIG_NET_SCH_HTB_MODULE 1
CONFIG_EEPROM_AT24_MODULE 1
CONFIG_UIO_SERCOS3_MODULE 1
CONFIG_HID_CP2112_MODULE 1
CONFIG_HOSTAP_FIRMWARE_NVRAM 1
CONFIG_PPP_BSDCOMP_MODULE 1
CONFIG_SCHED_SMT 1
CONFIG_DVB_USB_TTUSB2_MODULE 1
CONFIG_SND_SOC_AMD_RENOIR_MODULE 1
CONFIG_EDAC_SUPPORT 1
CONFIG_RT_MUTEXES 1
CONFIG_MFD_MADERA_SPI_MODULE 1
CONFIG_LOCK_SPIN_ON_OWNER 1
CONFIG_REGULATOR_LTC3676_MODULE 1
CONFIG_WLCORE_MODULE 1
CONFIG_HID_ORTEK_MODULE 1
CONFIG_VIDEO_V4L2_TPG_MODULE 1
CONFIG_NETFILTER_XT_TARGET_MARK_MODULE 1
CONFIG_NFT_SYNPROXY_MODULE 1
CONFIG_HID_ASUS_MODULE 1
CONFIG_DRM_GEM_CMA_HELPER 1
CONFIG_AR5523_MODULE 1
CONFIG_DEVICE_PRIVATE 1
CONFIG_MEDIA_TUNER_MXL5007T_MODULE 1
CONFIG_ATH10K_CE 1
CONFIG_CX_ECAT_MODULE 1
CONFIG_DRM_I2C_SIL164_MODULE 1
CONFIG_MD_LINEAR_MODULE 1
CONFIG_SATA_INIC162X_MODULE 1
CONFIG_HUGETLBFS 1
CONFIG_CHECK_SIGNATURE 1
CONFIG_DVB_TDA10021_MODULE 1
CONFIG_VIDEO_CX231XX_DVB_MODULE 1
CONFIG_SLAB_MERGE_DEFAULT 1
CONFIG_KERNFS 1
CONFIG_CXD2880_SPI_DRV_MODULE 1
CONFIG_X86_INTEL_MPX 1
CONFIG_WL1251_MODULE 1
CONFIG_I2C_ALGOBIT_MODULE 1
CONFIG_IPV6_SUBTREES 1
CONFIG_MMC_BLOCK_MODULE 1
CONFIG_BATTERY_AXP20X_MODULE 1
CONFIG_NET_CLS_FW_MODULE 1
CONFIG_CRYPTO_DEV_CCP 1
CONFIG_KVM_MODULE 1
CONFIG_PAGE_COUNTER 1
CONFIG_KEYBOARD_DLINK_DIR685_MODULE 1
CONFIG_SND_SIMPLE_CARD_MODULE 1
CONFIG_ABX500_CORE 1
CONFIG_W1_SLAVE_DS2781_MODULE 1
CONFIG_VIDEO_SAA7185_MODULE 1
CONFIG_SND_PCI 1
CONFIG_VIDEO_SAA7134_DVB_MODULE 1
CONFIG_ATM_FORE200E_DEBUG 0
CONFIG_EXPERT 1
CONFIG_TOUCHSCREEN_PCAP_MODULE 1
CONFIG_NVME_TARGET_TCP_MODULE 1
CONFIG_DVB_NETUP_UNIDVB_MODULE 1
CONFIG_ATL1C_MODULE 1
CONFIG_IR_SANYO_DECODER_MODULE 1
CONFIG_DMAR_TABLE 1
CONFIG_MFD_INTEL_LPSS_PCI_MODULE 1
CONFIG_HW_RANDOM_INTEL_MODULE 1
CONFIG_LCD_LTV350QV_MODULE 1
CONFIG_LXT_PHY_MODULE 1
CONFIG_CFG80211_CRDA_SUPPORT 1
CONFIG_FB_MB862XX_MODULE 1
CONFIG_VIDEO_OV9650_MODULE 1
CONFIG_VIDEO_MT9V011_MODULE 1
CONFIG_SND_SOC_ALC5623_MODULE 1
CONFIG_SND_SOC_IMG 1
CONFIG_CAN_M_CAN_MODULE 1
CONFIG_BPFILTER 1
CONFIG_WIRELESS 1
CONFIG_WEXT_PROC 1
CONFIG_BCMA_DRIVER_PCI 1
CONFIG_SQUASHFS 1
CONFIG_6LOWPAN_NHC_MODULE 1
CONFIG_EDAC_I7CORE_MODULE 1
CONFIG_RMNET_MODULE 1
CONFIG_HZ_250 1
CONFIG_FB_N411_MODULE 1
CONFIG_X86_IO_APIC 1
CONFIG_ARCH_HAS_STRICT_KERNEL_RWX 1
CONFIG_NFT_DUP_IPV6_MODULE 1
CONFIG_DELL_WMI_AIO_MODULE 1
CONFIG_PCIE_DW_PLAT_HOST 1
CONFIG_SND_ALS4000_MODULE 1
CONFIG_SND_SOC_SOF_APOLLOLAKE_SUPPORT 1
CONFIG_USB_GSPCA_KONICA_MODULE 1
CONFIG_TCG_TIS_I2C_ATMEL_MODULE 1
CONFIG_LOCK_DEBUGGING_SUPPORT 1
CONFIG_SND_SOC_WM8770_MODULE 1
CONFIG_NET_SCH_TBF_MODULE 1
CONFIG_SHIFT_FS_POSIX_ACL 1
CONFIG_BT_HCIBTUSB_MODULE 1
CONFIG_FRAME_VECTOR 1
CONFIG_PKCS7_MESSAGE_PARSER 1
CONFIG_XILINX_PR_DECOUPLER_MODULE 1
CONFIG_BACKLIGHT_RAVE_SP_MODULE 1
CONFIG_USB_NET_CH9200_MODULE 1
CONFIG_CC_HAS_SANE_STACKPROTECTOR 1
CONFIG_USB_LED_TRIG 1
CONFIG_VIDEO_TVP7002_MODULE 1
CONFIG_DVB_CX22702_MODULE 1
CONFIG_KGDB 1
CONFIG_LTR501_MODULE 1
CONFIG_CROS_EC_LIGHTBAR_MODULE 1
CONFIG_SERIO_RAW_MODULE 1
CONFIG_TASK_IO_ACCOUNTING 1
CONFIG_MISC_RTSX_PCI_MODULE 1
CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
CONFIG_USBIP_VHCI_NR_HCS 1
CONFIG_UWB_MODULE 1
CONFIG_VIDEO_IMX258_MODULE 1
CONFIG_ASYNC_XOR_MODULE 1
CONFIG_USB_CONFIGFS_MASS_STORAGE 1
CONFIG_SND_SOC_INTEL_SST_TOPLEVEL 1
CONFIG_ISDN_CAPI_MIDDLEWARE 1
CONFIG_NET_CLS_RSVP_MODULE 1
CONFIG_TIPC_MODULE 1
CONFIG_MEMORY_HOTPLUG_SPARSE 1
CONFIG_DVB_STB6100_MODULE 1
CONFIG_W83977F_WDT_MODULE 1
CONFIG_MD_RAID0_MODULE 1
CONFIG_FRAME_WARN 1024
CONFIG_VIDEO_MT9P031_MODULE 1
CONFIG_NET_VENDOR_AGERE 1
CONFIG_SND_FIREFACE_MODULE 1
CONFIG_USB_NET_CDC_NCM_MODULE 1
CONFIG_SND_SOC_SOF_BAYTRAIL_MODULE 1
CONFIG_HID_GENERIC_MODULE 1
CONFIG_SND_SOC_SOF_INTEL_COMMON_MODULE 1
CONFIG_FB_SIS_300 1
CONFIG_ARCH_MMAP_RND_BITS 28
CONFIG_X86_VSYSCALL_EMULATION 1
CONFIG_DUMMY_IRQ_MODULE 1
CONFIG_USB_DWC2_HOST 1
CONFIG_USB_HACKRF_MODULE 1
CONFIG_AD7303_MODULE 1
CONFIG_HP_WATCHDOG_MODULE 1
CONFIG_COMEDI_DAS08_ISA_MODULE 1
CONFIG_MTD_DATAFLASH_OTP 1
CONFIG_HID_RETRODE_MODULE 1
CONFIG_COMEDI_USB_DRIVERS_MODULE 1
CONFIG_BCM87XX_PHY_MODULE 1
CONFIG_I2C_DESIGNWARE_PCI_MODULE 1
CONFIG_USB_ETH_MODULE 1
CONFIG_PATA_SCH_MODULE 1
CONFIG_VIDEO_VIM2M_MODULE 1
CONFIG_SND_SOC_ADAU1701_MODULE 1
CONFIG_BATTERY_TWL4030_MADC_MODULE 1
CONFIG_ZRAM_MEMORY_TRACKING 1
CONFIG_CRYPTO_DEV_SP_PSP 1
CONFIG_INITRAMFS_SOURCE ""
CONFIG_VIDEO_THS7303_MODULE 1
CONFIG_VIDEO_TW5864_MODULE 1
CONFIG_RTL_CARDS_MODULE 1
CONFIG_PATA_NETCELL_MODULE 1
CONFIG_SND_SOC_INTEL_SKL_HDA_DSP_GENERIC_MACH_MODULE 1
CONFIG_X86_MCELOG_LEGACY 1
CONFIG_INPUT_IMS_PCU_MODULE 1
CONFIG_VIDEO_IMX319_MODULE 1
CONFIG_DHT11_MODULE 1
CONFIG_RTC_DRV_DS1374_WDT 1
CONFIG_ATM_CLIP_MODULE 1
CONFIG_X86_CPU_RESCTRL 1
CONFIG_COMEDI_RTD520_MODULE 1
CONFIG_SND_HDA_CODEC_SIGMATEL_MODULE 1
CONFIG_CGROUPS 1
CONFIG_MFD_AXP20X_MODULE 1
CONFIG_SND_SOC_RT5670_MODULE 1
CONFIG_SND_USB_CAIAQ_INPUT 1
CONFIG_MMC 1
CONFIG_LZO_COMPRESS 1
CONFIG_DAX 1
CONFIG_USB_F_PHONET_MODULE 1
CONFIG_NET_DSA_SJA1105_MODULE 1
CONFIG_PAGE_POISONING_ZERO 1
CONFIG_VIRTIO_INPUT_MODULE 1
CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS 1
CONFIG_DELL_RBTN_MODULE 1
CONFIG_TOUCHSCREEN_USB_GUNZE 1
CONFIG_CRYPTO_SEQIV 1
CONFIG_ACPI_SPCR_TABLE 1
CONFIG_NI903X_WDT_MODULE 1
CONFIG_GPIO_XRA1403_MODULE 1
CONFIG_BRCMFMAC_MODULE 1
CONFIG_COMEDI_QUATECH_DAQP_CS_MODULE 1
CONFIG_TOUCHSCREEN_AD7877_MODULE 1
CONFIG_SND_HDA_POWER_SAVE_DEFAULT 1
CONFIG_TTY_PRINTK 1
CONFIG_9P_FSCACHE 1
CONFIG_HID_LOGITECH_MODULE 1
CONFIG_SND_INDIGODJX_MODULE 1
CONFIG_ARCNET_COM90xx_MODULE 1
CONFIG_VME_BUS 1
CONFIG_DM_LOG_USERSPACE_MODULE 1
CONFIG_JOYSTICK_GAMECON_MODULE 1
CONFIG_CRYPTO_USER_API_RNG_MODULE 1
CONFIG_SCSI_ENCLOSURE_MODULE 1
CONFIG_HAVE_GCC_PLUGINS 1
CONFIG_DYNAMIC_EVENTS 1
CONFIG_DVB_SP887X_MODULE 1
CONFIG_STACKTRACE 1
CONFIG_NET_EMATCH_CANID_MODULE 1
CONFIG_TAHVO_USB_HOST_BY_DEFAULT 1
CONFIG_HAVE_PCI 1
CONFIG_SENSORS_LM92_MODULE 1
CONFIG_EXTCON 1
CONFIG_COMEDI_ADDI_APCI_3120_MODULE 1
CONFIG_CHELSIO_LIB_MODULE 1
CONFIG_SCSI_SAS_LIBSAS_MODULE 1
CONFIG_ISCSI_TARGET_MODULE 1
CONFIG_IMA_MEASURE_PCR_IDX 10
CONFIG_HAVE_ACPI_APEI 1
CONFIG_ARCNET_RIM_I_MODULE 1
CONFIG_OPROFILE_NMI_TIMER 1
CONFIG_PATA_RADISYS_MODULE 1
CONFIG_TOSHIBA_HAPS_MODULE 1
CONFIG_IPV6_GRE_MODULE 1
CONFIG_NETFILTER_XT_TARGET_IDLETIMER_MODULE 1
CONFIG_FB_ATY128_MODULE 1
CONFIG_GPIO_TPS65086_MODULE 1
CONFIG_VFIO_PCI_INTX 1
CONFIG_BMG160_MODULE 1
CONFIG_UIO_AEC_MODULE 1
CONFIG_SCSI_PM8001_MODULE 1
CONFIG_USB_NET_RNDIS_WLAN_MODULE 1
CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC 1
CONFIG_VIDEO_TUNER_MODULE 1
CONFIG_IFB_MODULE 1
CONFIG_IIO_ST_ACCEL_3AXIS_MODULE 1
CONFIG_USB_FUNCTIONFS_ETH 1
CONFIG_TCS3472_MODULE 1
CONFIG_RDMA_SIW_MODULE 1
CONFIG_LEDS_LP3944_MODULE 1
CONFIG_USB_SEVSEG_MODULE 1
CONFIG_SND_MPU401_UART_MODULE 1
CONFIG_IPV6_VTI_MODULE 1
CONFIG_CRYPTO_DRBG 1
CONFIG_RTC_DRV_PCF8563_MODULE 1
CONFIG_SND_MAX_CARDS 32
CONFIG_PPTP_MODULE 1
CONFIG_MEDIA_TUNER_MSI001_MODULE 1
CONFIG_DVB_USB_V2_MODULE 1
CONFIG_SENSORS_SMSC47M1_MODULE 1
CONFIG_SND_USB_US122L_MODULE 1
CONFIG_TEST_BLACKHOLE_DEV_MODULE 1
CONFIG_USB_CDC_COMPOSITE_MODULE 1
CONFIG_USB_DSBR_MODULE 1
CONFIG_ISCSI_IBFT_FIND 1
CONFIG_KGDB_KDB 1
CONFIG_DCB 1
CONFIG_PCIPCWATCHDOG_MODULE 1
CONFIG_WLAN_VENDOR_ADMTEK 1
CONFIG_MLX5_MPFS 1
CONFIG_CGROUP_CPUACCT 1
CONFIG_FS_VERITY 1
CONFIG_USB_SERIAL_OTI6858_MODULE 1
CONFIG_SND_HDA_COMPONENT 1
CONFIG_SERIAL_SC16IS7XX_CORE_MODULE 1
CONFIG_MCP4531_MODULE 1
CONFIG_VIDEO_GO7007_USB_MODULE 1
CONFIG_CAN_BCM_MODULE 1
CONFIG_HAS_IOPORT_MAP 1
CONFIG_SND_SOC_ES8328_I2C_MODULE 1
CONFIG_X86_CMPXCHG64 1
CONFIG_VIDEO_SAA7146_VV_MODULE 1
CONFIG_DA9062_WATCHDOG_MODULE 1
CONFIG_PINCTRL_CS47L35 1
CONFIG_CARL9170_HWRNG 1
CONFIG_NLMON_MODULE 1
CONFIG_ATH10K_PCI_MODULE 1
CONFIG_CAN_PEAK_PCMCIA_MODULE 1
CONFIG_HAVE_FAST_GUP 1
CONFIG_NET_VENDOR_VIA 1
CONFIG_UBIFS_FS_SECURITY 1
CONFIG_USB_ATM_MODULE 1
CONFIG_ISA_DMA_API 1
CONFIG_PCMCIA_FDOMAIN_MODULE 1
CONFIG_HZ 250
CONFIG_IIO_SIMPLE_DUMMY_MODULE 1
CONFIG_SERIAL_8250_SHARE_IRQ 1
CONFIG_MT76x2U_MODULE 1
CONFIG_DPS310_MODULE 1
CONFIG_UCB1400_CORE_MODULE 1
CONFIG_NET_ACT_VLAN_MODULE 1
CONFIG_IXGBE_HWMON 1
CONFIG_USB_RTL8152_MODULE 1
CONFIG_NEED_MULTIPLE_NODES 1
CONFIG_ECHO_MODULE 1
CONFIG_ASYMMETRIC_TPM_KEY_SUBTYPE_MODULE 1
CONFIG_USB_CONFIGFS_F_UAC2 1
CONFIG_I2C_HELPER_AUTO 1
CONFIG_NETFILTER_XT_MATCH_U32_MODULE 1
CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE 1
CONFIG_VIDEO_SONY_BTF_MPX_MODULE 1
CONFIG_INTEGRITY_TRUSTED_KEYRING 1
CONFIG_SQUASHFS_ZLIB 1
CONFIG_VIDEO_CX23885_MODULE 1
CONFIG_AGP_INTEL 1
CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
CONFIG_NLS_ISO8859_4_MODULE 1
CONFIG_TOUCHSCREEN_AD7879_I2C_MODULE 1
CONFIG_INTEL_OAKTRAIL_MODULE 1
CONFIG_SND_MTS64_MODULE 1
CONFIG_FB_BACKLIGHT_MODULE 1
CONFIG_RTC_DRV_RX8025_MODULE 1
CONFIG_SERIAL_8250_NR_UARTS 48
CONFIG_WILCO_EC_TELEMETRY_MODULE 1
CONFIG_ARCH_HAS_STRICT_MODULE_RWX 1
CONFIG_TCP_CONG_DCTCP_MODULE 1
CONFIG_RTC_DRV_MAX8997_MODULE 1
CONFIG_NET_EMATCH_IPSET_MODULE 1
CONFIG_TSL2772_MODULE 1
CONFIG_TI_AM335X_ADC_MODULE 1
CONFIG_AD7291_MODULE 1
CONFIG_CC_IS_GCC 1
CONFIG_INFINIBAND_SRPT_MODULE 1
CONFIG_CRYPTO_RMD160_MODULE 1
CONFIG_IR_IMON_MODULE 1
CONFIG_CPU_SUP_HYGON 1
CONFIG_BCM7XXX_PHY_MODULE 1
CONFIG_PATA_HPT366_MODULE 1
CONFIG_NET_EGRESS 1
CONFIG_XEN_AUTO_XLATE 1
CONFIG_RMI4_CORE_MODULE 1
CONFIG_NET_VENDOR_ARC 1
CONFIG_SCHED_MC_PRIO 1
CONFIG_IP_SET_HASH_MAC_MODULE 1
CONFIG_CRYPTO_ENGINE_MODULE 1
CONFIG_INET_AH_MODULE 1
CONFIG_SENSORS_ATXP1_MODULE 1
CONFIG_HID_LENOVO_MODULE 1
CONFIG_SND_SOC_MAX98373_MODULE 1
CONFIG_HAVE_USER_RETURN_NOTIFIER 1
CONFIG_SND_SOC_ADAU17X1_MODULE 1
CONFIG_MTD_UBI_BEB_LIMIT 20
CONFIG_DRM_I2C_CH7006_MODULE 1
CONFIG_TABLET_USB_KBTAB_MODULE 1
CONFIG_UDF_FS_MODULE 1
CONFIG_RTC_DRV_DS1343_MODULE 1
CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH_MODULE 1
CONFIG_IPV6_MIP6_MODULE 1
CONFIG_MARVELL_PHY_MODULE 1
CONFIG_NFT_SOCKET_MODULE 1
CONFIG_HAVE_PERF_USER_STACK_DUMP 1
CONFIG_ACPI_EC_DEBUGFS_MODULE 1
CONFIG_EROFS_FS_SECURITY 1
CONFIG_APPLE_PROPERTIES 1
CONFIG_VXFS_FS_MODULE 1
CONFIG_USB_CONN_GPIO_MODULE 1
CONFIG_GPIO_SCH_MODULE 1
CONFIG_CGROUP_PERF 1
CONFIG_NLATTR 1
CONFIG_SND_LOLA_MODULE 1
CONFIG_ISDN_CAPI_MODULE 1
CONFIG_HOTPLUG_PCI 1
CONFIG_IIO_ADIS_LIB_MODULE 1
CONFIG_LOCK_DOWN_KERNEL_FORCE_NONE 1
CONFIG_ZD1211RW_MODULE 1
CONFIG_SRF08_MODULE 1
CONFIG_PCI_PF_STUB_MODULE 1
CONFIG_TCP_CONG_CUBIC 1
CONFIG_CEPH_FS_MODULE 1
CONFIG_MPL115_SPI_MODULE 1
CONFIG_SGI_XP_MODULE 1
CONFIG_SCSI_NETLINK 1
CONFIG_BACKLIGHT_BD6107_MODULE 1
CONFIG_TCG_TIS_ST33ZP24_I2C_MODULE 1
CONFIG_NR_CPUS 8192
CONFIG_IXGBE_MODULE 1
CONFIG_SUSPEND_FREEZER 1
CONFIG_HAVE_EXIT_THREAD 1
CONFIG_IIO_BUFFER_CB_MODULE 1
CONFIG_MMC_SDHCI_MODULE 1
CONFIG_GPIO_CRYSTAL_COVE_MODULE 1
CONFIG_USB_MOUSE_MODULE 1
CONFIG_B43_SSB 1
CONFIG_SND_SUPPORT_OLD_API 1
CONFIG_DVB_DIB7000M_MODULE 1
CONFIG_NETFILTER_XT_CONNMARK_MODULE 1
CONFIG_ENA_ETHERNET_MODULE 1
CONFIG_SND_SOC_CS35L35_MODULE 1
CONFIG_NR_CPUS_RANGE_BEGIN 8192
CONFIG_IIO_ST_ACCEL_SPI_3AXIS_MODULE 1
CONFIG_LOGITECH_FF 1
CONFIG_DVB_AF9033_MODULE 1
CONFIG_IPV6_FOU_TUNNEL_MODULE 1
CONFIG_GREYBUS_RAW_MODULE 1
CONFIG_EDAC_PND2_MODULE 1
CONFIG_HID_KYE_MODULE 1
CONFIG_MOUSE_PS2_TRACKPOINT 1
CONFIG_CRYPTO_CHACHA20_MODULE 1
CONFIG_HID_GEMBIRD_MODULE 1
CONFIG_MOUSE_VSXXXAA_MODULE 1
CONFIG_IP_MROUTE_MULTIPLE_TABLES 1
CONFIG_VIDEO_TM6000_ALSA_MODULE 1
CONFIG_NFT_COMPAT_MODULE 1
CONFIG_LEDS_PCA963X_MODULE 1
CONFIG_DRM_NOUVEAU_BACKLIGHT 1
CONFIG_SOFT_WATCHDOG_MODULE 1
CONFIG_SYSFS 1
CONFIG_IPWIRELESS_MODULE 1
CONFIG_PARIDE_FRPW_MODULE 1
CONFIG_IP_SET_BITMAP_IPMAC_MODULE 1
CONFIG_ISCSI_TARGET_CXGB4_MODULE 1
CONFIG_MTD_NAND_RICOH_MODULE 1
CONFIG_USB_DEFAULT_PERSIST 1
CONFIG_PANEL_PARPORT 0
CONFIG_DVB_MN88473_MODULE 1
CONFIG_TOUCHSCREEN_UCB1400_MODULE 1
CONFIG_LIB80211_CRYPT_WEP_MODULE 1
CONFIG_DELL_WMI_MODULE 1
CONFIG_SBP_TARGET_MODULE 1
CONFIG_SENSORS_W83791D_MODULE 1
CONFIG_INPUT_TOUCHSCREEN 1
CONFIG_RT2800USB_UNKNOWN 1
CONFIG_RADIO_SI4713_MODULE 1
CONFIG_DRM_PANEL_BRIDGE 1
CONFIG_RIONET_RX_SIZE 128
CONFIG_JAILHOUSE_GUEST 1
CONFIG_SND_SOC_CS42L51_I2C_MODULE 1
CONFIG_ROCKCHIP_PHY_MODULE 1
CONFIG_USB_HUB_USB251XB_MODULE 1
CONFIG_I2C_VIAPRO_MODULE 1
CONFIG_FB_HYPERV_MODULE 1
CONFIG_USB_GSPCA_NW80X_MODULE 1
CONFIG_KPC2000_CORE_MODULE 1
CONFIG_NF_CONNTRACK_LABELS 1
CONFIG_GPIO_ADP5520_MODULE 1
CONFIG_RTC_DRV_RC5T583_MODULE 1
CONFIG_IP_NF_MATCH_AH_MODULE 1
CONFIG_INFINIBAND_SRP_MODULE 1
CONFIG_SYNCLINK_CS_MODULE 1
CONFIG_CARL9170_WPC 1
CONFIG_GPIO_BD9571MWV_MODULE 1
CONFIG_XDP_SOCKETS 1
CONFIG_VIDEO_SAA7134_GO7007_MODULE 1
CONFIG_TCP_CONG_VENO_MODULE 1
CONFIG_DVB_S5H1420_MODULE 1
CONFIG_INFINIBAND_MODULE 1
CONFIG_AFS_FS_MODULE 1
CONFIG_MFD_88PM800_MODULE 1
CONFIG_SLIMBUS_MODULE 1
CONFIG_SMC_MODULE 1
CONFIG_COMEDI_S526_MODULE 1
CONFIG_COMEDI_DAS1800_MODULE 1
CONFIG_USB_EHCI_HCD_PLATFORM 1
CONFIG_DVB_NET 1
CONFIG_ASN1 1
CONFIG_NF_LOG_COMMON_MODULE 1
CONFIG_I2C_PARPORT_LIGHT_MODULE 1
CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE 1
CONFIG_CRYPTO_AES_NI_INTEL_MODULE 1
CONFIG_NFC_SHDLC 1
CONFIG_CRYPTO_DEV_VIRTIO_MODULE 1
CONFIG_MFD_WM8998 1
CONFIG_ULI526X_MODULE 1
CONFIG_TOUCHSCREEN_BU21013_MODULE 1
CONFIG_I2C_SIMTEC_MODULE 1
CONFIG_FB_SMSCUFX_MODULE 1
CONFIG_FPGA_DFL_FME_BRIDGE_MODULE 1
CONFIG_NTB_TRANSPORT_MODULE 1
CONFIG_XZ_DEC_ARM 1
CONFIG_MAX44000_MODULE 1
CONFIG_NLS_CODEPAGE_775_MODULE 1
CONFIG_MFD_TI_LMU_MODULE 1
CONFIG_USB_CONFIGFS_EEM 1
CONFIG_RTLLIB_CRYPTO_TKIP_MODULE 1
CONFIG_MOUSE_SERIAL_MODULE 1
CONFIG_CRYPTO_HASH_INFO 1
CONFIG_FB_SYS_FOPS_MODULE 1
CONFIG_JOYSTICK_ANALOG_MODULE 1
CONFIG_MISDN_HFCPCI_MODULE 1
CONFIG_WIMAX_MODULE 1
CONFIG_QED_FCOE 1
CONFIG_BLK_SCSI_REQUEST 1
CONFIG_VIDEO_SR030PC30_MODULE 1
CONFIG_HAVE_SYSCALL_TRACEPOINTS 1
CONFIG_NFC_ST_NCI_I2C_MODULE 1
CONFIG_NET_DSA_TAG_BRCM_COMMON_MODULE 1
CONFIG_MEDIA_TUNER_XC4000_MODULE 1
CONFIG_NETFILTER_XT_MATCH_DEVGROUP_MODULE 1
CONFIG_ACPI_BATTERY 1
CONFIG_SND_SOC_TAS571X_MODULE 1
CONFIG_DVB_LGDT3305_MODULE 1
CONFIG_CAN_HI311X_MODULE 1
CONFIG_MEMSTICK_MODULE 1
CONFIG_RTC_DRV_RX6110_MODULE 1
CONFIG_FUJITSU_TABLET_MODULE 1
CONFIG_IIO_ST_PRESS_SPI_MODULE 1
CONFIG_KEYBOARD_MPR121_MODULE 1
CONFIG_FPGA_DFL_AFU_MODULE 1
CONFIG_VIDEO_USBTV_MODULE 1
CONFIG_EEPROM_IDT_89HPESX_MODULE 1
CONFIG_PM_DEVFREQ 1
CONFIG_MFD_JANZ_CMODIO_MODULE 1
CONFIG_VIDEO_SAA7146_MODULE 1
CONFIG_MTD_COMPLEX_MAPPINGS 1
CONFIG_MARVELL_10G_PHY_MODULE 1
CONFIG_FB 1
CONFIG_GREYBUS_LOG_MODULE 1
CONFIG_BATTERY_DA9030_MODULE 1
CONFIG_IMA_NG_TEMPLATE 1
CONFIG_NET_DSA_TAG_8021Q_MODULE 1
CONFIG_TRACING 1
CONFIG_IIO_SYSFS_TRIGGER_MODULE 1
CONFIG_BLK_MQ_VIRTIO 1
CONFIG_TOUCHSCREEN_S6SY761_MODULE 1
CONFIG_IP_NF_MATCH_RPFILTER_MODULE 1
CONFIG_IR_IMON_RAW_MODULE 1
CONFIG_REGMAP_W1_MODULE 1
CONFIG_NLS_CODEPAGE_865_MODULE 1
CONFIG_I2C_COMPAT 1
CONFIG_KEYBOARD_OPENCORES_MODULE 1
CONFIG_DRM_SCHED_MODULE 1
CONFIG_WLAN_VENDOR_ZYDAS 1
CONFIG_SECURITY_LOCKDOWN_LSM_EARLY 1
CONFIG_EFI_DEV_PATH_PARSER 1
CONFIG_INET_SCTP_DIAG_MODULE 1
CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH_MODULE 1
CONFIG_NFSD_V3_ACL 1
CONFIG_SND_SOC_SSM4567_MODULE 1
CONFIG_SDR_MAX2175_MODULE 1
CONFIG_USB_GSPCA_SPCA500_MODULE 1
CONFIG_GPIO_UCB1400_MODULE 1
CONFIG_SPARSEMEM_VMEMMAP_ENABLE 1
CONFIG_LEDS_TRIGGER_CPU 1
CONFIG_PC300TOO_MODULE 1
CONFIG_HID_ELO_MODULE 1
CONFIG_ENCX24J600_MODULE 1
CONFIG_IPVLAN_MODULE 1
CONFIG_HALTPOLL_CPUIDLE_MODULE 1
CONFIG_COMEDI_NI_LABPC_ISADMA_MODULE 1
CONFIG_RTC_DRV_RV3028_MODULE 1
CONFIG_SND_SOC_DA7213_MODULE 1
CONFIG_NET_ACT_NAT_MODULE 1
CONFIG_BATTERY_DS2780_MODULE 1
CONFIG_GPIO_104_IDI_48_MODULE 1
CONFIG_NFC_PORT100_MODULE 1
CONFIG_FTRACE_MCOUNT_RECORD 1
CONFIG_OCFS2_FS_STATS 1
CONFIG_CC_HAS_ASM_GOTO 1
CONFIG_SND_SOC_SOF_PCI_MODULE 1
CONFIG_MFD_SKY81452_MODULE 1
CONFIG_VIRTUALIZATION 1
CONFIG_ND_CLAIM 1
CONFIG_MSDOS_PARTITION 1
CONFIG_USB_CHIPIDEA_PCI_MODULE 1
CONFIG_COMEDI_RTI800_MODULE 1
CONFIG_MXC4005_MODULE 1
CONFIG_RTC_I2C_AND_SPI 1
CONFIG_MYRI10GE_DCA 1
CONFIG_PATA_PLATFORM_MODULE 1
CONFIG_BT_HCIUART_MODULE 1
CONFIG_RESET_ATTACK_MITIGATION 1
CONFIG_TOUCHSCREEN_USB_NEXIO 1
CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE 0
CONFIG_RT2800USB_RT33XX 1
CONFIG_SND_SOC_SOF_INTEL_TOPLEVEL 1
CONFIG_SND_SOC_WM8903_MODULE 1
CONFIG_DVB_LNBP22_MODULE 1
CONFIG_SENSORS_WM831X_MODULE 1
CONFIG_PINCTRL_INTEL_MODULE 1
CONFIG_RTC_DRV_TPS6586X_MODULE 1
CONFIG_VIDEO_OV2659_MODULE 1
CONFIG_GPIO_ADP5588_MODULE 1
CONFIG_SENSORS_TMP421_MODULE 1
CONFIG_SND_SOC_WM8804_SPI_MODULE 1
CONFIG_SND_SOC_PCM186X_SPI_MODULE 1
CONFIG_FB_RADEON_I2C 1
CONFIG_HMEM_REPORTING 1
CONFIG_DVB_RTL2832_SDR_MODULE 1
CONFIG_CAN_PEAK_PCIEFD_MODULE 1
CONFIG_USB_GSPCA_SN9C2028_MODULE 1
CONFIG_SUNGEM_MODULE 1
CONFIG_BMP280_I2C_MODULE 1
CONFIG_HAVE_OPROFILE 1
CONFIG_IR_STREAMZAP_MODULE 1
CONFIG_SND_HDSPM_MODULE 1
CONFIG_CAN_PEAK_PCIEC 1
CONFIG_EFI_VARS_PSTORE_MODULE 1
CONFIG_X86_INTEL_LPSS 1
CONFIG_LEDS_CLEVO_MAIL_MODULE 1
CONFIG_CPU_IDLE_GOV_LADDER 1
CONFIG_CPU_SUP_ZHAOXIN 1
CONFIG_IP_SET_MODULE 1
CONFIG_THERMAL 1
CONFIG_DVB_BUDGET_PATCH_MODULE 1
CONFIG_SYNC_FILE 1
CONFIG_USB_XHCI_PCI 1
CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE 1
CONFIG_AMD8111_ETH_MODULE 1
CONFIG_COMEDI_ADL_PCI8164_MODULE 1
CONFIG_SND_SOC_ACPI_INTEL_MATCH_MODULE 1
CONFIG_XEN_ACPI 1
CONFIG_AMD_IOMMU 1
CONFIG_VIDEO_S5K6AA_MODULE 1
CONFIG_I2C_AMD8111_MODULE 1
CONFIG_INPUT_POWERMATE_MODULE 1
CONFIG_OVERLAY_FS_XINO_AUTO 1
CONFIG_NET_FC 1
CONFIG_ACPI_WATCHDOG 1
CONFIG_FB_S3_MODULE 1
CONFIG_BRCMUTIL_MODULE 1
CONFIG_SI1133_MODULE 1
CONFIG_DVB_TTUSB_BUDGET_MODULE 1
CONFIG_VETH_MODULE 1
CONFIG_RTC_DRV_PCF8583_MODULE 1
CONFIG_DVB_MT312_MODULE 1
CONFIG_MLX5_CORE_EN 1
CONFIG_LEDS_PCA955X_GPIO 1
CONFIG_MFD_TPS65912_I2C 1
CONFIG_NET_VENDOR_3COM 1
CONFIG_TOUCHSCREEN_ROHM_BU21023_MODULE 1
CONFIG_ATM_DUMMY_MODULE 1
CONFIG_MAX517_MODULE 1
CONFIG_HID_PETALYNX_MODULE 1
CONFIG_AMD_NUMA 1
CONFIG_MTD_PCMCIA_MODULE 1
CONFIG_FB_ATY_CT 1
CONFIG_STACKPROTECTOR 1
CONFIG_IRQ_BYPASS_MANAGER 1
CONFIG_ADXRS450_MODULE 1
CONFIG_TLAN_MODULE 1
CONFIG_INTEL_MIC_BUS_MODULE 1
CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK 1
CONFIG_COMEDI_AMPLC_PCI230_MODULE 1
CONFIG_SND_SOC_PCM3060_SPI_MODULE 1
CONFIG_SND_HDA_CODEC_VIA_MODULE 1
CONFIG_CMDLINE_PARTITION 1
CONFIG_MEMSTICK_TIFM_MS_MODULE 1
CONFIG_ATM_LANE_MODULE 1
CONFIG_MLXSW_CORE_THERMAL 1
CONFIG_COMMON_CLK_PWM_MODULE 1
CONFIG_NET_DSA_TAG_BRCM_MODULE 1
CONFIG_SENSORS_W83L786NG_MODULE 1
CONFIG_SND_SOC_PCM1681_MODULE 1
CONFIG_NET_ACT_MIRRED_MODULE 1
CONFIG_HAVE_ARCH_KGDB 1
CONFIG_ARCH_USE_QUEUED_SPINLOCKS 1
CONFIG_IMA_DEFAULT_HASH "sha1"
CONFIG_SOUNDWIRE_CADENCE_MODULE 1
CONFIG_INPUT_APANEL_MODULE 1
CONFIG_NF_TPROXY_IPV4_MODULE 1
CONFIG_B43_PCICORE_AUTOSELECT 1
CONFIG_BLK_DEBUG_FS 1
CONFIG_MLX5_FPGA_TLS 1
CONFIG_QLCNIC_SRIOV 1
CONFIG_MYRI10GE_MODULE 1
CONFIG_X86_PM_TIMER 1
CONFIG_TI_ADC161S626_MODULE 1
CONFIG_USB_VL600_MODULE 1
CONFIG_VIDEO_IMX355_MODULE 1
CONFIG_PARIDE_BPCK_MODULE 1
CONFIG_ISL29501_MODULE 1
CONFIG_RTC_DRV_HID_SENSOR_TIME_MODULE 1
CONFIG_ZPA2326_I2C_MODULE 1
CONFIG_B43LEGACY_HWRNG 1
CONFIG_NET_DSA_TAG_LAN9303_MODULE 1
CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH_MODULE 1
CONFIG_ATH9K_BTCOEX_SUPPORT 1
CONFIG_CAN_SOFTING_MODULE 1
CONFIG_STM_DUMMY_MODULE 1
CONFIG_RT2X00_LIB_PCI_MODULE 1
CONFIG_SND_DUMMY_MODULE 1
CONFIG_VIDEOBUF2_V4L2_MODULE 1
CONFIG_X86_DEBUG_FPU 1
CONFIG_SCSI_MVSAS_MODULE 1
CONFIG_CPU_FREQ_GOV_SCHEDUTIL 1
CONFIG_ADIS16260_MODULE 1
CONFIG_NET_VENDOR_INTEL 1
CONFIG_USB_WUSB_CBAF_MODULE 1
CONFIG_NFC_PN544_I2C_MODULE 1
CONFIG_SND_SOC_TAS2552_MODULE 1
CONFIG_RPS 1
CONFIG_PACKET_DIAG_MODULE 1
CONFIG_SND_SOC_IMG_I2S_OUT_MODULE 1
CONFIG_DVB_AU8522_DTV_MODULE 1
CONFIG_USB_NET_ZAURUS_MODULE 1
CONFIG_SERIAL_8250_EXAR_MODULE 1
CONFIG_DEVFREQ_GOV_PERFORMANCE 1
CONFIG_INET6_XFRM_TUNNEL_MODULE 1
CONFIG_DRM_AST_MODULE 1
CONFIG_DM_MULTIPATH_ST_MODULE 1
CONFIG_NET_TEAM_MODE_RANDOM_MODULE 1
CONFIG_SPI_DW_MID_DMA 1
CONFIG_SENSORS_LM95241_MODULE 1
CONFIG_PROC_PID_CPUSET 1
CONFIG_CPU_IDLE_GOV_TEO 1
CONFIG_REALTEK_AUTOPM 1
CONFIG_IEEE802154_ADF7242_MODULE 1
CONFIG_USB_NET_AX88179_178A_MODULE 1
CONFIG_FB_METRONOME_MODULE 1
CONFIG_NF_TABLES_BRIDGE_MODULE 1
CONFIG_USB_MV_U3D_MODULE 1
CONFIG_AD525X_DPOT_SPI_MODULE 1
CONFIG_BATTERY_GAUGE_LTC2941_MODULE 1
CONFIG_INET_ESP_OFFLOAD_MODULE 1
CONFIG_PM_GENERIC_DOMAINS 1
CONFIG_LEGACY_PTY_COUNT 0
CONFIG_MEDIA_TUNER_E4000_MODULE 1
CONFIG_PMS7003_MODULE 1
CONFIG_INPUT_ATLAS_BTNS_MODULE 1
CONFIG_LOAD_UEFI_KEYS 1
CONFIG_ACQUIRE_WDT_MODULE 1
CONFIG_PM_WAKELOCKS_LIMIT 100
CONFIG_VIDEO_SAA6588_MODULE 1
CONFIG_IPV6_FOU_MODULE 1
CONFIG_TOUCHSCREEN_USB_DMC_TSC10 1
CONFIG_TPM_KEY_PARSER_MODULE 1
CONFIG_CAPI_AVM 1
CONFIG_DVB_ZL10039_MODULE 1
CONFIG_INTEL_ATOMISP2_PM_MODULE 1
CONFIG_MTD_MAP_BANK_WIDTH_2 1
CONFIG_USB_AUDIO_MODULE 1
CONFIG_NFT_REJECT_MODULE 1
CONFIG_NVME_TARGET_RDMA_MODULE 1
CONFIG_WDTPCI_MODULE 1
CONFIG_STX104_MODULE 1
CONFIG_LG_LAPTOP_MODULE 1
CONFIG_USB_SERIAL_DEBUG_MODULE 1
CONFIG_SENSORS_MAX16064_MODULE 1
CONFIG_IP_SET_HASH_IPPORTIP_MODULE 1
CONFIG_MLX4_EN_MODULE 1
CONFIG_PARIDE_DSTR_MODULE 1
CONFIG_TABLET_USB_ACECAD_MODULE 1
CONFIG_HYPERVISOR_GUEST 1
CONFIG_SENSORS_LM70_MODULE 1
CONFIG_SERIAL_MAX310X 1
CONFIG_SECURITY_SMACK_NETFILTER 1
CONFIG_NET_EMATCH_NBYTE_MODULE 1
CONFIG_SENSORS_BH1770_MODULE 1
CONFIG_NORTEL_HERMES_MODULE 1
CONFIG_SPI_NXP_FLEXSPI_MODULE 1
CONFIG_SIS190_MODULE 1
CONFIG_SND_SOC_MT6358_MODULE 1
CONFIG_INTEL_INT0002_VGPIO_MODULE 1
CONFIG_RAPIDIO_DMA_ENGINE 1
CONFIG_FONT_TER16x32 1
CONFIG_USB_BDC_UDC_MODULE 1
CONFIG_TCG_NSC_MODULE 1
CONFIG_BCMA_SFLASH 1
CONFIG_ZISOFS 1
CONFIG_WLAN_VENDOR_MEDIATEK 1
CONFIG_WIMAX_I2400M_MODULE 1
CONFIG_CUSE_MODULE 1
CONFIG_SND_SOC_WM8728_MODULE 1
CONFIG_HTC_PASIC3_MODULE 1
CONFIG_USB_ZERO_MODULE 1
CONFIG_BLK_DEV_CRYPTOLOOP_MODULE 1
CONFIG_TOUCHSCREEN_WM97XX_MODULE 1
CONFIG_NF_TABLES_IPV4 1
CONFIG_IP_MULTICAST 1
CONFIG_FB_RADEON_MODULE 1
CONFIG_DM_CACHE_SMQ_MODULE 1
CONFIG_CRYPTO_RMD256_MODULE 1
CONFIG_NF_TABLES_SET_MODULE 1
CONFIG_SND_SOC_INTEL_HASWELL_MODULE 1
CONFIG_DVB_MT352_MODULE 1
CONFIG_RC_ATI_REMOTE_MODULE 1
CONFIG_W83627HF_WDT_MODULE 1
CONFIG_SQUASHFS_XZ 1
CONFIG_FB_VOODOO1_MODULE 1
CONFIG_WILCO_EC_EVENTS_MODULE 1
CONFIG_USB_NET_CX82310_ETH_MODULE 1
CONFIG_GENERIC_CMOS_UPDATE 1
CONFIG_NET_VENDOR_CISCO 1
CONFIG_REGULATOR_AS3711_MODULE 1
CONFIG_EEPROM_MAX6875_MODULE 1
CONFIG_ACPI_ALS_MODULE 1
CONFIG_W1_MASTER_MATROX_MODULE 1
CONFIG_DRM_CIRRUS_QEMU_MODULE 1
CONFIG_MOUSE_APPLETOUCH_MODULE 1
CONFIG_HID_LOGITECH_DJ_MODULE 1
CONFIG_ARCH_HAS_PTE_DEVMAP 1
CONFIG_MFD_DLN2_MODULE 1
CONFIG_VIDEO_STK1160_MODULE 1
CONFIG_BT_LEDS 1
CONFIG_CRYPTO_DH 1
CONFIG_FUNCTION_ERROR_INJECTION 1
CONFIG_TICK_ONESHOT 1
CONFIG_USB_CDNS3_PCI_WRAP_MODULE 1
CONFIG_FB_I740_MODULE 1
CONFIG_XEN_PCIDEV_FRONTEND_MODULE 1
CONFIG_HID_BETOP_FF_MODULE 1
CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE 1
CONFIG_CRYPTO_CTR 1
CONFIG_SND_SOC_MAX9867_MODULE 1
CONFIG_GPIO_TPS6586X 1
CONFIG_PCMCIA_XIRC2PS_MODULE 1
CONFIG_CAN_F81601_MODULE 1
CONFIG_COMPAT_FOR_U64_ALIGNMENT 1
CONFIG_MTRR_SANITIZER 1
CONFIG_GNSS_UBX_SERIAL_MODULE 1
CONFIG_XARRAY_MULTI 1
CONFIG_DVB_STV090x_MODULE 1
CONFIG_USB_CDNS3_GADGET 1
CONFIG_DRM_AMD_DC_DCN2_0 1
CONFIG_CROS_EC_ISHTP_MODULE 1
CONFIG_SCSI_HPTIOP_MODULE 1
CONFIG_NATIONAL_PHY_MODULE 1
CONFIG_B43LEGACY_PCICORE_AUTOSELECT 1
CONFIG_SW_SYNC 1
CONFIG_REGMAP_SCCB_MODULE 1
CONFIG_USB_CONFIGFS_F_LB_SS 1
CONFIG_SPI_DW_PCI_MODULE 1
CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE 1
CONFIG_VIDEO_TW68_MODULE 1
CONFIG_WIRELESS_EXT 1
CONFIG_MEDIA_TUNER_MT2060_MODULE 1
CONFIG_HID_PICOLCD_BACKLIGHT 1
CONFIG_SND_SOC_RT5640_MODULE 1
CONFIG_COMEDI_ADV_PCI1710_MODULE 1
CONFIG_SND_HDA_CODEC_CA0110_MODULE 1
CONFIG_GPIO_TPS65910 1
CONFIG_NFC_ST_NCI_MODULE 1
CONFIG_VIDEO_OV6650_MODULE 1
CONFIG_RTC_DRV_RS5C348_MODULE 1
CONFIG_REGULATOR_PV88080_MODULE 1
CONFIG_RTC_DRV_FTRTC010_MODULE 1
CONFIG_SND_SOC_MAX9759_MODULE 1
CONFIG_SND_INTEL_DSP_CONFIG_MODULE 1
CONFIG_STM_PROTO_SYS_T_MODULE 1
CONFIG_DELL_UART_BACKLIGHT_MODULE 1
CONFIG_MODVERSIONS 1
CONFIG_HW_RANDOM 1
CONFIG_B43_PCI_AUTOSELECT 1
CONFIG_MUTEX_SPIN_ON_OWNER 1
CONFIG_SND_SOC_INTEL_MACH 1
CONFIG_PATA_LEGACY_MODULE 1
CONFIG_DVB_USB_AU6610_MODULE 1
CONFIG_SPI_LM70_LLP_MODULE 1
CONFIG_X86_SPEEDSTEP_LIB_MODULE 1
CONFIG_VIDEO_SMIAPP_PLL_MODULE 1
CONFIG_IE6XX_WDT_MODULE 1
CONFIG_BT_HCIBTUSB_RTL 1
CONFIG_SYS_HYPERVISOR 1
CONFIG_TOUCHSCREEN_WACOM_I2C_MODULE 1
CONFIG_USB_LEDS_TRIGGER_USBPORT_MODULE 1
CONFIG_ATM_IA_MODULE 1
CONFIG_VIRTIO_VSOCKETS_COMMON_MODULE 1
CONFIG_DRM_AMD_DC_DCN1_0 1
CONFIG_TRACE_ROUTER_MODULE 1
CONFIG_SND_VIRTUOSO_MODULE 1
CONFIG_AMIGA_PARTITION 1
CONFIG_EARLY_PRINTK 1
CONFIG_SND_SOC_WM8804_I2C_MODULE 1
CONFIG_THINKPAD_ACPI_ALSA_SUPPORT 1
CONFIG_CGROUP_NET_CLASSID 1
CONFIG_MTD_AR7_PARTS_MODULE 1
CONFIG_MEMCG_SWAP 1
CONFIG_SENSORS_ADS7871_MODULE 1
CONFIG_NETFILTER_SYNPROXY_MODULE 1
CONFIG_TPL0102_MODULE 1
CONFIG_FS_DAX 1
CONFIG_INTEL_TH_MSU_MODULE 1
CONFIG_SND_SOC_RT5677_MODULE 1
CONFIG_NLS_CODEPAGE_737_MODULE 1
CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
CONFIG_HW_RANDOM_VIA_MODULE 1
CONFIG_SUNDANCE_MODULE 1
CONFIG_SENSORS_W83781D_MODULE 1
CONFIG_I2C_DESIGNWARE_PLATFORM 1
CONFIG_CAN_SOFTING_CS_MODULE 1
CONFIG_HAVE_CMPXCHG_LOCAL 1
CONFIG_NVDIMM_PFN 1
CONFIG_AF_KCM_MODULE 1
CONFIG_VIDEOBUF2_CORE_MODULE 1
CONFIG_PARIDE_COMM_MODULE 1
CONFIG_DVB_HELENE_MODULE 1
CONFIG_SSB_DRIVER_GPIO 1
CONFIG_MTD_PHYSMAP_GPIO_ADDR 1
CONFIG_EEEPC_WMI_MODULE 1
CONFIG_INPUT_ADXL34X_I2C_MODULE 1
CONFIG_TREE_SRCU 1
CONFIG_CRYPTO_NULL2 1
CONFIG_NTFS_FS_MODULE 1
CONFIG_VIDEO_AU0828_V4L2 1
CONFIG_REGULATOR_MAX8998_MODULE 1
CONFIG_ACPI_THERMAL 1
CONFIG_SLIM_QCOM_CTRL_MODULE 1
CONFIG_NET_DSA_LANTIQ_GSWIP_MODULE 1
CONFIG_RT2X00_LIB_CRYPTO 1
CONFIG_CRYPTO_LIB_DES_MODULE 1
CONFIG_SCSI_DH_HP_SW_MODULE 1
CONFIG_IP_SCTP_MODULE 1
CONFIG_DVB_STB0899_MODULE 1
CONFIG_INPUT_SOC_BUTTON_ARRAY_MODULE 1
CONFIG_P54_PCI_MODULE 1
CONFIG_LEDS_ADP5520_MODULE 1
CONFIG_SCSI_SIM710_MODULE 1
CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE 1
CONFIG_MADERA_IRQ_MODULE 1
CONFIG_SERIAL_8250_DMA 1
CONFIG_VIDEO_IPU3_IMGU_MODULE 1
CONFIG_BASE_SMALL 0
CONFIG_IWLEGACY_DEBUGFS 1
CONFIG_ADE7854_I2C_MODULE 1
CONFIG_INPUT_GPIO_VIBRA_MODULE 1
CONFIG_XEN_GRANT_DEV_ALLOC_MODULE 1
CONFIG_PM_WAKELOCKS 1
CONFIG_CRYPTO_BLKCIPHER2 1
CONFIG_COUNTER_MODULE 1
CONFIG_SCSI_SAS_ATTRS_MODULE 1
CONFIG_SECURITY_SELINUX_AVC_STATS 1
CONFIG_RTL8187_MODULE 1
CONFIG_X86_PMEM_LEGACY_DEVICE 1
CONFIG_NFP_APP_ABM_NIC 1
CONFIG_SND_SEQ_DUMMY_MODULE 1
CONFIG_QTNFMAC_MODULE 1
CONFIG_B43LEGACY_PCI_AUTOSELECT 1
CONFIG_DM_RAID_MODULE 1
CONFIG_COMPACTION 1
CONFIG_ARCH_HAS_UACCESS_MCSAFE 1
CONFIG_NFS_V2_MODULE 1
CONFIG_RTW88_DEBUG 1
CONFIG_USB_HCD_BCMA_MODULE 1
CONFIG_ADE7854_SPI_MODULE 1
CONFIG_SCSI_MPT3SAS_MAX_SGE 128
CONFIG_CAN_SJA1000_ISA_MODULE 1
CONFIG_QLGE_MODULE 1
CONFIG_DVB_TDA18271C2DD_MODULE 1
CONFIG_USB_AIRSPY_MODULE 1
CONFIG_ALIENWARE_WMI_MODULE 1
CONFIG_VIDEO_TM6000_MODULE 1
CONFIG_DVB_CXD2820R_MODULE 1
CONFIG_WM8350_WATCHDOG_MODULE 1
CONFIG_BT_HCIUART_MRVL 1
CONFIG_VIDEO_TDA7432_MODULE 1
CONFIG_TEST_POWER_MODULE 1
CONFIG_SND_INTEL_NHLT 1
CONFIG_NF_DUP_IPV6_MODULE 1
CONFIG_RTL8723BE_MODULE 1
CONFIG_Z3FOLD_MODULE 1
CONFIG_RTC_DRV_DS2404_MODULE 1
CONFIG_DM_ERA_MODULE 1
CONFIG_COMEDI_NI_DAQ_DIO24_CS_MODULE 1
CONFIG_USB_GSPCA_SONIXJ_MODULE 1
CONFIG_SERIAL_ALTERA_UART_BAUDRATE 115200
CONFIG_THINKPAD_ACPI_HOTKEY_POLL 1
CONFIG_REGULATOR_MT6323_MODULE 1
CONFIG_USB_SERIAL_F81232_MODULE 1
CONFIG_DRM_AMDGPU_MODULE 1
CONFIG_VIDEO_OV7670_MODULE 1
CONFIG_RTC_DRV_DS1553_MODULE 1
CONFIG_TOUCHSCREEN_HAMPSHIRE_MODULE 1
CONFIG_CRYPTO_KHAZAD_MODULE 1
CONFIG_TOUCHSCREEN_TSC2005_MODULE 1
CONFIG_PROC_FS 1
CONFIG_MMC_CB710_MODULE 1
CONFIG_MTD_BLOCK_MODULE 1
CONFIG_SND_OXFW_MODULE 1
CONFIG_MPL3115_MODULE 1
CONFIG_ACPI_HOTPLUG_MEMORY 1
CONFIG_VIDEOBUF2_VMALLOC_MODULE 1
CONFIG_NFT_BRIDGE_REJECT_MODULE 1
CONFIG_GENERIC_BUG_RELATIVE_POINTERS 1
CONFIG_SND_SOC_WM8523_MODULE 1
CONFIG_6LOWPAN_NHC_FRAGMENT_MODULE 1
CONFIG_SECURITY_TOMOYO 1
CONFIG_RC_MAP_MODULE 1
CONFIG_WEXT_PRIV 1
CONFIG_THINKPAD_ACPI_VIDEO 1
CONFIG_VIRTIO_MMIO 1
CONFIG_NET_VENDOR_ROCKER 1
CONFIG_SCSI_LOWLEVEL 1
CONFIG_SND_SOC_MAX98504_MODULE 1
CONFIG_DP83822_PHY_MODULE 1
CONFIG_ROSE_MODULE 1
CONFIG_HYPERV_VSOCKETS_MODULE 1
CONFIG_INTEL_SOC_PMIC_CHTDC_TI_MODULE 1
CONFIG_INTEL_SOC_DTS_IOSF_CORE_MODULE 1
CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE 1
CONFIG_IP_VS_PROTO_AH_ESP 1
CONFIG_MTD_QINFO_PROBE_MODULE 1
CONFIG_GREYBUS_POWER_MODULE 1
CONFIG_SND_SOC_NAU8825_MODULE 1
CONFIG_MEMFD_CREATE 1
CONFIG_INPUT_DRV260X_HAPTICS_MODULE 1
CONFIG_DEV_DAX_PMEM_COMPAT_MODULE 1
CONFIG_IRQ_FORCED_THREADING 1
CONFIG_NILFS2_FS_MODULE 1
CONFIG_ATH9K_PCI 1
CONFIG_GNSS_SERIAL_MODULE 1
CONFIG_TOUCHSCREEN_HIDEEP_MODULE 1
CONFIG_NET_DSA_REALTEK_SMI_MODULE 1
CONFIG_EDAC_ATOMIC_SCRUB 1
CONFIG_NFSD_FLEXFILELAYOUT 1
CONFIG_USB_F_HID_MODULE 1
CONFIG_NLS_ISO8859_3_MODULE 1
CONFIG_RSI_91X_MODULE 1
CONFIG_FB_OPENCORES_MODULE 1
CONFIG_XEN_SYS_HYPERVISOR 1
CONFIG_CRYPTO_CMAC_MODULE 1
CONFIG_DELL_SMBIOS_WMI 1
CONFIG_INTEL_TELEMETRY_MODULE 1
CONFIG_IIO_CROS_EC_LIGHT_PROX_MODULE 1
CONFIG_MAX30100_MODULE 1
CONFIG_MEDIA_TUNER_TDA18250_MODULE 1
CONFIG_BATMAN_ADV_SYSFS 1
CONFIG_COMEDI_PCL816_MODULE 1
CONFIG_HID_PANTHERLORD_MODULE 1
CONFIG_DRM_FBDEV_EMULATION 1
CONFIG_MTDRAM_ERASE_SIZE 128
CONFIG_SND_MODULE 1
CONFIG_MTD_ICHXROM_MODULE 1
CONFIG_UBIFS_FS_AUTHENTICATION 1
CONFIG_SND_SOC_STI_SAS_MODULE 1
CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_MODULE 1
CONFIG_SND_SOC_INTEL_SST_MODULE 1
CONFIG_IIO_ST_GYRO_I2C_3AXIS_MODULE 1
CONFIG_NET_SCH_TEQL_MODULE 1
CONFIG_EROFS_FS_CLUSTER_PAGE_LIMIT 1
CONFIG_MEMSTICK_JMICRON_38X_MODULE 1
CONFIG_SENSORS_MCP3021_MODULE 1
CONFIG_SND_SOC_SOF_COFFEELAKE_SUPPORT 1
CONFIG_IR_RC6_DECODER_MODULE 1
CONFIG_XEN_NETDEV_BACKEND_MODULE 1
CONFIG_LTC2485_MODULE 1
CONFIG_MFD_LP3943_MODULE 1
CONFIG_RTC_DRV_ABB5ZES3_MODULE 1
CONFIG_SCSI_SNIC_MODULE 1
CONFIG_KXCJK1013_MODULE 1
CONFIG_MTD_OOPS_MODULE 1
CONFIG_IWLEGACY_MODULE 1
CONFIG_SCSI_INIA100_MODULE 1
CONFIG_S2IO_MODULE 1
CONFIG_IP_VS_SH_MODULE 1
CONFIG_XEN_BALLOON 1
CONFIG_VIDEO_MSP3400_MODULE 1
CONFIG_VIDEO_BT856_MODULE 1
CONFIG_USB_F_OBEX_MODULE 1
CONFIG_PLIP_MODULE 1
CONFIG_CRYPTO_SERPENT_AVX_X86_64_MODULE 1
CONFIG_TCG_TIS_SPI_MODULE 1
CONFIG_MC3230_MODULE 1
CONFIG_USB_PEGASUS_MODULE 1
CONFIG_NET_DSA_MICROCHIP_KSZ8795_MODULE 1
CONFIG_IIO_ST_MAGN_3AXIS_MODULE 1
CONFIG_HI8435_MODULE 1
CONFIG_USB_TMC_MODULE 1
CONFIG_SND_SOC_WM8962_MODULE 1
CONFIG_NET_VRF_MODULE 1
CONFIG_INPUT_E3X0_BUTTON_MODULE 1
CONFIG_USB_G_WEBCAM_MODULE 1
CONFIG_SBC_EPX_C3_WATCHDOG_MODULE 1
CONFIG_ATM_HE_USE_SUNI 1
CONFIG_PCIE_DW 1
CONFIG_ATH9K_PCI_NO_EEPROM_MODULE 1
CONFIG_NET_DSA_SMSC_LAN9303_MODULE 1
CONFIG_BLK_DEV_FD_MODULE 1
CONFIG_LCD_HX8357_MODULE 1
CONFIG_V4L_PLATFORM_DRIVERS 1
CONFIG_W1_SLAVE_DS2408_READBACK 1
CONFIG_EVM 1
CONFIG_SND_PCSP_MODULE 1
CONFIG_FB_NVIDIA_I2C 1
CONFIG_SND_SOC_SOF_HDA_COMMON_MODULE 1
CONFIG_RFKILL_INPUT 1
CONFIG_NXP_TJA11XX_PHY_MODULE 1
CONFIG_COMEDI_NI_USB6501_MODULE 1
CONFIG_BLK_MQ_RDMA 1
CONFIG_RAPIDIO_MPORT_CDEV_MODULE 1
CONFIG_FB_CIRRUS_MODULE 1
CONFIG_SENSORS_MAX20751_MODULE 1
CONFIG_DEV_DAX_MODULE 1
CONFIG_NET_VENDOR_NATSEMI 1
CONFIG_USB_MUSB_DUAL_ROLE 1
CONFIG_BLK_DEV_BSGLIB 1
CONFIG_NET_DSA_TAG_MTK_MODULE 1
CONFIG_GPIO_TPS68470 1
CONFIG_ATH5K_PCI 1
CONFIG_MEDIA_TUNER_FC2580_MODULE 1
CONFIG_AQUANTIA_PHY_MODULE 1
CONFIG_UNISYS_VISORINPUT_MODULE 1
CONFIG_TABLET_USB_HANWANG_MODULE 1
CONFIG_USB_DWC3_HAPS_MODULE 1
CONFIG_RTW88_8822CE 1
CONFIG_USB_F_MASS_STORAGE_MODULE 1
CONFIG_REGULATOR_AAT2870_MODULE 1
CONFIG_MENF21BMC_WATCHDOG_MODULE 1
CONFIG_ATH9K_COMMON_MODULE 1
CONFIG_NFT_XFRM_MODULE 1
CONFIG_NET_VENDOR_GOOGLE 1
CONFIG_CRYPTO_DEV_QAT_C62XVF_MODULE 1
CONFIG_DVB_STB6000_MODULE 1
CONFIG_SERIAL_FSL_LINFLEXUART_MODULE 1
CONFIG_SND_SOC_CS35L36_MODULE 1
CONFIG_SND_FIREWIRE_MOTU_MODULE 1
CONFIG_COMEDI_MISC_DRIVERS 1
CONFIG_USB_SERIAL_QCAUX_MODULE 1
CONFIG_NFSD_BLOCKLAYOUT 1
CONFIG_SATA_ACARD_AHCI_MODULE 1
CONFIG_GENERIC_IRQ_MIGRATION 1
CONFIG_NET_VENDOR_NETRONOME 1
CONFIG_NFS_USE_KERNEL_DNS 1
CONFIG_SENSORS_MAX31722_MODULE 1
CONFIG_MISDN_SPEEDFAX_MODULE 1
CONFIG_SENSORS_IBMAEM_MODULE 1
CONFIG_DMA_ENGINE_RAID 1
CONFIG_INTEL_MIC_HOST_MODULE 1
CONFIG_ARCH_HAS_FORTIFY_SOURCE 1
CONFIG_GCC_VERSION 90400
CONFIG_SND_HDA_I915 1
CONFIG_QCOM_SPMI_VADC_MODULE 1
CONFIG_EXTCON_PTN5150_MODULE 1
CONFIG_LATTICE_ECP3_CONFIG_MODULE 1
CONFIG_SYSCTL 1
CONFIG_CRYPTO_DES3_EDE_X86_64_MODULE 1
CONFIG_842_DECOMPRESS_MODULE 1
CONFIG_ARCH_HAS_GCOV_PROFILE_ALL 1
CONFIG_SND_USB_AUDIO_USE_MEDIA_CONTROLLER 1
CONFIG_VIDEO_TLV320AIC23B_MODULE 1
CONFIG_BRIDGE_IGMP_SNOOPING 1
CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE 1
CONFIG_MTD_BLOCK2MTD_MODULE 1
CONFIG_W1_SLAVE_THERM_MODULE 1
CONFIG_CAN_SLCAN_MODULE 1
CONFIG_PCIE_DW_EP 1
CONFIG_PARIDE_KBIC_MODULE 1
CONFIG_JOYSTICK_TWIDJOY_MODULE 1
CONFIG_EL3_MODULE 1
CONFIG_PHYS_ADDR_T_64BIT 1
CONFIG_COMEDI_DT2815_MODULE 1
CONFIG_SND_SOC_RT5663_MODULE 1
CONFIG_THREAD_INFO_IN_TASK 1
CONFIG_DVB_M88DS3103_MODULE 1
CONFIG_NOZOMI_MODULE 1
CONFIG_COMEDI_PCL711_MODULE 1
CONFIG_USB_DWC3_ULPI 1
CONFIG_MLX4_EN_DCB 1
CONFIG_CRYPTO_842_MODULE 1
CONFIG_NETFILTER_XT_TARGET_AUDIT_MODULE 1
CONFIG_VT6655_MODULE 1
CONFIG_TOUCHSCREEN_PIXCIR_MODULE 1
CONFIG_HOSTAP_CS_MODULE 1
CONFIG_MLX90632_MODULE 1
CONFIG_INTEL_TH_ACPI_MODULE 1
CONFIG_WM831X_BACKUP_MODULE 1
CONFIG_HAVE_C_RECORDMCOUNT 1
CONFIG_GENERIC_MSI_IRQ 1
CONFIG_SND_SOC_AMD_ACP_MODULE 1
CONFIG_SENSORS_ADCXX_MODULE 1
CONFIG_SND_CS4281_MODULE 1
CONFIG_COMEDI_8255_MODULE 1
CONFIG_MEDIA_TUNER_MT2131_MODULE 1
CONFIG_SENSORS_DELL_SMM_MODULE 1
CONFIG_INFINIBAND_I40IW_MODULE 1
CONFIG_HID_THINGM_MODULE 1
CONFIG_USB_NET_KALMIA_MODULE 1
CONFIG_IR_TTUSBIR_MODULE 1
CONFIG_ATH6KL_SDIO_MODULE 1
CONFIG_USB_NET_DM9601_MODULE 1
CONFIG_HAVE_ARCH_TRACEHOOK 1
CONFIG_RTC_DRV_WILCO_EC_MODULE 1
CONFIG_SSB_PCIHOST 1
CONFIG_FXAS21002C_MODULE 1
CONFIG_RPMSG_CHAR_MODULE 1
CONFIG_SND_SOC_INTEL_KBL_RT5663_MAX98927_MACH_MODULE 1
CONFIG_WATCHDOG_PRETIMEOUT_GOV 1
CONFIG_IR_MCEUSB_MODULE 1
CONFIG_IIO_ST_ACCEL_I2C_3AXIS_MODULE 1
CONFIG_LDM_PARTITION 1
CONFIG_CIFS_MODULE 1
CONFIG_DRM_FBDEV_OVERALLOC 100
CONFIG_SMSC37B787_WDT_MODULE 1
CONFIG_XFRM_USER_MODULE 1
CONFIG_BMI160_I2C_MODULE 1
CONFIG_I3C_MODULE 1
CONFIG_TCP_CONG_BIC_MODULE 1
CONFIG_EXTCON_PALMAS_MODULE 1
CONFIG_LEDS_PCA9532_MODULE 1
CONFIG_TASK_DELAY_ACCT 1
CONFIG_IR_IGORPLUGUSB_MODULE 1
CONFIG_INPUT_PCF50633_PMU_MODULE 1
CONFIG_INPUT_DA9063_ONKEY_MODULE 1
CONFIG_SCSI_DH_EMC_MODULE 1
CONFIG_EXTCON_USB_GPIO_MODULE 1
CONFIG_NET_NS 1
CONFIG_USB_ISP1760_DUAL_ROLE 1
CONFIG_SENSORS_TMP401_MODULE 1
CONFIG_XEN_BALLOON_MEMORY_HOTPLUG_LIMIT 512
CONFIG_REGULATOR_MAX1586_MODULE 1
CONFIG_REISERFS_FS_XATTR 1
CONFIG_SENSORS_ADT7475_MODULE 1
CONFIG_MEMORY 1
CONFIG_HAVE_PERF_EVENTS 1
CONFIG_PCMCIA_XIRCOM_MODULE 1
CONFIG_EVM_ADD_XATTRS 1
CONFIG_COMEDI_II_PCI20KC_MODULE 1
CONFIG_EISA_VLB_PRIMING 1
CONFIG_B53_SRAB_DRIVER_MODULE 1
CONFIG_BT_HCIBTUSB_AUTOSUSPEND 1
CONFIG_CRYPTO_DEV_QAT_C62X_MODULE 1
CONFIG_DVB_MANTIS_MODULE 1
CONFIG_SENSORS_LIS3_I2C_MODULE 1
CONFIG_GPD_POCKET_FAN_MODULE 1
CONFIG_RT2800PCI_RT35XX 1
CONFIG_MTD_NAND_GPIO_MODULE 1
CONFIG_CAN_C_CAN_MODULE 1
CONFIG_BTT 1
CONFIG_ATA_SFF 1
CONFIG_LEDS_MENF21BMC_MODULE 1
CONFIG_JOYSTICK_WALKERA0701_MODULE 1
CONFIG_CRYPTO_LRW_MODULE 1
CONFIG_NVME_TCP_MODULE 1
CONFIG_RTC_DRV_DS1685_FAMILY_MODULE 1
CONFIG_REGULATOR_WM8350_MODULE 1
CONFIG_IWLWIFI_OPMODE_MODULAR 1
CONFIG_NET_EMATCH_CMP_MODULE 1
CONFIG_UV_MMTIMER_MODULE 1
CONFIG_USB_GSPCA_T613_MODULE 1
CONFIG_MLXSW_SWITCHX2_MODULE 1
CONFIG_SND_VIA82XX_MODEM_MODULE 1
CONFIG_SND_SOC_WM8580_MODULE 1
CONFIG_TOUCHSCREEN_DMI 1
CONFIG_SND_MTPAV_MODULE 1
CONFIG_PPP_ASYNC_MODULE 1
CONFIG_MD_RAID10_MODULE 1
CONFIG_NFSD_SCSILAYOUT 1
CONFIG_HAVE_ALIGNED_STRUCT_PAGE 1
CONFIG_VIDEO_NOON010PC30_MODULE 1
CONFIG_SSB_SDIOHOST_POSSIBLE 1
CONFIG_SENSORS_APPLESMC_MODULE 1
CONFIG_NET_VENDOR_SOLARFLARE 1
CONFIG_CAN_GW_MODULE 1
CONFIG_NLS_CODEPAGE_866_MODULE 1
CONFIG_SENSORS_ABITUGURU3_MODULE 1
CONFIG_CRAMFS_MODULE 1
CONFIG_RADIO_SAA7706H_MODULE 1
CONFIG_SKGE_GENESIS 1
CONFIG_WM831X_POWER_MODULE 1
CONFIG_PINCTRL_SUNRISEPOINT_MODULE 1
CONFIG_TINYDRM_ILI9341_MODULE 1
CONFIG_LEDS_TRIGGER_TRANSIENT_MODULE 1
CONFIG_CYCLADES_MODULE 1
CONFIG_KEYBOARD_LM8323_MODULE 1
CONFIG_STMMAC_ETH_MODULE 1
CONFIG_CHELSIO_T1_MODULE 1
CONFIG_PCIE_DW_PLAT 1
CONFIG_COMEDI_AIO_AIO12_8_MODULE 1
CONFIG_NFSD_V4_SECURITY_LABEL 1
CONFIG_QCOM_HIDMA_MGMT_MODULE 1
CONFIG_CEPH_FS_POSIX_ACL 1
CONFIG_BLK_DEV_PMEM_MODULE 1
CONFIG_AUDIT 1
CONFIG_WILCO_EC_MODULE 1
CONFIG_CHR_DEV_ST_MODULE 1
CONFIG_RTC_DRV_TPS65910_MODULE 1
CONFIG_BATTERY_RT5033_MODULE 1
CONFIG_BCH_MODULE 1
CONFIG_INTEL_IOMMU 1
CONFIG_DVB_GP8PSK_FE_MODULE 1
CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE 1
CONFIG_DM_MULTIPATH_MODULE 1
CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE 1
CONFIG_SCSI_3W_SAS_MODULE 1
CONFIG_BPF_JIT_ALWAYS_ON 1
CONFIG_COMEDI_NI_ATMIO16D_MODULE 1
CONFIG_REGULATOR_MC13892_MODULE 1
CONFIG_SENSORS_LM80_MODULE 1
CONFIG_CMA_AREAS 7
CONFIG_EXTCON_FSA9480_MODULE 1
CONFIG_PCI_HYPERV_MODULE 1
CONFIG_PCIEASPM 1
CONFIG_PM_ADVANCED_DEBUG 1
CONFIG_MT76_LEDS 1
CONFIG_INTEL_IDMA64_MODULE 1
CONFIG_VME_TSI148_MODULE 1
CONFIG_SND_SOC_RT5514_MODULE 1
CONFIG_ATA_PIIX 1
CONFIG_B43LEGACY_MODULE 1
CONFIG_SND_SOC_WM8904_MODULE 1
CONFIG_AIC7XXX_REG_PRETTY_PRINT 1
CONFIG_HID_MULTITOUCH_MODULE 1
CONFIG_ECRYPT_FS_MESSAGING 1
CONFIG_FB_DEFERRED_IO 1
CONFIG_SATA_AHCI_MODULE 1
CONFIG_COMEDI_MITE_MODULE 1
CONFIG_RTW88_8723DE 1
CONFIG_SLAB_FREELIST_RANDOM 1
CONFIG_DVB_USB_A800_MODULE 1
CONFIG_SYSTEMPORT_MODULE 1
CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH_MODULE 1
CONFIG_XEN_BALLOON_MEMORY_HOTPLUG 1
CONFIG_SECURITY 1
CONFIG_I2C_SI470X_MODULE 1
CONFIG_DVB_A8293_MODULE 1
CONFIG_SENSORS_ASC7621_MODULE 1
CONFIG_OPTPROBES 1
CONFIG_USB_AMD5536UDC_MODULE 1
CONFIG_BE2NET_BE3 1
CONFIG_CHARGER_BQ2415X_MODULE 1
CONFIG_NETXEN_NIC_MODULE 1
CONFIG_BNX2X_SRIOV 1
CONFIG_ACPI_NUMA 1
CONFIG_SND_SOC_SOF_CANNONLAKE_SUPPORT 1
CONFIG_INTERCONNECT_MODULE 1
CONFIG_ATM_TCP_MODULE 1
CONFIG_USB_GR_UDC_MODULE 1
CONFIG_DVB_USB_CXUSB_ANALOG 1
CONFIG_REGULATOR_ISL9305_MODULE 1
CONFIG_SND_SOC_SOF_ELKHARTLAKE_MODULE 1
CONFIG_PCIE_DW_PLAT_EP 1
CONFIG_HID_ELECOM_MODULE 1
CONFIG_SND_TIMER_MODULE 1
CONFIG_COMEDI_ICP_MULTI_MODULE 1
CONFIG_BATTERY_DA9150_MODULE 1
CONFIG_KVM_MMIO 1
CONFIG_USB_EHCI_TT_NEWSCHED 1
CONFIG_FAT_DEFAULT_CODEPAGE 437
CONFIG_ALTERA_FREEZE_BRIDGE_MODULE 1
CONFIG_TCM_FC_MODULE 1
CONFIG_IPV6_MROUTE_MULTIPLE_TABLES 1
CONFIG_BLK_DEV 1
CONFIG_SND_SOC_TLV320AIC31XX_MODULE 1
CONFIG_SND_SOC_PCM179X_SPI_MODULE 1
CONFIG_SERIO_I8042 1
CONFIG_MAC80211_RC_DEFAULT "minstrel_ht"
CONFIG_NIC7018_WDT_MODULE 1
CONFIG_FARSYNC_MODULE 1
CONFIG_RTL8187_LEDS 1
CONFIG_NFS_ACL_SUPPORT_MODULE 1
CONFIG_RT2800USB_RT55XX 1
CONFIG_CHARGER_ADP5061_MODULE 1
CONFIG_W1_SLAVE_DS2433_MODULE 1
CONFIG_CHROME_PLATFORMS 1
CONFIG_ATL1_MODULE 1
CONFIG_APPLICOM_MODULE 1
CONFIG_USB_SERIAL_OMNINET_MODULE 1
CONFIG_HDLC_PPP_MODULE 1
CONFIG_X86_AMD_PLATFORM_DEVICE 1
CONFIG_BRIDGE_NETFILTER_MODULE 1
CONFIG_TCP_CONG_SCALABLE_MODULE 1
CONFIG_DVB_MB86A20S_MODULE 1
CONFIG_PATA_TRIFLEX_MODULE 1
CONFIG_LEDS_MLXREG_MODULE 1
CONFIG_COMEDI_PCL818_MODULE 1
CONFIG_JOYSTICK_TMDC_MODULE 1
CONFIG_MCP4922_MODULE 1
CONFIG_SERIAL_ALTERA_UART_MAXPORTS 4
CONFIG_SND_SYNTH_EMUX_MODULE 1
CONFIG_IOMMU_API 1
CONFIG_GPIO_GENERIC_MODULE 1
CONFIG_USB_CDNS3_HOST 1
CONFIG_TRACING_SUPPORT 1
CONFIG_SND_SOC_PCM3060_MODULE 1
CONFIG_UNIX98_PTYS 1
CONFIG_CDROM_PKTCDVD_MODULE 1
CONFIG_MS_BLOCK_MODULE 1
CONFIG_VFIO 1
CONFIG_MT76x2E_MODULE 1
CONFIG_NFC_MICROREAD_MEI_MODULE 1
CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE 1
CONFIG_MINIX_SUBPARTITION 1
CONFIG_CHROMEOS_PSTORE_MODULE 1
CONFIG_NET_RX_BUSY_POLL 1
CONFIG_RADIO_WL1273_MODULE 1
CONFIG_SENSORS_SMSC47B397_MODULE 1
CONFIG_CRYPTO_MICHAEL_MIC_MODULE 1
CONFIG_NET_VENDOR_SOCIONEXT 1
CONFIG_CRYPTO_ANSI_CPRNG_MODULE 1
CONFIG_SECURITY_SELINUX 1
CONFIG_ZONE_DMA32 1
CONFIG_NET_SCHED 1
CONFIG_LCD_LMS501KF03_MODULE 1
CONFIG_REGULATOR_TPS65086_MODULE 1
CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE 1
CONFIG_UWB_I1480U_MODULE 1
CONFIG_COMEDI_PCL726_MODULE 1
CONFIG_MFD_CS47L85 1
CONFIG_LIQUIDIO_MODULE 1
CONFIG_STAGING_MEDIA 1
CONFIG_NVME_RDMA_MODULE 1
CONFIG_DRM_PANEL 1
CONFIG_DVB_PLL_MODULE 1
CONFIG_PRINTK_TIME 1
CONFIG_PANEL_MODULE 1
CONFIG_SERIAL_JSM_MODULE 1
CONFIG_SND_SOC_INTEL_GLK_MODULE 1
CONFIG_VIDEO_VIVID_MAX_DEVS 64
CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
CONFIG_SECCOMP_FILTER 1
CONFIG_PATA_HPT37X_MODULE 1
CONFIG_SENSORS_RM3100_SPI_MODULE 1
CONFIG_MPU3050_MODULE 1
CONFIG_MLXSW_SWITCHIB_MODULE 1
CONFIG_SND_SOC_INTEL_SST_FIRMWARE_MODULE 1
CONFIG_UIO_PCI_GENERIC_MODULE 1
CONFIG_PPP 1
CONFIG_RFD_FTL_MODULE 1
CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE 1
CONFIG_TI_ST_MODULE 1
CONFIG_ARCH_MAY_HAVE_PC_FDC 1
CONFIG_NET_SCH_PIE_MODULE 1
CONFIG_TOUCHSCREEN_ATMEL_MXT_MODULE 1
CONFIG_NFT_FIB_IPV4_MODULE 1
CONFIG_HAVE_KERNEL_LZO 1
CONFIG_ASYNC_CORE_MODULE 1
CONFIG_INTEL_PMC_CORE 1
CONFIG_NET_SCH_MULTIQ_MODULE 1
CONFIG_INET_DIAG_MODULE 1
CONFIG_CRYPTO_GHASH 1
CONFIG_OCFS2_DEBUG_MASKLOG 1
CONFIG_SND_SOC_WM8741_MODULE 1
CONFIG_SYNCLINKMP_MODULE 1
CONFIG_PSTORE 1
CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW 1
CONFIG_SCSI_LPFC_MODULE 1
CONFIG_SND_SOC_CS53L30_MODULE 1
CONFIG_DVB_MN88443X_MODULE 1
CONFIG_NFC_ST95HF_MODULE 1
CONFIG_NF_NAT_FTP_MODULE 1
CONFIG_MAC80211_RC_MINSTREL 1
CONFIG_CRYPTO_RMD320_MODULE 1
CONFIG_IIO_CONSUMERS_PER_TRIGGER 2
CONFIG_NF_CT_PROTO_UDPLITE 1
CONFIG_VIRTIO_BLK_SCSI 1
CONFIG_CARDMAN_4000_MODULE 1
CONFIG_SPEAKUP_MODULE 1
CONFIG_IP6_NF_TARGET_SYNPROXY_MODULE 1
CONFIG_HANGCHECK_TIMER_MODULE 1
CONFIG_JOYSTICK_WARRIOR_MODULE 1
CONFIG_COMEDI_AIO_IIRO_16_MODULE 1
CONFIG_SENSORS_W83627EHF_MODULE 1
CONFIG_ELF_CORE 1
CONFIG_DEV_COREDUMP 1
CONFIG_NOTIFIER_ERROR_INJECTION_MODULE 1
CONFIG_SENSORS_LM73_MODULE 1
CONFIG_VIA_VELOCITY_MODULE 1
CONFIG_SENSORS_PC87360_MODULE 1
CONFIG_DVB_LNBH29_MODULE 1
CONFIG_TEXTSEARCH 1
CONFIG_DRM_AMDGPU_USERPTR 1
CONFIG_VIDEO_IVTV_MODULE 1
CONFIG_ACPI_DOCK 1
CONFIG_SND_SOC_CS4341_MODULE 1
CONFIG_USB_DWC3_MODULE 1
CONFIG_KS8851_MODULE 1
CONFIG_XEN_HAVE_PVMMU 1
CONFIG_MTD_JEDECPROBE_MODULE 1
CONFIG_TSYS01_MODULE 1
CONFIG_RTC_DRV_ABEOZ9_MODULE 1
CONFIG_NF_CT_NETLINK_HELPER_MODULE 1
CONFIG_INFINIBAND_ON_DEMAND_PAGING 1
CONFIG_INA2XX_ADC_MODULE 1
CONFIG_EFI_TEST_MODULE 1
CONFIG_MTD_ONENAND_VERIFY_WRITE 1
CONFIG_INPUT_PCF8574_MODULE 1
CONFIG_USB_SUPPORT 1
CONFIG_SOFT_WATCHDOG_PRETIMEOUT 1
CONFIG_NVME_TARGET_MODULE 1
CONFIG_I2C_SCMI_MODULE 1
CONFIG_I2C_VIA_MODULE 1
CONFIG_BMC150_MAGN_SPI_MODULE 1
CONFIG_INPUT_POLLDEV_MODULE 1
CONFIG_INPUT_MAX8925_ONKEY_MODULE 1
CONFIG_CRYPTO_DEV_QAT_C3XXX_MODULE 1
CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES 1
CONFIG_SND_SOC_SOF_GEMINILAKE_MODULE 1
CONFIG_SND_INTEL8X0M_MODULE 1
CONFIG_ACPI_DEBUG 1
CONFIG_MODIFY_LDT_SYSCALL 1
CONFIG_SENSORS_ADC128D818_MODULE 1
CONFIG_KEMPLD_WDT_MODULE 1
CONFIG_SURFACE3_WMI_MODULE 1
CONFIG_RTC_DRV_BQ32K_MODULE 1
CONFIG_USB_GSPCA_PAC7311_MODULE 1
CONFIG_HID_JABRA_MODULE 1
CONFIG_WLAN_VENDOR_ST 1
CONFIG_MAX44009_MODULE 1
CONFIG_COMEDI_PCMAD_MODULE 1
CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS 1
CONFIG_VIA_WDT_MODULE 1
CONFIG_UCLAMP_TASK 1
CONFIG_BLK_DEV_NVME_MODULE 1
CONFIG_BRCMFMAC_PROTO_BCDC 1
CONFIG_TWL4030_CORE 1
CONFIG_USB_HWA_HCD_MODULE 1
CONFIG_SPI_ZYNQMP_GQSPI_MODULE 1
CONFIG_TOUCHSCREEN_USB_EASYTOUCH 1
CONFIG_SND_SOC_TAS6424_MODULE 1
CONFIG_STAGING 1
CONFIG_NET_VENDOR_SIS 1
CONFIG_F2FS_FS_MODULE 1
CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE 1
CONFIG_FPGA_DFL_FME_MODULE 1
CONFIG_SND_SOC_RL6347A_MODULE 1
CONFIG_FB_RIVA_I2C 1
CONFIG_SENSORS_LIS3LV02D_MODULE 1
CONFIG_USB_CDNS3_MODULE 1
CONFIG_EXTCON_MAX14577_MODULE 1
CONFIG_AD9523_MODULE 1
CONFIG_SND_SOC_RT5645_MODULE 1
CONFIG_FIREWIRE_MODULE 1
CONFIG_WIZNET_W5100_SPI_MODULE 1
CONFIG_CHARGER_CROS_USBPD_MODULE 1
CONFIG_ATM_MODULE 1
CONFIG_MMIOTRACE 1
CONFIG_MAX63XX_WATCHDOG_MODULE 1
CONFIG_PAGE_POOL 1
CONFIG_CRYPTO_SM4_MODULE 1
CONFIG_TOUCHSCREEN_ST1232_MODULE 1
CONFIG_SCSI_FC_ATTRS_MODULE 1
CONFIG_VT_CONSOLE 1
CONFIG_EDAC_SBRIDGE_MODULE 1
CONFIG_HID_UCLOGIC_MODULE 1
CONFIG_VFIO_MDEV_MODULE 1
CONFIG_HW_RANDOM_VIRTIO_MODULE 1
CONFIG_COMEDI_PCMCIA_DRIVERS_MODULE 1
CONFIG_REGULATOR_88PG86X_MODULE 1
CONFIG_ACPI_APEI 1
CONFIG_SND_SOC_PCM186X_MODULE 1
CONFIG_SND_ES1968_RADIO 1
CONFIG_MT7615E_MODULE 1
CONFIG_LEDS_GPIO_MODULE 1
CONFIG_SENSIRION_SGP30_MODULE 1
CONFIG_SND_SB_COMMON_MODULE 1
CONFIG_LED_TRIGGER_PHY 1
CONFIG_CFG80211_WEXT_EXPORT 1
CONFIG_SND_CS46XX_MODULE 1
CONFIG_SCHED_INFO 1
CONFIG_USB_GSPCA_STK014_MODULE 1
CONFIG_MQ_IOSCHED_KYBER_MODULE 1
CONFIG_ACPI_DEBUGGER 1
CONFIG_IP_VS_FTP_MODULE 1
CONFIG_KEYBOARD_APPLESPI_MODULE 1
CONFIG_FANOTIFY_ACCESS_PERMISSIONS 1
CONFIG_SENSORS_LM3533_MODULE 1
CONFIG_EFI_EARLYCON 1
CONFIG_IIO_ST_PRESS_I2C_MODULE 1
CONFIG_STM_SOURCE_FTRACE_MODULE 1
CONFIG_VIDEO_CX18_MODULE 1
CONFIG_XILINX_WATCHDOG_MODULE 1
CONFIG_VMWARE_PVSCSI_MODULE 1
CONFIG_CFG80211_WEXT 1
CONFIG_VIRTIO_VSOCKETS_MODULE 1
CONFIG_WLAN_VENDOR_MARVELL 1
CONFIG_VIDEO_OV8856_MODULE 1
CONFIG_SERIAL_SCCNXP_CONSOLE 1
CONFIG_SMARTJOYPLUS_FF 1
CONFIG_SND_SOC_XTFPGA_I2S_MODULE 1
CONFIG_I2C_PARPORT_MODULE 1
CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE 1
CONFIG_NOP_USB_XCEIV_MODULE 1
CONFIG_NET_SOCK_MSG 1
CONFIG_GPIO_DA9052_MODULE 1
CONFIG_BRCMFMAC_PCIE 1
CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE 1
CONFIG_EXTCON_MAX77843_MODULE 1
CONFIG_SND_VIA82XX_MODULE 1
CONFIG_CC10001_ADC_MODULE 1
CONFIG_NFC_PN533_MODULE 1
CONFIG_REGULATOR_ANATOP_MODULE 1
CONFIG_DVB_USB_DIBUSB_MB_MODULE 1
CONFIG_SERIAL_8250_DWLIB 1
CONFIG_TWL6030_GPADC_MODULE 1
CONFIG_GREYBUS_GPIO_MODULE 1
CONFIG_SND_DARLA20_MODULE 1
CONFIG_MFD_MAX77843 1
CONFIG_SND_SEQ_MIDI_MODULE 1
CONFIG_BLK_DEV_RAM_MODULE 1
CONFIG_USB_F_NCM_MODULE 1
CONFIG_ARCH_MMAP_RND_COMPAT_BITS 8
CONFIG_TOUCHSCREEN_AD7879_MODULE 1
CONFIG_MMA9553_MODULE 1
CONFIG_SENSORS_HDAPS_MODULE 1
CONFIG_NETFILTER_XT_MATCH_STATE_MODULE 1
CONFIG_DVB_L64781_MODULE 1
CONFIG_TOUCHSCREEN_RM_TS_MODULE 1
CONFIG_INPUT_EVBUG_MODULE 1
CONFIG_NET_DSA_BCM_SF2_MODULE 1
CONFIG_IEEE802154_AT86RF230_DEBUGFS 1
CONFIG_LOGIRUMBLEPAD2_FF 1
CONFIG_SND_INDIGOIOX_MODULE 1
CONFIG_VIDEO_OV772X_MODULE 1
CONFIG_MFD_TPS6586X 1
CONFIG_SND_ASIHPI_MODULE 1
CONFIG_EROFS_FS_XATTR 1
CONFIG_SND_SOC_SOF_MODULE 1
CONFIG_BSD_DISKLABEL 1
CONFIG_RTC_DRV_M48T35_MODULE 1
CONFIG_I2C_TAOS_EVM_MODULE 1
CONFIG_CRYPTO_CAST_COMMON_MODULE 1
CONFIG_IIO_TRIGGERED_BUFFER_MODULE 1
CONFIG_COMEDI_KCOMEDILIB_MODULE 1
CONFIG_FB_HGA_MODULE 1
CONFIG_XEN_PVH 1
CONFIG_RTC_DRV_PCF2127_MODULE 1
CONFIG_USB_STORAGE_FREECOM_MODULE 1
CONFIG_LCD_VGG2432A4_MODULE 1
CONFIG_MFD_TPS65086_MODULE 1
CONFIG_SCSI_BUSLOGIC_MODULE 1
CONFIG_BRIDGE_EBT_LOG_MODULE 1
CONFIG_VIDEO_THS8200_MODULE 1
CONFIG_MICROCHIP_PHY_MODULE 1
CONFIG_TOUCHSCREEN_ADS7846_MODULE 1
CONFIG_BACKLIGHT_CARILLO_RANCH_MODULE 1
CONFIG_OPENVSWITCH_VXLAN_MODULE 1
CONFIG_FONT_6x10 1
CONFIG_GADGET_UAC1 1
CONFIG_IR_RC5_DECODER_MODULE 1
CONFIG_REGULATOR_S5M8767_MODULE 1
CONFIG_FIREWIRE_NOSY_MODULE 1
CONFIG_NET_SCH_GRED_MODULE 1
CONFIG_PCI_DIRECT 1
CONFIG_MMC_VIA_SDMMC_MODULE 1
CONFIG_DRM_MODULE 1
CONFIG_VIDEO_S5K4ECGX_MODULE 1
CONFIG_FUSION_MAX_SGE 128
CONFIG_RTC_DRV_DA9055_MODULE 1
CONFIG_DRM_XEN 1
CONFIG_DRM_I915_FORCE_PROBE ""
CONFIG_DOUBLEFAULT 1
CONFIG_MCP4018_MODULE 1
CONFIG_SND_SOC_RT5682_MODULE 1
CONFIG_TOUCHSCREEN_ADC_MODULE 1
CONFIG_AD7150_MODULE 1
CONFIG_MEDIA_RADIO_SUPPORT 1
CONFIG_PCF50633_GPIO_MODULE 1
CONFIG_VIDEO_S5K5BAF_MODULE 1
CONFIG_IWL4965_MODULE 1
CONFIG_NET_DSA_SJA1105_PTP 1
CONFIG_PCIE_DPC 1
CONFIG_POSIX_MQUEUE_SYSCTL 1
CONFIG_RTC_DRV_MAX6900_MODULE 1
CONFIG_ICS932S401_MODULE 1
CONFIG_RIONET_TX_SIZE 128
CONFIG_XILINX_GMII2RGMII_MODULE 1
CONFIG_GPIO_WINBOND_MODULE 1
CONFIG_UNUSED_SYMBOLS 1
CONFIG_UDMABUF 1
CONFIG_SENSORS_MAX1111_MODULE 1
CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE 1
CONFIG_INTEL_TH_STH_MODULE 1
CONFIG_ISDN_DRV_AVMB1_B1PCIV4 1
CONFIG_SAMSUNG_LAPTOP_MODULE 1
CONFIG_BE2NET_HWMON 1
CONFIG_USB_USS720_MODULE 1
CONFIG_DEBUG_MISC 1
CONFIG_LEDS_DAC124S085_MODULE 1
CONFIG_FB_CFB_COPYAREA 1
CONFIG_USB_F_ECM_MODULE 1
CONFIG_GPIO_IT87_MODULE 1
CONFIG_FB_EFI 1
CONFIG_MOUSE_GPIO_MODULE 1
CONFIG_USB_SISUSBVGA_MODULE 1
CONFIG_DVB_RTL2830_MODULE 1
CONFIG_I40E_MODULE 1
CONFIG_BRIDGE_EBT_STP_MODULE 1
CONFIG_HAVE_KVM_IRQCHIP 1
CONFIG_SND_SOC_MTK_BTCVSD_MODULE 1
CONFIG_RT73USB_MODULE 1
CONFIG_USB_ULPI_BUS_MODULE 1
CONFIG_DE2104X_DSL 0
CONFIG_BRIDGE_EBT_ARP_MODULE 1
CONFIG_NET_VENDOR_MICROSEMI 1
CONFIG_BALLOON_COMPACTION 1
CONFIG_BMC150_ACCEL_I2C_MODULE 1
CONFIG_MANDATORY_FILE_LOCKING 1
CONFIG_CHARGER_MAX8997_MODULE 1
CONFIG_USB_CYTHERM_MODULE 1
CONFIG_MFD_TWL4030_AUDIO 1
CONFIG_HX711_MODULE 1
CONFIG_SND_SOC_MSM8916_WCD_ANALOG_MODULE 1
CONFIG_IP6_NF_MATCH_EUI64_MODULE 1
CONFIG_BINARY_PRINTF 1
CONFIG_MWIFIEX_MODULE 1
CONFIG_HP_ILO_MODULE 1
CONFIG_SATA_DWC_OLD_DMA 1
CONFIG_USB_STORAGE_JUMPSHOT_MODULE 1
CONFIG_SENSORS_MAX6642_MODULE 1
CONFIG_GPIO_MC33880_MODULE 1
CONFIG_SND_SOC_SGTL5000_MODULE 1
CONFIG_NET_SCH_PLUG_MODULE 1
CONFIG_SND_GINA20_MODULE 1
CONFIG_ACPI_REV_OVERRIDE_POSSIBLE 1
CONFIG_HARDLOCKUP_CHECK_TIMESTAMP 1
CONFIG_TRACER_MAX_TRACE 1
CONFIG_ZSTD_DECOMPRESS 1
CONFIG_USB_KEENE_MODULE 1
CONFIG_SND_SOC_SIMPLE_AMPLIFIER_MODULE 1
CONFIG_VIDEOBUF_GEN_MODULE 1
CONFIG_MTD_CFI_AMDSTD_MODULE 1
CONFIG_CLK_TWL6040_MODULE 1
CONFIG_LEDS_WM831X_STATUS_MODULE 1
CONFIG_SND_SOC_SOF_ICELAKE_SUPPORT 1
CONFIG_SGI_PARTITION 1
CONFIG_INPUT_SPARSEKMAP_MODULE 1
CONFIG_GPIO_PALMAS 1
CONFIG_BT_HCIUART_RTL 1
CONFIG_NF_LOG_NETDEV_MODULE 1
CONFIG_CRYPTO_TWOFISH_X86_64_3WAY_MODULE 1
CONFIG_HIO_MODULE 1
CONFIG_ADIS16400_MODULE 1
CONFIG_AIC7XXX_CMDS_PER_DEVICE 8
CONFIG_SYSFS_SYSCALL 1
CONFIG_WLAN_VENDOR_QUANTENNA 1
CONFIG_RTL8192EE_MODULE 1
CONFIG_SECURITY_INFINIBAND 1
CONFIG_TCG_XEN_MODULE 1
CONFIG_VIDEO_V4L2_MODULE 1
CONFIG_SND_PCM_TIMER 1
CONFIG_DVB_STV6110_MODULE 1
CONFIG_MPL115_I2C_MODULE 1
CONFIG_RTC_DRV_DS1685 1
CONFIG_AC97_BUS_MODULE 1
CONFIG_CW1200_MODULE 1
CONFIG_ARCH_HAS_SET_DIRECT_MAP 1
CONFIG_SYSVIPC_SYSCTL 1
CONFIG_SND_FIREWORKS_MODULE 1
CONFIG_QEDI_MODULE 1
CONFIG_NVME_FABRICS_MODULE 1
CONFIG_WLAN_VENDOR_TI 1
CONFIG_HID_NTRIG_MODULE 1
CONFIG_IP_VS_IPV6 1
CONFIG_X86_64_ACPI_NUMA 1
CONFIG_DMA_SHARED_BUFFER 1
CONFIG_RTC_SYSTOHC 1
CONFIG_DVB_USB_NOVA_T_USB2_MODULE 1
CONFIG_VHOST_SCSI_MODULE 1
CONFIG_CIFS_POSIX 1
CONFIG_AMD_XGBE_HAVE_ECC 1
CONFIG_PATA_RDC_MODULE 1
CONFIG_SND_PORTMAN2X4_MODULE 1
CONFIG_USB_EPSON2888 1
CONFIG_AF_RXRPC_IPV6 1
CONFIG_TOUCHSCREEN_ZET6223_MODULE 1
CONFIG_SND_INDIGODJ_MODULE 1
CONFIG_SENSORS_W83L785TS_MODULE 1
CONFIG_USB_SERIAL_MXUPORT_MODULE 1
CONFIG_W1_SLAVE_DS28E04_MODULE 1
CONFIG_DECOMPRESS_GZIP 1
CONFIG_SND_AW2_MODULE 1
CONFIG_SENSORS_EMC2103_MODULE 1
CONFIG_NLS_MAC_CELTIC_MODULE 1
CONFIG_SND_AU8830_MODULE 1
CONFIG_SPI_SC18IS602_MODULE 1
CONFIG_RTLLIB_CRYPTO_WEP_MODULE 1
CONFIG_THERMAL_GOV_POWER_ALLOCATOR 1
CONFIG_VIRTIO_MENU 1
CONFIG_VIRTIO_BLK_MODULE 1
CONFIG_AX88796B_PHY_MODULE 1
CONFIG_SERIAL_8250_CS_MODULE 1
CONFIG_NET_DSA_SJA1105_TAS 1
CONFIG_DECOMPRESS_LZO 1
CONFIG_CRYPTO_XXHASH_MODULE 1
CONFIG_USB_SERIAL_ARK3116_MODULE 1
CONFIG_64BIT 1
CONFIG_SND_MIXART_MODULE 1
CONFIG_PARPORT_PANEL_MODULE 1
CONFIG_QUOTA 1
CONFIG_SND_BT87X_MODULE 1
CONFIG_IIO_CROS_EC_SENSORS_CORE_MODULE 1
CONFIG_SENSORS_WM8350_MODULE 1
CONFIG_DM9102_MODULE 1
CONFIG_COMEDI_NI_MIO_CS_MODULE 1
CONFIG_SENSORS_LINEAGE_MODULE 1
CONFIG_CAN_EMS_PCMCIA_MODULE 1
CONFIG_SCSI_MPT2SAS_MAX_SGE 128
CONFIG_VXGE_MODULE 1
CONFIG_PARIDE_PCD_MODULE 1
CONFIG_ZBUD 1
CONFIG_MMC_SDHCI_PLTFM_MODULE 1
CONFIG_I2C_CHARDEV 1
CONFIG_MFD_MADERA_MODULE 1
CONFIG_MEDIA_TUNER_FC0013_MODULE 1
CONFIG_LLC_MODULE 1
CONFIG_MTD_NAND_NANDSIM_MODULE 1
CONFIG_REGULATOR_MAX8649_MODULE 1
CONFIG_ARCH_USE_QUEUED_RWLOCKS 1
CONFIG_VIDEO_ADV7183_MODULE 1
CONFIG_GENWQE_MODULE 1
CONFIG_MEDIA_TUNER_TEA5761_MODULE 1
CONFIG_MFD_MC13XXX_SPI_MODULE 1
CONFIG_SC92031_MODULE 1
CONFIG_I2C_MULTI_INSTANTIATE_MODULE 1
CONFIG_REGMAP_MMIO 1
CONFIG_ARCH_HAS_PKEYS 1
CONFIG_SND_TRIDENT_MODULE 1
CONFIG_INTEL_HID_EVENT_MODULE 1
CONFIG_GPIO_MB86S7X_MODULE 1
CONFIG_NETWORK_SECMARK 1
CONFIG_SND_RIPTIDE_MODULE 1
CONFIG_SND_CTXFI_MODULE 1
CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
CONFIG_VIDEO_TVAUDIO_MODULE 1
CONFIG_REGULATOR_MAX8907_MODULE 1
CONFIG_RXKAD 1
CONFIG_CRYPTO_SIMD_MODULE 1
CONFIG_HID_HOLTEK_MODULE 1
CONFIG_SND_SOC_ES7241_MODULE 1
CONFIG_POWER_SUPPLY_HWMON 1
CONFIG_KEYBOARD_SAMSUNG_MODULE 1
CONFIG_ARCH_RANDOM 1
CONFIG_SERIAL_8250_PCI 1
CONFIG_LIB80211_CRYPT_CCMP_MODULE 1
CONFIG_HAVE_MIXED_BREAKPOINTS_REGS 1
CONFIG_USB_GSPCA_DTCS033_MODULE 1
CONFIG_RTC_DRV_DS1672_MODULE 1
CONFIG_INTEL_MEI_MODULE 1
CONFIG_QCOM_SPMI_ADC5_MODULE 1
CONFIG_USB_SERIAL_SSU100_MODULE 1
CONFIG_BATMAN_ADV_DAT 1
CONFIG_MOUSE_PS2_SYNAPTICS 1
CONFIG_DVB_USB_DIB3000MC_MODULE 1
CONFIG_ATA_BMDMA 1
CONFIG_NFC_SIM_MODULE 1
CONFIG_ATALK_MODULE 1
CONFIG_XZ_DEC_ARMTHUMB 1
CONFIG_B43_BCMA 1
CONFIG_SND_SOC_RT5631_MODULE 1
CONFIG_AD7791_MODULE 1
CONFIG_SND_SOC_CS35L33_MODULE 1
CONFIG_MTD_SWAP_MODULE 1
CONFIG_USB_F_UAC1_MODULE 1
CONFIG_DW_EDMA_MODULE 1
CONFIG_JFFS2_CMODE_FAVOURLZO 1
CONFIG_SND_SOC_HDAC_HDA_MODULE 1
CONFIG_MEMORY_FAILURE 1
CONFIG_NFS_V4_1 1
CONFIG_SKFP_MODULE 1
CONFIG_ARCH_USE_CMPXCHG_LOCKREF 1
CONFIG_REGMAP 1
CONFIG_SFC_MCDI_MON 1
CONFIG_6PACK_MODULE 1
CONFIG_NLS_UTF8_MODULE 1
CONFIG_RADIO_SI470X_MODULE 1
CONFIG_PCIE_PME 1
CONFIG_TINYDRM_ILI9225_MODULE 1
CONFIG_VIDEO_TM6000_DVB_MODULE 1
CONFIG_JOYSTICK_XPAD_MODULE 1
CONFIG_FB_ATY_BACKLIGHT 1
CONFIG_BCMA_HOST_SOC 1
CONFIG_PHY_PXA_28NM_USB2_MODULE 1
CONFIG_SND_SOC_SSM2602_I2C_MODULE 1
CONFIG_HARDENED_USERCOPY 1
CONFIG_KS7010_MODULE 1
CONFIG_INFINIBAND_ISERT_MODULE 1
CONFIG_ADIS16130_MODULE 1
CONFIG_BAYCOM_PAR_MODULE 1
CONFIG_DRM_AMD_ACP 1
CONFIG_HAVE_MOD_ARCH_SPECIFIC 1
CONFIG_AB3100_CORE 1
CONFIG_FB_NOTIFY 1
CONFIG_CAN_DEV_MODULE 1
CONFIG_BACKLIGHT_WM831X_MODULE 1
CONFIG_INPUT_YEALINK_MODULE 1
CONFIG_VIDEO_ASPEED_MODULE 1
CONFIG_COMEDI_VMK80XX_MODULE 1
CONFIG_DVB_DIB3000MB_MODULE 1
CONFIG_IEEE802154_CC2520_MODULE 1
CONFIG_FW_CFG_SYSFS_MODULE 1
CONFIG_USB_PXA27X_MODULE 1
CONFIG_MFD_DA9055 1
CONFIG_SENSORS_NCT6683_MODULE 1
CONFIG_AD5755_MODULE 1
CONFIG_TI_ADC081C_MODULE 1
CONFIG_PKCS8_PRIVATE_KEY_PARSER_MODULE 1
CONFIG_SPEAKUP_SYNTH_SPKOUT_MODULE 1
CONFIG_TYPEC_NVIDIA_ALTMODE_MODULE 1
CONFIG_RTC_DRV_M41T80_MODULE 1
CONFIG_STRICT_MODULE_RWX 1
CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER_MODULE 1
CONFIG_SERIAL_MEN_Z135_MODULE 1
CONFIG_PCCARD_NONSTATIC 1
CONFIG_VT6656_MODULE 1
CONFIG_XEN_SCSI_FRONTEND_MODULE 1
CONFIG_USB_USBNET_MODULE 1
CONFIG_IIO_ST_LSM6DSX_MODULE 1
CONFIG_NET_DEVLINK 1
CONFIG_INTEL_SOC_PMIC_BXTWC_MODULE 1
CONFIG_EBC_C384_WDT_MODULE 1
CONFIG_PROC_PID_ARCH_STATUS 1
CONFIG_CPU_SUP_CENTAUR 1
CONFIG_SND_SOC_CS4271_MODULE 1
CONFIG_CB710_CORE_MODULE 1
CONFIG_USB_SERIAL_PL2303_MODULE 1
CONFIG_NET_ACT_POLICE_MODULE 1
CONFIG_AIC79XX_DEBUG_MASK 0
CONFIG_ASM_MODVERSIONS 1
CONFIG_UEFI_CPER 1
CONFIG_NODES_SPAN_OTHER_NODES 1
CONFIG_HAVE_INTEL_TXT 1
CONFIG_HAMRADIO 1
CONFIG_SYSCTL_EXCEPTION_TRACE 1
CONFIG_M62332_MODULE 1
CONFIG_REGULATOR_PCAP_MODULE 1
CONFIG_SERIAL_UARTLITE_NR_UARTS 1
CONFIG_SYSVIPC_COMPAT 1
CONFIG_GPIO_PCA953X_MODULE 1
CONFIG_INPUT_XEN_KBDDEV_FRONTEND_MODULE 1
CONFIG_HOTPLUG_PCI_SHPC 1
CONFIG_VIDEO_AD9389B_MODULE 1
CONFIG_HINIC_MODULE 1
CONFIG_ADIS16240_MODULE 1
CONFIG_DVB_USB_CINERGY_T2_MODULE 1
CONFIG_FHANDLE 1
CONFIG_COMEDI_ADDI_APCI_3XXX_MODULE 1
CONFIG_FS_VERITY_BUILTIN_SIGNATURES 1
CONFIG_SERIAL_ALTERA_UART_MODULE 1
CONFIG_USB_MICROTEK_MODULE 1
CONFIG_PANASONIC_LAPTOP_MODULE 1
CONFIG_INPUT_MC13783_PWRBUTTON_MODULE 1
CONFIG_HID_SMARTJOYPLUS_MODULE 1
CONFIG_WATCHDOG_OPEN_TIMEOUT 0
CONFIG_ATA_GENERIC 1
CONFIG_BPFILTER_UMH_MODULE 1
CONFIG_TOUCHSCREEN_GOODIX_MODULE 1
CONFIG_CRYPTO_LIB_SHA256 1
CONFIG_NEW_LEDS 1
CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_PCI_MODULE 1
CONFIG_SWAP 1
CONFIG_CRC64_MODULE 1
CONFIG_MTD_MCHP23K256_MODULE 1
CONFIG_AD5592R_BASE_MODULE 1
CONFIG_MFD_TPS80031 1
CONFIG_MTD_ONENAND_MODULE 1
CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP 1
CONFIG_B53_SPI_DRIVER_MODULE 1
CONFIG_NFT_BRIDGE_META_MODULE 1
CONFIG_MICROCODE_INTEL 1
CONFIG_GENERIC_ADC_BATTERY_MODULE 1
CONFIG_MOUSE_ELAN_I2C_I2C 1
CONFIG_RTC_DRV_DS1511_MODULE 1
CONFIG_USB_NET_CDC_SUBSET_ENABLE_MODULE 1
CONFIG_IP_FIB_TRIE_STATS 1
CONFIG_CRYPTO_SHA256_SSSE3_MODULE 1
CONFIG_ATM_FORE200E_MODULE 1
CONFIG_VIDEO_SOLO6X10_MODULE 1
CONFIG_MLX5_EN_RXNFC 1
CONFIG_NET_SCH_HFSC_MODULE 1
CONFIG_RTC_DRV_RV3029C2_MODULE 1
CONFIG_GPIO_TWL6040_MODULE 1
CONFIG_ADIN_PHY_MODULE 1
CONFIG_WIL6210_MODULE 1
CONFIG_SND_ISIGHT_MODULE 1
CONFIG_VIDEOBUF_DMA_SG_MODULE 1
CONFIG_MTD_NAND_DISKONCHIP_MODULE 1
CONFIG_MAC80211_MODULE 1
CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH_MODULE 1
CONFIG_SPI_ALTERA_MODULE 1
CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH 1
CONFIG_MEGARAID_MM_MODULE 1
CONFIG_BME680_I2C_MODULE 1
CONFIG_ARCH_USES_PG_UNCACHED 1
CONFIG_CRC_CCITT 1
CONFIG_SND_SOC_TS3A227E_MODULE 1
CONFIG_SND_SOC_XILINX_I2S_MODULE 1
CONFIG_IPVLAN_L3S 1
CONFIG_GPIOLIB_IRQCHIP 1
CONFIG_NET_VENDOR_CAVIUM 1
CONFIG_BPF_UNPRIV_DEFAULT_OFF 1
CONFIG_DVB_TDA8261_MODULE 1
CONFIG_SND_HDA_EXT_CORE_MODULE 1
CONFIG_IGBVF_MODULE 1
CONFIG_BLK_DEV_SD 1
CONFIG_SND_SEQ_VIRMIDI_MODULE 1
CONFIG_SND_SOC_SOF_APOLLOLAKE_MODULE 1
CONFIG_MFD_MAX14577 1
CONFIG_NET_NCSI 1
CONFIG_PHYSICAL_ALIGN 0x200000
CONFIG_SND_SOC_SOF_HDA_LINK_BASELINE_MODULE 1
CONFIG_ACPI_LEGACY_TABLES_LOOKUP 1
CONFIG_INPUT_AD714X_SPI_MODULE 1
CONFIG_NETFILTER_NETLINK_MODULE 1
CONFIG_VITESSE_PHY_MODULE 1
CONFIG_MODULE_UNLOAD 1
CONFIG_KEXEC_BZIMAGE_VERIFY_SIG 1
CONFIG_FSCACHE_STATS 1
CONFIG_DEVFREQ_GOV_USERSPACE 1
CONFIG_INFINIBAND_MTHCA_MODULE 1
CONFIG_SENSORS_MAX6650_MODULE 1
CONFIG_SPI_SLAVE 1
CONFIG_USB_GSPCA_BENQ_MODULE 1
CONFIG_HAVE_ACPI_APEI_NMI 1
CONFIG_REGULATOR_TPS65023_MODULE 1
CONFIG_BT_LE 1
CONFIG_PINCTRL_SX150X 1
CONFIG_SND_AC97_CODEC_MODULE 1
CONFIG_PCI_SW_SWITCHTEC_MODULE 1
CONFIG_ARCH_WANT_OLD_COMPAT_IPC 1
CONFIG_MOST_USB_MODULE 1
CONFIG_RTC_DRV_CROS_EC_MODULE 1
CONFIG_HID_U2FZERO_MODULE 1
CONFIG_SND_SOC_DA7219_MODULE 1
CONFIG_MOXA_SMARTIO_MODULE 1
CONFIG_SND_SOC_AK4613_MODULE 1
CONFIG_VIDEO_MT9V032_MODULE 1
CONFIG_XIAOMI_WMI_MODULE 1
CONFIG_DVB_USB_CXUSB_MODULE 1
CONFIG_TSL2583_MODULE 1
CONFIG_X25_ASY_MODULE 1
CONFIG_RT2500PCI_MODULE 1
CONFIG_CMA 1
CONFIG_RWSEM_SPIN_ON_OWNER 1
CONFIG_SENSORS_LM85_MODULE 1
CONFIG_AD525X_DPOT_MODULE 1
CONFIG_SND_ATIIXP_MODULE 1
CONFIG_VL6180_MODULE 1
CONFIG_DIMLIB 1
CONFIG_MEDIA_TUNER_M88RS6000T_MODULE 1
CONFIG_TRACER_SNAPSHOT 1
CONFIG_INFINIBAND_IPOIB_CM 1
CONFIG_COMEDI_PARPORT_MODULE 1
CONFIG_ADE7854_MODULE 1
CONFIG_HID_PICOLCD_LCD 1
CONFIG_HAVE_RELIABLE_STACKTRACE 1
CONFIG_SENSORS_MLXREG_FAN_MODULE 1
CONFIG_BITREVERSE 1
CONFIG_DEVPORT 1
CONFIG_IGC_MODULE 1
CONFIG_VIDEO_CX88_ENABLE_VP3054 1
CONFIG_DRM_I915_COMPRESS_ERROR 1
CONFIG_IOSCHED_BFQ_MODULE 1
CONFIG_MACB_USE_HWSTAMP 1
CONFIG_INTEL_RST_MODULE 1
CONFIG_X509_CERTIFICATE_PARSER 1
CONFIG_GPIO_PCIE_IDIO_24_MODULE 1
CONFIG_BLK_DEV_RAM_SIZE 65536
CONFIG_USB_SERIAL_WWAN_MODULE 1
CONFIG_REGMAP_I3C_MODULE 1
CONFIG_SND_ICE1724_MODULE 1
CONFIG_MAC_PARTITION 1
CONFIG_CONSOLE_POLL 1
CONFIG_EARLY_PRINTK_USB 1
CONFIG_HID_ALPS_MODULE 1
CONFIG_IIO_ADIS_LIB_BUFFER 1
CONFIG_SENSORS_DA9052_ADC_MODULE 1
CONFIG_NFT_TPROXY_MODULE 1
CONFIG_XFS_POSIX_ACL 1
CONFIG_BT_WILINK_MODULE 1
CONFIG_TTY_PRINTK_LEVEL 6
CONFIG_PTP_1588_CLOCK_KVM_MODULE 1
CONFIG_TOUCHSCREEN_DA9034_MODULE 1
CONFIG_ND_BLK_MODULE 1
CONFIG_IIO_ST_LSM6DSX_SPI_MODULE 1
CONFIG_MLXREG_IO_MODULE 1
CONFIG_INT3406_THERMAL_MODULE 1
CONFIG_MSI_LAPTOP_MODULE 1
CONFIG_COMEDI_DT2801_MODULE 1
CONFIG_BRCMFMAC_USB 1
CONFIG_TOUCHSCREEN_DYNAPRO_MODULE 1
CONFIG_FB_MODE_HELPERS 1
CONFIG_NLS_ISO8859_13_MODULE 1
CONFIG_MTD_MTDRAM_MODULE 1
CONFIG_PCI_PRI 1
CONFIG_BLK_DEV_SX8_MODULE 1
CONFIG_CRYPTO_BLKCIPHER 1
CONFIG_EXTCON_MAX77693_MODULE 1
CONFIG_X86_L1_CACHE_SHIFT 6
CONFIG_BATTERY_BQ27XXX_HDQ_MODULE 1
CONFIG_X86_PAT 1
CONFIG_USB_STORAGE_ONETOUCH_MODULE 1
CONFIG_NLS_ISO8859_8_MODULE 1
CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH_MODULE 1
CONFIG_RT2400PCI_MODULE 1
CONFIG_NF_CONNTRACK_MODULE 1
CONFIG_RTC_DRV_PCF8523_MODULE 1
CONFIG_EROFS_FS_MODULE 1
CONFIG_HID_PICOLCD_CIR 1
CONFIG_BACKLIGHT_PANDORA_MODULE 1
CONFIG_COMEDI_GSC_HPDI_MODULE 1
CONFIG_NI_XGE_MANAGEMENT_ENET_MODULE 1
CONFIG_FB_NVIDIA_MODULE 1
CONFIG_EFI_RUNTIME_WRAPPERS 1
CONFIG_LCD_CLASS_DEVICE_MODULE 1
CONFIG_LSM "lockdown,yama,integrity,apparmor"
CONFIG_ARCH_DMA_ADDR_T_64BIT 1
CONFIG_FILE_LOCKING 1
CONFIG_PATA_HPT3X3_MODULE 1
CONFIG_USB_GSPCA_XIRLINK_CIT_MODULE 1
CONFIG_AD2S1200_MODULE 1
CONFIG_RTC_DRV_STK17TA8_MODULE 1
CONFIG_USB_GSPCA_SN9C20X_MODULE 1
CONFIG_RMI4_F03 1
CONFIG_TOUCHSCREEN_USB_ELO 1
CONFIG_RTC_DRV_DS1302_MODULE 1
CONFIG_USB_CHAOSKEY_MODULE 1
CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST 1
CONFIG_TEST_BPF_MODULE 1
CONFIG_FS_DAX_PMD 1
CONFIG_BACKLIGHT_LV5207LP_MODULE 1
CONFIG_KARMA_PARTITION 1
CONFIG_FB_SM501_MODULE 1
CONFIG_SND_SOC_I2C_AND_SPI_MODULE 1
CONFIG_NETPOLL 1
CONFIG_COMEDI_ISADMA_MODULE 1
CONFIG_ZSWAP 1
CONFIG_SPEAKUP_SYNTH_AUDPTR_MODULE 1
CONFIG_MAC80211_MESSAGE_TRACING 1
CONFIG_SENSORS_F71882FG_MODULE 1
CONFIG_ACPI_APEI_GHES 1
CONFIG_SND_SOC_UDA1334_MODULE 1
CONFIG_FB_CARILLO_RANCH_MODULE 1
CONFIG_SND_SOC_SOF_TOPLEVEL 1
CONFIG_PINCTRL_ICELAKE_MODULE 1
CONFIG_SENSORS_ADT7310_MODULE 1
CONFIG_RAVE_SP_EEPROM_MODULE 1
CONFIG_AIO 1
CONFIG_SERIO_ARC_PS2_MODULE 1
CONFIG_DVB_TDA8083_MODULE 1
CONFIG_NET_MPLS_GSO_MODULE 1
CONFIG_NFC_FDP_I2C_MODULE 1
CONFIG_RTC_DRV_DS1347_MODULE 1
CONFIG_USB_FOTG210_UDC_MODULE 1
CONFIG_CLKEVT_I8253 1
CONFIG_DVB_USB_AZ6007_MODULE 1
CONFIG_REGULATOR_USERSPACE_CONSUMER_MODULE 1
CONFIG_NET_EMATCH 1
CONFIG_PERF_EVENTS 1
CONFIG_MMC_REALTEK_USB_MODULE 1
CONFIG_GENERIC_TIME_VSYSCALL 1
CONFIG_IP_NF_TARGET_REJECT_MODULE 1
CONFIG_HAVE_MOVE_PMD 1
CONFIG_ZIIRAVE_WATCHDOG_MODULE 1
CONFIG_NET_SCH_CHOKE_MODULE 1
CONFIG_GVE_MODULE 1
CONFIG_LEDS_CLASS 1
CONFIG_COMEDI_BOND_MODULE 1
CONFIG_DVB_USB_DIGITV_MODULE 1
CONFIG_IP6_NF_MATCH_HL_MODULE 1
CONFIG_PERF_EVENTS_INTEL_CSTATE_MODULE 1
CONFIG_KALLSYMS_BASE_RELATIVE 1
CONFIG_TIPC_MEDIA_IB 1
CONFIG_VIDEO_SAA7110_MODULE 1
CONFIG_MTD_L440GX_MODULE 1
CONFIG_GPIO_GPIO_MM_MODULE 1
CONFIG_IP_VS_TAB_BITS 12
CONFIG_COMEDI_NI_AT_AO_MODULE 1
CONFIG_IP6_NF_MATCH_OPTS_MODULE 1
CONFIG_SENSORS_DA9055_MODULE 1
CONFIG_INPUT_TWL4030_PWRBUTTON_MODULE 1
CONFIG_SCSI_SAS_HOST_SMP 1
CONFIG_VERSION_SIGNATURE "Ubuntu 5.4.0-159.176-generic 5.4.241"
CONFIG_RTC_INTF_DEV 1
CONFIG_SPI_SIFIVE_MODULE 1
CONFIG_MTD_MAP_BANK_WIDTH_4 1
CONFIG_IIO_ST_SENSORS_SPI_MODULE 1
CONFIG_GREYBUS_SPI_MODULE 1
CONFIG_EISA_VIRTUAL_ROOT 1
CONFIG_DCACHE_WORD_ACCESS 1
CONFIG_IP6_NF_TARGET_NPT_MODULE 1
CONFIG_DVB_USB_CE6230_MODULE 1
CONFIG_RTW88_8822BE 1
CONFIG_PARIDE_ATEN_MODULE 1
CONFIG_INFINIBAND_CXGB3_MODULE 1
CONFIG_VIDEO_OV5675_MODULE 1
CONFIG_USB_SERIAL_SYMBOL_MODULE 1
CONFIG_PSTORE_COMPRESS 1
CONFIG_CHARGER_MAX77693_MODULE 1
CONFIG_HERMES_MODULE 1
CONFIG_REGULATOR_MAX8952_MODULE 1
CONFIG_SND_SOC_HDMI_CODEC_MODULE 1
CONFIG_NETFILTER_XT_MATCH_OSF_MODULE 1
CONFIG_MLX_PLATFORM_MODULE 1
CONFIG_ADIS16460_MODULE 1
CONFIG_USB_MIDI_GADGET_MODULE 1
CONFIG_SATA_QSTOR_MODULE 1
CONFIG_WILINK_PLATFORM_DATA 1
CONFIG_VIDEO_GO7007_MODULE 1
CONFIG_PATA_SIS 1
CONFIG_MESSAGE_LOGLEVEL_DEFAULT 4
CONFIG_GPIO_TWL4030_MODULE 1
CONFIG_AMD_NB 1
CONFIG_SND_VIRMIDI_MODULE 1
CONFIG_LIB80211_CRYPT_TKIP_MODULE 1
CONFIG_APDS9960_MODULE 1
CONFIG_LOCKUP_DETECTOR 1
CONFIG_QSEMI_PHY_MODULE 1
CONFIG_IP_VS_PROTO_UDP 1
CONFIG_VIDEO_BT866_MODULE 1
CONFIG_NLS_DEFAULT "utf8"
CONFIG_WATCHDOG_PRETIMEOUT_GOV_NOOP 1
CONFIG_ACPI_CONTAINER 1
CONFIG_SND_DMA_SGBUF 1
CONFIG_UTS_NS 1
CONFIG_I2C_AMD_MP2_MODULE 1
CONFIG_NF_CT_PROTO_GRE 1
CONFIG_HDMI_LPE_AUDIO_MODULE 1
CONFIG_WMI_BMOF_MODULE 1
CONFIG_DAX_DRIVER 1
CONFIG_BT_HCIUART_BCSP 1
CONFIG_REGULATOR_S2MPA01_MODULE 1
CONFIG_NF_CT_NETLINK_MODULE 1
CONFIG_EFS_FS_MODULE 1
CONFIG_AUXDISPLAY 1
CONFIG_USB_NET_SR9800_MODULE 1
CONFIG_DMA_ENGINE 1
CONFIG_NET_EMATCH_TEXT_MODULE 1
CONFIG_SND_HDA_CODEC_ANALOG_MODULE 1
CONFIG_ADIS16209_MODULE 1
CONFIG_X86_ACPI_CPUFREQ 1
CONFIG_HID_WIIMOTE_MODULE 1
CONFIG_BACKLIGHT_AS3711_MODULE 1
CONFIG_APDS9300_MODULE 1
CONFIG_USB_MA901_MODULE 1
CONFIG_P54_SPI_MODULE 1
CONFIG_IAVF_MODULE 1
CONFIG_RDS_TCP_MODULE 1
CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD 1
CONFIG_CGROUP_PIDS 1
CONFIG_CRYPTO_AEAD2 1
CONFIG_CRYPTO_FCRYPT_MODULE 1
CONFIG_X86_HV_CALLBACK_VECTOR 1
CONFIG_PCMCIA_ATMEL_MODULE 1
CONFIG_NFC_NCI_MODULE 1
CONFIG_TOSHIBA_BT_RFKILL_MODULE 1
CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC_MODULE 1
CONFIG_MOUSE_PS2_MODULE 1
CONFIG_NET_IPIP_MODULE 1
CONFIG_IP_VS_SH_TAB_BITS 8
CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
CONFIG_USB_SERIAL_IPAQ_MODULE 1
CONFIG_PCI_ENDPOINT 1
CONFIG_NETFILTER_XT_MATCH_HL_MODULE 1
CONFIG_CHROMEOS_LAPTOP_MODULE 1
CONFIG_NFC_DIGITAL_MODULE 1
CONFIG_LEDS_TCA6507_MODULE 1
CONFIG_SND_USB_POD_MODULE 1
CONFIG_CRYPTO_ALGAPI2 1
CONFIG_SATA_SIS_MODULE 1
CONFIG_PHYSICAL_START 0x1000000
CONFIG_NETFILTER_XT_TARGET_LED_MODULE 1
CONFIG_WEXT_SPY 1
CONFIG_UBIFS_FS_LZO 1
CONFIG_SI1145_MODULE 1
CONFIG_USB_G_ACM_MS_MODULE 1
CONFIG_ACPI_SBS_MODULE 1
CONFIG_KEYBOARD_ADP5589_MODULE 1
CONFIG_MCP41010_MODULE 1
CONFIG_GENERIC_IRQ_RESERVATION_MODE 1
CONFIG_FB_3DFX_MODULE 1
CONFIG_TOUCHSCREEN_SILEAD_MODULE 1
CONFIG_X86_PMEM_LEGACY 1
CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
CONFIG_INPUT 1
CONFIG_MICROCHIP_T1_PHY_MODULE 1
CONFIG_PCI200SYN_MODULE 1
CONFIG_PPPOATM_MODULE 1
CONFIG_SIOX_MODULE 1
CONFIG_PMIC_DA9052 1
CONFIG_PATA_OPTI_MODULE 1
CONFIG_PROC_SYSCTL 1
CONFIG_SND_HDA_CODEC_REALTEK_MODULE 1
CONFIG_ATH6KL_MODULE 1
CONFIG_HAVE_PERF_EVENTS_NMI 1
CONFIG_SND_SOC_FSL_ASRC_MODULE 1
CONFIG_NETFILTER_XT_TARGET_CT_MODULE 1
CONFIG_RD_LZ4 1
CONFIG_MMU 1
CONFIG_DVB_CX24123_MODULE 1
CONFIG_MEDIA_CONTROLLER_DVB 1
CONFIG_NET_DSA_MV88E6XXX_PTP 1
CONFIG_OCFS2_FS_MODULE 1
CONFIG_USB_KAWETH_MODULE 1
CONFIG_VIDEO_CADENCE 1
CONFIG_USB_SIERRA_NET_MODULE 1
CONFIG_AIC7XXX_RESET_DELAY_MS 5000
CONFIG_VMWARE_BALLOON_MODULE 1
CONFIG_BRIDGE_EBT_NFLOG_MODULE 1
CONFIG_CAN_SJA1000_PLATFORM_MODULE 1
CONFIG_TABLET_USB_AIPTEK_MODULE 1
CONFIG_BNXT_SRIOV 1
CONFIG_SND_SOC_INTEL_CHT_BSW_NAU8824_MACH_MODULE 1
CONFIG_AGP 1
CONFIG_INLINE_WRITE_UNLOCK 1
CONFIG_ZPOOL 1
CONFIG_REGULATOR_TPS6524X_MODULE 1
CONFIG_INPUT_AD714X_MODULE 1
CONFIG_SENSORS_GL520SM_MODULE 1
CONFIG_E1000_MODULE 1
CONFIG_SCSI_SYM53C8XX_MMIO 1
__LITTLE_ENDIAN 1234
__ARG_PLACEHOLDER_1 0,
__take_second_arg(,) 
__and(,) ___and(, )
___and(,) ____and(__ARG_PLACEHOLDER_##, )
____and(,) __take_second_arg( , 0)
__or(,) ___or(, )
___or(,) ____or(__ARG_PLACEHOLDER_##, )
____or(,) __take_second_arg( 1, )
__is_defined() ___is_defined()
___is_defined() ____is_defined(__ARG_PLACEHOLDER_##)
____is_defined() __take_second_arg( 1, 0)
IS_BUILTIN() __is_defined()
IS_MODULE() __is_defined(##_MODULE)
IS_REACHABLE() __or(IS_BUILTIN(), __and(IS_MODULE(), __is_defined(MODULE)))
IS_ENABLED() __or(IS_BUILTIN(), IS_MODULE())
__user 
__kernel 
__safe 
__force 
__nocast 
__iomem 
__chk_user_ptr() (void)0
__chk_io_ptr() (void)0
__builtin_warning(,) (1)
__must_hold() 
__acquires() 
__releases() 
__acquire() (void)0
__release() (void)0
__cond_lock(,) ()
__percpu 
__rcu 
__private 
ACCESS_PRIVATE(,) (()->)
___PASTE(,) ##
__PASTE(,) ___PASTE(,)
__alias() __attribute__((__alias__(#)))
__aligned() __attribute__((__aligned__()))
__aligned_largest __attribute__((__aligned__))
__always_inline inline __attribute__((__always_inline__))
__assume_aligned() __attribute__((__assume_aligned__(, ## __VA_ARGS__)))
__cold __attribute__((__cold__))
__attribute_const__ __attribute__((__const__))
__copy() 
__deprecated 
__designated_init 
__visible 
__printf(,) __attribute__((__format__(printf, , )))
__scanf(,) __attribute__((__format__(scanf, , )))
__gnu_inline __attribute__((__gnu_inline__))
__malloc __attribute__((__malloc__))
__mode() __attribute__((__mode__()))
__noclone 
fallthrough __attribute__((__fallthrough__))
noinline __attribute__((__noinline__))
__nonstring 
__noreturn __attribute__((__noreturn__))
__packed __attribute__((__packed__))
__pure __attribute__((__pure__))
__section() __attribute__((__section__(#)))
__always_unused __attribute__((__unused__))
__maybe_unused __attribute__((__unused__))
__used __attribute__((__used__))
__weak __attribute__((__weak__))
uninitialized_var()  = *(&())
__UNIQUE_ID() __PASTE(__PASTE(__UNIQUE_ID_, ), __COUNTER__)
KASAN_ABI_VERSION 5
__no_sanitize_address 
COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW 1
__must_check 
notrace __attribute__((__no_instrument_function__))
noinstr noinline notrace __attribute((__section__(".noinstr.text")))
__naked __attribute__((__naked__)) notrace
__compiler_offsetof(,) __builtin_offsetof(, )
inline inline __gnu_inline __inline_maybe_unused notrace
__inline__ inline
__inline_maybe_unused __maybe_unused
noinline_for_stack noinline
__latent_entropy 
__randomize_layout __designated_init
__no_randomize_layout 
randomized_struct_fields_start 
randomized_struct_fields_end 
asm_volatile_goto() asm goto()
asm_inline asm __inline
__same_type(,) __builtin_types_compatible_p(typeof(), typeof())
__native_word() (sizeof() == sizeof(char) || sizeof() == sizeof(short) || sizeof() == sizeof(int) || sizeof() == sizeof(long))
__diag() 
__diag_GCC(,,) 
__diag_push() __diag(push)
__diag_pop() __diag(pop)
__diag_ignore(,,,) __diag_ ## (, ignore, )
__diag_warn(,,,) __diag_ ## (, warn, )
__diag_error(,,,) __diag_ ## (, error, )
likely() __builtin_expect(!!(), 1)
unlikely() __builtin_expect(!!(), 0)
barrier() __asm__ __volatile__("": : :"memory")
barrier_data() __asm__ __volatile__("": :"r"() :"memory")
barrier_before_unreachable() do { } while (0)
annotate_reachable() ({ asm volatile("%c0:\n\t" ".pushsection .discard.reachable\n\t" ".long %c0b - .\n\t" ".popsection\n\t" : : "i" (__COUNTER__)); \
})
annotate_unreachable() ({ asm volatile("%c0:\n\t" ".pushsection .discard.unreachable\n\t" ".long %c0b - .\n\t" ".popsection\n\t" : : "i" (__COUNTER__)); \
})
ASM_UNREACHABLE "999:\n\t" ".pushsection .discard.unreachable\n\t" ".long 999b - .\n\t" ".popsection\n\t"
__annotate_jump_table __section(.rodata..c_jump_table)
instrumentation_begin() do { } while(0)
instrumentation_end() do { } while(0)
unreachable() do { annotate_unreachable(); __builtin_unreachable(); \
} while (0)
KENTRY() extern typeof() ; static const unsigned long __kentry_## __used __section("___kentry" "+" # ) = (unsigned long)&;
RELOC_HIDE(,) ({ unsigned long __ptr; __ptr = (unsigned long) (); (typeof()) (__ptr + ()); })
absolute_pointer() RELOC_HIDE((void *)(), 0)
OPTIMIZER_HIDE_VAR() __asm__ ("" : "=r" () : "0" ())
__BITS_PER_LONG 64
BITS_PER_LONG 64
BITS_PER_LONG_LONG 64
S8_C() 
U8_C()  ## U
S16_C() 
U16_C()  ## U
S32_C() 
U32_C()  ## U
S64_C()  ## LL
U64_C()  ## ULL
NULL ((void *)0)
offsetof(,) __compiler_offsetof(, )
sizeof_field(,) sizeof(((( *)0)->))
offsetofend(,) (offsetof(, ) + sizeof_field(, ))
__FD_SETSIZE 1024
__kernel_old_uid_t __kernel_old_uid_t
__kernel_old_dev_t __kernel_old_dev_t
__bitwise__ 
__bitwise __bitwise__
__aligned_u64 __u64 __attribute__((aligned(8)))
__aligned_be64 __be64 __attribute__((aligned(8)))
__aligned_le64 __le64 __attribute__((aligned(8)))
__READ_ONCE_SIZE \
({ switch (size) { case 1: *(__u8 *)res = *(volatile __u8 *)p; break; case 2: *(__u16 *)res = *(volatile __u16 *)p; break; case 4: *(__u32 *)res = *(volatile __u32 *)p; break; case 8: *(__u64 *)res = *(volatile __u64 *)p; break; default: barrier(); __builtin_memcpy((void *)res, (const void *)p, size); barrier(); } \
})
__no_kasan_or_inline __always_inline
__EXPORTED_HEADERS__ 
DECLARE_BITMAP(,) unsigned long [BITS_TO_LONGS()]
_SIZE_T 
_SSIZE_T 
_PTRDIFF_T 
_TIME_T 
_CLOCK_T 
_CADDR_T 
__BIT_TYPES_DEFINED__ 
aligned_u64 __aligned_u64
aligned_be64 __aligned_be64
aligned_le64 __aligned_le64
pgoff_t unsigned long
rcu_head callback_head
__stringify_1() #
__stringify() __stringify_1()
__ASM_FORM() " " __stringify() " "
__ASM_FORM_RAW() __stringify()
__ASM_FORM_COMMA() " " __stringify() ","
__ASM_SEL(,) __ASM_FORM()
__ASM_SEL_RAW(,) __ASM_FORM_RAW()
__ASM_SIZE() __ASM_SEL(##l##__VA_ARGS__, ##q##__VA_ARGS__)
__ASM_REG() __ASM_SEL_RAW(e##, r##)
_ASM_PTR __ASM_SEL(.long, .quad)
_ASM_ALIGN __ASM_SEL(.balign 4, .balign 8)
_ASM_MOV __ASM_SIZE(mov)
_ASM_INC __ASM_SIZE(inc)
_ASM_DEC __ASM_SIZE(dec)
_ASM_ADD __ASM_SIZE(add)
_ASM_SUB __ASM_SIZE(sub)
_ASM_XADD __ASM_SIZE(xadd)
_ASM_MUL __ASM_SIZE(mul)
_ASM_AX __ASM_REG(ax)
_ASM_BX __ASM_REG(bx)
_ASM_CX __ASM_REG(cx)
_ASM_DX __ASM_REG(dx)
_ASM_SP __ASM_REG(sp)
_ASM_BP __ASM_REG(bp)
_ASM_SI __ASM_REG(si)
_ASM_DI __ASM_REG(di)
_ASM_ARG1 _ASM_DI
_ASM_ARG2 _ASM_SI
_ASM_ARG3 _ASM_DX
_ASM_ARG4 _ASM_CX
_ASM_ARG5 r8
_ASM_ARG6 r9
_ASM_ARG1Q rdi
_ASM_ARG2Q rsi
_ASM_ARG3Q rdx
_ASM_ARG4Q rcx
_ASM_ARG5Q r8
_ASM_ARG6Q r9
_ASM_ARG1L edi
_ASM_ARG2L esi
_ASM_ARG3L edx
_ASM_ARG4L ecx
_ASM_ARG5L r8d
_ASM_ARG6L r9d
_ASM_ARG1W di
_ASM_ARG2W si
_ASM_ARG3W dx
_ASM_ARG4W cx
_ASM_ARG5W r8w
_ASM_ARG6W r9w
_ASM_ARG1B dil
_ASM_ARG2B sil
_ASM_ARG3B dl
_ASM_ARG4B cl
_ASM_ARG5B r8b
_ASM_ARG6B r9b
CC_SET() "\n\t/* output condition code " # "*/\n"
CC_OUT() "=@cc" #
_EXPAND_EXTABLE_HANDLE() #
_ASM_EXTABLE_HANDLE(,,) " .pushsection \"__ex_table\",\"a\"\n" " .balign 4\n" " .long (" # ") - .\n" " .long (" # ") - .\n" " .long (" _EXPAND_EXTABLE_HANDLE() ") - .\n" " .popsection\n"
_ASM_EXTABLE(,) _ASM_EXTABLE_HANDLE(, , ex_handler_default)
_ASM_EXTABLE_UA(,) _ASM_EXTABLE_HANDLE(, , ex_handler_uaccess)
_ASM_EXTABLE_FAULT(,) _ASM_EXTABLE_HANDLE(, , ex_handler_fault)
_ASM_EXTABLE_EX(,) _ASM_EXTABLE_HANDLE(, , ex_handler_ext)
ASM_CALL_CONSTRAINT "+r" (current_stack_pointer)
LOCK_PREFIX_HERE ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" /* offset */ ".popsection\n" "671:"
LOCK_PREFIX LOCK_PREFIX_HERE "\n\tlock; "
ANNOTATE_IGNORE_ALTERNATIVE "999:\n\t" ".pushsection .discard.ignore_alts\n\t" ".long 999b - .\n\t" ".popsection\n\t"
b_replacement() "664"#
e_replacement() "665"#
alt_end_marker "663"
alt_slen "662b-661b"
alt_pad_len alt_end_marker"b-662b"
alt_total_slen alt_end_marker"b-661b"
alt_rlen() e_replacement()"f-"b_replacement()"f"
OLDINSTR(,) "# ALT: oldnstr\n" "661:\n\t"  "\n662:\n" "# ALT: padding\n" ".skip -(((" alt_rlen() ")-(" alt_slen ")) > 0) * " "((" alt_rlen() ")-(" alt_slen ")),0x90\n" alt_end_marker ":\n"
alt_max_short(,) "(("  ") ^ ((("  ") ^ ("  ")) & -(-(("  ") < ("  ")))))"
OLDINSTR_2(,,) "# ALT: oldinstr2\n" "661:\n\t"  "\n662:\n" "# ALT: padding2\n" ".skip -((" alt_max_short(alt_rlen(), alt_rlen()) " - (" alt_slen ")) > 0) * " "(" alt_max_short(alt_rlen(), alt_rlen()) " - (" alt_slen ")), 0x90\n" alt_end_marker ":\n"
OLDINSTR_3(,,,) "# ALT: oldinstr3\n" "661:\n\t"  "\n662:\n" "# ALT: padding3\n" ".skip -((" alt_max_short(alt_max_short(alt_rlen(), alt_rlen()), alt_rlen()) " - (" alt_slen ")) > 0) * " "(" alt_max_short(alt_max_short(alt_rlen(), alt_rlen()), alt_rlen()) " - (" alt_slen ")), 0x90\n" alt_end_marker ":\n"
ALTINSTR_ENTRY(,) " .long 661b - .\n" /* label           */ " .long " b_replacement()"f - .\n" /* new instruction */ " .word " __stringify() "\n" /* feature bit     */ " .byte " alt_total_slen "\n" /* source len      */ " .byte " alt_rlen() "\n" /* replacement len */ " .byte " alt_pad_len "\n"
ALTINSTR_REPLACEMENT(,,) /* replacement */ "# ALT: replacement " # "\n" b_replacement()":\n\t"  "\n" e_replacement() ":\n"
ALTERNATIVE(,,) OLDINSTR(, 1) ".pushsection .altinstructions,\"a\"\n" ALTINSTR_ENTRY(, 1) ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" ALTINSTR_REPLACEMENT(, , 1) ".popsection\n"
ALTERNATIVE_2(,,,,) OLDINSTR_2(, 1, 2) ".pushsection .altinstructions,\"a\"\n" ALTINSTR_ENTRY(, 1) ALTINSTR_ENTRY(, 2) ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" ALTINSTR_REPLACEMENT(, , 1) ALTINSTR_REPLACEMENT(, , 2) ".popsection\n"
ALTERNATIVE_3(,,,,,,) OLDINSTR_3(, 1, 2, 3) ".pushsection .altinstructions,\"a\"\n" ALTINSTR_ENTRY(, 1) ALTINSTR_ENTRY(, 2) ALTINSTR_ENTRY(, 3) ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" ALTINSTR_REPLACEMENT(, , 1) ALTINSTR_REPLACEMENT(, , 2) ALTINSTR_REPLACEMENT(, , 3) ".popsection\n"
alternative(,,) asm_inline volatile (ALTERNATIVE(, , ) : : : "memory")
alternative_2(,,,,) asm_inline volatile(ALTERNATIVE_2(, , , , ) ::: "memory")
alternative_input(,,,) asm_inline volatile (ALTERNATIVE(, , ) : : "i" (0), ## )
alternative_input_2(,,,,,) asm_inline volatile(ALTERNATIVE_2(, , , , ) : : "i" (0), ## )
alternative_io(,,,,) asm_inline volatile (ALTERNATIVE(, , ) :  : "i" (0), ## )
alternative_call(,,,,) asm_inline volatile (ALTERNATIVE("call %P[old]", "call %P[new]", ) :  : [old] "i" (), [new] "i" (), ## )
alternative_call_2(,,,,,,) asm_inline volatile (ALTERNATIVE_2("call %P[old]", "call %P[new1]", , "call %P[new2]", ) : , ASM_CALL_CONSTRAINT : [old] "i" (), [new1] "i" (), [new2] "i" (), ## )
ASM_OUTPUT2() 
ASM_NO_INPUT_CLOBBER() "i" (0) : 
NOP_DS_PREFIX 0x3e
GENERIC_NOP1 0x90
GENERIC_NOP2 0x89,0xf6
GENERIC_NOP3 0x8d,0x76,0x00
GENERIC_NOP4 0x8d,0x74,0x26,0x00
GENERIC_NOP5 GENERIC_NOP1,GENERIC_NOP4
GENERIC_NOP6 0x8d,0xb6,0x00,0x00,0x00,0x00
GENERIC_NOP7 0x8d,0xb4,0x26,0x00,0x00,0x00,0x00
GENERIC_NOP8 GENERIC_NOP1,GENERIC_NOP7
GENERIC_NOP5_ATOMIC NOP_DS_PREFIX,GENERIC_NOP4
K8_NOP1 GENERIC_NOP1
K8_NOP2 0x66,K8_NOP1
K8_NOP3 0x66,K8_NOP2
K8_NOP4 0x66,K8_NOP3
K8_NOP5 K8_NOP3,K8_NOP2
K8_NOP6 K8_NOP3,K8_NOP3
K8_NOP7 K8_NOP4,K8_NOP3
K8_NOP8 K8_NOP4,K8_NOP4
K8_NOP5_ATOMIC 0x66,K8_NOP4
K7_NOP1 GENERIC_NOP1
K7_NOP2 0x8b,0xc0
K7_NOP3 0x8d,0x04,0x20
K7_NOP4 0x8d,0x44,0x20,0x00
K7_NOP5 K7_NOP4,K7_NOP1
K7_NOP6 0x8d,0x80,0,0,0,0
K7_NOP7 0x8D,0x04,0x05,0,0,0,0
K7_NOP8 K7_NOP7,K7_NOP1
K7_NOP5_ATOMIC NOP_DS_PREFIX,K7_NOP4
P6_NOP1 GENERIC_NOP1
P6_NOP2 0x66,0x90
P6_NOP3 0x0f,0x1f,0x00
P6_NOP4 0x0f,0x1f,0x40,0
P6_NOP5 0x0f,0x1f,0x44,0x00,0
P6_NOP6 0x66,0x0f,0x1f,0x44,0x00,0
P6_NOP7 0x0f,0x1f,0x80,0,0,0,0
P6_NOP8 0x0f,0x1f,0x84,0x00,0,0,0,0
P6_NOP5_ATOMIC P6_NOP5
_ASM_MK_NOP() ".byte " __stringify() "\n"
ASM_NOP1 _ASM_MK_NOP(K8_NOP1)
ASM_NOP2 _ASM_MK_NOP(K8_NOP2)
ASM_NOP3 _ASM_MK_NOP(K8_NOP3)
ASM_NOP4 _ASM_MK_NOP(K8_NOP4)
ASM_NOP5 _ASM_MK_NOP(K8_NOP5)
ASM_NOP6 _ASM_MK_NOP(K8_NOP6)
ASM_NOP7 _ASM_MK_NOP(K8_NOP7)
ASM_NOP8 _ASM_MK_NOP(K8_NOP8)
ASM_NOP5_ATOMIC _ASM_MK_NOP(K8_NOP5_ATOMIC)
ASM_NOP_MAX 8
NOP_ATOMIC5 (ASM_NOP_MAX+1)
mb() asm volatile("mfence":::"memory")
rmb() asm volatile("lfence":::"memory")
wmb() asm volatile("sfence" ::: "memory")
array_index_mask_nospec array_index_mask_nospec
barrier_nospec() alternative("", "lfence", X86_FEATURE_LFENCE_RDTSC)
dma_rmb() barrier()
dma_wmb() barrier()
__smp_mb() asm volatile("lock; addl $0,-4(%%rsp)" ::: "memory", "cc")
__smp_rmb() dma_rmb()
__smp_wmb() barrier()
__smp_store_mb(,) do { (void)xchg(&, ); } while (0)
__smp_store_release(,) do { compiletime_assert_atomic_type(*); barrier(); WRITE_ONCE(*, ); \
} while (0)
__smp_load_acquire() \
({ typeof(*) ___p1 = READ_ONCE(*); compiletime_assert_atomic_type(*); barrier(); ___p1; \
})
__smp_mb__before_atomic() do { } while (0)
__smp_mb__after_atomic() do { } while (0)
nop() asm volatile ("nop")
read_barrier_depends() do { } while (0)
__smp_read_barrier_depends() read_barrier_depends()
smp_mb() __smp_mb()
smp_rmb() __smp_rmb()
smp_wmb() __smp_wmb()
smp_read_barrier_depends() __smp_read_barrier_depends()
smp_store_mb(,) __smp_store_mb(, )
smp_mb__before_atomic() __smp_mb__before_atomic()
smp_mb__after_atomic() __smp_mb__after_atomic()
smp_store_release(,) __smp_store_release(, )
smp_load_acquire() __smp_load_acquire()
virt_mb() __smp_mb()
virt_rmb() __smp_rmb()
virt_wmb() __smp_wmb()
virt_read_barrier_depends() __smp_read_barrier_depends()
virt_store_mb(,) __smp_store_mb(, )
virt_mb__before_atomic() __smp_mb__before_atomic()
virt_mb__after_atomic() __smp_mb__after_atomic()
virt_store_release(,) __smp_store_release(, )
virt_load_acquire() __smp_load_acquire()
smp_acquire__after_ctrl_dep() smp_rmb()
smp_cond_load_relaxed(,) ({ typeof() __PTR = (); typeof(*) VAL; for (;;) { VAL = READ_ONCE(*__PTR); if () break; cpu_relax(); } VAL; \
})
smp_cond_load_acquire(,) ({ typeof(*) _val; _val = smp_cond_load_relaxed(, ); smp_acquire__after_ctrl_dep(); _val; \
})
__READ_ONCE(,) \
({ union { typeof() __val; char __c[1]; } __u; if () __read_once_size(&(), __u.__c, sizeof()); else __read_once_size_nocheck(&(), __u.__c, sizeof()); smp_read_barrier_depends(); /* Enforce dependency ordering from x */ __u.__val; \
})
READ_ONCE() __READ_ONCE(, 1)
READ_ONCE_NOCHECK() __READ_ONCE(, 0)
WRITE_ONCE(,) \
({ union { typeof() __val; char __c[1]; } __u = { .__val = (__force typeof()) () }; __write_once_size(&(), __u.__c, sizeof()); __u.__val; \
})
__ADDRESSABLE() static void * __section(.discard.addressable) __used __PASTE(__addressable_##, __LINE__) = (void *)&;
__compiletime_object_size() -1
__compiletime_warning() 
__compiletime_error() 
__compiletime_assert(,,,) do { extern void  ## (void) __compiletime_error(); if (!())  ## (); } while (0)
_compiletime_assert(,,,) __compiletime_assert(, , , )
compiletime_assert(,) _compiletime_assert(, , __compiletime_assert_, __COUNTER__)
compiletime_assert_atomic_type() compiletime_assert(__native_word(), "Need native word sized stores/loads for atomicity.")
__must_be_array() BUILD_BUG_ON_ZERO(__same_type((), &()[0]))
prevent_tail_call_optimization() mb()
__noinitretpoline 
__init __section(.init.text) __cold __latent_entropy __noinitretpoline
__initdata __section(.init.data)
__initconst __section(.init.rodata)
__exitdata __section(.exit.data)
__exit_call __used __section(.exitcall.exit)
__ref __section(.ref.text) noinline
__refdata __section(.ref.data)
__refconst __section(.ref.rodata)
__exitused __used
__exit __section(.exit.text) __exitused __cold notrace
__meminit __section(.meminit.text) __cold notrace __latent_entropy
__meminitdata __section(.meminit.data)
__meminitconst __section(.meminit.rodata)
__memexit __section(.memexit.text) __exitused __cold notrace
__memexitdata __section(.memexit.data)
__memexitconst __section(.memexit.rodata)
__HEAD .section ".head.text","ax"
__INIT .section ".init.text","ax"
__FINIT .previous
__INITDATA .section ".init.data","aw",%progbits
__INITRODATA .section ".init.rodata","a",%progbits
__FINITDATA .previous
__MEMINIT .section ".meminit.text", "ax"
__MEMINITDATA .section ".meminit.data", "aw"
__MEMINITRODATA .section ".meminit.rodata", "a"
__REF .section ".ref.text", "ax"
__REFDATA .section ".ref.data", "aw"
__REFCONST .section ".ref.rodata", "a"
___define_initcall(,,) __ADDRESSABLE() asm(".section	\"" # ".init\", \"a\"	\n" "__initcall_" # # ":			\n" ".long	" # " - .			\n" ".previous					\n");
__define_initcall(,) ___define_initcall(, , .initcall##)
early_initcall() __define_initcall(, early)
pure_initcall() __define_initcall(, 0)
core_initcall() __define_initcall(, 1)
core_initcall_sync() __define_initcall(, 1s)
postcore_initcall() __define_initcall(, 2)
postcore_initcall_sync() __define_initcall(, 2s)
arch_initcall() __define_initcall(, 3)
arch_initcall_sync() __define_initcall(, 3s)
subsys_initcall() __define_initcall(, 4)
subsys_initcall_sync() __define_initcall(, 4s)
fs_initcall() __define_initcall(, 5)
fs_initcall_sync() __define_initcall(, 5s)
rootfs_initcall() __define_initcall(, rootfs)
device_initcall() __define_initcall(, 6)
device_initcall_sync() __define_initcall(, 6s)
late_initcall() __define_initcall(, 7)
late_initcall_sync() __define_initcall(, 7s)
__initcall() device_initcall()
__exitcall() static exitcall_t __exitcall_## __exit_call = 
console_initcall() ___define_initcall(,, .con_initcall)
__setup_param(,,,) static const char __setup_str_##[] __initconst __aligned(1) = ; static struct obs_kernel_param __setup_## __used __section(.init.setup) __attribute__((aligned((sizeof(long))))) = { __setup_str_##, ,  }
__setup(,) __setup_param(, , , 0)
early_param(,) __setup_param(, , , 1)
early_param_on_off(,,,) int  = IS_ENABLED(); static int __init parse_####_on(char *arg) {  = 1; return 0; } __setup_param(, parse_####_on, parse_####_on, 1); static int __init parse_####_off(char *arg) {  = 0; return 0; } __setup_param(, parse_####_off, parse_####_off, 1)
__nosavedata __section(.data..nosave)
__exit_p() NULL
POISON_POINTER_DELTA _AC(CONFIG_ILLEGAL_POINTER_VALUE, UL)
LIST_POISON1 ((void *) 0x100 + POISON_POINTER_DELTA)
LIST_POISON2 ((void *) 0x122 + POISON_POINTER_DELTA)
TIMER_ENTRY_STATIC ((void *) 0x300 + POISON_POINTER_DELTA)
PAGE_POISON 0x00
TAIL_MAPPING ((void *) 0x400 + POISON_POINTER_DELTA)
RED_INACTIVE 0x09F911029D74E35BULL
RED_ACTIVE 0xD84156C5635688C0ULL
SLUB_RED_INACTIVE 0xbb
SLUB_RED_ACTIVE 0xcc
POISON_INUSE 0x5a
POISON_FREE 0x6b
POISON_END 0xa5
POISON_FREE_INITMEM 0xcc
JBD_POISON_FREE 0x5b
JBD2_POISON_FREE 0x5c
POOL_POISON_FREED 0xa7
POOL_POISON_ALLOCATED 0xa9
ATM_POISON_FREE 0x12
ATM_POISON 0xdeadbeef
MUTEX_DEBUG_INIT 0x11
MUTEX_DEBUG_FREE 0x22
MUTEX_POISON_WW_CTX ((void *) 0x500 + POISON_POINTER_DELTA)
KEY_DESTROY 0xbd
__AC(,) (##)
_AC(,) __AC(,)
_AT(,) (()())
_UL() (_AC(, UL))
_ULL() (_AC(, ULL))
_BITUL() (_UL(1) << ())
_BITULL() (_ULL(1) << ())
__ALIGN_KERNEL(,) __ALIGN_KERNEL_MASK(, (typeof())() - 1)
__ALIGN_KERNEL_MASK(,) ((() + ()) & ~())
__KERNEL_DIV_ROUND_UP(,) ((() + () - 1) / ())
UL() (_UL())
ULL() (_ULL())
_ANSI_STDARG_H_ 
__GNUC_VA_LIST 
va_start(,) __builtin_va_start(,)
va_end() __builtin_va_end()
va_arg(,) __builtin_va_arg(,)
va_copy(,) __builtin_va_copy(,)
__va_copy(,) __builtin_va_copy(,)
_VA_LIST_ 
_VA_LIST 
_VA_LIST_DEFINED 
_VA_LIST_T_H 
__va_list__ 
NR_OPEN 1024
NGROUPS_MAX 65536
ARG_MAX 131072
LINK_MAX 127
MAX_CANON 255
MAX_INPUT 255
NAME_MAX 255
PATH_MAX 4096
PIPE_BUF 4096
XATTR_NAME_MAX 255
XATTR_SIZE_MAX 65536
XATTR_LIST_MAX 65536
RTSIG_MAX 32
USHRT_MAX ((unsigned short)~0U)
SHRT_MAX ((short)(USHRT_MAX >> 1))
SHRT_MIN ((short)(-SHRT_MAX - 1))
INT_MAX ((int)(~0U >> 1))
INT_MIN (-INT_MAX - 1)
UINT_MAX (~0U)
LONG_MAX ((long)(~0UL >> 1))
LONG_MIN (-LONG_MAX - 1)
ULONG_MAX (~0UL)
LLONG_MAX ((long long)(~0ULL >> 1))
LLONG_MIN (-LLONG_MAX - 1)
ULLONG_MAX (~0ULL)
SIZE_MAX (~(size_t)0)
PHYS_ADDR_MAX (~(phys_addr_t)0)
U8_MAX ((u8)~0U)
S8_MAX ((s8)(U8_MAX >> 1))
S8_MIN ((s8)(-S8_MAX - 1))
U16_MAX ((u16)~0U)
S16_MAX ((s16)(U16_MAX >> 1))
S16_MIN ((s16)(-S16_MAX - 1))
U32_MAX ((u32)~0U)
S32_MAX ((s32)(U32_MAX >> 1))
S32_MIN ((s32)(-S32_MAX - 1))
U64_MAX ((u64)~0ULL)
S64_MAX ((s64)(U64_MAX >> 1))
S64_MIN ((s64)(-S64_MAX - 1))
THIS_MODULE ((struct module *)0)
__CRC_SYMBOL(,) asm("	.section \"___kcrctab"  "+" # "\", \"a\"	\n" "	.weak	__crc_" # "				\n" "	.long	__crc_" # "				\n" "	.previous					\n")
__KSYMTAB_ENTRY_NS(,) __ADDRESSABLE() asm("	.section \"___ksymtab"  "+" # "\", \"a\"	\n" "	.balign	4					\n" "__ksymtab_" # ":				\n" "	.long	" # "- .				\n" "	.long	__kstrtab_" # "- .			\n" "	.long	__kstrtabns_" # "- .			\n" "	.previous					\n")
__KSYMTAB_ENTRY(,) __ADDRESSABLE() asm("	.section \"___ksymtab"  "+" # "\", \"a\"	\n" "	.balign 4					\n" "__ksymtab_" # ":				\n" "	.long	" # "- .				\n" "	.long	__kstrtab_" # "- .			\n" "	.long	0					\n" "	.previous					\n")
___export_symbol_common(,) extern typeof() ; __CRC_SYMBOL(, ); static const char __kstrtab_##[] __attribute__((section("__ksymtab_strings"), used, aligned(1))) = #
___EXPORT_SYMBOL_NS(,,) ___export_symbol_common(, ); static const char __kstrtabns_##[] __attribute__((section("__ksymtab_strings"), used, aligned(1))) = #; __KSYMTAB_ENTRY_NS(, )
___EXPORT_SYMBOL(,) ___export_symbol_common(, ); __KSYMTAB_ENTRY(, )
__EXPORT_SYMBOL_NS(,,) ___EXPORT_SYMBOL_NS(,,)
__EXPORT_SYMBOL(,) ___EXPORT_SYMBOL(,)
EXPORT_SYMBOL() __EXPORT_SYMBOL(, "")
EXPORT_SYMBOL_GPL() __EXPORT_SYMBOL(, "_gpl")
EXPORT_SYMBOL_GPL_FUTURE() __EXPORT_SYMBOL(, "_gpl_future")
EXPORT_SYMBOL_NS(,) __EXPORT_SYMBOL_NS(, "", )
EXPORT_SYMBOL_NS_GPL(,) __EXPORT_SYMBOL_NS(, "_gpl", )
EXPORT_UNUSED_SYMBOL() __EXPORT_SYMBOL(, "_unused")
EXPORT_UNUSED_SYMBOL_GPL() __EXPORT_SYMBOL(, "_unused_gpl")
notrace __attribute__((no_instrument_function))
ASM_NL ;
CPP_ASMLINKAGE 
asmlinkage CPP_ASMLINKAGE
cond_syscall() asm( ".weak " __stringify() "\n\t" ".set  " __stringify() "," __stringify(sys_ni_syscall))
SYSCALL_ALIAS(,) asm( ".globl " __stringify() "\n\t" ".set   " __stringify() "," __stringify())
__page_aligned_data __section(.data..page_aligned) __aligned(PAGE_SIZE)
__page_aligned_bss __section(.bss..page_aligned) __aligned(PAGE_SIZE)
__PAGE_ALIGNED_DATA .section ".data..page_aligned", "aw"
__PAGE_ALIGNED_BSS .section ".bss..page_aligned", "aw"
asmlinkage_protect(,,) do { } while (0)
__ALIGN .align 4,0x90
__ALIGN_STR ".align 4,0x90"
BIT() (UL(1) << ())
BIT_ULL() (ULL(1) << ())
BIT_MASK() (UL(1) << (() % BITS_PER_LONG))
BIT_WORD() (() / BITS_PER_LONG)
BIT_ULL_MASK() (ULL(1) << (() % BITS_PER_LONG_LONG))
BIT_ULL_WORD() (() / BITS_PER_LONG_LONG)
BITS_PER_BYTE 8
GENMASK(,) (((~UL(0)) - (UL(1) << ()) + 1) & (~UL(0) >> (BITS_PER_LONG - 1 - ())))
GENMASK_ULL(,) (((~ULL(0)) - (ULL(1) << ()) + 1) & (~ULL(0) >> (BITS_PER_LONG_LONG - 1 - ())))
aligned_byte_mask() ((1UL << 8*())-1)
BITS_PER_TYPE() (sizeof() * BITS_PER_BYTE)
BITS_TO_LONGS() DIV_ROUND_UP(, BITS_PER_TYPE(long))
__RMWcc_ARGS(,,,,,,,,,,,,,,) 
RMWcc_ARGS() __RMWcc_ARGS(, ##, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
__RMWcc_CONCAT(,)  ## 
RMWcc_CONCAT(,) __RMWcc_CONCAT(, )
__CLOBBERS_MEM() "memory", ## 
__GEN_RMWcc(,,,) \
({ bool c; asm volatile ( CC_SET() : [var] "+m" (), CC_OUT() (c) : __VA_ARGS__ : ); c; \
})
GEN_UNARY_RMWcc_4(,,,) __GEN_RMWcc( " " , , , __CLOBBERS_MEM())
GEN_UNARY_RMWcc_3(,,) GEN_UNARY_RMWcc_4(, , , "%[var]")
GEN_UNARY_RMWcc() RMWcc_CONCAT(GEN_UNARY_RMWcc_, RMWcc_ARGS())()
GEN_BINARY_RMWcc_6(,,,,,) __GEN_RMWcc( " %[val], " , , , __CLOBBERS_MEM(), [val]  ())
GEN_BINARY_RMWcc_5(,,,,) GEN_BINARY_RMWcc_6(, , , , , "%[var]")
GEN_BINARY_RMWcc() RMWcc_CONCAT(GEN_BINARY_RMWcc_, RMWcc_ARGS())()
GEN_UNARY_SUFFIXED_RMWcc(,,,,) __GEN_RMWcc( " %[var]\n\t" , , , __CLOBBERS_MEM())
GEN_BINARY_SUFFIXED_RMWcc(,,,,,,) __GEN_RMWcc( " %[val], %[var]\n\t" , , , __CLOBBERS_MEM(), [val]  ())
_BITOPS_LONG_SHIFT 6
BIT_64() (U64_C(1) << ())
RLONG_ADDR() "m" (*(volatile long *) ())
WBYTE_ADDR() "+m" (*(volatile char *) ())
ADDR RLONG_ADDR(addr)
CONST_MASK_ADDR(,) WBYTE_ADDR((void *)() + (()>>3))
CONST_MASK() (1 << (() & 7))
arch_clear_bit_unlock_is_negative_byte arch_clear_bit_unlock_is_negative_byte
arch_test_bit(,) (__builtin_constant_p(()) ? constant_test_bit((), ()) : variable_test_bit((), ()))
NEED_FPU (1<<(X86_FEATURE_FPU & 31))
NEED_PAE (1<<(X86_FEATURE_PAE & 31))
NEED_CX8 (1<<(X86_FEATURE_CX8 & 31))
NEED_CMOV (1<<(X86_FEATURE_CMOV & 31))
NEED_3DNOW 0
NEED_NOPL (1<<(X86_FEATURE_NOPL & 31))
NEED_MOVBE 0
NEED_PSE 0
NEED_PGE 0
NEED_MSR (1<<(X86_FEATURE_MSR & 31))
NEED_FXSR (1<<(X86_FEATURE_FXSR & 31))
NEED_XMM (1<<(X86_FEATURE_XMM & 31))
NEED_XMM2 (1<<(X86_FEATURE_XMM2 & 31))
NEED_LM (1<<(X86_FEATURE_LM & 31))
REQUIRED_MASK0 (NEED_FPU|NEED_PSE|NEED_MSR|NEED_PAE| NEED_CX8|NEED_PGE|NEED_FXSR|NEED_CMOV| NEED_XMM|NEED_XMM2)
SSE_MASK (NEED_XMM|NEED_XMM2)
REQUIRED_MASK1 (NEED_LM|NEED_3DNOW)
REQUIRED_MASK2 0
REQUIRED_MASK3 (NEED_NOPL)
REQUIRED_MASK4 (NEED_MOVBE)
REQUIRED_MASK5 0
REQUIRED_MASK6 0
REQUIRED_MASK7 0
REQUIRED_MASK8 0
REQUIRED_MASK9 0
REQUIRED_MASK10 0
REQUIRED_MASK11 0
REQUIRED_MASK12 0
REQUIRED_MASK13 0
REQUIRED_MASK14 0
REQUIRED_MASK15 0
REQUIRED_MASK16 0
REQUIRED_MASK17 0
REQUIRED_MASK18 0
REQUIRED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 19)
DISABLE_MPX 0
DISABLE_SMAP 0
DISABLE_UMIP 0
DISABLE_VME (1<<(X86_FEATURE_VME & 31))
DISABLE_K6_MTRR (1<<(X86_FEATURE_K6_MTRR & 31))
DISABLE_CYRIX_ARR (1<<(X86_FEATURE_CYRIX_ARR & 31))
DISABLE_CENTAUR_MCR (1<<(X86_FEATURE_CENTAUR_MCR & 31))
DISABLE_PCID 0
DISABLE_PKU 0
DISABLE_OSPKE 0
DISABLE_LA57 (1<<(X86_FEATURE_LA57 & 31))
DISABLE_PTI 0
DISABLED_MASK0 (DISABLE_VME)
DISABLED_MASK1 0
DISABLED_MASK2 0
DISABLED_MASK3 (DISABLE_CYRIX_ARR|DISABLE_CENTAUR_MCR|DISABLE_K6_MTRR)
DISABLED_MASK4 (DISABLE_PCID)
DISABLED_MASK5 0
DISABLED_MASK6 0
DISABLED_MASK7 (DISABLE_PTI)
DISABLED_MASK8 0
DISABLED_MASK9 (DISABLE_MPX|DISABLE_SMAP)
DISABLED_MASK10 0
DISABLED_MASK11 0
DISABLED_MASK12 0
DISABLED_MASK13 0
DISABLED_MASK14 0
DISABLED_MASK15 0
DISABLED_MASK16 (DISABLE_PKU|DISABLE_OSPKE|DISABLE_LA57|DISABLE_UMIP)
DISABLED_MASK17 0
DISABLED_MASK18 0
DISABLED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 19)
NCAPINTS 19
NBUGINTS 1
X86_FEATURE_FPU ( 0*32+ 0)
X86_FEATURE_VME ( 0*32+ 1)
X86_FEATURE_DE ( 0*32+ 2)
X86_FEATURE_PSE ( 0*32+ 3)
X86_FEATURE_TSC ( 0*32+ 4)
X86_FEATURE_MSR ( 0*32+ 5)
X86_FEATURE_PAE ( 0*32+ 6)
X86_FEATURE_MCE ( 0*32+ 7)
X86_FEATURE_CX8 ( 0*32+ 8)
X86_FEATURE_APIC ( 0*32+ 9)
X86_FEATURE_SEP ( 0*32+11)
X86_FEATURE_MTRR ( 0*32+12)
X86_FEATURE_PGE ( 0*32+13)
X86_FEATURE_MCA ( 0*32+14)
X86_FEATURE_CMOV ( 0*32+15)
X86_FEATURE_PAT ( 0*32+16)
X86_FEATURE_PSE36 ( 0*32+17)
X86_FEATURE_PN ( 0*32+18)
X86_FEATURE_CLFLUSH ( 0*32+19)
X86_FEATURE_DS ( 0*32+21)
X86_FEATURE_ACPI ( 0*32+22)
X86_FEATURE_MMX ( 0*32+23)
X86_FEATURE_FXSR ( 0*32+24)
X86_FEATURE_XMM ( 0*32+25)
X86_FEATURE_XMM2 ( 0*32+26)
X86_FEATURE_SELFSNOOP ( 0*32+27)
X86_FEATURE_HT ( 0*32+28)
X86_FEATURE_ACC ( 0*32+29)
X86_FEATURE_IA64 ( 0*32+30)
X86_FEATURE_PBE ( 0*32+31)
X86_FEATURE_SYSCALL ( 1*32+11)
X86_FEATURE_MP ( 1*32+19)
X86_FEATURE_NX ( 1*32+20)
X86_FEATURE_MMXEXT ( 1*32+22)
X86_FEATURE_FXSR_OPT ( 1*32+25)
X86_FEATURE_GBPAGES ( 1*32+26)
X86_FEATURE_RDTSCP ( 1*32+27)
X86_FEATURE_LM ( 1*32+29)
X86_FEATURE_3DNOWEXT ( 1*32+30)
X86_FEATURE_3DNOW ( 1*32+31)
X86_FEATURE_RECOVERY ( 2*32+ 0)
X86_FEATURE_LONGRUN ( 2*32+ 1)
X86_FEATURE_LRTI ( 2*32+ 3)
X86_FEATURE_CXMMX ( 3*32+ 0)
X86_FEATURE_K6_MTRR ( 3*32+ 1)
X86_FEATURE_CYRIX_ARR ( 3*32+ 2)
X86_FEATURE_CENTAUR_MCR ( 3*32+ 3)
X86_FEATURE_K8 ( 3*32+ 4)
X86_FEATURE_K7 ( 3*32+ 5)
X86_FEATURE_P3 ( 3*32+ 6)
X86_FEATURE_P4 ( 3*32+ 7)
X86_FEATURE_CONSTANT_TSC ( 3*32+ 8)
X86_FEATURE_UP ( 3*32+ 9)
X86_FEATURE_ART ( 3*32+10)
X86_FEATURE_ARCH_PERFMON ( 3*32+11)
X86_FEATURE_PEBS ( 3*32+12)
X86_FEATURE_BTS ( 3*32+13)
X86_FEATURE_SYSCALL32 ( 3*32+14)
X86_FEATURE_SYSENTER32 ( 3*32+15)
X86_FEATURE_REP_GOOD ( 3*32+16)
X86_FEATURE_SME_COHERENT ( 3*32+17)
X86_FEATURE_LFENCE_RDTSC ( 3*32+18)
X86_FEATURE_ACC_POWER ( 3*32+19)
X86_FEATURE_NOPL ( 3*32+20)
X86_FEATURE_ALWAYS ( 3*32+21)
X86_FEATURE_XTOPOLOGY ( 3*32+22)
X86_FEATURE_TSC_RELIABLE ( 3*32+23)
X86_FEATURE_NONSTOP_TSC ( 3*32+24)
X86_FEATURE_CPUID ( 3*32+25)
X86_FEATURE_EXTD_APICID ( 3*32+26)
X86_FEATURE_AMD_DCM ( 3*32+27)
X86_FEATURE_APERFMPERF ( 3*32+28)
X86_FEATURE_NONSTOP_TSC_S3 ( 3*32+30)
X86_FEATURE_TSC_KNOWN_FREQ ( 3*32+31)
X86_FEATURE_XMM3 ( 4*32+ 0)
X86_FEATURE_PCLMULQDQ ( 4*32+ 1)
X86_FEATURE_DTES64 ( 4*32+ 2)
X86_FEATURE_MWAIT ( 4*32+ 3)
X86_FEATURE_DSCPL ( 4*32+ 4)
X86_FEATURE_VMX ( 4*32+ 5)
X86_FEATURE_SMX ( 4*32+ 6)
X86_FEATURE_EST ( 4*32+ 7)
X86_FEATURE_TM2 ( 4*32+ 8)
X86_FEATURE_SSSE3 ( 4*32+ 9)
X86_FEATURE_CID ( 4*32+10)
X86_FEATURE_SDBG ( 4*32+11)
X86_FEATURE_FMA ( 4*32+12)
X86_FEATURE_CX16 ( 4*32+13)
X86_FEATURE_XTPR ( 4*32+14)
X86_FEATURE_PDCM ( 4*32+15)
X86_FEATURE_PCID ( 4*32+17)
X86_FEATURE_DCA ( 4*32+18)
X86_FEATURE_XMM4_1 ( 4*32+19)
X86_FEATURE_XMM4_2 ( 4*32+20)
X86_FEATURE_X2APIC ( 4*32+21)
X86_FEATURE_MOVBE ( 4*32+22)
X86_FEATURE_POPCNT ( 4*32+23)
X86_FEATURE_TSC_DEADLINE_TIMER ( 4*32+24)
X86_FEATURE_AES ( 4*32+25)
X86_FEATURE_XSAVE ( 4*32+26)
X86_FEATURE_OSXSAVE ( 4*32+27)
X86_FEATURE_AVX ( 4*32+28)
X86_FEATURE_F16C ( 4*32+29)
X86_FEATURE_RDRAND ( 4*32+30)
X86_FEATURE_HYPERVISOR ( 4*32+31)
X86_FEATURE_XSTORE ( 5*32+ 2)
X86_FEATURE_XSTORE_EN ( 5*32+ 3)
X86_FEATURE_XCRYPT ( 5*32+ 6)
X86_FEATURE_XCRYPT_EN ( 5*32+ 7)
X86_FEATURE_ACE2 ( 5*32+ 8)
X86_FEATURE_ACE2_EN ( 5*32+ 9)
X86_FEATURE_PHE ( 5*32+10)
X86_FEATURE_PHE_EN ( 5*32+11)
X86_FEATURE_PMM ( 5*32+12)
X86_FEATURE_PMM_EN ( 5*32+13)
X86_FEATURE_LAHF_LM ( 6*32+ 0)
X86_FEATURE_CMP_LEGACY ( 6*32+ 1)
X86_FEATURE_SVM ( 6*32+ 2)
X86_FEATURE_EXTAPIC ( 6*32+ 3)
X86_FEATURE_CR8_LEGACY ( 6*32+ 4)
X86_FEATURE_ABM ( 6*32+ 5)
X86_FEATURE_SSE4A ( 6*32+ 6)
X86_FEATURE_MISALIGNSSE ( 6*32+ 7)
X86_FEATURE_3DNOWPREFETCH ( 6*32+ 8)
X86_FEATURE_OSVW ( 6*32+ 9)
X86_FEATURE_IBS ( 6*32+10)
X86_FEATURE_XOP ( 6*32+11)
X86_FEATURE_SKINIT ( 6*32+12)
X86_FEATURE_WDT ( 6*32+13)
X86_FEATURE_LWP ( 6*32+15)
X86_FEATURE_FMA4 ( 6*32+16)
X86_FEATURE_TCE ( 6*32+17)
X86_FEATURE_NODEID_MSR ( 6*32+19)
X86_FEATURE_TBM ( 6*32+21)
X86_FEATURE_TOPOEXT ( 6*32+22)
X86_FEATURE_PERFCTR_CORE ( 6*32+23)
X86_FEATURE_PERFCTR_NB ( 6*32+24)
X86_FEATURE_BPEXT ( 6*32+26)
X86_FEATURE_PTSC ( 6*32+27)
X86_FEATURE_PERFCTR_LLC ( 6*32+28)
X86_FEATURE_MWAITX ( 6*32+29)
X86_FEATURE_RING3MWAIT ( 7*32+ 0)
X86_FEATURE_CPUID_FAULT ( 7*32+ 1)
X86_FEATURE_CPB ( 7*32+ 2)
X86_FEATURE_EPB ( 7*32+ 3)
X86_FEATURE_CAT_L3 ( 7*32+ 4)
X86_FEATURE_CAT_L2 ( 7*32+ 5)
X86_FEATURE_CDP_L3 ( 7*32+ 6)
X86_FEATURE_INVPCID_SINGLE ( 7*32+ 7)
X86_FEATURE_HW_PSTATE ( 7*32+ 8)
X86_FEATURE_PROC_FEEDBACK ( 7*32+ 9)
X86_FEATURE_SME ( 7*32+10)
X86_FEATURE_PTI ( 7*32+11)
X86_FEATURE_KERNEL_IBRS ( 7*32+12)
X86_FEATURE_RSB_VMEXIT ( 7*32+13)
X86_FEATURE_INTEL_PPIN ( 7*32+14)
X86_FEATURE_CDP_L2 ( 7*32+15)
X86_FEATURE_MSR_SPEC_CTRL ( 7*32+16)
X86_FEATURE_SSBD ( 7*32+17)
X86_FEATURE_MBA ( 7*32+18)
X86_FEATURE_RSB_CTXSW ( 7*32+19)
X86_FEATURE_SEV ( 7*32+20)
X86_FEATURE_USE_IBPB ( 7*32+21)
X86_FEATURE_USE_IBRS_FW ( 7*32+22)
X86_FEATURE_SPEC_STORE_BYPASS_DISABLE ( 7*32+23)
X86_FEATURE_LS_CFG_SSBD ( 7*32+24)
X86_FEATURE_IBRS ( 7*32+25)
X86_FEATURE_IBPB ( 7*32+26)
X86_FEATURE_STIBP ( 7*32+27)
X86_FEATURE_ZEN ( 7*32+28)
X86_FEATURE_L1TF_PTEINV ( 7*32+29)
X86_FEATURE_IBRS_ENHANCED ( 7*32+30)
X86_FEATURE_TPR_SHADOW ( 8*32+ 0)
X86_FEATURE_VNMI ( 8*32+ 1)
X86_FEATURE_FLEXPRIORITY ( 8*32+ 2)
X86_FEATURE_EPT ( 8*32+ 3)
X86_FEATURE_VPID ( 8*32+ 4)
X86_FEATURE_VMMCALL ( 8*32+15)
X86_FEATURE_XENPV ( 8*32+16)
X86_FEATURE_EPT_AD ( 8*32+17)
X86_FEATURE_VMCALL ( 8*32+18)
X86_FEATURE_VMW_VMMCALL ( 8*32+19)
X86_FEATURE_FSGSBASE ( 9*32+ 0)
X86_FEATURE_TSC_ADJUST ( 9*32+ 1)
X86_FEATURE_BMI1 ( 9*32+ 3)
X86_FEATURE_HLE ( 9*32+ 4)
X86_FEATURE_AVX2 ( 9*32+ 5)
X86_FEATURE_FDP_EXCPTN_ONLY ( 9*32+ 6)
X86_FEATURE_SMEP ( 9*32+ 7)
X86_FEATURE_BMI2 ( 9*32+ 8)
X86_FEATURE_ERMS ( 9*32+ 9)
X86_FEATURE_INVPCID ( 9*32+10)
X86_FEATURE_RTM ( 9*32+11)
X86_FEATURE_CQM ( 9*32+12)
X86_FEATURE_ZERO_FCS_FDS ( 9*32+13)
X86_FEATURE_MPX ( 9*32+14)
X86_FEATURE_RDT_A ( 9*32+15)
X86_FEATURE_AVX512F ( 9*32+16)
X86_FEATURE_AVX512DQ ( 9*32+17)
X86_FEATURE_RDSEED ( 9*32+18)
X86_FEATURE_ADX ( 9*32+19)
X86_FEATURE_SMAP ( 9*32+20)
X86_FEATURE_AVX512IFMA ( 9*32+21)
X86_FEATURE_CLFLUSHOPT ( 9*32+23)
X86_FEATURE_CLWB ( 9*32+24)
X86_FEATURE_INTEL_PT ( 9*32+25)
X86_FEATURE_AVX512PF ( 9*32+26)
X86_FEATURE_AVX512ER ( 9*32+27)
X86_FEATURE_AVX512CD ( 9*32+28)
X86_FEATURE_SHA_NI ( 9*32+29)
X86_FEATURE_AVX512BW ( 9*32+30)
X86_FEATURE_AVX512VL ( 9*32+31)
X86_FEATURE_XSAVEOPT (10*32+ 0)
X86_FEATURE_XSAVEC (10*32+ 1)
X86_FEATURE_XGETBV1 (10*32+ 2)
X86_FEATURE_XSAVES (10*32+ 3)
X86_FEATURE_CQM_LLC (11*32+ 0)
X86_FEATURE_CQM_OCCUP_LLC (11*32+ 1)
X86_FEATURE_CQM_MBM_TOTAL (11*32+ 2)
X86_FEATURE_CQM_MBM_LOCAL (11*32+ 3)
X86_FEATURE_FENCE_SWAPGS_USER (11*32+ 4)
X86_FEATURE_FENCE_SWAPGS_KERNEL (11*32+ 5)
X86_FEATURE_RRSBA_CTRL (11*32+11)
X86_FEATURE_RETPOLINE (11*32+12)
X86_FEATURE_RETPOLINE_LFENCE (11*32+13)
X86_FEATURE_RSB_VMEXIT_LITE (11*32+17)
X86_FEATURE_MSR_TSX_CTRL (11*32+18)
X86_FEATURE_AVX512_BF16 (12*32+ 5)
X86_FEATURE_CLZERO (13*32+ 0)
X86_FEATURE_IRPERF (13*32+ 1)
X86_FEATURE_XSAVEERPTR (13*32+ 2)
X86_FEATURE_WBNOINVD (13*32+ 9)
X86_FEATURE_AMD_IBPB (13*32+12)
X86_FEATURE_AMD_IBRS (13*32+14)
X86_FEATURE_AMD_STIBP (13*32+15)
X86_FEATURE_AMD_STIBP_ALWAYS_ON (13*32+17)
X86_FEATURE_AMD_SSBD (13*32+24)
X86_FEATURE_VIRT_SSBD (13*32+25)
X86_FEATURE_AMD_SSB_NO (13*32+26)
X86_FEATURE_BTC_NO (13*32+29)
X86_FEATURE_DTHERM (14*32+ 0)
X86_FEATURE_IDA (14*32+ 1)
X86_FEATURE_ARAT (14*32+ 2)
X86_FEATURE_PLN (14*32+ 4)
X86_FEATURE_PTS (14*32+ 6)
X86_FEATURE_HWP (14*32+ 7)
X86_FEATURE_HWP_NOTIFY (14*32+ 8)
X86_FEATURE_HWP_ACT_WINDOW (14*32+ 9)
X86_FEATURE_HWP_EPP (14*32+10)
X86_FEATURE_HWP_PKG_REQ (14*32+11)
X86_FEATURE_NPT (15*32+ 0)
X86_FEATURE_LBRV (15*32+ 1)
X86_FEATURE_SVML (15*32+ 2)
X86_FEATURE_NRIPS (15*32+ 3)
X86_FEATURE_TSCRATEMSR (15*32+ 4)
X86_FEATURE_VMCBCLEAN (15*32+ 5)
X86_FEATURE_FLUSHBYASID (15*32+ 6)
X86_FEATURE_DECODEASSISTS (15*32+ 7)
X86_FEATURE_PAUSEFILTER (15*32+10)
X86_FEATURE_PFTHRESHOLD (15*32+12)
X86_FEATURE_AVIC (15*32+13)
X86_FEATURE_V_VMSAVE_VMLOAD (15*32+15)
X86_FEATURE_VGIF (15*32+16)
X86_FEATURE_AVX512VBMI (16*32+ 1)
X86_FEATURE_UMIP (16*32+ 2)
X86_FEATURE_PKU (16*32+ 3)
X86_FEATURE_OSPKE (16*32+ 4)
X86_FEATURE_WAITPKG (16*32+ 5)
X86_FEATURE_AVX512_VBMI2 (16*32+ 6)
X86_FEATURE_GFNI (16*32+ 8)
X86_FEATURE_VAES (16*32+ 9)
X86_FEATURE_VPCLMULQDQ (16*32+10)
X86_FEATURE_AVX512_VNNI (16*32+11)
X86_FEATURE_AVX512_BITALG (16*32+12)
X86_FEATURE_TME (16*32+13)
X86_FEATURE_AVX512_VPOPCNTDQ (16*32+14)
X86_FEATURE_LA57 (16*32+16)
X86_FEATURE_RDPID (16*32+22)
X86_FEATURE_CLDEMOTE (16*32+25)
X86_FEATURE_MOVDIRI (16*32+27)
X86_FEATURE_MOVDIR64B (16*32+28)
X86_FEATURE_OVERFLOW_RECOV (17*32+ 0)
X86_FEATURE_SUCCOR (17*32+ 1)
X86_FEATURE_SMCA (17*32+ 3)
X86_FEATURE_AVX512_4VNNIW (18*32+ 2)
X86_FEATURE_AVX512_4FMAPS (18*32+ 3)
X86_FEATURE_AVX512_VP2INTERSECT (18*32+ 8)
X86_FEATURE_SRBDS_CTRL (18*32+ 9)
X86_FEATURE_MD_CLEAR (18*32+10)
X86_FEATURE_TSX_FORCE_ABORT (18*32+13)
X86_FEATURE_PCONFIG (18*32+18)
X86_FEATURE_SPEC_CTRL (18*32+26)
X86_FEATURE_INTEL_STIBP (18*32+27)
X86_FEATURE_FLUSH_L1D (18*32+28)
X86_FEATURE_ARCH_CAPABILITIES (18*32+29)
X86_FEATURE_SPEC_CTRL_SSBD (18*32+31)
X86_BUG() (NCAPINTS*32 + ())
X86_BUG_F00F X86_BUG(0)
X86_BUG_FDIV X86_BUG(1)
X86_BUG_COMA X86_BUG(2)
X86_BUG_AMD_TLB_MMATCH X86_BUG(3)
X86_BUG_AMD_APIC_C1E X86_BUG(4)
X86_BUG_11AP X86_BUG(5)
X86_BUG_FXSAVE_LEAK X86_BUG(6)
X86_BUG_CLFLUSH_MONITOR X86_BUG(7)
X86_BUG_SYSRET_SS_ATTRS X86_BUG(8)
X86_BUG_NULL_SEG X86_BUG(10)
X86_BUG_SWAPGS_FENCE X86_BUG(11)
X86_BUG_MONITOR X86_BUG(12)
X86_BUG_AMD_E400 X86_BUG(13)
X86_BUG_CPU_MELTDOWN X86_BUG(14)
X86_BUG_SPECTRE_V1 X86_BUG(15)
X86_BUG_SPECTRE_V2 X86_BUG(16)
X86_BUG_SPEC_STORE_BYPASS X86_BUG(17)
X86_BUG_L1TF X86_BUG(18)
X86_BUG_MDS X86_BUG(19)
X86_BUG_MSBDS_ONLY X86_BUG(20)
X86_BUG_SWAPGS X86_BUG(21)
X86_BUG_TAA X86_BUG(22)
X86_BUG_ITLB_MULTIHIT X86_BUG(23)
X86_BUG_SRBDS X86_BUG(24)
X86_BUG_MMIO_STALE_DATA X86_BUG(25)
X86_BUG_RETBLEED X86_BUG(26)
X86_BUG_EIBRS_PBRSB X86_BUG(27)
X86_BUG_MMIO_UNKNOWN X86_BUG(28)
X86_BUG_SMT_RSB X86_BUG(29)
X86_BUG_GDS X86_BUG(30)
REG_IN "D"
REG_OUT "a"
__const_hweight8() ((unsigned int) ((!!(() & (1ULL << 0))) + (!!(() & (1ULL << 1))) + (!!(() & (1ULL << 2))) + (!!(() & (1ULL << 3))) + (!!(() & (1ULL << 4))) + (!!(() & (1ULL << 5))) + (!!(() & (1ULL << 6))) + (!!(() & (1ULL << 7)))))
__const_hweight16() (__const_hweight8() + __const_hweight8(() >> 8 ))
__const_hweight32() (__const_hweight16() + __const_hweight16(() >> 16))
__const_hweight64() (__const_hweight32() + __const_hweight32(() >> 32))
hweight8() (__builtin_constant_p() ? __const_hweight8() : __arch_hweight8())
hweight16() (__builtin_constant_p() ? __const_hweight16() : __arch_hweight16())
hweight32() (__builtin_constant_p() ? __const_hweight32() : __arch_hweight32())
hweight64() (__builtin_constant_p() ? __const_hweight64() : __arch_hweight64())
HWEIGHT8() (BUILD_BUG_ON_ZERO(!__builtin_constant_p()) + __const_hweight8())
HWEIGHT16() (BUILD_BUG_ON_ZERO(!__builtin_constant_p()) + __const_hweight16())
HWEIGHT32() (BUILD_BUG_ON_ZERO(!__builtin_constant_p()) + __const_hweight32())
HWEIGHT64() (BUILD_BUG_ON_ZERO(!__builtin_constant_p()) + __const_hweight64())
HWEIGHT() HWEIGHT64((u64))
clear_bit_unlock_is_negative_byte clear_bit_unlock_is_negative_byte
__LITTLE_ENDIAN_BITFIELD 
__arch_swab32 __arch_swab32
__arch_swab64 __arch_swab64
___constant_swab16() ((__u16)( (((__u16)() & (__u16)0x00ffU) << 8) | (((__u16)() & (__u16)0xff00U) >> 8)))
___constant_swab32() ((__u32)( (((__u32)() & (__u32)0x000000ffUL) << 24) | (((__u32)() & (__u32)0x0000ff00UL) << 8) | (((__u32)() & (__u32)0x00ff0000UL) >> 8) | (((__u32)() & (__u32)0xff000000UL) >> 24)))
___constant_swab64() ((__u64)( (((__u64)() & (__u64)0x00000000000000ffULL) << 56) | (((__u64)() & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)() & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)() & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)() & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)() & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)() & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)() & (__u64)0xff00000000000000ULL) >> 56)))
___constant_swahw32() ((__u32)( (((__u32)() & (__u32)0x0000ffffUL) << 16) | (((__u32)() & (__u32)0xffff0000UL) >> 16)))
___constant_swahb32() ((__u32)( (((__u32)() & (__u32)0x00ff00ffUL) << 8) | (((__u32)() & (__u32)0xff00ff00UL) >> 8)))
__swab16() (__builtin_constant_p((__u16)()) ? ___constant_swab16() : __fswab16())
__swab32() (__builtin_constant_p((__u32)()) ? ___constant_swab32() : __fswab32())
__swab64() (__builtin_constant_p((__u64)()) ? ___constant_swab64() : __fswab64())
__swahw32() (__builtin_constant_p((__u32)()) ? ___constant_swahw32() : __fswahw32())
__swahb32() (__builtin_constant_p((__u32)()) ? ___constant_swahb32() : __fswahb32())
swab16 __swab16
swab32 __swab32
swab64 __swab64
swab __swab
swahw32 __swahw32
swahb32 __swahb32
swab16p __swab16p
swab32p __swab32p
swab64p __swab64p
swahw32p __swahw32p
swahb32p __swahb32p
swab16s __swab16s
swab32s __swab32s
swab64s __swab64s
swahw32s __swahw32s
swahb32s __swahb32s
__constant_htonl() ((__force __be32)___constant_swab32(()))
__constant_ntohl() ___constant_swab32((__force __be32)())
__constant_htons() ((__force __be16)___constant_swab16(()))
__constant_ntohs() ___constant_swab16((__force __be16)())
__constant_cpu_to_le64() ((__force __le64)(__u64)())
__constant_le64_to_cpu() ((__force __u64)(__le64)())
__constant_cpu_to_le32() ((__force __le32)(__u32)())
__constant_le32_to_cpu() ((__force __u32)(__le32)())
__constant_cpu_to_le16() ((__force __le16)(__u16)())
__constant_le16_to_cpu() ((__force __u16)(__le16)())
__constant_cpu_to_be64() ((__force __be64)___constant_swab64(()))
__constant_be64_to_cpu() ___constant_swab64((__force __u64)(__be64)())
__constant_cpu_to_be32() ((__force __be32)___constant_swab32(()))
__constant_be32_to_cpu() ___constant_swab32((__force __u32)(__be32)())
__constant_cpu_to_be16() ((__force __be16)___constant_swab16(()))
__constant_be16_to_cpu() ___constant_swab16((__force __u16)(__be16)())
__cpu_to_le64() ((__force __le64)(__u64)())
__le64_to_cpu() ((__force __u64)(__le64)())
__cpu_to_le32() ((__force __le32)(__u32)())
__le32_to_cpu() ((__force __u32)(__le32)())
__cpu_to_le16() ((__force __le16)(__u16)())
__le16_to_cpu() ((__force __u16)(__le16)())
__cpu_to_be64() ((__force __be64)__swab64(()))
__be64_to_cpu() __swab64((__force __u64)(__be64)())
__cpu_to_be32() ((__force __be32)__swab32(()))
__be32_to_cpu() __swab32((__force __u32)(__be32)())
__cpu_to_be16() ((__force __be16)__swab16(()))
__be16_to_cpu() __swab16((__force __u16)(__be16)())
__cpu_to_le64s() do { (void)(); } while (0)
__le64_to_cpus() do { (void)(); } while (0)
__cpu_to_le32s() do { (void)(); } while (0)
__le32_to_cpus() do { (void)(); } while (0)
__cpu_to_le16s() do { (void)(); } while (0)
__le16_to_cpus() do { (void)(); } while (0)
__cpu_to_be64s() __swab64s(())
__be64_to_cpus() __swab64s(())
__cpu_to_be32s() __swab32s(())
__be32_to_cpus() __swab32s(())
__cpu_to_be16s() __swab16s(())
__be16_to_cpus() __swab16s(())
cpu_to_le64 __cpu_to_le64
le64_to_cpu __le64_to_cpu
cpu_to_le32 __cpu_to_le32
le32_to_cpu __le32_to_cpu
cpu_to_le16 __cpu_to_le16
le16_to_cpu __le16_to_cpu
cpu_to_be64 __cpu_to_be64
be64_to_cpu __be64_to_cpu
cpu_to_be32 __cpu_to_be32
be32_to_cpu __be32_to_cpu
cpu_to_be16 __cpu_to_be16
be16_to_cpu __be16_to_cpu
cpu_to_le64p __cpu_to_le64p
le64_to_cpup __le64_to_cpup
cpu_to_le32p __cpu_to_le32p
le32_to_cpup __le32_to_cpup
cpu_to_le16p __cpu_to_le16p
le16_to_cpup __le16_to_cpup
cpu_to_be64p __cpu_to_be64p
be64_to_cpup __be64_to_cpup
cpu_to_be32p __cpu_to_be32p
be32_to_cpup __be32_to_cpup
cpu_to_be16p __cpu_to_be16p
be16_to_cpup __be16_to_cpup
cpu_to_le64s __cpu_to_le64s
le64_to_cpus __le64_to_cpus
cpu_to_le32s __cpu_to_le32s
le32_to_cpus __le32_to_cpus
cpu_to_le16s __cpu_to_le16s
le16_to_cpus __le16_to_cpus
cpu_to_be64s __cpu_to_be64s
be64_to_cpus __be64_to_cpus
cpu_to_be32s __cpu_to_be32s
be32_to_cpus __be32_to_cpus
cpu_to_be16s __cpu_to_be16s
be16_to_cpus __be16_to_cpus
___htonl() __cpu_to_be32()
___htons() __cpu_to_be16()
___ntohl() __be32_to_cpu()
___ntohs() __be16_to_cpu()
htonl() ___htonl()
ntohl() ___ntohl()
htons() ___htons()
ntohs() ___ntohs()
BITOP_LE_SWIZZLE 0
ext2_set_bit_atomic(,,) test_and_set_bit_le(, )
ext2_clear_bit_atomic(,,) test_and_clear_bit_le(, )
for_each_set_bit(,,) for (() = find_first_bit((), ()); () < (); () = find_next_bit((), (), () + 1))
for_each_set_bit_from(,,) for (() = find_next_bit((), (), ()); () < (); () = find_next_bit((), (), () + 1))
for_each_clear_bit(,,) for (() = find_first_zero_bit((), ()); () < (); () = find_next_zero_bit((), (), () + 1))
for_each_clear_bit_from(,,) for (() = find_next_zero_bit((), (), ()); () < (); () = find_next_zero_bit((), (), () + 1))
set_mask_bits(,,) \
({ const typeof(*()) mask__ = (), bits__ = (); typeof(*()) old__, new__; do { old__ = READ_ONCE(*()); new__ = (old__ & ~mask__) | bits__; } while (cmpxchg(, old__, new__) != old__); old__; \
})
bit_clear_unless(,,) \
({ const typeof(*()) clear__ = (), test__ = (); typeof(*()) old__, new__; do { old__ = READ_ONCE(*()); new__ = old__ & ~clear__; } while (!(old__ & test__) && cmpxchg(, old__, new__) != old__); !(old__ & test__); \
})
const_ilog2() \
( __builtin_constant_p() ? ( () < 2 ? 0 : () & (1ULL << 63) ? 63 : () & (1ULL << 62) ? 62 : () & (1ULL << 61) ? 61 : () & (1ULL << 60) ? 60 : () & (1ULL << 59) ? 59 : () & (1ULL << 58) ? 58 : () & (1ULL << 57) ? 57 : () & (1ULL << 56) ? 56 : () & (1ULL << 55) ? 55 : () & (1ULL << 54) ? 54 : () & (1ULL << 53) ? 53 : () & (1ULL << 52) ? 52 : () & (1ULL << 51) ? 51 : () & (1ULL << 50) ? 50 : () & (1ULL << 49) ? 49 : () & (1ULL << 48) ? 48 : () & (1ULL << 47) ? 47 : () & (1ULL << 46) ? 46 : () & (1ULL << 45) ? 45 : () & (1ULL << 44) ? 44 : () & (1ULL << 43) ? 43 : () & (1ULL << 42) ? 42 : () & (1ULL << 41) ? 41 : () & (1ULL << 40) ? 40 : () & (1ULL << 39) ? 39 : () & (1ULL << 38) ? 38 : () & (1ULL << 37) ? 37 : () & (1ULL << 36) ? 36 : () & (1ULL << 35) ? 35 : () & (1ULL << 34) ? 34 : () & (1ULL << 33) ? 33 : () & (1ULL << 32) ? 32 : () & (1ULL << 31) ? 31 : () & (1ULL << 30) ? 30 : () & (1ULL << 29) ? 29 : () & (1ULL << 28) ? 28 : () & (1ULL << 27) ? 27 : () & (1ULL << 26) ? 26 : () & (1ULL << 25) ? 25 : () & (1ULL << 24) ? 24 : () & (1ULL << 23) ? 23 : () & (1ULL << 22) ? 22 : () & (1ULL << 21) ? 21 : () & (1ULL << 20) ? 20 : () & (1ULL << 19) ? 19 : () & (1ULL << 18) ? 18 : () & (1ULL << 17) ? 17 : () & (1ULL << 16) ? 16 : () & (1ULL << 15) ? 15 : () & (1ULL << 14) ? 14 : () & (1ULL << 13) ? 13 : () & (1ULL << 12) ? 12 : () & (1ULL << 11) ? 11 : () & (1ULL << 10) ? 10 : () & (1ULL << 9) ? 9 : () & (1ULL << 8) ? 8 : () & (1ULL << 7) ? 7 : () & (1ULL << 6) ? 6 : () & (1ULL << 5) ? 5 : () & (1ULL << 4) ? 4 : () & (1ULL << 3) ? 3 : () & (1ULL << 2) ? 2 : 1) : -1)
ilog2() \
( __builtin_constant_p() ? const_ilog2() : (sizeof() <= 4) ? __ilog2_u32() : __ilog2_u64() )
roundup_pow_of_two() \
( __builtin_constant_p() ? ( (() == 1) ? 1 : (1UL << (ilog2(() - 1) + 1)) ) : __roundup_pow_of_two() )
rounddown_pow_of_two() \
( __builtin_constant_p() ? ( (1UL << ilog2())) : __rounddown_pow_of_two() )
order_base_2() \
( __builtin_constant_p() ? ( (() == 0 || () == 1) ? 0 : ilog2(() - 1) + 1) : __order_base_2() \
)
bits_per() \
( __builtin_constant_p() ? ( (() == 0 || () == 1) ? 1 : ilog2() + 1 ) : __bits_per() \
)
typecheck(,) \
({  __dummy; typeof() __dummy2; (void)(&__dummy == &__dummy2); 1; \
})
typecheck_fn(,) \
({ typeof() __tmp = ; (void)__tmp; \
})
KERN_SOH "\001"
KERN_SOH_ASCII '\001'
KERN_EMERG KERN_SOH "0"
KERN_ALERT KERN_SOH "1"
KERN_CRIT KERN_SOH "2"
KERN_ERR KERN_SOH "3"
KERN_WARNING KERN_SOH "4"
KERN_NOTICE KERN_SOH "5"
KERN_INFO KERN_SOH "6"
KERN_DEBUG KERN_SOH "7"
KERN_DEFAULT ""
KERN_CONT KERN_SOH "c"
LOGLEVEL_SCHED -2
LOGLEVEL_DEFAULT -1
LOGLEVEL_EMERG 0
LOGLEVEL_ALERT 1
LOGLEVEL_CRIT 2
LOGLEVEL_ERR 3
LOGLEVEL_WARNING 4
LOGLEVEL_NOTICE 5
LOGLEVEL_INFO 6
LOGLEVEL_DEBUG 7
SI_LOAD_SHIFT 16
L1_CACHE_SHIFT (CONFIG_X86_L1_CACHE_SHIFT)
L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
__read_mostly __attribute__((__section__(".data..read_mostly")))
INTERNODE_CACHE_SHIFT CONFIG_X86_INTERNODE_CACHE_SHIFT
INTERNODE_CACHE_BYTES (1 << INTERNODE_CACHE_SHIFT)
L1_CACHE_ALIGN() __ALIGN_KERNEL(, L1_CACHE_BYTES)
SMP_CACHE_BYTES L1_CACHE_BYTES
__ro_after_init __attribute__((__section__(".data..ro_after_init")))
____cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES)))
____cacheline_aligned_in_smp ____cacheline_aligned
__cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES), __section__(".data..cacheline_aligned")))
__cacheline_aligned_in_smp __cacheline_aligned
____cacheline_internodealigned_in_smp __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))
PRINTK_MAX_SINGLE_HEADER_LEN 2
CONSOLE_EXT_LOG_MAX 8192
MESSAGE_LOGLEVEL_DEFAULT CONFIG_MESSAGE_LOGLEVEL_DEFAULT
CONSOLE_LOGLEVEL_SILENT 0
CONSOLE_LOGLEVEL_MIN 1
CONSOLE_LOGLEVEL_DEBUG 10
CONSOLE_LOGLEVEL_MOTORMOUTH 15
CONSOLE_LOGLEVEL_DEFAULT CONFIG_CONSOLE_LOGLEVEL_DEFAULT
CONSOLE_LOGLEVEL_QUIET CONFIG_CONSOLE_LOGLEVEL_QUIET
console_loglevel (console_printk[0])
default_message_loglevel (console_printk[1])
minimum_console_loglevel (console_printk[2])
default_console_loglevel (console_printk[3])
DEVKMSG_STR_MAX_SIZE 10
FW_BUG "[Firmware Bug]: "
FW_WARN "[Firmware Warn]: "
FW_INFO "[Firmware Info]: "
HW_ERR "[Hardware Error]: "
DEPRECATED "[Deprecated]: "
no_printk() \
({ if (0) printk(, ##__VA_ARGS__); 0; \
})
printk_ratelimit() __printk_ratelimit(__func__)
pr_fmt() 
pr_printk_hash(,) printk( pr_fmt(), ##__VA_ARGS__)
pr_emerg() pr_printk_hash(KERN_EMERG, , ##__VA_ARGS__)
pr_alert() pr_printk_hash(KERN_ALERT, , ##__VA_ARGS__)
pr_crit() pr_printk_hash(KERN_CRIT, , ##__VA_ARGS__)
pr_err() pr_printk_hash(KERN_ERR, , ##__VA_ARGS__)
pr_warning() pr_printk_hash(KERN_WARNING, , ##__VA_ARGS__)
pr_warn pr_warning
pr_notice() pr_printk_hash(KERN_NOTICE, , ##__VA_ARGS__)
pr_info() pr_printk_hash(KERN_INFO, , ##__VA_ARGS__)
pr_cont() printk(KERN_CONT , ##__VA_ARGS__)
pr_devel() no_printk(KERN_DEBUG pr_fmt(), ##__VA_ARGS__)
STATIC_KEY_CHECK_USE() WARN(!static_key_initialized, "%s(): static key '%pS' used before call to jump_label_init()", __func__, ())
HAVE_JUMP_LABEL_BATCH 
JUMP_LABEL_NOP_SIZE 5
STATIC_KEY_INIT_NOP P6_NOP5_ATOMIC
JUMP_TYPE_FALSE 0UL
JUMP_TYPE_TRUE 1UL
JUMP_TYPE_LINKED 2UL
JUMP_TYPE_MASK 3UL
STATIC_KEY_INIT_TRUE { .enabled = { 1 }, { .entries = (void *)JUMP_TYPE_TRUE } }
STATIC_KEY_INIT_FALSE { .enabled = { 0 }, { .entries = (void *)JUMP_TYPE_FALSE } }
STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
jump_label_enabled static_key_enabled
STATIC_KEY_TRUE_INIT (struct static_key_true) { .key = STATIC_KEY_INIT_TRUE, }
STATIC_KEY_FALSE_INIT (struct static_key_false){ .key = STATIC_KEY_INIT_FALSE, }
DEFINE_STATIC_KEY_TRUE() struct static_key_true  = STATIC_KEY_TRUE_INIT
DEFINE_STATIC_KEY_TRUE_RO() struct static_key_true  __ro_after_init = STATIC_KEY_TRUE_INIT
DECLARE_STATIC_KEY_TRUE() extern struct static_key_true 
DEFINE_STATIC_KEY_FALSE() struct static_key_false  = STATIC_KEY_FALSE_INIT
DEFINE_STATIC_KEY_FALSE_RO() struct static_key_false  __ro_after_init = STATIC_KEY_FALSE_INIT
DECLARE_STATIC_KEY_FALSE() extern struct static_key_false 
DEFINE_STATIC_KEY_ARRAY_TRUE(,) struct static_key_true [] = { [0 ... () - 1] = STATIC_KEY_TRUE_INIT, }
DEFINE_STATIC_KEY_ARRAY_FALSE(,) struct static_key_false [] = { [0 ... () - 1] = STATIC_KEY_FALSE_INIT, }
static_key_enabled() \
({ if (!__builtin_types_compatible_p(typeof(*), struct static_key) && !__builtin_types_compatible_p(typeof(*), struct static_key_true) && !__builtin_types_compatible_p(typeof(*), struct static_key_false)) ____wrong_branch_error(); static_key_count((struct static_key *)) > 0; \
})
static_branch_likely() \
({ bool branch; if (__builtin_types_compatible_p(typeof(*), struct static_key_true)) branch = !arch_static_branch(&()->key, true); else if (__builtin_types_compatible_p(typeof(*), struct static_key_false)) branch = !arch_static_branch_jump(&()->key, true); else branch = ____wrong_branch_error(); likely(branch); \
})
static_branch_unlikely() \
({ bool branch; if (__builtin_types_compatible_p(typeof(*), struct static_key_true)) branch = arch_static_branch_jump(&()->key, false); else if (__builtin_types_compatible_p(typeof(*), struct static_key_false)) branch = arch_static_branch(&()->key, false); else branch = ____wrong_branch_error(); unlikely(branch); \
})
static_branch_inc() static_key_slow_inc(&()->key)
static_branch_dec() static_key_slow_dec(&()->key)
static_branch_inc_cpuslocked() static_key_slow_inc_cpuslocked(&()->key)
static_branch_dec_cpuslocked() static_key_slow_dec_cpuslocked(&()->key)
static_branch_enable() static_key_enable(&()->key)
static_branch_disable() static_key_disable(&()->key)
static_branch_enable_cpuslocked() static_key_enable_cpuslocked(&()->key)
static_branch_disable_cpuslocked() static_key_disable_cpuslocked(&()->key)
_DPRINTK_FLAGS_NONE 0
_DPRINTK_FLAGS_PRINT (1<<0)
_DPRINTK_FLAGS_INCL_MODNAME (1<<1)
_DPRINTK_FLAGS_INCL_FUNCNAME (1<<2)
_DPRINTK_FLAGS_INCL_LINENO (1<<3)
_DPRINTK_FLAGS_INCL_TID (1<<4)
_DPRINTK_FLAGS_DEFAULT 0
DEFINE_DYNAMIC_DEBUG_METADATA(,) static struct _ddebug __aligned(8) __attribute__((section("__verbose")))  = { .modname = KBUILD_MODNAME, .function = __func__, .filename = __FILE__, .format = (), .lineno = __LINE__, .flags = _DPRINTK_FLAGS_DEFAULT, _DPRINTK_KEY_INIT }
_DPRINTK_KEY_INIT .key.dd_key_false = (STATIC_KEY_FALSE_INIT)
DYNAMIC_DEBUG_BRANCH() static_branch_unlikely(&.key.dd_key_false)
__dynamic_func_call(,,) do { DEFINE_DYNAMIC_DEBUG_METADATA(, ); if (DYNAMIC_DEBUG_BRANCH()) (&, ##__VA_ARGS__); \
} while (0)
__dynamic_func_call_no_desc(,,) do { DEFINE_DYNAMIC_DEBUG_METADATA(, ); if (DYNAMIC_DEBUG_BRANCH()) (__VA_ARGS__); \
} while (0)
_dynamic_func_call(,) __dynamic_func_call(__UNIQUE_ID(ddebug), , , ##__VA_ARGS__)
_dynamic_func_call_no_desc(,) __dynamic_func_call_no_desc(__UNIQUE_ID(ddebug), , , ##__VA_ARGS__)
dynamic_pr_debug() _dynamic_func_call(, __dynamic_pr_debug, pr_fmt(), ##__VA_ARGS__)
dynamic_dev_dbg(,) _dynamic_func_call(,__dynamic_dev_dbg, , , ##__VA_ARGS__)
dynamic_netdev_dbg(,) _dynamic_func_call(, __dynamic_netdev_dbg, , , ##__VA_ARGS__)
dynamic_ibdev_dbg(,) _dynamic_func_call(, __dynamic_ibdev_dbg, , , ##__VA_ARGS__)
dynamic_hex_dump(,,,,,,) _dynamic_func_call_no_desc(__builtin_constant_p() ?  : "hexdump", print_hex_dump, KERN_DEBUG, , , , , , , )
pr_debug() dynamic_pr_debug(, ##__VA_ARGS__)
printk_once() \
({ static bool __section(.data.once) __print_once; bool __ret_print_once = !__print_once; if (!__print_once) { __print_once = true; printk(, ##__VA_ARGS__); } unlikely(__ret_print_once); \
})
printk_deferred_once() \
({ static bool __section(.data.once) __print_once; bool __ret_print_once = !__print_once; if (!__print_once) { __print_once = true; printk_deferred(, ##__VA_ARGS__); } unlikely(__ret_print_once); \
})
pr_emerg_once() printk_once(KERN_EMERG pr_fmt(), ##__VA_ARGS__)
pr_alert_once() printk_once(KERN_ALERT pr_fmt(), ##__VA_ARGS__)
pr_crit_once() printk_once(KERN_CRIT pr_fmt(), ##__VA_ARGS__)
pr_err_once() printk_once(KERN_ERR pr_fmt(), ##__VA_ARGS__)
pr_warn_once() printk_once(KERN_WARNING pr_fmt(), ##__VA_ARGS__)
pr_notice_once() printk_once(KERN_NOTICE pr_fmt(), ##__VA_ARGS__)
pr_info_once() printk_once(KERN_INFO pr_fmt(), ##__VA_ARGS__)
pr_cont_once() printk_once(KERN_CONT pr_fmt(), ##__VA_ARGS__)
pr_devel_once() no_printk(KERN_DEBUG pr_fmt(), ##__VA_ARGS__)
pr_debug_once() no_printk(KERN_DEBUG pr_fmt(), ##__VA_ARGS__)
printk_ratelimited() \
({ static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL, DEFAULT_RATELIMIT_BURST); if (__ratelimit(&_rs)) printk(, ##__VA_ARGS__); \
})
pr_emerg_ratelimited() printk_ratelimited(KERN_EMERG pr_fmt(), ##__VA_ARGS__)
pr_alert_ratelimited() printk_ratelimited(KERN_ALERT pr_fmt(), ##__VA_ARGS__)
pr_crit_ratelimited() printk_ratelimited(KERN_CRIT pr_fmt(), ##__VA_ARGS__)
pr_err_ratelimited() printk_ratelimited(KERN_ERR pr_fmt(), ##__VA_ARGS__)
pr_warn_ratelimited() printk_ratelimited(KERN_WARNING pr_fmt(), ##__VA_ARGS__)
pr_notice_ratelimited() printk_ratelimited(KERN_NOTICE pr_fmt(), ##__VA_ARGS__)
pr_info_ratelimited() printk_ratelimited(KERN_INFO pr_fmt(), ##__VA_ARGS__)
pr_devel_ratelimited() no_printk(KERN_DEBUG pr_fmt(), ##__VA_ARGS__)
pr_debug_ratelimited() do { static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL, DEFAULT_RATELIMIT_BURST); DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, pr_fmt()); if (DYNAMIC_DEBUG_BRANCH(descriptor) && __ratelimit(&_rs)) __dynamic_pr_debug(&descriptor, pr_fmt(), ##__VA_ARGS__); \
} while (0)
print_hex_dump_debug(,,,,,,) dynamic_hex_dump(, , , , , , )
print_hex_dump_bytes(,,,) print_hex_dump_debug(, , 16, 1, , , true)
BUILD_BUG_ON_ZERO() (sizeof(struct { int:(-!!()); }))
__BUILD_BUG_ON_NOT_POWER_OF_2() BUILD_BUG_ON((() & (() - 1)) != 0)
BUILD_BUG_ON_NOT_POWER_OF_2() BUILD_BUG_ON(() == 0 || ((() & (() - 1)) != 0))
BUILD_BUG_ON_INVALID() ((void)(sizeof((__force long)())))
BUILD_BUG_ON_MSG(,) compiletime_assert(!(), )
BUILD_BUG_ON() BUILD_BUG_ON_MSG(, "BUILD_BUG_ON failed: " #)
BUILD_BUG() BUILD_BUG_ON_MSG(1, "BUILD_BUG failed")
static_assert() __static_assert(, ##__VA_ARGS__, #)
__static_assert(,) _Static_assert(, )
do_div(,) ({ uint32_t __base = (); uint32_t __rem; __rem = ((uint64_t)()) % __base; () = ((uint64_t)()) / __base; __rem; })
mul_u64_u32_div mul_u64_u32_div
STACK_MAGIC 0xdeadbeef
REPEAT_BYTE() ((~0ul / 0xff) * ())
ALIGN(,) __ALIGN_KERNEL((), ())
ALIGN_DOWN(,) __ALIGN_KERNEL(() - (() - 1), ())
__ALIGN_MASK(,) __ALIGN_KERNEL_MASK((), ())
PTR_ALIGN(,) ((typeof())ALIGN((unsigned long)(), ()))
IS_ALIGNED(,) ((() & ((typeof())() - 1)) == 0)
READ 0
WRITE 1
ARRAY_SIZE() (sizeof() / sizeof(()[0]) + __must_be_array())
u64_to_user_ptr() ( \
{ typecheck(u64, ()); (void __user *)(uintptr_t)(); \
} \
)
__round_mask(,) ((__typeof__())(()-1))
round_up(,) (((()-1) | __round_mask(, ))+1)
round_down(,) (() & ~__round_mask(, ))
FIELD_SIZEOF(,) (sizeof(((*)0)->))
typeof_member(,) typeof(((*)0)->)
DIV_ROUND_UP __KERNEL_DIV_ROUND_UP
DIV_ROUND_DOWN_ULL(,) ({ unsigned long long _tmp = (); do_div(_tmp, ); _tmp; })
DIV_ROUND_UP_ULL(,) DIV_ROUND_DOWN_ULL((unsigned long long)() + () - 1, ())
DIV_ROUND_UP_SECTOR_T(,) DIV_ROUND_UP(,)
roundup(,) ( \
{ typeof() __y = ; ((() + (__y - 1)) / __y) * __y; \
} \
)
rounddown(,) ( \
{ typeof() __x = (); __x - (__x % ()); \
} \
)
DIV_ROUND_CLOSEST(,) ( \
{ typeof() __x = ; typeof() __d = ; (((typeof())-1) > 0 || ((typeof())-1) > 0 || (((__x) > 0) == ((__d) > 0))) ? (((__x) + ((__d) / 2)) / (__d)) : (((__x) - ((__d) / 2)) / (__d)); \
} \
)
DIV_ROUND_CLOSEST_ULL(,) ( \
{ typeof() __d = ; unsigned long long _tmp = () + (__d) / 2; do_div(_tmp, __d); _tmp; \
} \
)
mult_frac(,,) ( \
{ typeof() quot = () / (); typeof() rem = () % (); (quot * ()) + ((rem * ()) / ()); \
} \
)
_RET_IP_ (unsigned long)__builtin_return_address(0)
_THIS_IP_ ({ __label__ __here; __here: (unsigned long)&&__here; })
sector_div(,) do_div(, )
upper_32_bits() ((u32)((() >> 16) >> 16))
lower_32_bits() ((u32)())
might_resched() _cond_resched()
might_sleep() do { might_resched(); } while (0)
cant_sleep() do { } while (0)
sched_annotate_sleep() do { } while (0)
non_block_start() do { } while (0)
non_block_end() do { } while (0)
might_sleep_if() do { if () might_sleep(); } while (0)
abs() __abs_choose_expr(, long long, __abs_choose_expr(, long, __abs_choose_expr(, int, __abs_choose_expr(, short, __abs_choose_expr(, char, __builtin_choose_expr( __builtin_types_compatible_p(typeof(), char), (char)({ signed char __x = (); __x<0?-__x:__x; }), ((void)0)))))))
__abs_choose_expr(,,) __builtin_choose_expr( __builtin_types_compatible_p(typeof(), signed ) || __builtin_types_compatible_p(typeof(), unsigned ), ({ signed  __x = (); __x < 0 ? -__x : __x; }), )
PANIC_CPU_INVALID -1
TAINT_PROPRIETARY_MODULE 0
TAINT_FORCED_MODULE 1
TAINT_CPU_OUT_OF_SPEC 2
TAINT_FORCED_RMMOD 3
TAINT_MACHINE_CHECK 4
TAINT_BAD_PAGE 5
TAINT_USER 6
TAINT_DIE 7
TAINT_OVERRIDDEN_ACPI_TABLE 8
TAINT_WARN 9
TAINT_CRAP 10
TAINT_FIRMWARE_WORKAROUND 11
TAINT_OOT_MODULE 12
TAINT_UNSIGNED_MODULE 13
TAINT_SOFTLOCKUP 14
TAINT_LIVEPATCH 15
TAINT_AUX 16
TAINT_RANDSTRUCT 17
TAINT_FLAGS_COUNT 18
hex_asc_lo() hex_asc[(() & 0x0f)]
hex_asc_hi() hex_asc[(() & 0xf0) >> 4]
hex_asc_upper_lo() hex_asc_upper[(() & 0x0f)]
hex_asc_upper_hi() hex_asc_upper[(() & 0xf0) >> 4]
__trace_printk_check_format(,) do { if (0) ____trace_printk_check_format(, ##); \
} while (0)
trace_printk() do { char _______STR[] = __stringify((__VA_ARGS__)); if (sizeof(_______STR) > 3) do_trace_printk(, ##__VA_ARGS__); else trace_puts(); \
} while (0)
do_trace_printk(,) do { static const char *trace_printk_fmt __used __attribute__((section("__trace_printk_fmt"))) = __builtin_constant_p() ?  : NULL; __trace_printk_check_format(, ##); if (__builtin_constant_p()) __trace_bprintk(_THIS_IP_, trace_printk_fmt, ##); else __trace_printk(_THIS_IP_, , ##); \
} while (0)
trace_puts() ({ static const char *trace_printk_fmt __used __attribute__((section("__trace_printk_fmt"))) = __builtin_constant_p() ?  : NULL; if (__builtin_constant_p()) __trace_bputs(_THIS_IP_, trace_printk_fmt); else __trace_puts(_THIS_IP_, , strlen()); \
})
ftrace_vprintk(,) do { if (__builtin_constant_p()) { static const char *trace_printk_fmt __used __attribute__((section("__trace_printk_fmt"))) = __builtin_constant_p() ?  : NULL; __ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, ); } else __ftrace_vprintk(_THIS_IP_, , ); \
} while (0)
__typecheck(,) (!!(sizeof((typeof() *)1 == (typeof() *)1)))
__is_constexpr() (sizeof(int) == sizeof(*(8 ? ((void *)((long)() * 0l)) : (int *)8)))
__no_side_effects(,) (__is_constexpr() && __is_constexpr())
__safe_cmp(,) (__typecheck(, ) && __no_side_effects(, ))
__cmp(,,) (()  () ? () : ())
__cmp_once(,,,,) ({ typeof()  = (); typeof()  = (); __cmp(, , ); })
__careful_cmp(,,) __builtin_choose_expr(__safe_cmp(, ), __cmp(, , ), __cmp_once(, , __UNIQUE_ID(__x), __UNIQUE_ID(__y), ))
min(,) __careful_cmp(, , <)
max(,) __careful_cmp(, , >)
min3(,,) min((typeof())min(, ), )
max3(,,) max((typeof())max(, ), )
min_not_zero(,) ({ typeof() __x = (); typeof() __y = (); __x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })
clamp(,,) min((typeof())max(, ), )
min_t(,,) __careful_cmp(()(), ()(), <)
max_t(,,) __careful_cmp(()(), ()(), >)
clamp_t(,,,) min_t(, max_t(, , ), )
clamp_val(,,) clamp_t(typeof(), , , )
swap(,) do { typeof() __tmp = (); () = (); () = __tmp; } while (0)
__COUNT_ARGS(,,,,,,,,,,,,,,) 
COUNT_ARGS() __COUNT_ARGS(, ##, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
__CONCAT(,)  ## 
CONCATENATE(,) __CONCAT(, )
container_of(,,) ({ void *__mptr = (void *)(); BUILD_BUG_ON_MSG(!__same_type(*(), (( *)0)->) && !__same_type(*(), void), "pointer type mismatch in container_of()"); (( *)(__mptr - offsetof(, ))); })
container_of_safe(,,) ({ void *__mptr = (void *)(); BUILD_BUG_ON_MSG(!__same_type(*(), (( *)0)->) && !__same_type(*(), void), "pointer type mismatch in container_of()"); IS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) : (( *)(__mptr - offsetof(, ))); })
REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD 
VERIFY_OCTAL_PERMISSIONS() (BUILD_BUG_ON_ZERO(() < 0) + BUILD_BUG_ON_ZERO(() > 0777) + /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */ BUILD_BUG_ON_ZERO(((() >> 6) & 4) < ((() >> 3) & 4)) + BUILD_BUG_ON_ZERO(((() >> 3) & 4) < (() & 4)) + /* USER_WRITABLE >= GROUP_WRITABLE */ BUILD_BUG_ON_ZERO(((() >> 6) & 2) < ((() >> 3) & 2)) + /* OTHER_WRITABLE?  Generally considered a bad idea. */ BUILD_BUG_ON_ZERO(() & 2) + ())
LIST_HEAD_INIT() { &(), &() }
LIST_HEAD() struct list_head  = LIST_HEAD_INIT()
list_entry(,,) container_of(, , )
list_first_entry(,,) list_entry(()->next, , )
list_last_entry(,,) list_entry(()->prev, , )
list_first_entry_or_null(,,) ({ struct list_head *head__ = (); struct list_head *pos__ = READ_ONCE(head__->next); pos__ != head__ ? list_entry(pos__, , ) : NULL; \
})
list_next_entry(,) list_entry(()->.next, typeof(*()), )
list_prev_entry(,) list_entry(()->.prev, typeof(*()), )
list_for_each(,) for ( = ()->next;  != ();  = ->next)
list_for_each_prev(,) for ( = ()->prev;  != ();  = ->prev)
list_for_each_safe(,,) for ( = ()->next,  = ->next;  != ();  = ,  = ->next)
list_for_each_prev_safe(,,) for ( = ()->prev,  = ->prev;  != ();  = ,  = ->prev)
list_entry_is_head(,,) (&-> == ())
list_for_each_entry(,,) for ( = list_first_entry(, typeof(*), ); !list_entry_is_head(, , );  = list_next_entry(, ))
list_for_each_entry_reverse(,,) for ( = list_last_entry(, typeof(*), ); !list_entry_is_head(, , );  = list_prev_entry(, ))
list_prepare_entry(,,) (() ? : list_entry(, typeof(*), ))
list_for_each_entry_continue(,,) for ( = list_next_entry(, ); !list_entry_is_head(, , );  = list_next_entry(, ))
list_for_each_entry_continue_reverse(,,) for ( = list_prev_entry(, ); !list_entry_is_head(, , );  = list_prev_entry(, ))
list_for_each_entry_from(,,) for (; !list_entry_is_head(, , );  = list_next_entry(, ))
list_for_each_entry_from_reverse(,,) for (; !list_entry_is_head(, , );  = list_prev_entry(, ))
list_for_each_entry_safe(,,,) for ( = list_first_entry(, typeof(*), ),  = list_next_entry(, ); !list_entry_is_head(, , );  = ,  = list_next_entry(, ))
list_for_each_entry_safe_continue(,,,) for ( = list_next_entry(, ),  = list_next_entry(, ); !list_entry_is_head(, , );  = ,  = list_next_entry(, ))
list_for_each_entry_safe_from(,,,) for ( = list_next_entry(, ); !list_entry_is_head(, , );  = ,  = list_next_entry(, ))
list_for_each_entry_safe_reverse(,,,) for ( = list_last_entry(, typeof(*), ),  = list_prev_entry(, ); !list_entry_is_head(, , );  = ,  = list_prev_entry(, ))
list_safe_reset_next(,,)  = list_next_entry(, )
HLIST_HEAD_INIT { .first = NULL }
HLIST_HEAD() struct hlist_head  = { .first = NULL }
INIT_HLIST_HEAD() (()->first = NULL)
hlist_entry(,,) container_of(,,)
hlist_for_each(,) for ( = ()->first;  ;  = ->next)
hlist_for_each_safe(,,) for ( = ()->first;  && ({  = ->next; 1; });  = )
hlist_entry_safe(,,) ({ typeof() ____ptr = (); ____ptr ? hlist_entry(____ptr, , ) : NULL; })
hlist_for_each_entry(,,) for ( = hlist_entry_safe(()->first, typeof(*()), ); ;  = hlist_entry_safe(()->.next, typeof(*()), ))
hlist_for_each_entry_continue(,) for ( = hlist_entry_safe(()->.next, typeof(*()), ); ;  = hlist_entry_safe(()->.next, typeof(*()), ))
hlist_for_each_entry_from(,) for (; ;  = hlist_entry_safe(()->.next, typeof(*()), ))
hlist_for_each_entry_safe(,,,) for ( = hlist_entry_safe(()->first, typeof(*), );  && ({  = ->.next; 1; });  = hlist_entry_safe(, typeof(*), ))
STAT_HAVE_NSEC 1
INIT_STRUCT_STAT_PADDING() do { .__pad0 = 0; .__unused[0] = 0; .__unused[1] = 0; .__unused[2] = 0; \
} while (0)
S_IFMT 00170000
S_IFSOCK 0140000
S_IFLNK 0120000
S_IFREG 0100000
S_IFBLK 0060000
S_IFDIR 0040000
S_IFCHR 0020000
S_IFIFO 0010000
S_ISUID 0004000
S_ISGID 0002000
S_ISVTX 0001000
S_ISLNK() ((() & S_IFMT) == S_IFLNK)
S_ISREG() ((() & S_IFMT) == S_IFREG)
S_ISDIR() ((() & S_IFMT) == S_IFDIR)
S_ISCHR() ((() & S_IFMT) == S_IFCHR)
S_ISBLK() ((() & S_IFMT) == S_IFBLK)
S_ISFIFO() ((() & S_IFMT) == S_IFIFO)
S_ISSOCK() ((() & S_IFMT) == S_IFSOCK)
S_IRWXU 00700
S_IRUSR 00400
S_IWUSR 00200
S_IXUSR 00100
S_IRWXG 00070
S_IRGRP 00040
S_IWGRP 00020
S_IXGRP 00010
S_IRWXO 00007
S_IROTH 00004
S_IWOTH 00002
S_IXOTH 00001
STATX_TYPE 0x00000001U
STATX_MODE 0x00000002U
STATX_NLINK 0x00000004U
STATX_UID 0x00000008U
STATX_GID 0x00000010U
STATX_ATIME 0x00000020U
STATX_MTIME 0x00000040U
STATX_CTIME 0x00000080U
STATX_INO 0x00000100U
STATX_SIZE 0x00000200U
STATX_BLOCKS 0x00000400U
STATX_BASIC_STATS 0x000007ffU
STATX_BTIME 0x00000800U
STATX_ALL 0x00000fffU
STATX__RESERVED 0x80000000U
STATX_ATTR_COMPRESSED 0x00000004
STATX_ATTR_IMMUTABLE 0x00000010
STATX_ATTR_APPEND 0x00000020
STATX_ATTR_NODUMP 0x00000040
STATX_ATTR_ENCRYPTED 0x00000800
STATX_ATTR_AUTOMOUNT 0x00001000
S_IRWXUGO (S_IRWXU|S_IRWXG|S_IRWXO)
S_IALLUGO (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO)
S_IRUGO (S_IRUSR|S_IRGRP|S_IROTH)
S_IWUGO (S_IWUSR|S_IWGRP|S_IWOTH)
S_IXUGO (S_IXUSR|S_IXGRP|S_IXOTH)
UTIME_NOW ((1l << 30) - 1l)
UTIME_OMIT ((1l << 30) - 2l)
PREEMPT_BITS 8
SOFTIRQ_BITS 8
HARDIRQ_BITS 4
NMI_BITS 1
PREEMPT_SHIFT 0
SOFTIRQ_SHIFT (PREEMPT_SHIFT + PREEMPT_BITS)
HARDIRQ_SHIFT (SOFTIRQ_SHIFT + SOFTIRQ_BITS)
NMI_SHIFT (HARDIRQ_SHIFT + HARDIRQ_BITS)
__IRQ_MASK() ((1UL << ())-1)
PREEMPT_MASK (__IRQ_MASK(PREEMPT_BITS) << PREEMPT_SHIFT)
SOFTIRQ_MASK (__IRQ_MASK(SOFTIRQ_BITS) << SOFTIRQ_SHIFT)
HARDIRQ_MASK (__IRQ_MASK(HARDIRQ_BITS) << HARDIRQ_SHIFT)
NMI_MASK (__IRQ_MASK(NMI_BITS) << NMI_SHIFT)
PREEMPT_OFFSET (1UL << PREEMPT_SHIFT)
SOFTIRQ_OFFSET (1UL << SOFTIRQ_SHIFT)
HARDIRQ_OFFSET (1UL << HARDIRQ_SHIFT)
NMI_OFFSET (1UL << NMI_SHIFT)
SOFTIRQ_DISABLE_OFFSET (2 * SOFTIRQ_OFFSET)
PREEMPT_DISABLED (PREEMPT_DISABLE_OFFSET + PREEMPT_ENABLED)
INIT_PREEMPT_COUNT PREEMPT_OFFSET
FORK_PREEMPT_COUNT (2*PREEMPT_DISABLE_OFFSET + PREEMPT_ENABLED)
__percpu_seg gs
__percpu_mov_op movq
__percpu_prefix "%%"__stringify(__percpu_seg)":"
__my_cpu_offset this_cpu_read(this_cpu_off)
arch_raw_cpu_ptr() \
({ unsigned long tcp_ptr__; asm volatile("add " __percpu_arg(1) ", %0" : "=r" (tcp_ptr__) : "m" (this_cpu_off), "0" ()); (typeof(*()) __kernel __force *)tcp_ptr__; \
})
__percpu_arg() __percpu_prefix "%" #
DECLARE_INIT_PER_CPU() extern typeof() init_per_cpu_var()
init_per_cpu_var() init_per_cpu__##
percpu_to_op(,,,) do { typedef typeof() pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = (); (void)pto_tmp__; } switch (sizeof()) { case 1: asm  ( "b %1,"__percpu_arg(0) : "+m" () : "qi" ((pto_T__)())); break; case 2: asm  ( "w %1,"__percpu_arg(0) : "+m" () : "ri" ((pto_T__)())); break; case 4: asm  ( "l %1,"__percpu_arg(0) : "+m" () : "ri" ((pto_T__)())); break; case 8: asm  ( "q %1,"__percpu_arg(0) : "+m" () : "re" ((pto_T__)())); break; default: __bad_percpu_size(); } \
} while (0)
percpu_add_op(,,) do { typedef typeof() pao_T__; const int pao_ID__ = (__builtin_constant_p() && (() == 1 || () == -1)) ? (int)() : 0; if (0) { pao_T__ pao_tmp__; pao_tmp__ = (); (void)pao_tmp__; } switch (sizeof()) { case 1: if (pao_ID__ == 1) asm  ("incb "__percpu_arg(0) : "+m" ()); else if (pao_ID__ == -1) asm  ("decb "__percpu_arg(0) : "+m" ()); else asm  ("addb %1, "__percpu_arg(0) : "+m" () : "qi" ((pao_T__)())); break; case 2: if (pao_ID__ == 1) asm  ("incw "__percpu_arg(0) : "+m" ()); else if (pao_ID__ == -1) asm  ("decw "__percpu_arg(0) : "+m" ()); else asm  ("addw %1, "__percpu_arg(0) : "+m" () : "ri" ((pao_T__)())); break; case 4: if (pao_ID__ == 1) asm  ("incl "__percpu_arg(0) : "+m" ()); else if (pao_ID__ == -1) asm  ("decl "__percpu_arg(0) : "+m" ()); else asm  ("addl %1, "__percpu_arg(0) : "+m" () : "ri" ((pao_T__)())); break; case 8: if (pao_ID__ == 1) asm  ("incq "__percpu_arg(0) : "+m" ()); else if (pao_ID__ == -1) asm  ("decq "__percpu_arg(0) : "+m" ()); else asm  ("addq %1, "__percpu_arg(0) : "+m" () : "re" ((pao_T__)())); break; default: __bad_percpu_size(); } \
} while (0)
percpu_from_op(,,) \
({ typeof() pfo_ret__; switch (sizeof()) { case 1: asm  ( "b "__percpu_arg(1)",%0" : "=q" (pfo_ret__) : "m" ()); break; case 2: asm  ( "w "__percpu_arg(1)",%0" : "=r" (pfo_ret__) : "m" ()); break; case 4: asm  ( "l "__percpu_arg(1)",%0" : "=r" (pfo_ret__) : "m" ()); break; case 8: asm  ( "q "__percpu_arg(1)",%0" : "=r" (pfo_ret__) : "m" ()); break; default: __bad_percpu_size(); } pfo_ret__; \
})
percpu_stable_op(,) \
({ typeof() pfo_ret__; switch (sizeof()) { case 1: asm( "b "__percpu_arg(P1)",%0" : "=q" (pfo_ret__) : "p" (&())); break; case 2: asm( "w "__percpu_arg(P1)",%0" : "=r" (pfo_ret__) : "p" (&())); break; case 4: asm( "l "__percpu_arg(P1)",%0" : "=r" (pfo_ret__) : "p" (&())); break; case 8: asm( "q "__percpu_arg(P1)",%0" : "=r" (pfo_ret__) : "p" (&())); break; default: __bad_percpu_size(); } pfo_ret__; \
})
percpu_unary_op(,,) \
({ switch (sizeof()) { case 1: asm  ( "b "__percpu_arg(0) : "+m" ()); break; case 2: asm  ( "w "__percpu_arg(0) : "+m" ()); break; case 4: asm  ( "l "__percpu_arg(0) : "+m" ()); break; case 8: asm  ( "q "__percpu_arg(0) : "+m" ()); break; default: __bad_percpu_size(); } \
})
percpu_add_return_op(,,) \
({ typeof() paro_ret__ = ; switch (sizeof()) { case 1: asm  ("xaddb %0, "__percpu_arg(1) : "+q" (paro_ret__), "+m" () : : "memory"); break; case 2: asm  ("xaddw %0, "__percpu_arg(1) : "+r" (paro_ret__), "+m" () : : "memory"); break; case 4: asm  ("xaddl %0, "__percpu_arg(1) : "+r" (paro_ret__), "+m" () : : "memory"); break; case 8: asm  ("xaddq %0, "__percpu_arg(1) : "+re" (paro_ret__), "+m" () : : "memory"); break; default: __bad_percpu_size(); } paro_ret__ += ; paro_ret__; \
})
percpu_xchg_op(,,) \
({ typeof() pxo_ret__; typeof() pxo_new__ = (); switch (sizeof()) { case 1: asm  ("\n\tmov "__percpu_arg(1)",%%al" "\n1:\tcmpxchgb %2, "__percpu_arg(1) "\n\tjnz 1b" : "=&a" (pxo_ret__), "+m" () : "q" (pxo_new__) : "memory"); break; case 2: asm  ("\n\tmov "__percpu_arg(1)",%%ax" "\n1:\tcmpxchgw %2, "__percpu_arg(1) "\n\tjnz 1b" : "=&a" (pxo_ret__), "+m" () : "r" (pxo_new__) : "memory"); break; case 4: asm  ("\n\tmov "__percpu_arg(1)",%%eax" "\n1:\tcmpxchgl %2, "__percpu_arg(1) "\n\tjnz 1b" : "=&a" (pxo_ret__), "+m" () : "r" (pxo_new__) : "memory"); break; case 8: asm  ("\n\tmov "__percpu_arg(1)",%%rax" "\n1:\tcmpxchgq %2, "__percpu_arg(1) "\n\tjnz 1b" : "=&a" (pxo_ret__), "+m" () : "r" (pxo_new__) : "memory"); break; default: __bad_percpu_size(); } pxo_ret__; \
})
percpu_cmpxchg_op(,,,) \
({ typeof() pco_ret__; typeof() pco_old__ = (); typeof() pco_new__ = (); switch (sizeof()) { case 1: asm  ("cmpxchgb %2, "__percpu_arg(1) : "=a" (pco_ret__), "+m" () : "q" (pco_new__), "0" (pco_old__) : "memory"); break; case 2: asm  ("cmpxchgw %2, "__percpu_arg(1) : "=a" (pco_ret__), "+m" () : "r" (pco_new__), "0" (pco_old__) : "memory"); break; case 4: asm  ("cmpxchgl %2, "__percpu_arg(1) : "=a" (pco_ret__), "+m" () : "r" (pco_new__), "0" (pco_old__) : "memory"); break; case 8: asm  ("cmpxchgq %2, "__percpu_arg(1) : "=a" (pco_ret__), "+m" () : "r" (pco_new__), "0" (pco_old__) : "memory"); break; default: __bad_percpu_size(); } pco_ret__; \
})
this_cpu_read_stable() percpu_stable_op("mov", )
raw_cpu_read_1() percpu_from_op(, "mov", )
raw_cpu_read_2() percpu_from_op(, "mov", )
raw_cpu_read_4() percpu_from_op(, "mov", )
raw_cpu_write_1(,) percpu_to_op(, "mov", (), )
raw_cpu_write_2(,) percpu_to_op(, "mov", (), )
raw_cpu_write_4(,) percpu_to_op(, "mov", (), )
raw_cpu_add_1(,) percpu_add_op(, (), )
raw_cpu_add_2(,) percpu_add_op(, (), )
raw_cpu_add_4(,) percpu_add_op(, (), )
raw_cpu_and_1(,) percpu_to_op(, "and", (), )
raw_cpu_and_2(,) percpu_to_op(, "and", (), )
raw_cpu_and_4(,) percpu_to_op(, "and", (), )
raw_cpu_or_1(,) percpu_to_op(, "or", (), )
raw_cpu_or_2(,) percpu_to_op(, "or", (), )
raw_cpu_or_4(,) percpu_to_op(, "or", (), )
raw_percpu_xchg_op(,) \
({ typeof() pxo_ret__ = raw_cpu_read(); raw_cpu_write(, ()); pxo_ret__; \
})
raw_cpu_xchg_1(,) raw_percpu_xchg_op(, )
raw_cpu_xchg_2(,) raw_percpu_xchg_op(, )
raw_cpu_xchg_4(,) raw_percpu_xchg_op(, )
this_cpu_read_1() percpu_from_op(volatile, "mov", )
this_cpu_read_2() percpu_from_op(volatile, "mov", )
this_cpu_read_4() percpu_from_op(volatile, "mov", )
this_cpu_write_1(,) percpu_to_op(volatile, "mov", (), )
this_cpu_write_2(,) percpu_to_op(volatile, "mov", (), )
this_cpu_write_4(,) percpu_to_op(volatile, "mov", (), )
this_cpu_add_1(,) percpu_add_op(volatile, (), )
this_cpu_add_2(,) percpu_add_op(volatile, (), )
this_cpu_add_4(,) percpu_add_op(volatile, (), )
this_cpu_and_1(,) percpu_to_op(volatile, "and", (), )
this_cpu_and_2(,) percpu_to_op(volatile, "and", (), )
this_cpu_and_4(,) percpu_to_op(volatile, "and", (), )
this_cpu_or_1(,) percpu_to_op(volatile, "or", (), )
this_cpu_or_2(,) percpu_to_op(volatile, "or", (), )
this_cpu_or_4(,) percpu_to_op(volatile, "or", (), )
this_cpu_xchg_1(,) percpu_xchg_op(volatile, , )
this_cpu_xchg_2(,) percpu_xchg_op(volatile, , )
this_cpu_xchg_4(,) percpu_xchg_op(volatile, , )
raw_cpu_add_return_1(,) percpu_add_return_op(, , )
raw_cpu_add_return_2(,) percpu_add_return_op(, , )
raw_cpu_add_return_4(,) percpu_add_return_op(, , )
raw_cpu_cmpxchg_1(,,) percpu_cmpxchg_op(, , , )
raw_cpu_cmpxchg_2(,,) percpu_cmpxchg_op(, , , )
raw_cpu_cmpxchg_4(,,) percpu_cmpxchg_op(, , , )
this_cpu_add_return_1(,) percpu_add_return_op(volatile, , )
this_cpu_add_return_2(,) percpu_add_return_op(volatile, , )
this_cpu_add_return_4(,) percpu_add_return_op(volatile, , )
this_cpu_cmpxchg_1(,,) percpu_cmpxchg_op(volatile, , , )
this_cpu_cmpxchg_2(,,) percpu_cmpxchg_op(volatile, , , )
this_cpu_cmpxchg_4(,,) percpu_cmpxchg_op(volatile, , , )
percpu_cmpxchg8b_double(,,,,,) \
({ bool __ret; typeof() __o1 = (), __n1 = (); typeof() __o2 = (), __n2 = (); asm volatile("cmpxchg8b "__percpu_arg(1) CC_SET(z) : CC_OUT(z) (__ret), "+m" (), "+m" (), "+a" (__o1), "+d" (__o2) : "b" (__n1), "c" (__n2)); __ret; \
})
raw_cpu_cmpxchg_double_4 percpu_cmpxchg8b_double
this_cpu_cmpxchg_double_4 percpu_cmpxchg8b_double
raw_cpu_read_8() percpu_from_op(, "mov", )
raw_cpu_write_8(,) percpu_to_op(, "mov", (), )
raw_cpu_add_8(,) percpu_add_op(, (), )
raw_cpu_and_8(,) percpu_to_op(, "and", (), )
raw_cpu_or_8(,) percpu_to_op(, "or", (), )
raw_cpu_add_return_8(,) percpu_add_return_op(, , )
raw_cpu_xchg_8(,) raw_percpu_xchg_op(, )
raw_cpu_cmpxchg_8(,,) percpu_cmpxchg_op(, , , )
this_cpu_read_8() percpu_from_op(volatile, "mov", )
this_cpu_write_8(,) percpu_to_op(volatile, "mov", (), )
this_cpu_add_8(,) percpu_add_op(volatile, (), )
this_cpu_and_8(,) percpu_to_op(volatile, "and", (), )
this_cpu_or_8(,) percpu_to_op(volatile, "or", (), )
this_cpu_add_return_8(,) percpu_add_return_op(volatile, , )
this_cpu_xchg_8(,) percpu_xchg_op(volatile, , )
this_cpu_cmpxchg_8(,,) percpu_cmpxchg_op(volatile, , , )
percpu_cmpxchg16b_double(,,,,,) \
({ bool __ret; typeof() __o1 = (), __n1 = (); typeof() __o2 = (), __n2 = (); alternative_io("leaq %P1,%%rsi\n\tcall this_cpu_cmpxchg16b_emu\n\t", "cmpxchg16b " __percpu_arg(1) "\n\tsetz %0\n\t", X86_FEATURE_CX16, ASM_OUTPUT2("=a" (__ret), "+m" (), "+m" (), "+d" (__o2)), "b" (__n1), "c" (__n2), "a" (__o1) : "rsi"); __ret; \
})
raw_cpu_cmpxchg_double_8 percpu_cmpxchg16b_double
this_cpu_cmpxchg_double_8 percpu_cmpxchg16b_double
x86_this_cpu_test_bit(,) (__builtin_constant_p(()) ? x86_this_cpu_constant_test_bit((), ()) : x86_this_cpu_variable_test_bit((), ()))
NR_CPUS CONFIG_NR_CPUS
MIN_THREADS_LEFT_FOR_ROOT 4
PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)
PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : (sizeof(long) > 4 ? 4 * 1024 * 1024 : PID_MAX_DEFAULT))
PIDS_PER_CPU_DEFAULT 1024
PIDS_PER_CPU_MIN 8
PER_CPU_SHARED_ALIGNED_SECTION "..shared_aligned"
PER_CPU_ALIGNED_SECTION "..shared_aligned"
PER_CPU_FIRST_SECTION "..first"
__PCPU_ATTRS() __percpu __attribute__((section(PER_CPU_BASE_SECTION ))) PER_CPU_ATTRIBUTES
__PCPU_DUMMY_ATTRS __attribute__((section(".discard"), unused))
DECLARE_PER_CPU_SECTION(,,) extern __PCPU_ATTRS() __typeof__() 
DEFINE_PER_CPU_SECTION(,,) __PCPU_ATTRS() __typeof__() 
DECLARE_PER_CPU(,) DECLARE_PER_CPU_SECTION(, , "")
DEFINE_PER_CPU(,) DEFINE_PER_CPU_SECTION(, , "")
DECLARE_PER_CPU_FIRST(,) DECLARE_PER_CPU_SECTION(, , PER_CPU_FIRST_SECTION)
DEFINE_PER_CPU_FIRST(,) DEFINE_PER_CPU_SECTION(, , PER_CPU_FIRST_SECTION)
DECLARE_PER_CPU_SHARED_ALIGNED(,) DECLARE_PER_CPU_SECTION(, , PER_CPU_SHARED_ALIGNED_SECTION) ____cacheline_aligned_in_smp
DEFINE_PER_CPU_SHARED_ALIGNED(,) DEFINE_PER_CPU_SECTION(, , PER_CPU_SHARED_ALIGNED_SECTION) ____cacheline_aligned_in_smp
DECLARE_PER_CPU_ALIGNED(,) DECLARE_PER_CPU_SECTION(, , PER_CPU_ALIGNED_SECTION) ____cacheline_aligned
DEFINE_PER_CPU_ALIGNED(,) DEFINE_PER_CPU_SECTION(, , PER_CPU_ALIGNED_SECTION) ____cacheline_aligned
DECLARE_PER_CPU_PAGE_ALIGNED(,) DECLARE_PER_CPU_SECTION(, , "..page_aligned") __aligned(PAGE_SIZE)
DEFINE_PER_CPU_PAGE_ALIGNED(,) DEFINE_PER_CPU_SECTION(, , "..page_aligned") __aligned(PAGE_SIZE)
DECLARE_PER_CPU_READ_MOSTLY(,) DECLARE_PER_CPU_SECTION(, , "..read_mostly")
DEFINE_PER_CPU_READ_MOSTLY(,) DEFINE_PER_CPU_SECTION(, , "..read_mostly")
DECLARE_PER_CPU_DECRYPTED(,) DECLARE_PER_CPU_SECTION(, , "..decrypted")
DEFINE_PER_CPU_DECRYPTED(,) DEFINE_PER_CPU_SECTION(, , "..decrypted")
EXPORT_PER_CPU_SYMBOL() EXPORT_SYMBOL()
EXPORT_PER_CPU_SYMBOL_GPL() EXPORT_SYMBOL_GPL()
__verify_pcpu_ptr() do { const void __percpu *__vpp_verify = (typeof(() + 0))NULL; (void)__vpp_verify; \
} while (0)
SHIFT_PERCPU_PTR(,) RELOC_HIDE((typeof(*()) __kernel __force *)(), ())
per_cpu_ptr(,) \
({ __verify_pcpu_ptr(); SHIFT_PERCPU_PTR((), per_cpu_offset(())); \
})
raw_cpu_ptr() \
({ __verify_pcpu_ptr(); arch_raw_cpu_ptr(); \
})
this_cpu_ptr() raw_cpu_ptr()
per_cpu(,) (*per_cpu_ptr(&(), ))
get_cpu_var() \
(*({ preempt_disable(); this_cpu_ptr(&); \
}))
put_cpu_var() do { (void)&(); preempt_enable(); \
} while (0)
get_cpu_ptr() \
({ preempt_disable(); this_cpu_ptr(); \
})
put_cpu_ptr() do { (void)(); preempt_enable(); \
} while (0)
__pcpu_size_call_return(,) \
({ typeof() pscr_ret__; __verify_pcpu_ptr(&()); switch(sizeof()) { case 1: pscr_ret__ = ##1(); break; case 2: pscr_ret__ = ##2(); break; case 4: pscr_ret__ = ##4(); break; case 8: pscr_ret__ = ##8(); break; default: __bad_size_call_parameter(); break; } pscr_ret__; \
})
__pcpu_size_call_return2(,) \
({ typeof() pscr2_ret__; __verify_pcpu_ptr(&()); switch(sizeof()) { case 1: pscr2_ret__ = ##1(, __VA_ARGS__); break; case 2: pscr2_ret__ = ##2(, __VA_ARGS__); break; case 4: pscr2_ret__ = ##4(, __VA_ARGS__); break; case 8: pscr2_ret__ = ##8(, __VA_ARGS__); break; default: __bad_size_call_parameter(); break; } pscr2_ret__; \
})
__pcpu_double_call_return_bool(,,) \
({ bool pdcrb_ret__; __verify_pcpu_ptr(&()); BUILD_BUG_ON(sizeof() != sizeof()); VM_BUG_ON((unsigned long)(&()) % (2 * sizeof())); VM_BUG_ON((unsigned long)(&()) != (unsigned long)(&()) + sizeof()); switch(sizeof()) { case 1: pdcrb_ret__ = ##1(, , __VA_ARGS__); break; case 2: pdcrb_ret__ = ##2(, , __VA_ARGS__); break; case 4: pdcrb_ret__ = ##4(, , __VA_ARGS__); break; case 8: pdcrb_ret__ = ##8(, , __VA_ARGS__); break; default: __bad_size_call_parameter(); break; } pdcrb_ret__; \
})
__pcpu_size_call(,) do { __verify_pcpu_ptr(&()); switch(sizeof()) { case 1: ##1(, __VA_ARGS__);break; case 2: ##2(, __VA_ARGS__);break; case 4: ##4(, __VA_ARGS__);break; case 8: ##8(, __VA_ARGS__);break; default: __bad_size_call_parameter();break; } \
} while (0)
raw_cpu_read() __pcpu_size_call_return(raw_cpu_read_, )
raw_cpu_write(,) __pcpu_size_call(raw_cpu_write_, , )
raw_cpu_add(,) __pcpu_size_call(raw_cpu_add_, , )
raw_cpu_and(,) __pcpu_size_call(raw_cpu_and_, , )
raw_cpu_or(,) __pcpu_size_call(raw_cpu_or_, , )
raw_cpu_add_return(,) __pcpu_size_call_return2(raw_cpu_add_return_, , )
raw_cpu_xchg(,) __pcpu_size_call_return2(raw_cpu_xchg_, , )
raw_cpu_cmpxchg(,,) __pcpu_size_call_return2(raw_cpu_cmpxchg_, , , )
raw_cpu_cmpxchg_double(,,,,,) __pcpu_double_call_return_bool(raw_cpu_cmpxchg_double_, , , , , , )
raw_cpu_sub(,) raw_cpu_add(, -())
raw_cpu_inc() raw_cpu_add(, 1)
raw_cpu_dec() raw_cpu_sub(, 1)
raw_cpu_sub_return(,) raw_cpu_add_return(, -(typeof())())
raw_cpu_inc_return() raw_cpu_add_return(, 1)
raw_cpu_dec_return() raw_cpu_add_return(, -1)
__this_cpu_read() \
({ __this_cpu_preempt_check("read"); raw_cpu_read(); \
})
__this_cpu_write(,) \
({ __this_cpu_preempt_check("write"); raw_cpu_write(, ); \
})
__this_cpu_add(,) \
({ __this_cpu_preempt_check("add"); raw_cpu_add(, ); \
})
__this_cpu_and(,) \
({ __this_cpu_preempt_check("and"); raw_cpu_and(, ); \
})
__this_cpu_or(,) \
({ __this_cpu_preempt_check("or"); raw_cpu_or(, ); \
})
__this_cpu_add_return(,) \
({ __this_cpu_preempt_check("add_return"); raw_cpu_add_return(, ); \
})
__this_cpu_xchg(,) \
({ __this_cpu_preempt_check("xchg"); raw_cpu_xchg(, ); \
})
__this_cpu_cmpxchg(,,) \
({ __this_cpu_preempt_check("cmpxchg"); raw_cpu_cmpxchg(, , ); \
})
__this_cpu_cmpxchg_double(,,,,,) \
({ __this_cpu_preempt_check("cmpxchg_double"); raw_cpu_cmpxchg_double(, , , , , ); \
})
__this_cpu_sub(,) __this_cpu_add(, -(typeof())())
__this_cpu_inc() __this_cpu_add(, 1)
__this_cpu_dec() __this_cpu_sub(, 1)
__this_cpu_sub_return(,) __this_cpu_add_return(, -(typeof())())
__this_cpu_inc_return() __this_cpu_add_return(, 1)
__this_cpu_dec_return() __this_cpu_add_return(, -1)
this_cpu_read() __pcpu_size_call_return(this_cpu_read_, )
this_cpu_write(,) __pcpu_size_call(this_cpu_write_, , )
this_cpu_add(,) __pcpu_size_call(this_cpu_add_, , )
this_cpu_and(,) __pcpu_size_call(this_cpu_and_, , )
this_cpu_or(,) __pcpu_size_call(this_cpu_or_, , )
this_cpu_add_return(,) __pcpu_size_call_return2(this_cpu_add_return_, , )
this_cpu_xchg(,) __pcpu_size_call_return2(this_cpu_xchg_, , )
this_cpu_cmpxchg(,,) __pcpu_size_call_return2(this_cpu_cmpxchg_, , , )
this_cpu_cmpxchg_double(,,,,,) __pcpu_double_call_return_bool(this_cpu_cmpxchg_double_, , , , , , )
this_cpu_sub(,) this_cpu_add(, -(typeof())())
this_cpu_inc() this_cpu_add(, 1)
this_cpu_dec() this_cpu_sub(, 1)
this_cpu_sub_return(,) this_cpu_add_return(, -(typeof())())
this_cpu_inc_return() this_cpu_add_return(, 1)
this_cpu_dec_return() this_cpu_add_return(, -1)
per_cpu_offset() (__per_cpu_offset[])
my_cpu_offset __my_cpu_offset
PER_CPU_BASE_SECTION ".data..percpu"
PER_CPU_ATTRIBUTES 
raw_cpu_generic_read() \
({ *raw_cpu_ptr(&()); \
})
raw_cpu_generic_to_op(,,) do { *raw_cpu_ptr(&())  ; \
} while (0)
raw_cpu_generic_add_return(,) \
({ typeof(&()) __p = raw_cpu_ptr(&()); *__p += ; *__p; \
})
raw_cpu_generic_xchg(,) \
({ typeof(&()) __p = raw_cpu_ptr(&()); typeof() __ret; __ret = *__p; *__p = ; __ret; \
})
raw_cpu_generic_cmpxchg(,,) \
({ typeof(&()) __p = raw_cpu_ptr(&()); typeof() __ret; __ret = *__p; if (__ret == ()) *__p = ; __ret; \
})
raw_cpu_generic_cmpxchg_double(,,,,,) \
({ typeof(&()) __p1 = raw_cpu_ptr(&()); typeof(&()) __p2 = raw_cpu_ptr(&()); int __ret = 0; if (*__p1 == () && *__p2 == ()) { *__p1 = ; *__p2 = ; __ret = 1; } (__ret); \
})
__this_cpu_generic_read_nopreempt() \
({ typeof() __ret; preempt_disable_notrace(); __ret = READ_ONCE(*raw_cpu_ptr(&())); preempt_enable_notrace(); __ret; \
})
__this_cpu_generic_read_noirq() \
({ typeof() __ret; unsigned long __flags; raw_local_irq_save(__flags); __ret = raw_cpu_generic_read(); raw_local_irq_restore(__flags); __ret; \
})
this_cpu_generic_read() \
({ typeof() __ret; if (__native_word()) __ret = __this_cpu_generic_read_nopreempt(); else __ret = __this_cpu_generic_read_noirq(); __ret; \
})
this_cpu_generic_to_op(,,) do { unsigned long __flags; raw_local_irq_save(__flags); raw_cpu_generic_to_op(, , ); raw_local_irq_restore(__flags); \
} while (0)
this_cpu_generic_add_return(,) \
({ typeof() __ret; unsigned long __flags; raw_local_irq_save(__flags); __ret = raw_cpu_generic_add_return(, ); raw_local_irq_restore(__flags); __ret; \
})
this_cpu_generic_xchg(,) \
({ typeof() __ret; unsigned long __flags; raw_local_irq_save(__flags); __ret = raw_cpu_generic_xchg(, ); raw_local_irq_restore(__flags); __ret; \
})
this_cpu_generic_cmpxchg(,,) \
({ typeof() __ret; unsigned long __flags; raw_local_irq_save(__flags); __ret = raw_cpu_generic_cmpxchg(, , ); raw_local_irq_restore(__flags); __ret; \
})
this_cpu_generic_cmpxchg_double(,,,,,) \
({ int __ret; unsigned long __flags; raw_local_irq_save(__flags); __ret = raw_cpu_generic_cmpxchg_double(, , , , , ); raw_local_irq_restore(__flags); __ret; \
})
raw_cpu_cmpxchg_double_1(,,,,,) raw_cpu_generic_cmpxchg_double(, , , , , )
raw_cpu_cmpxchg_double_2(,,,,,) raw_cpu_generic_cmpxchg_double(, , , , , )
this_cpu_cmpxchg_double_1(,,,,,) this_cpu_generic_cmpxchg_double(, , , , , )
this_cpu_cmpxchg_double_2(,,,,,) this_cpu_generic_cmpxchg_double(, , , , , )
DEFINE_EARLY_PER_CPU(,,) DEFINE_PER_CPU(, ) = ; __typeof__() ##_early_map[NR_CPUS] __initdata = { [0 ... NR_CPUS-1] =  }; __typeof__() *##_early_ptr __refdata = ##_early_map
DEFINE_EARLY_PER_CPU_READ_MOSTLY(,,) DEFINE_PER_CPU_READ_MOSTLY(, ) = ; __typeof__() ##_early_map[NR_CPUS] __initdata = { [0 ... NR_CPUS-1] =  }; __typeof__() *##_early_ptr __refdata = ##_early_map
EXPORT_EARLY_PER_CPU_SYMBOL() EXPORT_PER_CPU_SYMBOL()
DECLARE_EARLY_PER_CPU(,) DECLARE_PER_CPU(, ); extern __typeof__() *##_early_ptr; extern __typeof__() ##_early_map[]
DECLARE_EARLY_PER_CPU_READ_MOSTLY(,) DECLARE_PER_CPU_READ_MOSTLY(, ); extern __typeof__() *##_early_ptr; extern __typeof__() ##_early_map[]
early_per_cpu_ptr() (##_early_ptr)
early_per_cpu_map(,) (##_early_map[])
early_per_cpu(,) *(early_per_cpu_ptr() ? &early_per_cpu_ptr()[] : &per_cpu(, ))
ASM_UD0 ".byte 0x0f, 0xff"
ASM_UD1 ".byte 0x0f, 0xb9"
ASM_UD2 ".byte 0x0f, 0x0b"
INSN_UD0 0xff0f
INSN_UD2 0x0b0f
LEN_UD2 2
__BUG_REL() ".long " __stringify() " - 2b"
_BUG_FLAGS(,) do { asm_inline volatile("1:\t"  "\n" ".pushsection __bug_table,\"aw\"\n" "2:\t" __BUG_REL(1b) "\t# bug_entry::bug_addr\n" "\t" __BUG_REL(%c0) "\t# bug_entry::file\n" "\t.word %c1" "\t# bug_entry::line\n" "\t.word %c2" "\t# bug_entry::flags\n" "\t.org 2b+%c3\n" ".popsection" : : "i" (__FILE__), "i" (__LINE__), "i" (), "i" (sizeof(struct bug_entry))); \
} while (0)
HAVE_ARCH_BUG 
BUG() do { _BUG_FLAGS(ASM_UD2, 0); unreachable(); \
} while (0)
__WARN_FLAGS() do { _BUG_FLAGS(ASM_UD2, BUGFLAG_WARNING|()); annotate_reachable(); \
} while (0)
CUT_HERE "------------[ cut here ]------------\n"
BUGFLAG_WARNING (1 << 0)
BUGFLAG_ONCE (1 << 1)
BUGFLAG_DONE (1 << 2)
BUGFLAG_NO_CUT_HERE (1 << 3)
BUGFLAG_TAINT() (() << 8)
BUG_GET_TAINT() (()->flags >> 8)
BUG_ON() do { if (unlikely()) BUG(); } while (0)
__WARN() __WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))
__WARN_printf(,) do { __warn_printk(); __WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT()); } while (0)
WARN_ON_ONCE() ({ int __ret_warn_on = !!(); if (unlikely(__ret_warn_on)) __WARN_FLAGS(BUGFLAG_ONCE | BUGFLAG_TAINT(TAINT_WARN)); unlikely(__ret_warn_on); \
})
WARN_ON() ({ int __ret_warn_on = !!(); if (unlikely(__ret_warn_on)) __WARN(); unlikely(__ret_warn_on); \
})
WARN(,) ({ int __ret_warn_on = !!(); if (unlikely(__ret_warn_on)) __WARN_printf(TAINT_WARN, ); unlikely(__ret_warn_on); \
})
WARN_TAINT(,,) ({ int __ret_warn_on = !!(); if (unlikely(__ret_warn_on)) __WARN_printf(, ); unlikely(__ret_warn_on); \
})
WARN_ONCE(,) ({ static bool __section(.data.once) __warned; int __ret_warn_once = !!(); if (unlikely(__ret_warn_once && !__warned)) { __warned = true; WARN(1, ); } unlikely(__ret_warn_once); \
})
WARN_TAINT_ONCE(,,) ({ static bool __section(.data.once) __warned; int __ret_warn_once = !!(); if (unlikely(__ret_warn_once && !__warned)) { __warned = true; WARN_TAINT(1, , ); } unlikely(__ret_warn_once); \
})
WARN_ON_SMP() WARN_ON()
MAYBE_BUILD_BUG_ON() do { if (__builtin_constant_p(())) BUILD_BUG_ON(); else BUG_ON(); } while (0)
CHECK_DATA_CORRUPTION(,) check_data_corruption(({ bool corruption = unlikely(); if (corruption) { if (IS_ENABLED(CONFIG_BUG_ON_DATA_CORRUPTION)) { pr_err(, ##__VA_ARGS__); BUG(); } else WARN(1, , ##__VA_ARGS__); } corruption; }))
div64_long(,) div64_s64((), ())
div64_ul(,) div64_u64((), ())
DIV64_U64_ROUND_UP(,) ({ u64 _tmp = (); div64_u64(() + _tmp - 1, _tmp); })
DIV64_U64_ROUND_CLOSEST(,) ({ u64 _tmp = (); div64_u64(() + _tmp / 2, _tmp); })
_STRUCT_TIMESPEC 
ITIMER_REAL 0
ITIMER_VIRTUAL 1
ITIMER_PROF 2
CLOCK_REALTIME 0
CLOCK_MONOTONIC 1
CLOCK_PROCESS_CPUTIME_ID 2
CLOCK_THREAD_CPUTIME_ID 3
CLOCK_MONOTONIC_RAW 4
CLOCK_REALTIME_COARSE 5
CLOCK_MONOTONIC_COARSE 6
CLOCK_BOOTTIME 7
CLOCK_REALTIME_ALARM 8
CLOCK_BOOTTIME_ALARM 9
CLOCK_SGI_CYCLE 10
CLOCK_TAI 11
MAX_CLOCKS 16
CLOCKS_MASK (CLOCK_REALTIME | CLOCK_MONOTONIC)
CLOCKS_MONO CLOCK_MONOTONIC
TIMER_ABSTIME 0x01
MSEC_PER_SEC 1000L
USEC_PER_MSEC 1000L
NSEC_PER_USEC 1000L
NSEC_PER_MSEC 1000000L
USEC_PER_SEC 1000000L
NSEC_PER_SEC 1000000000L
FSEC_PER_SEC 1000000000000000LL
TIME64_MAX ((s64)~((u64)1 << 63))
TIME64_MIN (-TIME64_MAX - 1)
KTIME_MAX ((s64)~((u64)1 << 63))
KTIME_SEC_MAX (KTIME_MAX / NSEC_PER_SEC)
TIME_UPTIME_SEC_MAX (30LL * 365 * 24 *3600)
TIME_SETTOD_SEC_MAX (KTIME_SEC_MAX - TIME_UPTIME_SEC_MAX)
EPERM 1
ENOENT 2
ESRCH 3
EINTR 4
EIO 5
ENXIO 6
E2BIG 7
ENOEXEC 8
EBADF 9
ECHILD 10
EAGAIN 11
ENOMEM 12
EACCES 13
EFAULT 14
ENOTBLK 15
EBUSY 16
EEXIST 17
EXDEV 18
ENODEV 19
ENOTDIR 20
EISDIR 21
EINVAL 22
ENFILE 23
EMFILE 24
ENOTTY 25
ETXTBSY 26
EFBIG 27
ENOSPC 28
ESPIPE 29
EROFS 30
EMLINK 31
EPIPE 32
EDOM 33
ERANGE 34
EDEADLK 35
ENAMETOOLONG 36
ENOLCK 37
ENOSYS 38
ENOTEMPTY 39
ELOOP 40
EWOULDBLOCK EAGAIN
ENOMSG 42
EIDRM 43
ECHRNG 44
EL2NSYNC 45
EL3HLT 46
EL3RST 47
ELNRNG 48
EUNATCH 49
ENOCSI 50
EL2HLT 51
EBADE 52
EBADR 53
EXFULL 54
ENOANO 55
EBADRQC 56
EBADSLT 57
EDEADLOCK EDEADLK
EBFONT 59
ENOSTR 60
ENODATA 61
ETIME 62
ENOSR 63
ENONET 64
ENOPKG 65
EREMOTE 66
ENOLINK 67
EADV 68
ESRMNT 69
ECOMM 70
EPROTO 71
EMULTIHOP 72
EDOTDOT 73
EBADMSG 74
EOVERFLOW 75
ENOTUNIQ 76
EBADFD 77
EREMCHG 78
ELIBACC 79
ELIBBAD 80
ELIBSCN 81
ELIBMAX 82
ELIBEXEC 83
EILSEQ 84
ERESTART 85
ESTRPIPE 86
EUSERS 87
ENOTSOCK 88
EDESTADDRREQ 89
EMSGSIZE 90
EPROTOTYPE 91
ENOPROTOOPT 92
EPROTONOSUPPORT 93
ESOCKTNOSUPPORT 94
EOPNOTSUPP 95
EPFNOSUPPORT 96
EAFNOSUPPORT 97
EADDRINUSE 98
EADDRNOTAVAIL 99
ENETDOWN 100
ENETUNREACH 101
ENETRESET 102
ECONNABORTED 103
ECONNRESET 104
ENOBUFS 105
EISCONN 106
ENOTCONN 107
ESHUTDOWN 108
ETOOMANYREFS 109
ETIMEDOUT 110
ECONNREFUSED 111
EHOSTDOWN 112
EHOSTUNREACH 113
EALREADY 114
EINPROGRESS 115
ESTALE 116
EUCLEAN 117
ENOTNAM 118
ENAVAIL 119
EISNAM 120
EREMOTEIO 121
EDQUOT 122
ENOMEDIUM 123
EMEDIUMTYPE 124
ECANCELED 125
ENOKEY 126
EKEYEXPIRED 127
EKEYREVOKED 128
EKEYREJECTED 129
EOWNERDEAD 130
ENOTRECOVERABLE 131
ERFKILL 132
EHWPOISON 133
ERESTARTSYS 512
ERESTARTNOINTR 513
ERESTARTNOHAND 514
ENOIOCTLCMD 515
ERESTART_RESTARTBLOCK 516
EPROBE_DEFER 517
EOPENSTALE 518
ENOPARAM 519
EBADHANDLE 521
ENOTSYNC 522
EBADCOOKIE 523
ENOTSUPP 524
ETOOSMALL 525
ESERVERFAULT 526
EBADTYPE 527
EJUKEBOX 528
EIOCBQUEUED 529
ERECALLCONFLICT 530
current get_current()
current_thread_info() ((struct thread_info *)current)
SETUP_NONE 0
SETUP_E820_EXT 1
SETUP_DTB 2
SETUP_PCI 3
SETUP_EFI 4
SETUP_APPLE_PROPERTIES 5
SETUP_JAILHOUSE 6
RAMDISK_IMAGE_START_MASK 0x07FF
RAMDISK_PROMPT_FLAG 0x8000
RAMDISK_LOAD_FLAG 0x4000
LOADED_HIGH (1<<0)
KASLR_FLAG (1<<1)
QUIET_FLAG (1<<5)
KEEP_SEGMENTS (1<<6)
CAN_USE_HEAP (1<<7)
XLF_KERNEL_64 (1<<0)
XLF_CAN_BE_LOADED_ABOVE_4G (1<<1)
XLF_EFI_HANDOVER_32 (1<<2)
XLF_EFI_HANDOVER_64 (1<<3)
XLF_EFI_KEXEC (1<<4)
XLF_5LEVEL (1<<5)
XLF_5LEVEL_ENABLED (1<<6)
VIDEO_TYPE_MDA 0x10
VIDEO_TYPE_CGA 0x11
VIDEO_TYPE_EGAM 0x20
VIDEO_TYPE_EGAC 0x21
VIDEO_TYPE_VGAC 0x22
VIDEO_TYPE_VLFB 0x23
VIDEO_TYPE_PICA_S3 0x30
VIDEO_TYPE_MIPS_G364 0x31
VIDEO_TYPE_SGI 0x33
VIDEO_TYPE_TGAC 0x40
VIDEO_TYPE_SUN 0x50
VIDEO_TYPE_SUNPCI 0x51
VIDEO_TYPE_PMAC 0x60
VIDEO_TYPE_EFI 0x70
VIDEO_FLAGS_NOCURSOR (1 << 0)
VIDEO_CAPABILITY_SKIP_QUIRKS (1 << 0)
VIDEO_CAPABILITY_64BIT_BASE (1 << 1)
APM_STATE_READY 0x0000
APM_STATE_STANDBY 0x0001
APM_STATE_SUSPEND 0x0002
APM_STATE_OFF 0x0003
APM_STATE_BUSY 0x0004
APM_STATE_REJECT 0x0005
APM_STATE_OEM_SYS 0x0020
APM_STATE_OEM_DEV 0x0040
APM_STATE_DISABLE 0x0000
APM_STATE_ENABLE 0x0001
APM_STATE_DISENGAGE 0x0000
APM_STATE_ENGAGE 0x0001
APM_SYS_STANDBY 0x0001
APM_SYS_SUSPEND 0x0002
APM_NORMAL_RESUME 0x0003
APM_CRITICAL_RESUME 0x0004
APM_LOW_BATTERY 0x0005
APM_POWER_STATUS_CHANGE 0x0006
APM_UPDATE_TIME 0x0007
APM_CRITICAL_SUSPEND 0x0008
APM_USER_STANDBY 0x0009
APM_USER_SUSPEND 0x000a
APM_STANDBY_RESUME 0x000b
APM_CAPABILITY_CHANGE 0x000c
APM_USER_HIBERNATION 0x000d
APM_HIBERNATION_RESUME 0x000e
APM_SUCCESS 0x00
APM_DISABLED 0x01
APM_CONNECTED 0x02
APM_NOT_CONNECTED 0x03
APM_16_CONNECTED 0x05
APM_16_UNSUPPORTED 0x06
APM_32_CONNECTED 0x07
APM_32_UNSUPPORTED 0x08
APM_BAD_DEVICE 0x09
APM_BAD_PARAM 0x0a
APM_NOT_ENGAGED 0x0b
APM_BAD_FUNCTION 0x0c
APM_RESUME_DISABLED 0x0d
APM_NO_ERROR 0x53
APM_BAD_STATE 0x60
APM_NO_EVENTS 0x80
APM_NOT_PRESENT 0x86
APM_DEVICE_BIOS 0x0000
APM_DEVICE_ALL 0x0001
APM_DEVICE_DISPLAY 0x0100
APM_DEVICE_STORAGE 0x0200
APM_DEVICE_PARALLEL 0x0300
APM_DEVICE_SERIAL 0x0400
APM_DEVICE_NETWORK 0x0500
APM_DEVICE_PCMCIA 0x0600
APM_DEVICE_BATTERY 0x8000
APM_DEVICE_OEM 0xe000
APM_DEVICE_OLD_ALL 0xffff
APM_DEVICE_CLASS 0x00ff
APM_DEVICE_MASK 0xff00
APM_MAX_BATTERIES 2
APM_CAP_GLOBAL_STANDBY 0x0001
APM_CAP_GLOBAL_SUSPEND 0x0002
APM_CAP_RESUME_STANDBY_TIMER 0x0004
APM_CAP_RESUME_SUSPEND_TIMER 0x0008
APM_CAP_RESUME_STANDBY_RING 0x0010
APM_CAP_RESUME_SUSPEND_RING 0x0020
APM_CAP_RESUME_STANDBY_PCMCIA 0x0040
APM_CAP_RESUME_SUSPEND_PCMCIA 0x0080
_IOC_NRBITS 8
_IOC_TYPEBITS 8
_IOC_SIZEBITS 14
_IOC_DIRBITS 2
_IOC_NRMASK ((1 << _IOC_NRBITS)-1)
_IOC_TYPEMASK ((1 << _IOC_TYPEBITS)-1)
_IOC_SIZEMASK ((1 << _IOC_SIZEBITS)-1)
_IOC_DIRMASK ((1 << _IOC_DIRBITS)-1)
_IOC_NRSHIFT 0
_IOC_TYPESHIFT (_IOC_NRSHIFT+_IOC_NRBITS)
_IOC_SIZESHIFT (_IOC_TYPESHIFT+_IOC_TYPEBITS)
_IOC_DIRSHIFT (_IOC_SIZESHIFT+_IOC_SIZEBITS)
_IOC_NONE 0U
_IOC_WRITE 1U
_IOC_READ 2U
_IOC(,,,) ((() << _IOC_DIRSHIFT) | (() << _IOC_TYPESHIFT) | (() << _IOC_NRSHIFT) | (() << _IOC_SIZESHIFT))
_IO(,) _IOC(_IOC_NONE,(),(),0)
_IOR(,,) _IOC(_IOC_READ,(),(),(_IOC_TYPECHECK()))
_IOW(,,) _IOC(_IOC_WRITE,(),(),(_IOC_TYPECHECK()))
_IOWR(,,) _IOC(_IOC_READ|_IOC_WRITE,(),(),(_IOC_TYPECHECK()))
_IOR_BAD(,,) _IOC(_IOC_READ,(),(),sizeof())
_IOW_BAD(,,) _IOC(_IOC_WRITE,(),(),sizeof())
_IOWR_BAD(,,) _IOC(_IOC_READ|_IOC_WRITE,(),(),sizeof())
_IOC_DIR() ((() >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
_IOC_TYPE() ((() >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
_IOC_NR() ((() >> _IOC_NRSHIFT) & _IOC_NRMASK)
_IOC_SIZE() ((() >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
IOC_IN (_IOC_WRITE << _IOC_DIRSHIFT)
IOC_OUT (_IOC_READ << _IOC_DIRSHIFT)
IOC_INOUT ((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
IOCSIZE_MASK (_IOC_SIZEMASK << _IOC_SIZESHIFT)
IOCSIZE_SHIFT (_IOC_SIZESHIFT)
_IOC_TYPECHECK() ((sizeof() == sizeof([1]) && sizeof() < (1 << _IOC_SIZEBITS)) ? sizeof() : __invalid_size_argument_for_IOC)
APM_IOC_STANDBY _IO('A', 1)
APM_IOC_SUSPEND _IO('A', 2)
APM_CS (GDT_ENTRY_APMBIOS_BASE * 8)
APM_CS_16 (APM_CS + 8)
APM_DS (APM_CS_16 + 8)
APM_16_BIT_SUPPORT 0x0001
APM_32_BIT_SUPPORT 0x0002
APM_IDLE_SLOWS_CLOCK 0x0004
APM_BIOS_DISABLED 0x0008
APM_BIOS_DISENGAGED 0x0010
APM_FUNC_INST_CHECK 0x5300
APM_FUNC_REAL_CONN 0x5301
APM_FUNC_16BIT_CONN 0x5302
APM_FUNC_32BIT_CONN 0x5303
APM_FUNC_DISCONN 0x5304
APM_FUNC_IDLE 0x5305
APM_FUNC_BUSY 0x5306
APM_FUNC_SET_STATE 0x5307
APM_FUNC_ENABLE_PM 0x5308
APM_FUNC_RESTORE_BIOS 0x5309
APM_FUNC_GET_STATUS 0x530a
APM_FUNC_GET_EVENT 0x530b
APM_FUNC_GET_STATE 0x530c
APM_FUNC_ENABLE_DEV_PM 0x530d
APM_FUNC_VERSION 0x530e
APM_FUNC_ENGAGE_PM 0x530f
APM_FUNC_GET_CAP 0x5310
APM_FUNC_RESUME_TIMER 0x5311
APM_FUNC_RESUME_ON_RING 0x5312
APM_FUNC_TIMER 0x5313
APM_FUNC_DISABLE_TIMER 0
APM_FUNC_GET_TIMER 1
APM_FUNC_SET_TIMER 2
APM_FUNC_DISABLE_RING 0
APM_FUNC_ENABLE_RING 1
APM_FUNC_GET_RING 2
APM_FUNC_TIMER_DISABLE 0
APM_FUNC_TIMER_ENABLE 1
APM_FUNC_TIMER_GET 2
APM_DEVICE_BALL ((apm_info.connection_version > 0x0100) ? APM_DEVICE_ALL : APM_DEVICE_OLD_ALL)
EDDNR 0x1e9
EDDBUF 0xd00
EDDMAXNR 6
EDDEXTSIZE 8
EDDPARMSIZE 74
CHECKEXTENSIONSPRESENT 0x41
GETDEVICEPARAMETERS 0x48
LEGACYGETDEVICEPARAMETERS 0x08
EDDMAGIC1 0x55AA
EDDMAGIC2 0xAA55
READ_SECTORS 0x02
EDD_MBR_SIG_OFFSET 0x1B8
EDD_MBR_SIG_BUF 0x290
EDD_MBR_SIG_MAX 16
EDD_MBR_SIG_NR_BUF 0x1ea
EDD_EXT_FIXED_DISK_ACCESS (1 << 0)
EDD_EXT_DEVICE_LOCKING_AND_EJECTING (1 << 1)
EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT (1 << 2)
EDD_EXT_64BIT_EXTENSIONS (1 << 3)
EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT (1 << 0)
EDD_INFO_GEOMETRY_VALID (1 << 1)
EDD_INFO_REMOVABLE (1 << 2)
EDD_INFO_WRITE_VERIFY (1 << 3)
EDD_INFO_MEDIA_CHANGE_NOTIFICATION (1 << 4)
EDD_INFO_LOCKABLE (1 << 5)
EDD_INFO_NO_MEDIA_PRESENT (1 << 6)
EDD_INFO_USE_INT13_FN50 (1 << 7)
E820_MAX_ENTRIES_ZEROPAGE 128
JAILHOUSE_SETUP_REQUIRED_VERSION 1
__bss_decrypted __attribute__((__section__(".bss..decrypted")))
__sme_pa() (__pa() | sme_me_mask)
__sme_pa_nodebug() (__pa_nodebug() | sme_me_mask)
__sme_set() (() | sme_me_mask)
__sme_clr() (() & ~sme_me_mask)
PAGE_SHIFT 12
PAGE_SIZE (_AC(1,UL) << PAGE_SHIFT)
PAGE_MASK (~(PAGE_SIZE-1))
PMD_PAGE_SIZE (_AC(1, UL) << PMD_SHIFT)
PMD_PAGE_MASK (~(PMD_PAGE_SIZE-1))
PUD_PAGE_SIZE (_AC(1, UL) << PUD_SHIFT)
PUD_PAGE_MASK (~(PUD_PAGE_SIZE-1))
__VIRTUAL_MASK ((1UL << __VIRTUAL_MASK_SHIFT) - 1)
PHYSICAL_PAGE_MASK (((signed long)PAGE_MASK) & __PHYSICAL_MASK)
PHYSICAL_PMD_PAGE_MASK (((signed long)PMD_PAGE_MASK) & __PHYSICAL_MASK)
PHYSICAL_PUD_PAGE_MASK (((signed long)PUD_PAGE_MASK) & __PHYSICAL_MASK)
HPAGE_SHIFT PMD_SHIFT
HPAGE_SIZE (_AC(1,UL) << HPAGE_SHIFT)
HPAGE_MASK (~(HPAGE_SIZE - 1))
HUGETLB_PAGE_ORDER (HPAGE_SHIFT - PAGE_SHIFT)
HUGE_MAX_HSTATE 2
PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)
VM_DATA_DEFAULT_FLAGS (((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
__PHYSICAL_START ALIGN(CONFIG_PHYSICAL_START, CONFIG_PHYSICAL_ALIGN)
__START_KERNEL (__START_KERNEL_map + __PHYSICAL_START)
KASAN_STACK_ORDER 0
THREAD_SIZE_ORDER (2 + KASAN_STACK_ORDER)
THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)
EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER)
EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)
IST_INDEX_DF 0
IST_INDEX_NMI 1
IST_INDEX_DB 2
IST_INDEX_MCE 3
__PAGE_OFFSET_BASE_L5 _AC(0xff11000000000000, UL)
__PAGE_OFFSET_BASE_L4 _AC(0xffff888000000000, UL)
__PAGE_OFFSET page_offset_base
__START_KERNEL_map _AC(0xffffffff80000000, UL)
__PHYSICAL_MASK_SHIFT 52
__VIRTUAL_MASK_SHIFT 47
KERNEL_IMAGE_SIZE (1024 * 1024 * 1024)
IOREMAP_MAX_ORDER (PUD_SHIFT)
__PHYSICAL_MASK physical_mask
__phys_addr() __phys_addr_nodebug()
__phys_addr_symbol() ((unsigned long)() - __START_KERNEL_map + phys_base)
__phys_reloc_hide() ()
__HAVE_ARCH_GATE_AREA 1
MAX_RESOURCE ((resource_size_t)~0)
__alloc_zeroed_user_highpage(,,) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | , , )
__HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE 
__pa() __phys_addr((unsigned long)())
__pa_nodebug() __phys_addr_nodebug((unsigned long)())
__pa_symbol() __phys_addr_symbol(__phys_reloc_hide((unsigned long)()))
__va() ((void *)((unsigned long)()+PAGE_OFFSET))
__boot_va() __va()
__boot_pa() __pa()
virt_to_page() pfn_to_page(__pa() >> PAGE_SHIFT)
pfn_to_kaddr() __va(() << PAGE_SHIFT)
virt_addr_valid() __virt_addr_valid((unsigned long) ())
PFN_ALIGN() (((unsigned long)() + (PAGE_SIZE - 1)) & PAGE_MASK)
PFN_UP() ((() + PAGE_SIZE-1) >> PAGE_SHIFT)
PFN_DOWN() (() >> PAGE_SHIFT)
PFN_PHYS() ((phys_addr_t)() << PAGE_SHIFT)
PHYS_PFN() ((unsigned long)(() >> PAGE_SHIFT))
__pfn_to_page() (vmemmap + ())
__page_to_pfn() (unsigned long)(() - vmemmap)
__phys_to_pfn() PHYS_PFN()
__pfn_to_phys() PFN_PHYS()
page_to_pfn __page_to_pfn
pfn_to_page __pfn_to_page
HAVE_ARCH_HUGETLB_UNMAPPED_AREA 
TOP_OF_KERNEL_STACK_PADDING 0
X86_EFLAGS_CF_BIT 0
X86_EFLAGS_CF _BITUL(X86_EFLAGS_CF_BIT)
X86_EFLAGS_FIXED_BIT 1
X86_EFLAGS_FIXED _BITUL(X86_EFLAGS_FIXED_BIT)
X86_EFLAGS_PF_BIT 2
X86_EFLAGS_PF _BITUL(X86_EFLAGS_PF_BIT)
X86_EFLAGS_AF_BIT 4
X86_EFLAGS_AF _BITUL(X86_EFLAGS_AF_BIT)
X86_EFLAGS_ZF_BIT 6
X86_EFLAGS_ZF _BITUL(X86_EFLAGS_ZF_BIT)
X86_EFLAGS_SF_BIT 7
X86_EFLAGS_SF _BITUL(X86_EFLAGS_SF_BIT)
X86_EFLAGS_TF_BIT 8
X86_EFLAGS_TF _BITUL(X86_EFLAGS_TF_BIT)
X86_EFLAGS_IF_BIT 9
X86_EFLAGS_IF _BITUL(X86_EFLAGS_IF_BIT)
X86_EFLAGS_DF_BIT 10
X86_EFLAGS_DF _BITUL(X86_EFLAGS_DF_BIT)
X86_EFLAGS_OF_BIT 11
X86_EFLAGS_OF _BITUL(X86_EFLAGS_OF_BIT)
X86_EFLAGS_IOPL_BIT 12
X86_EFLAGS_IOPL (_AC(3,UL) << X86_EFLAGS_IOPL_BIT)
X86_EFLAGS_NT_BIT 14
X86_EFLAGS_NT _BITUL(X86_EFLAGS_NT_BIT)
X86_EFLAGS_RF_BIT 16
X86_EFLAGS_RF _BITUL(X86_EFLAGS_RF_BIT)
X86_EFLAGS_VM_BIT 17
X86_EFLAGS_VM _BITUL(X86_EFLAGS_VM_BIT)
X86_EFLAGS_AC_BIT 18
X86_EFLAGS_AC _BITUL(X86_EFLAGS_AC_BIT)
X86_EFLAGS_VIF_BIT 19
X86_EFLAGS_VIF _BITUL(X86_EFLAGS_VIF_BIT)
X86_EFLAGS_VIP_BIT 20
X86_EFLAGS_VIP _BITUL(X86_EFLAGS_VIP_BIT)
X86_EFLAGS_ID_BIT 21
X86_EFLAGS_ID _BITUL(X86_EFLAGS_ID_BIT)
X86_CR0_PE_BIT 0
X86_CR0_PE _BITUL(X86_CR0_PE_BIT)
X86_CR0_MP_BIT 1
X86_CR0_MP _BITUL(X86_CR0_MP_BIT)
X86_CR0_EM_BIT 2
X86_CR0_EM _BITUL(X86_CR0_EM_BIT)
X86_CR0_TS_BIT 3
X86_CR0_TS _BITUL(X86_CR0_TS_BIT)
X86_CR0_ET_BIT 4
X86_CR0_ET _BITUL(X86_CR0_ET_BIT)
X86_CR0_NE_BIT 5
X86_CR0_NE _BITUL(X86_CR0_NE_BIT)
X86_CR0_WP_BIT 16
X86_CR0_WP _BITUL(X86_CR0_WP_BIT)
X86_CR0_AM_BIT 18
X86_CR0_AM _BITUL(X86_CR0_AM_BIT)
X86_CR0_NW_BIT 29
X86_CR0_NW _BITUL(X86_CR0_NW_BIT)
X86_CR0_CD_BIT 30
X86_CR0_CD _BITUL(X86_CR0_CD_BIT)
X86_CR0_PG_BIT 31
X86_CR0_PG _BITUL(X86_CR0_PG_BIT)
X86_CR3_PWT_BIT 3
X86_CR3_PWT _BITUL(X86_CR3_PWT_BIT)
X86_CR3_PCD_BIT 4
X86_CR3_PCD _BITUL(X86_CR3_PCD_BIT)
X86_CR3_PCID_BITS 12
X86_CR3_PCID_MASK (_AC((1UL << X86_CR3_PCID_BITS) - 1, UL))
X86_CR3_PCID_NOFLUSH_BIT 63
X86_CR3_PCID_NOFLUSH _BITULL(X86_CR3_PCID_NOFLUSH_BIT)
X86_CR4_VME_BIT 0
X86_CR4_VME _BITUL(X86_CR4_VME_BIT)
X86_CR4_PVI_BIT 1
X86_CR4_PVI _BITUL(X86_CR4_PVI_BIT)
X86_CR4_TSD_BIT 2
X86_CR4_TSD _BITUL(X86_CR4_TSD_BIT)
X86_CR4_DE_BIT 3
X86_CR4_DE _BITUL(X86_CR4_DE_BIT)
X86_CR4_PSE_BIT 4
X86_CR4_PSE _BITUL(X86_CR4_PSE_BIT)
X86_CR4_PAE_BIT 5
X86_CR4_PAE _BITUL(X86_CR4_PAE_BIT)
X86_CR4_MCE_BIT 6
X86_CR4_MCE _BITUL(X86_CR4_MCE_BIT)
X86_CR4_PGE_BIT 7
X86_CR4_PGE _BITUL(X86_CR4_PGE_BIT)
X86_CR4_PCE_BIT 8
X86_CR4_PCE _BITUL(X86_CR4_PCE_BIT)
X86_CR4_OSFXSR_BIT 9
X86_CR4_OSFXSR _BITUL(X86_CR4_OSFXSR_BIT)
X86_CR4_OSXMMEXCPT_BIT 10
X86_CR4_OSXMMEXCPT _BITUL(X86_CR4_OSXMMEXCPT_BIT)
X86_CR4_UMIP_BIT 11
X86_CR4_UMIP _BITUL(X86_CR4_UMIP_BIT)
X86_CR4_LA57_BIT 12
X86_CR4_LA57 _BITUL(X86_CR4_LA57_BIT)
X86_CR4_VMXE_BIT 13
X86_CR4_VMXE _BITUL(X86_CR4_VMXE_BIT)
X86_CR4_SMXE_BIT 14
X86_CR4_SMXE _BITUL(X86_CR4_SMXE_BIT)
X86_CR4_FSGSBASE_BIT 16
X86_CR4_FSGSBASE _BITUL(X86_CR4_FSGSBASE_BIT)
X86_CR4_PCIDE_BIT 17
X86_CR4_PCIDE _BITUL(X86_CR4_PCIDE_BIT)
X86_CR4_OSXSAVE_BIT 18
X86_CR4_OSXSAVE _BITUL(X86_CR4_OSXSAVE_BIT)
X86_CR4_SMEP_BIT 20
X86_CR4_SMEP _BITUL(X86_CR4_SMEP_BIT)
X86_CR4_SMAP_BIT 21
X86_CR4_SMAP _BITUL(X86_CR4_SMAP_BIT)
X86_CR4_PKE_BIT 22
X86_CR4_PKE _BITUL(X86_CR4_PKE_BIT)
X86_CR8_TPR _AC(0x0000000f,UL)
CX86_PCR0 0x20
CX86_GCR 0xb8
CX86_CCR0 0xc0
CX86_CCR1 0xc1
CX86_CCR2 0xc2
CX86_CCR3 0xc3
CX86_CCR4 0xe8
CX86_CCR5 0xe9
CX86_CCR6 0xea
CX86_CCR7 0xeb
CX86_PCR1 0xf0
CX86_DIR0 0xfe
CX86_DIR1 0xff
CX86_ARR_BASE 0xc4
CX86_RCR_BASE 0xdc
CR0_STATE (X86_CR0_PE | X86_CR0_MP | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM | X86_CR0_PG)
X86_VM_MASK 0
CR3_ADDR_MASK __sme_clr(0x7FFFFFFFFFFFF000ull)
CR3_PCID_MASK 0xFFFull
CR3_NOFLUSH BIT_ULL(63)
X86_CR3_PTI_PCID_USER_BIT 11
GDT_ENTRY(,,) (((() & _AC(0xff000000,ULL)) << (56-24)) | ((() & _AC(0x0000f0ff,ULL)) << 40) | ((() & _AC(0x000f0000,ULL)) << (48-16)) | ((() & _AC(0x00ffffff,ULL)) << 16) | ((() & _AC(0x0000ffff,ULL))))
GDT_ENTRY_BOOT_CS 2
GDT_ENTRY_BOOT_DS 3
GDT_ENTRY_BOOT_TSS 4
__BOOT_CS (GDT_ENTRY_BOOT_CS*8)
__BOOT_DS (GDT_ENTRY_BOOT_DS*8)
__BOOT_TSS (GDT_ENTRY_BOOT_TSS*8)
SEGMENT_RPL_MASK 0x3
USER_SEGMENT_RPL_MASK 0x2
USER_RPL 0x3
SEGMENT_TI_MASK 0x4
SEGMENT_LDT 0x4
SEGMENT_GDT 0x0
GDT_ENTRY_INVALID_SEG 0
GDT_ENTRY_KERNEL32_CS 1
GDT_ENTRY_KERNEL_CS 2
GDT_ENTRY_KERNEL_DS 3
GDT_ENTRY_DEFAULT_USER32_CS 4
GDT_ENTRY_DEFAULT_USER_DS 5
GDT_ENTRY_DEFAULT_USER_CS 6
GDT_ENTRY_TSS 8
GDT_ENTRY_LDT 10
GDT_ENTRY_TLS_MIN 12
GDT_ENTRY_TLS_MAX 14
GDT_ENTRY_CPUNODE 15
GDT_ENTRIES 16
__KERNEL32_CS (GDT_ENTRY_KERNEL32_CS*8)
__KERNEL_CS (GDT_ENTRY_KERNEL_CS*8)
__KERNEL_DS (GDT_ENTRY_KERNEL_DS*8)
__USER32_CS (GDT_ENTRY_DEFAULT_USER32_CS*8 + 3)
__USER_DS (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
__USER32_DS __USER_DS
__USER_CS (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)
__CPUNODE_SEG (GDT_ENTRY_CPUNODE*8 + 3)
IDT_ENTRIES 256
NUM_EXCEPTION_VECTORS 32
EXCEPTION_ERRCODE_MASK 0x00027d00
GDT_SIZE (GDT_ENTRIES*8)
GDT_ENTRY_TLS_ENTRIES 3
TLS_SIZE (GDT_ENTRY_TLS_ENTRIES* 8)
VDSO_CPUNODE_BITS 12
VDSO_CPUNODE_MASK 0xfff
EARLY_IDT_HANDLER_SIZE 9
XEN_EARLY_IDT_HANDLER_SIZE 8
__loadsegment_simple(,) do { unsigned short __val = (); asm volatile("						\n" "1:	movl %k0,%%" # "		\n" ".section .fixup,\"ax\"			\n" "2:	xorl %k0,%k0			\n" "		jmp 1b				\n" ".previous					\n" _ASM_EXTABLE(1b, 2b) : "+r" (__val) : : "memory"); \
} while (0)
__loadsegment_ss() __loadsegment_simple(ss, ())
__loadsegment_ds() __loadsegment_simple(ds, ())
__loadsegment_es() __loadsegment_simple(es, ())
loadsegment(,) __loadsegment_ ##  ()
savesegment(,) asm("mov %%" # ",%0":"=r" () : : "memory")
FRAME_SIZE 168
PTRACE_GETREGS 12
PTRACE_SETREGS 13
PTRACE_GETFPREGS 14
PTRACE_SETFPREGS 15
PTRACE_GETFPXREGS 18
PTRACE_SETFPXREGS 19
PTRACE_OLDSETOPTIONS 21
PTRACE_GET_THREAD_AREA 25
PTRACE_SET_THREAD_AREA 26
PTRACE_ARCH_PRCTL 30
PTRACE_SYSEMU 31
PTRACE_SYSEMU_SINGLESTEP 32
PTRACE_SINGLEBLOCK 33
CLBR_NONE 0
CLBR_EAX (1 << 0)
CLBR_ECX (1 << 1)
CLBR_EDX (1 << 2)
CLBR_EDI (1 << 3)
CLBR_RAX CLBR_EAX
CLBR_RCX CLBR_ECX
CLBR_RDX CLBR_EDX
CLBR_RDI CLBR_EDI
CLBR_RSI (1 << 4)
CLBR_R8 (1 << 5)
CLBR_R9 (1 << 6)
CLBR_R10 (1 << 7)
CLBR_R11 (1 << 8)
CLBR_ANY ((1 << 9) - 1)
CLBR_ARG_REGS (CLBR_RDI | CLBR_RSI | CLBR_RDX | CLBR_RCX | CLBR_R8 | CLBR_R9)
CLBR_RET_REG (CLBR_RAX)
CLBR_SCRATCH (CLBR_R10 | CLBR_R11)
CLBR_CALLEE_SAVE ((CLBR_ARG_REGS | CLBR_SCRATCH) & ~CLBR_RET_REG)
GDT_ENTRY_INIT(,,) { .limit0 = (u16) (), .limit1 = (() >> 16) & 0x0F, .base0 = (u16) (), .base1 = (() >> 16) & 0xFF, .base2 = (() >> 24) & 0xFF, .type = ( & 0x0f), .s = ( >> 4) & 0x01, .dpl = ( >> 5) & 0x03, .p = ( >> 7) & 0x01, .avl = ( >> 12) & 0x01, .l = ( >> 13) & 0x01, .d = ( >> 14) & 0x01, .g = ( >> 15) & 0x01, }
AR_TYPE_RODATA (0 * (1 << 9))
AR_TYPE_RWDATA (1 * (1 << 9))
AR_TYPE_RODATA_EXPDOWN (2 * (1 << 9))
AR_TYPE_RWDATA_EXPDOWN (3 * (1 << 9))
AR_TYPE_XOCODE (4 * (1 << 9))
AR_TYPE_XRCODE (5 * (1 << 9))
AR_TYPE_XOCODE_CONF (6 * (1 << 9))
AR_TYPE_XRCODE_CONF (7 * (1 << 9))
AR_TYPE_MASK (7 * (1 << 9))
AR_DPL0 (0 * (1 << 13))
AR_DPL3 (3 * (1 << 13))
AR_DPL_MASK (3 * (1 << 13))
AR_A (1 << 8)
AR_S (1 << 12)
AR_P (1 << 15)
AR_AVL (1 << 20)
AR_L (1 << 21)
AR_DB (1 << 22)
AR_G (1 << 23)
KM_TYPE_NR 20
FIRST_USER_ADDRESS 0UL
_PAGE_BIT_PRESENT 0
_PAGE_BIT_RW 1
_PAGE_BIT_USER 2
_PAGE_BIT_PWT 3
_PAGE_BIT_PCD 4
_PAGE_BIT_ACCESSED 5
_PAGE_BIT_DIRTY 6
_PAGE_BIT_PSE 7
_PAGE_BIT_PAT 7
_PAGE_BIT_GLOBAL 8
_PAGE_BIT_SOFTW1 9
_PAGE_BIT_SOFTW2 10
_PAGE_BIT_SOFTW3 11
_PAGE_BIT_PAT_LARGE 12
_PAGE_BIT_SOFTW4 58
_PAGE_BIT_PKEY_BIT0 59
_PAGE_BIT_PKEY_BIT1 60
_PAGE_BIT_PKEY_BIT2 61
_PAGE_BIT_PKEY_BIT3 62
_PAGE_BIT_NX 63
_PAGE_BIT_SPECIAL _PAGE_BIT_SOFTW1
_PAGE_BIT_CPA_TEST _PAGE_BIT_SOFTW1
_PAGE_BIT_SOFT_DIRTY _PAGE_BIT_SOFTW3
_PAGE_BIT_DEVMAP _PAGE_BIT_SOFTW4
_PAGE_BIT_PROTNONE _PAGE_BIT_GLOBAL
_PAGE_PRESENT (_AT(pteval_t, 1) << _PAGE_BIT_PRESENT)
_PAGE_RW (_AT(pteval_t, 1) << _PAGE_BIT_RW)
_PAGE_USER (_AT(pteval_t, 1) << _PAGE_BIT_USER)
_PAGE_PWT (_AT(pteval_t, 1) << _PAGE_BIT_PWT)
_PAGE_PCD (_AT(pteval_t, 1) << _PAGE_BIT_PCD)
_PAGE_ACCESSED (_AT(pteval_t, 1) << _PAGE_BIT_ACCESSED)
_PAGE_DIRTY (_AT(pteval_t, 1) << _PAGE_BIT_DIRTY)
_PAGE_PSE (_AT(pteval_t, 1) << _PAGE_BIT_PSE)
_PAGE_GLOBAL (_AT(pteval_t, 1) << _PAGE_BIT_GLOBAL)
_PAGE_SOFTW1 (_AT(pteval_t, 1) << _PAGE_BIT_SOFTW1)
_PAGE_SOFTW2 (_AT(pteval_t, 1) << _PAGE_BIT_SOFTW2)
_PAGE_SOFTW3 (_AT(pteval_t, 1) << _PAGE_BIT_SOFTW3)
_PAGE_PAT (_AT(pteval_t, 1) << _PAGE_BIT_PAT)
_PAGE_PAT_LARGE (_AT(pteval_t, 1) << _PAGE_BIT_PAT_LARGE)
_PAGE_SPECIAL (_AT(pteval_t, 1) << _PAGE_BIT_SPECIAL)
_PAGE_CPA_TEST (_AT(pteval_t, 1) << _PAGE_BIT_CPA_TEST)
_PAGE_PKEY_BIT0 (_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT0)
_PAGE_PKEY_BIT1 (_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT1)
_PAGE_PKEY_BIT2 (_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT2)
_PAGE_PKEY_BIT3 (_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT3)
_PAGE_PKEY_MASK (_PAGE_PKEY_BIT0 | _PAGE_PKEY_BIT1 | _PAGE_PKEY_BIT2 | _PAGE_PKEY_BIT3)
_PAGE_KNL_ERRATUM_MASK (_PAGE_DIRTY | _PAGE_ACCESSED)
_PAGE_SOFT_DIRTY (_AT(pteval_t, 1) << _PAGE_BIT_SOFT_DIRTY)
_PAGE_SWP_SOFT_DIRTY _PAGE_RW
_PAGE_NX (_AT(pteval_t, 1) << _PAGE_BIT_NX)
_PAGE_DEVMAP (_AT(u64, 1) << _PAGE_BIT_DEVMAP)
_PAGE_PROTNONE (_AT(pteval_t, 1) << _PAGE_BIT_PROTNONE)
_PAGE_TABLE_NOENC (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_DIRTY)
_KERNPG_TABLE_NOENC (_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY)
_PAGE_CHG_MASK (PTE_PFN_MASK | _PAGE_PCD | _PAGE_PWT | _PAGE_SPECIAL | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_SOFT_DIRTY | _PAGE_DEVMAP | _PAGE_ENC)
_HPAGE_CHG_MASK (_PAGE_CHG_MASK | _PAGE_PSE)
_PAGE_CACHE_MASK (_PAGE_PAT | _PAGE_PCD | _PAGE_PWT)
_PAGE_LARGE_CACHE_MASK (_PAGE_PWT | _PAGE_PCD | _PAGE_PAT_LARGE)
_PAGE_NOCACHE (cachemode2protval(_PAGE_CACHE_MODE_UC))
_PAGE_CACHE_WP (cachemode2protval(_PAGE_CACHE_MODE_WP))
PAGE_NONE __pgprot(_PAGE_PROTNONE | _PAGE_ACCESSED)
PAGE_SHARED __pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
PAGE_SHARED_EXEC __pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
PAGE_COPY_NOEXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
PAGE_COPY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
PAGE_COPY PAGE_COPY_NOEXEC
PAGE_READONLY __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
__PAGE_KERNEL_EXEC (_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_GLOBAL)
__PAGE_KERNEL (__PAGE_KERNEL_EXEC | _PAGE_NX)
__PAGE_KERNEL_RO (__PAGE_KERNEL & ~_PAGE_RW)
__PAGE_KERNEL_RX (__PAGE_KERNEL_EXEC & ~_PAGE_RW)
__PAGE_KERNEL_NOCACHE (__PAGE_KERNEL | _PAGE_NOCACHE)
__PAGE_KERNEL_VVAR (__PAGE_KERNEL_RO | _PAGE_USER)
__PAGE_KERNEL_LARGE (__PAGE_KERNEL | _PAGE_PSE)
__PAGE_KERNEL_LARGE_EXEC (__PAGE_KERNEL_EXEC | _PAGE_PSE)
__PAGE_KERNEL_WP (__PAGE_KERNEL | _PAGE_CACHE_WP)
__PAGE_KERNEL_IO (__PAGE_KERNEL)
__PAGE_KERNEL_IO_NOCACHE (__PAGE_KERNEL_NOCACHE)
_PAGE_ENC (_AT(pteval_t, sme_me_mask))
_KERNPG_TABLE (_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_ENC)
_PAGE_TABLE (_KERNPG_TABLE | _PAGE_USER)
__PAGE_KERNEL_ENC (__PAGE_KERNEL | _PAGE_ENC)
__PAGE_KERNEL_ENC_WP (__PAGE_KERNEL_WP | _PAGE_ENC)
__PAGE_KERNEL_NOENC (__PAGE_KERNEL)
__PAGE_KERNEL_NOENC_WP (__PAGE_KERNEL_WP)
default_pgprot() __pgprot(() & __default_kernel_pte_mask)
PAGE_KERNEL default_pgprot(__PAGE_KERNEL | _PAGE_ENC)
PAGE_KERNEL_NOENC default_pgprot(__PAGE_KERNEL)
PAGE_KERNEL_RO default_pgprot(__PAGE_KERNEL_RO | _PAGE_ENC)
PAGE_KERNEL_EXEC default_pgprot(__PAGE_KERNEL_EXEC | _PAGE_ENC)
PAGE_KERNEL_EXEC_NOENC default_pgprot(__PAGE_KERNEL_EXEC)
PAGE_KERNEL_RX default_pgprot(__PAGE_KERNEL_RX | _PAGE_ENC)
PAGE_KERNEL_NOCACHE default_pgprot(__PAGE_KERNEL_NOCACHE | _PAGE_ENC)
PAGE_KERNEL_LARGE default_pgprot(__PAGE_KERNEL_LARGE | _PAGE_ENC)
PAGE_KERNEL_LARGE_EXEC default_pgprot(__PAGE_KERNEL_LARGE_EXEC | _PAGE_ENC)
PAGE_KERNEL_VVAR default_pgprot(__PAGE_KERNEL_VVAR | _PAGE_ENC)
PAGE_KERNEL_IO default_pgprot(__PAGE_KERNEL_IO)
PAGE_KERNEL_IO_NOCACHE default_pgprot(__PAGE_KERNEL_IO_NOCACHE)
__P000 PAGE_NONE
__P001 PAGE_READONLY
__P010 PAGE_COPY
__P011 PAGE_COPY
__P100 PAGE_READONLY_EXEC
__P101 PAGE_READONLY_EXEC
__P110 PAGE_COPY_EXEC
__P111 PAGE_COPY_EXEC
__S000 PAGE_NONE
__S001 PAGE_READONLY
__S010 PAGE_SHARED
__S011 PAGE_SHARED
__S100 PAGE_READONLY_EXEC
__S101 PAGE_READONLY_EXEC
__S110 PAGE_SHARED_EXEC
__S111 PAGE_SHARED_EXEC
__PAGE_KERNEL_IDENT_LARGE_EXEC __PAGE_KERNEL_LARGE_EXEC
SECTION_SIZE_BITS 27
MAX_PHYSADDR_BITS (pgtable_l5_enabled() ? 52 : 44)
MAX_PHYSMEM_BITS (pgtable_l5_enabled() ? 52 : 46)
pgtable_l5_enabled() 0
SHARED_KERNEL_PMD 0
PGDIR_SHIFT 39
PTRS_PER_PGD 512
MAX_PTRS_PER_P4D 1
PUD_SHIFT 30
PTRS_PER_PUD 512
PMD_SHIFT 21
PTRS_PER_PMD 512
PTRS_PER_PTE 512
PMD_SIZE (_AC(1, UL) << PMD_SHIFT)
PMD_MASK (~(PMD_SIZE - 1))
PUD_SIZE (_AC(1, UL) << PUD_SHIFT)
PUD_MASK (~(PUD_SIZE - 1))
PGDIR_SIZE (_AC(1, UL) << PGDIR_SHIFT)
PGDIR_MASK (~(PGDIR_SIZE - 1))
MAXMEM (1UL << MAX_PHYSMEM_BITS)
GUARD_HOLE_PGD_ENTRY -256UL
GUARD_HOLE_SIZE (16UL << PGDIR_SHIFT)
GUARD_HOLE_BASE_ADDR (GUARD_HOLE_PGD_ENTRY << PGDIR_SHIFT)
GUARD_HOLE_END_ADDR (GUARD_HOLE_BASE_ADDR + GUARD_HOLE_SIZE)
LDT_PGD_ENTRY -240UL
LDT_BASE_ADDR (LDT_PGD_ENTRY << PGDIR_SHIFT)
LDT_END_ADDR (LDT_BASE_ADDR + PGDIR_SIZE)
__VMALLOC_BASE_L4 0xffffc90000000000UL
__VMALLOC_BASE_L5 0xffa0000000000000UL
VMALLOC_SIZE_TB_L4 32UL
VMALLOC_SIZE_TB_L5 12800UL
__VMEMMAP_BASE_L4 0xffffea0000000000UL
__VMEMMAP_BASE_L5 0xffd4000000000000UL
VMALLOC_START vmalloc_base
VMALLOC_SIZE_TB (pgtable_l5_enabled() ? VMALLOC_SIZE_TB_L5 : VMALLOC_SIZE_TB_L4)
VMEMMAP_START vmemmap_base
VMALLOC_END (VMALLOC_START + (VMALLOC_SIZE_TB << 40) - 1)
MODULES_VADDR (__START_KERNEL_map + KERNEL_IMAGE_SIZE)
MODULES_END _AC(0xffffffffff000000, UL)
MODULES_LEN (MODULES_END - MODULES_VADDR)
ESPFIX_PGD_ENTRY _AC(-2, UL)
ESPFIX_BASE_ADDR (ESPFIX_PGD_ENTRY << P4D_SHIFT)
CPU_ENTRY_AREA_PGD _AC(-4, UL)
CPU_ENTRY_AREA_BASE (CPU_ENTRY_AREA_PGD << P4D_SHIFT)
EFI_VA_START ( -4 * (_AC(1, UL) << 30))
EFI_VA_END (-68 * (_AC(1, UL) << 30))
EARLY_DYNAMIC_PAGE_TABLES 64
PGD_KERNEL_START ((PAGE_SIZE / 2) / sizeof(pgd_t))
PTE_PFN_MASK ((pteval_t)PHYSICAL_PAGE_MASK)
PTE_FLAGS_MASK (~PTE_PFN_MASK)
PGD_ALLOWED_BITS (~0ULL)
__PAGETABLE_P4D_FOLDED 1
P4D_SHIFT PGDIR_SHIFT
MAX_PTRS_PER_P4D 1
PTRS_PER_P4D 1
P4D_SIZE (1UL << P4D_SHIFT)
P4D_MASK (~(P4D_SIZE-1))
p4d_ERROR() (pgd_ERROR(().pgd))
pgd_populate(,,) do { } while (0)
pgd_populate_safe(,,) do { } while (0)
set_pgd(,) set_p4d((p4d_t *)(), (p4d_t) {  })
p4d_val() (pgd_val(().pgd))
__p4d() ((p4d_t) { __pgd() })
pgd_page() (p4d_page((p4d_t){  }))
pgd_page_vaddr() (p4d_page_vaddr((p4d_t){  }))
p4d_alloc_one(,) NULL
p4d_free(,) do { } while (0)
__p4d_free_tlb(,,) do { } while (0)
p4d_addr_end(,) ()
pgprot_val() (().pgprot)
__pgprot() ((pgprot_t) { () } )
__pte2cm_idx() (((() >> (_PAGE_BIT_PAT - 2)) & 4) | ((() >> (_PAGE_BIT_PCD - 1)) & 2) | ((() >> _PAGE_BIT_PWT) & 1))
__cm_idx2pte() (((() & 4) << (_PAGE_BIT_PAT - 2)) | ((() & 2) << (_PAGE_BIT_PCD - 1)) | ((() & 1) << _PAGE_BIT_PWT))
pgprot_writecombine pgprot_writecombine
pgprot_writethrough pgprot_writethrough
__HAVE_PFNMAP_TRACKING 
__HAVE_PHYS_MEM_ACCESS_PROT 
native_pagetable_init paging_init
STACK_FRAME_NON_STANDARD() static void __used __section(.discard.func_stack_frame_non_standard) *__func_stack_frame_non_standard_## = 
MSR_EFER 0xc0000080
MSR_STAR 0xc0000081
MSR_LSTAR 0xc0000082
MSR_CSTAR 0xc0000083
MSR_SYSCALL_MASK 0xc0000084
MSR_FS_BASE 0xc0000100
MSR_GS_BASE 0xc0000101
MSR_KERNEL_GS_BASE 0xc0000102
MSR_TSC_AUX 0xc0000103
_EFER_SCE 0
_EFER_LME 8
_EFER_LMA 10
_EFER_NX 11
_EFER_SVME 12
_EFER_LMSLE 13
_EFER_FFXSR 14
EFER_SCE (1<<_EFER_SCE)
EFER_LME (1<<_EFER_LME)
EFER_LMA (1<<_EFER_LMA)
EFER_NX (1<<_EFER_NX)
EFER_SVME (1<<_EFER_SVME)
EFER_LMSLE (1<<_EFER_LMSLE)
EFER_FFXSR (1<<_EFER_FFXSR)
MSR_IA32_SPEC_CTRL 0x00000048
SPEC_CTRL_IBRS BIT(0)
SPEC_CTRL_STIBP_SHIFT 1
SPEC_CTRL_STIBP BIT(SPEC_CTRL_STIBP_SHIFT)
SPEC_CTRL_SSBD_SHIFT 2
SPEC_CTRL_SSBD BIT(SPEC_CTRL_SSBD_SHIFT)
SPEC_CTRL_RRSBA_DIS_S_SHIFT 6
SPEC_CTRL_RRSBA_DIS_S BIT(SPEC_CTRL_RRSBA_DIS_S_SHIFT)
SPEC_CTRL_MITIGATIONS_MASK (SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_SSBD | SPEC_CTRL_RRSBA_DIS_S)
MSR_IA32_PRED_CMD 0x00000049
PRED_CMD_IBPB BIT(0)
MSR_PPIN_CTL 0x0000004e
MSR_PPIN 0x0000004f
MSR_IA32_PERFCTR0 0x000000c1
MSR_IA32_PERFCTR1 0x000000c2
MSR_FSB_FREQ 0x000000cd
MSR_PLATFORM_INFO 0x000000ce
MSR_PLATFORM_INFO_CPUID_FAULT_BIT 31
MSR_PLATFORM_INFO_CPUID_FAULT BIT_ULL(MSR_PLATFORM_INFO_CPUID_FAULT_BIT)
MSR_IA32_UMWAIT_CONTROL 0xe1
MSR_IA32_UMWAIT_CONTROL_C02_DISABLE BIT(0)
MSR_IA32_UMWAIT_CONTROL_RESERVED BIT(1)
MSR_IA32_UMWAIT_CONTROL_TIME_MASK (~0x03U)
MSR_PKG_CST_CONFIG_CONTROL 0x000000e2
NHM_C3_AUTO_DEMOTE (1UL << 25)
NHM_C1_AUTO_DEMOTE (1UL << 26)
ATM_LNC_C6_AUTO_DEMOTE (1UL << 25)
SNB_C3_AUTO_UNDEMOTE (1UL << 27)
SNB_C1_AUTO_UNDEMOTE (1UL << 28)
MSR_MTRRcap 0x000000fe
MSR_IA32_ARCH_CAPABILITIES 0x0000010a
ARCH_CAP_RDCL_NO BIT(0)
ARCH_CAP_IBRS_ALL BIT(1)
ARCH_CAP_RSBA BIT(2)
ARCH_CAP_SKIP_VMENTRY_L1DFLUSH BIT(3)
ARCH_CAP_SSB_NO BIT(4)
ARCH_CAP_MDS_NO BIT(5)
ARCH_CAP_PSCHANGE_MC_NO BIT(6)
ARCH_CAP_TSX_CTRL_MSR BIT(7)
ARCH_CAP_TAA_NO BIT(8)
ARCH_CAP_SBDR_SSDP_NO BIT(13)
ARCH_CAP_FBSDP_NO BIT(14)
ARCH_CAP_PSDP_NO BIT(15)
ARCH_CAP_FB_CLEAR BIT(17)
ARCH_CAP_FB_CLEAR_CTRL BIT(18)
ARCH_CAP_RRSBA BIT(19)
ARCH_CAP_PBRSB_NO BIT(24)
ARCH_CAP_GDS_CTRL BIT(25)
ARCH_CAP_GDS_NO BIT(26)
MSR_IA32_FLUSH_CMD 0x0000010b
L1D_FLUSH BIT(0)
MSR_IA32_BBL_CR_CTL 0x00000119
MSR_IA32_BBL_CR_CTL3 0x0000011e
MSR_IA32_TSX_CTRL 0x00000122
TSX_CTRL_RTM_DISABLE BIT(0)
TSX_CTRL_CPUID_CLEAR BIT(1)
MSR_IA32_MCU_OPT_CTRL 0x00000123
RNGDS_MITG_DIS BIT(0)
FB_CLEAR_DIS BIT(3)
GDS_MITG_DIS BIT(4)
GDS_MITG_LOCKED BIT(5)
MSR_IA32_SYSENTER_CS 0x00000174
MSR_IA32_SYSENTER_ESP 0x00000175
MSR_IA32_SYSENTER_EIP 0x00000176
MSR_IA32_MCG_CAP 0x00000179
MSR_IA32_MCG_STATUS 0x0000017a
MSR_IA32_MCG_CTL 0x0000017b
MSR_IA32_MCG_EXT_CTL 0x000004d0
MSR_OFFCORE_RSP_0 0x000001a6
MSR_OFFCORE_RSP_1 0x000001a7
MSR_TURBO_RATIO_LIMIT 0x000001ad
MSR_TURBO_RATIO_LIMIT1 0x000001ae
MSR_TURBO_RATIO_LIMIT2 0x000001af
MSR_LBR_SELECT 0x000001c8
MSR_LBR_TOS 0x000001c9
MSR_LBR_NHM_FROM 0x00000680
MSR_LBR_NHM_TO 0x000006c0
MSR_LBR_CORE_FROM 0x00000040
MSR_LBR_CORE_TO 0x00000060
MSR_LBR_INFO_0 0x00000dc0
LBR_INFO_MISPRED BIT_ULL(63)
LBR_INFO_IN_TX BIT_ULL(62)
LBR_INFO_ABORT BIT_ULL(61)
LBR_INFO_CYCLES 0xffff
MSR_IA32_PEBS_ENABLE 0x000003f1
MSR_PEBS_DATA_CFG 0x000003f2
MSR_IA32_DS_AREA 0x00000600
MSR_IA32_PERF_CAPABILITIES 0x00000345
MSR_PEBS_LD_LAT_THRESHOLD 0x000003f6
MSR_IA32_RTIT_CTL 0x00000570
RTIT_CTL_TRACEEN BIT(0)
RTIT_CTL_CYCLEACC BIT(1)
RTIT_CTL_OS BIT(2)
RTIT_CTL_USR BIT(3)
RTIT_CTL_PWR_EVT_EN BIT(4)
RTIT_CTL_FUP_ON_PTW BIT(5)
RTIT_CTL_FABRIC_EN BIT(6)
RTIT_CTL_CR3EN BIT(7)
RTIT_CTL_TOPA BIT(8)
RTIT_CTL_MTC_EN BIT(9)
RTIT_CTL_TSC_EN BIT(10)
RTIT_CTL_DISRETC BIT(11)
RTIT_CTL_PTW_EN BIT(12)
RTIT_CTL_BRANCH_EN BIT(13)
RTIT_CTL_MTC_RANGE_OFFSET 14
RTIT_CTL_MTC_RANGE (0x0full << RTIT_CTL_MTC_RANGE_OFFSET)
RTIT_CTL_CYC_THRESH_OFFSET 19
RTIT_CTL_CYC_THRESH (0x0full << RTIT_CTL_CYC_THRESH_OFFSET)
RTIT_CTL_PSB_FREQ_OFFSET 24
RTIT_CTL_PSB_FREQ (0x0full << RTIT_CTL_PSB_FREQ_OFFSET)
RTIT_CTL_ADDR0_OFFSET 32
RTIT_CTL_ADDR0 (0x0full << RTIT_CTL_ADDR0_OFFSET)
RTIT_CTL_ADDR1_OFFSET 36
RTIT_CTL_ADDR1 (0x0full << RTIT_CTL_ADDR1_OFFSET)
RTIT_CTL_ADDR2_OFFSET 40
RTIT_CTL_ADDR2 (0x0full << RTIT_CTL_ADDR2_OFFSET)
RTIT_CTL_ADDR3_OFFSET 44
RTIT_CTL_ADDR3 (0x0full << RTIT_CTL_ADDR3_OFFSET)
MSR_IA32_RTIT_STATUS 0x00000571
RTIT_STATUS_FILTEREN BIT(0)
RTIT_STATUS_CONTEXTEN BIT(1)
RTIT_STATUS_TRIGGEREN BIT(2)
RTIT_STATUS_BUFFOVF BIT(3)
RTIT_STATUS_ERROR BIT(4)
RTIT_STATUS_STOPPED BIT(5)
RTIT_STATUS_BYTECNT_OFFSET 32
RTIT_STATUS_BYTECNT (0x1ffffull << RTIT_STATUS_BYTECNT_OFFSET)
MSR_IA32_RTIT_ADDR0_A 0x00000580
MSR_IA32_RTIT_ADDR0_B 0x00000581
MSR_IA32_RTIT_ADDR1_A 0x00000582
MSR_IA32_RTIT_ADDR1_B 0x00000583
MSR_IA32_RTIT_ADDR2_A 0x00000584
MSR_IA32_RTIT_ADDR2_B 0x00000585
MSR_IA32_RTIT_ADDR3_A 0x00000586
MSR_IA32_RTIT_ADDR3_B 0x00000587
MSR_IA32_RTIT_CR3_MATCH 0x00000572
MSR_IA32_RTIT_OUTPUT_BASE 0x00000560
MSR_IA32_RTIT_OUTPUT_MASK 0x00000561
MSR_MTRRfix64K_00000 0x00000250
MSR_MTRRfix16K_80000 0x00000258
MSR_MTRRfix16K_A0000 0x00000259
MSR_MTRRfix4K_C0000 0x00000268
MSR_MTRRfix4K_C8000 0x00000269
MSR_MTRRfix4K_D0000 0x0000026a
MSR_MTRRfix4K_D8000 0x0000026b
MSR_MTRRfix4K_E0000 0x0000026c
MSR_MTRRfix4K_E8000 0x0000026d
MSR_MTRRfix4K_F0000 0x0000026e
MSR_MTRRfix4K_F8000 0x0000026f
MSR_MTRRdefType 0x000002ff
MSR_IA32_CR_PAT 0x00000277
MSR_IA32_DEBUGCTLMSR 0x000001d9
MSR_IA32_LASTBRANCHFROMIP 0x000001db
MSR_IA32_LASTBRANCHTOIP 0x000001dc
MSR_IA32_LASTINTFROMIP 0x000001dd
MSR_IA32_LASTINTTOIP 0x000001de
DEBUGCTLMSR_LBR (1UL << 0)
DEBUGCTLMSR_BTF_SHIFT 1
DEBUGCTLMSR_BTF (1UL << 1)
DEBUGCTLMSR_TR (1UL << 6)
DEBUGCTLMSR_BTS (1UL << 7)
DEBUGCTLMSR_BTINT (1UL << 8)
DEBUGCTLMSR_BTS_OFF_OS (1UL << 9)
DEBUGCTLMSR_BTS_OFF_USR (1UL << 10)
DEBUGCTLMSR_FREEZE_LBRS_ON_PMI (1UL << 11)
DEBUGCTLMSR_FREEZE_PERFMON_ON_PMI (1UL << 12)
DEBUGCTLMSR_FREEZE_IN_SMM_BIT 14
DEBUGCTLMSR_FREEZE_IN_SMM (1UL << DEBUGCTLMSR_FREEZE_IN_SMM_BIT)
MSR_PEBS_FRONTEND 0x000003f7
MSR_IA32_POWER_CTL 0x000001fc
MSR_IA32_MC0_CTL 0x00000400
MSR_IA32_MC0_STATUS 0x00000401
MSR_IA32_MC0_ADDR 0x00000402
MSR_IA32_MC0_MISC 0x00000403
MSR_PKG_C3_RESIDENCY 0x000003f8
MSR_PKG_C6_RESIDENCY 0x000003f9
MSR_ATOM_PKG_C6_RESIDENCY 0x000003fa
MSR_PKG_C7_RESIDENCY 0x000003fa
MSR_CORE_C3_RESIDENCY 0x000003fc
MSR_CORE_C6_RESIDENCY 0x000003fd
MSR_CORE_C7_RESIDENCY 0x000003fe
MSR_KNL_CORE_C6_RESIDENCY 0x000003ff
MSR_PKG_C2_RESIDENCY 0x0000060d
MSR_PKG_C8_RESIDENCY 0x00000630
MSR_PKG_C9_RESIDENCY 0x00000631
MSR_PKG_C10_RESIDENCY 0x00000632
MSR_PKGC3_IRTL 0x0000060a
MSR_PKGC6_IRTL 0x0000060b
MSR_PKGC7_IRTL 0x0000060c
MSR_PKGC8_IRTL 0x00000633
MSR_PKGC9_IRTL 0x00000634
MSR_PKGC10_IRTL 0x00000635
MSR_RAPL_POWER_UNIT 0x00000606
MSR_PKG_POWER_LIMIT 0x00000610
MSR_PKG_ENERGY_STATUS 0x00000611
MSR_PKG_PERF_STATUS 0x00000613
MSR_PKG_POWER_INFO 0x00000614
MSR_DRAM_POWER_LIMIT 0x00000618
MSR_DRAM_ENERGY_STATUS 0x00000619
MSR_DRAM_PERF_STATUS 0x0000061b
MSR_DRAM_POWER_INFO 0x0000061c
MSR_PP0_POWER_LIMIT 0x00000638
MSR_PP0_ENERGY_STATUS 0x00000639
MSR_PP0_POLICY 0x0000063a
MSR_PP0_PERF_STATUS 0x0000063b
MSR_PP1_POWER_LIMIT 0x00000640
MSR_PP1_ENERGY_STATUS 0x00000641
MSR_PP1_POLICY 0x00000642
MSR_CONFIG_TDP_NOMINAL 0x00000648
MSR_CONFIG_TDP_LEVEL_1 0x00000649
MSR_CONFIG_TDP_LEVEL_2 0x0000064A
MSR_CONFIG_TDP_CONTROL 0x0000064B
MSR_TURBO_ACTIVATION_RATIO 0x0000064C
MSR_PLATFORM_ENERGY_STATUS 0x0000064D
MSR_PKG_WEIGHTED_CORE_C0_RES 0x00000658
MSR_PKG_ANY_CORE_C0_RES 0x00000659
MSR_PKG_ANY_GFXE_C0_RES 0x0000065A
MSR_PKG_BOTH_CORE_GFXE_C0_RES 0x0000065B
MSR_CORE_C1_RES 0x00000660
MSR_MODULE_C6_RES_MS 0x00000664
MSR_CC6_DEMOTION_POLICY_CONFIG 0x00000668
MSR_MC6_DEMOTION_POLICY_CONFIG 0x00000669
MSR_ATOM_CORE_RATIOS 0x0000066a
MSR_ATOM_CORE_VIDS 0x0000066b
MSR_ATOM_CORE_TURBO_RATIOS 0x0000066c
MSR_ATOM_CORE_TURBO_VIDS 0x0000066d
MSR_CORE_PERF_LIMIT_REASONS 0x00000690
MSR_GFX_PERF_LIMIT_REASONS 0x000006B0
MSR_RING_PERF_LIMIT_REASONS 0x000006B1
MSR_PPERF 0x0000064e
MSR_PERF_LIMIT_REASONS 0x0000064f
MSR_PM_ENABLE 0x00000770
MSR_HWP_CAPABILITIES 0x00000771
MSR_HWP_REQUEST_PKG 0x00000772
MSR_HWP_INTERRUPT 0x00000773
MSR_HWP_REQUEST 0x00000774
MSR_HWP_STATUS 0x00000777
HWP_BASE_BIT (1<<7)
HWP_NOTIFICATIONS_BIT (1<<8)
HWP_ACTIVITY_WINDOW_BIT (1<<9)
HWP_ENERGY_PERF_PREFERENCE_BIT (1<<10)
HWP_PACKAGE_LEVEL_REQUEST_BIT (1<<11)
HWP_HIGHEST_PERF() ((() >> 0) & 0xff)
HWP_GUARANTEED_PERF() ((() >> 8) & 0xff)
HWP_MOSTEFFICIENT_PERF() ((() >> 16) & 0xff)
HWP_LOWEST_PERF() ((() >> 24) & 0xff)
HWP_MIN_PERF() ( & 0xff)
HWP_MAX_PERF() (( & 0xff) << 8)
HWP_DESIRED_PERF() (( & 0xff) << 16)
HWP_ENERGY_PERF_PREFERENCE() (((unsigned long long)  & 0xff) << 24)
HWP_EPP_PERFORMANCE 0x00
HWP_EPP_BALANCE_PERFORMANCE 0x80
HWP_EPP_BALANCE_POWERSAVE 0xC0
HWP_EPP_POWERSAVE 0xFF
HWP_ACTIVITY_WINDOW() ((unsigned long long)( & 0xff3) << 32)
HWP_PACKAGE_CONTROL() ((unsigned long long)( & 0x1) << 42)
HWP_GUARANTEED_CHANGE() ( & 0x1)
HWP_EXCURSION_TO_MINIMUM() ( & 0x4)
HWP_CHANGE_TO_GUARANTEED_INT() ( & 0x1)
HWP_EXCURSION_TO_MINIMUM_INT() ( & 0x2)
MSR_AMD64_MC0_MASK 0xc0010044
MSR_IA32_MCx_CTL() (MSR_IA32_MC0_CTL + 4*())
MSR_IA32_MCx_STATUS() (MSR_IA32_MC0_STATUS + 4*())
MSR_IA32_MCx_ADDR() (MSR_IA32_MC0_ADDR + 4*())
MSR_IA32_MCx_MISC() (MSR_IA32_MC0_MISC + 4*())
MSR_AMD64_MCx_MASK() (MSR_AMD64_MC0_MASK + ())
MSR_IA32_MC0_CTL2 0x00000280
MSR_IA32_MCx_CTL2() (MSR_IA32_MC0_CTL2 + ())
MSR_P6_PERFCTR0 0x000000c1
MSR_P6_PERFCTR1 0x000000c2
MSR_P6_EVNTSEL0 0x00000186
MSR_P6_EVNTSEL1 0x00000187
MSR_KNC_PERFCTR0 0x00000020
MSR_KNC_PERFCTR1 0x00000021
MSR_KNC_EVNTSEL0 0x00000028
MSR_KNC_EVNTSEL1 0x00000029
MSR_IA32_PMC0 0x000004c1
MSR_RELOAD_PMC0 0x000014c1
MSR_RELOAD_FIXED_CTR0 0x00001309
MSR_AMD64_PATCH_LEVEL 0x0000008b
MSR_AMD64_TSC_RATIO 0xc0000104
MSR_AMD64_NB_CFG 0xc001001f
MSR_AMD64_CPUID_FN_1 0xc0011004
MSR_AMD64_PATCH_LOADER 0xc0010020
MSR_AMD_PERF_CTL 0xc0010062
MSR_AMD_PERF_STATUS 0xc0010063
MSR_AMD_PSTATE_DEF_BASE 0xc0010064
MSR_AMD64_OSVW_ID_LENGTH 0xc0010140
MSR_AMD64_OSVW_STATUS 0xc0010141
MSR_AMD64_LS_CFG 0xc0011020
MSR_AMD64_DC_CFG 0xc0011022
MSR_AMD64_DE_CFG 0xc0011029
MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT 1
MSR_AMD64_DE_CFG_LFENCE_SERIALIZE BIT_ULL(MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT)
MSR_AMD64_DE_CFG_ZEN2_FP_BACKUP_FIX_BIT 9
MSR_AMD64_BU_CFG2 0xc001102a
MSR_AMD64_IBSFETCHCTL 0xc0011030
MSR_AMD64_IBSFETCHLINAD 0xc0011031
MSR_AMD64_IBSFETCHPHYSAD 0xc0011032
MSR_AMD64_IBSFETCH_REG_COUNT 3
MSR_AMD64_IBSFETCH_REG_MASK ((1UL<<MSR_AMD64_IBSFETCH_REG_COUNT)-1)
MSR_AMD64_IBSOPCTL 0xc0011033
MSR_AMD64_IBSOPRIP 0xc0011034
MSR_AMD64_IBSOPDATA 0xc0011035
MSR_AMD64_IBSOPDATA2 0xc0011036
MSR_AMD64_IBSOPDATA3 0xc0011037
MSR_AMD64_IBSDCLINAD 0xc0011038
MSR_AMD64_IBSDCPHYSAD 0xc0011039
MSR_AMD64_IBSOP_REG_COUNT 7
MSR_AMD64_IBSOP_REG_MASK ((1UL<<MSR_AMD64_IBSOP_REG_COUNT)-1)
MSR_AMD64_IBSCTL 0xc001103a
MSR_AMD64_IBSBRTARGET 0xc001103b
MSR_AMD64_ICIBSEXTDCTL 0xc001103c
MSR_AMD64_IBSOPDATA4 0xc001103d
MSR_AMD64_IBS_REG_COUNT_MAX 8
MSR_AMD64_SEV 0xc0010131
MSR_AMD64_SEV_ENABLED_BIT 0
MSR_AMD64_SEV_ENABLED BIT_ULL(MSR_AMD64_SEV_ENABLED_BIT)
MSR_AMD64_VIRT_SPEC_CTRL 0xc001011f
MSR_F17H_IRPERF 0xc00000e9
MSR_F16H_L2I_PERF_CTL 0xc0010230
MSR_F16H_L2I_PERF_CTR 0xc0010231
MSR_F16H_DR1_ADDR_MASK 0xc0011019
MSR_F16H_DR2_ADDR_MASK 0xc001101a
MSR_F16H_DR3_ADDR_MASK 0xc001101b
MSR_F16H_DR0_ADDR_MASK 0xc0011027
MSR_F15H_PERF_CTL 0xc0010200
MSR_F15H_PERF_CTL0 MSR_F15H_PERF_CTL
MSR_F15H_PERF_CTL1 (MSR_F15H_PERF_CTL + 2)
MSR_F15H_PERF_CTL2 (MSR_F15H_PERF_CTL + 4)
MSR_F15H_PERF_CTL3 (MSR_F15H_PERF_CTL + 6)
MSR_F15H_PERF_CTL4 (MSR_F15H_PERF_CTL + 8)
MSR_F15H_PERF_CTL5 (MSR_F15H_PERF_CTL + 10)
MSR_F15H_PERF_CTR 0xc0010201
MSR_F15H_PERF_CTR0 MSR_F15H_PERF_CTR
MSR_F15H_PERF_CTR1 (MSR_F15H_PERF_CTR + 2)
MSR_F15H_PERF_CTR2 (MSR_F15H_PERF_CTR + 4)
MSR_F15H_PERF_CTR3 (MSR_F15H_PERF_CTR + 6)
MSR_F15H_PERF_CTR4 (MSR_F15H_PERF_CTR + 8)
MSR_F15H_PERF_CTR5 (MSR_F15H_PERF_CTR + 10)
MSR_F15H_NB_PERF_CTL 0xc0010240
MSR_F15H_NB_PERF_CTR 0xc0010241
MSR_F15H_PTSC 0xc0010280
MSR_F15H_IC_CFG 0xc0011021
MSR_F15H_EX_CFG 0xc001102c
MSR_FAM10H_MMIO_CONF_BASE 0xc0010058
FAM10H_MMIO_CONF_ENABLE (1<<0)
FAM10H_MMIO_CONF_BUSRANGE_MASK 0xf
FAM10H_MMIO_CONF_BUSRANGE_SHIFT 2
FAM10H_MMIO_CONF_BASE_MASK 0xfffffffULL
FAM10H_MMIO_CONF_BASE_SHIFT 20
MSR_FAM10H_NODE_ID 0xc001100c
MSR_K8_TOP_MEM1 0xc001001a
MSR_K8_TOP_MEM2 0xc001001d
MSR_K8_SYSCFG 0xc0010010
MSR_K8_SYSCFG_MEM_ENCRYPT_BIT 23
MSR_K8_SYSCFG_MEM_ENCRYPT BIT_ULL(MSR_K8_SYSCFG_MEM_ENCRYPT_BIT)
MSR_K8_INT_PENDING_MSG 0xc0010055
K8_INTP_C1E_ACTIVE_MASK 0x18000000
MSR_K8_TSEG_ADDR 0xc0010112
MSR_K8_TSEG_MASK 0xc0010113
K8_MTRRFIXRANGE_DRAM_ENABLE 0x00040000
K8_MTRRFIXRANGE_DRAM_MODIFY 0x00080000
K8_MTRR_RDMEM_WRMEM_MASK 0x18181818
MSR_K7_EVNTSEL0 0xc0010000
MSR_K7_PERFCTR0 0xc0010004
MSR_K7_EVNTSEL1 0xc0010001
MSR_K7_PERFCTR1 0xc0010005
MSR_K7_EVNTSEL2 0xc0010002
MSR_K7_PERFCTR2 0xc0010006
MSR_K7_EVNTSEL3 0xc0010003
MSR_K7_PERFCTR3 0xc0010007
MSR_K7_CLK_CTL 0xc001001b
MSR_K7_HWCR 0xc0010015
MSR_K7_HWCR_SMMLOCK_BIT 0
MSR_K7_HWCR_SMMLOCK BIT_ULL(MSR_K7_HWCR_SMMLOCK_BIT)
MSR_K7_HWCR_IRPERF_EN_BIT 30
MSR_K7_HWCR_IRPERF_EN BIT_ULL(MSR_K7_HWCR_IRPERF_EN_BIT)
MSR_K7_FID_VID_CTL 0xc0010041
MSR_K7_FID_VID_STATUS 0xc0010042
MSR_K6_WHCR 0xc0000082
MSR_K6_UWCCR 0xc0000085
MSR_K6_EPMR 0xc0000086
MSR_K6_PSOR 0xc0000087
MSR_K6_PFIR 0xc0000088
MSR_IDT_FCR1 0x00000107
MSR_IDT_FCR2 0x00000108
MSR_IDT_FCR3 0x00000109
MSR_IDT_FCR4 0x0000010a
MSR_IDT_MCR0 0x00000110
MSR_IDT_MCR1 0x00000111
MSR_IDT_MCR2 0x00000112
MSR_IDT_MCR3 0x00000113
MSR_IDT_MCR4 0x00000114
MSR_IDT_MCR5 0x00000115
MSR_IDT_MCR6 0x00000116
MSR_IDT_MCR7 0x00000117
MSR_IDT_MCR_CTRL 0x00000120
MSR_VIA_FCR 0x00001107
MSR_VIA_LONGHAUL 0x0000110a
MSR_VIA_RNG 0x0000110b
MSR_VIA_BCR2 0x00001147
MSR_TMTA_LONGRUN_CTRL 0x80868010
MSR_TMTA_LONGRUN_FLAGS 0x80868011
MSR_TMTA_LRTI_READOUT 0x80868018
MSR_TMTA_LRTI_VOLT_MHZ 0x8086801a
MSR_IA32_P5_MC_ADDR 0x00000000
MSR_IA32_P5_MC_TYPE 0x00000001
MSR_IA32_TSC 0x00000010
MSR_IA32_PLATFORM_ID 0x00000017
MSR_IA32_EBL_CR_POWERON 0x0000002a
MSR_EBC_FREQUENCY_ID 0x0000002c
MSR_SMI_COUNT 0x00000034
MSR_IA32_FEATURE_CONTROL 0x0000003a
MSR_IA32_TSC_ADJUST 0x0000003b
MSR_IA32_BNDCFGS 0x00000d90
MSR_IA32_BNDCFGS_RSVD 0x00000ffc
MSR_IA32_XSS 0x00000da0
FEATURE_CONTROL_LOCKED (1<<0)
FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX (1<<1)
FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX (1<<2)
FEATURE_CONTROL_LMCE (1<<20)
MSR_IA32_APICBASE 0x0000001b
MSR_IA32_APICBASE_BSP (1<<8)
MSR_IA32_APICBASE_ENABLE (1<<11)
MSR_IA32_APICBASE_BASE (0xfffff<<12)
MSR_IA32_TSCDEADLINE 0x000006e0
MSR_IA32_UCODE_WRITE 0x00000079
MSR_IA32_UCODE_REV 0x0000008b
MSR_IA32_SMM_MONITOR_CTL 0x0000009b
MSR_IA32_SMBASE 0x0000009e
MSR_IA32_PERF_STATUS 0x00000198
MSR_IA32_PERF_CTL 0x00000199
INTEL_PERF_CTL_MASK 0xffff
MSR_IA32_MPERF 0x000000e7
MSR_IA32_APERF 0x000000e8
MSR_IA32_THERM_CONTROL 0x0000019a
MSR_IA32_THERM_INTERRUPT 0x0000019b
THERM_INT_HIGH_ENABLE (1 << 0)
THERM_INT_LOW_ENABLE (1 << 1)
THERM_INT_PLN_ENABLE (1 << 24)
MSR_IA32_THERM_STATUS 0x0000019c
THERM_STATUS_PROCHOT (1 << 0)
THERM_STATUS_POWER_LIMIT (1 << 10)
MSR_THERM2_CTL 0x0000019d
MSR_THERM2_CTL_TM_SELECT (1ULL << 16)
MSR_IA32_MISC_ENABLE 0x000001a0
MSR_IA32_TEMPERATURE_TARGET 0x000001a2
MSR_MISC_FEATURE_CONTROL 0x000001a4
MSR_MISC_PWR_MGMT 0x000001aa
MSR_IA32_ENERGY_PERF_BIAS 0x000001b0
ENERGY_PERF_BIAS_PERFORMANCE 0
ENERGY_PERF_BIAS_BALANCE_PERFORMANCE 4
ENERGY_PERF_BIAS_NORMAL 6
ENERGY_PERF_BIAS_BALANCE_POWERSAVE 8
ENERGY_PERF_BIAS_POWERSAVE 15
MSR_IA32_PACKAGE_THERM_STATUS 0x000001b1
PACKAGE_THERM_STATUS_PROCHOT (1 << 0)
PACKAGE_THERM_STATUS_POWER_LIMIT (1 << 10)
MSR_IA32_PACKAGE_THERM_INTERRUPT 0x000001b2
PACKAGE_THERM_INT_HIGH_ENABLE (1 << 0)
PACKAGE_THERM_INT_LOW_ENABLE (1 << 1)
PACKAGE_THERM_INT_PLN_ENABLE (1 << 24)
THERM_INT_THRESHOLD0_ENABLE (1 << 15)
THERM_SHIFT_THRESHOLD0 8
THERM_MASK_THRESHOLD0 (0x7f << THERM_SHIFT_THRESHOLD0)
THERM_INT_THRESHOLD1_ENABLE (1 << 23)
THERM_SHIFT_THRESHOLD1 16
THERM_MASK_THRESHOLD1 (0x7f << THERM_SHIFT_THRESHOLD1)
THERM_STATUS_THRESHOLD0 (1 << 6)
THERM_LOG_THRESHOLD0 (1 << 7)
THERM_STATUS_THRESHOLD1 (1 << 8)
THERM_LOG_THRESHOLD1 (1 << 9)
MSR_IA32_MISC_ENABLE_FAST_STRING_BIT 0
MSR_IA32_MISC_ENABLE_FAST_STRING (1ULL << MSR_IA32_MISC_ENABLE_FAST_STRING_BIT)
MSR_IA32_MISC_ENABLE_TCC_BIT 1
MSR_IA32_MISC_ENABLE_TCC (1ULL << MSR_IA32_MISC_ENABLE_TCC_BIT)
MSR_IA32_MISC_ENABLE_EMON_BIT 7
MSR_IA32_MISC_ENABLE_EMON (1ULL << MSR_IA32_MISC_ENABLE_EMON_BIT)
MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT 11
MSR_IA32_MISC_ENABLE_BTS_UNAVAIL (1ULL << MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT)
MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT 12
MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL (1ULL << MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT)
MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT 16
MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP (1ULL << MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT)
MSR_IA32_MISC_ENABLE_MWAIT_BIT 18
MSR_IA32_MISC_ENABLE_MWAIT (1ULL << MSR_IA32_MISC_ENABLE_MWAIT_BIT)
MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT 22
MSR_IA32_MISC_ENABLE_LIMIT_CPUID (1ULL << MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT)
MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT 23
MSR_IA32_MISC_ENABLE_XTPR_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT 34
MSR_IA32_MISC_ENABLE_XD_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT 2
MSR_IA32_MISC_ENABLE_X87_COMPAT (1ULL << MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT)
MSR_IA32_MISC_ENABLE_TM1_BIT 3
MSR_IA32_MISC_ENABLE_TM1 (1ULL << MSR_IA32_MISC_ENABLE_TM1_BIT)
MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT 4
MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT 6
MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT 8
MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK (1ULL << MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT)
MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT 9
MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_FERR_BIT 10
MSR_IA32_MISC_ENABLE_FERR (1ULL << MSR_IA32_MISC_ENABLE_FERR_BIT)
MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT 10
MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX (1ULL << MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT)
MSR_IA32_MISC_ENABLE_TM2_BIT 13
MSR_IA32_MISC_ENABLE_TM2 (1ULL << MSR_IA32_MISC_ENABLE_TM2_BIT)
MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT 19
MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT 20
MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK (1ULL << MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT)
MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT 24
MSR_IA32_MISC_ENABLE_L1D_CONTEXT (1ULL << MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT)
MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT 37
MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT 38
MSR_IA32_MISC_ENABLE_TURBO_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT)
MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT 39
MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE (1ULL << MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT)
MSR_MISC_FEATURES_ENABLES 0x00000140
MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT 0
MSR_MISC_FEATURES_ENABLES_CPUID_FAULT BIT_ULL(MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT)
MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT 1
MSR_IA32_TSC_DEADLINE 0x000006E0
MSR_TSX_FORCE_ABORT 0x0000010F
MSR_TFA_RTM_FORCE_ABORT_BIT 0
MSR_TFA_RTM_FORCE_ABORT BIT_ULL(MSR_TFA_RTM_FORCE_ABORT_BIT)
MSR_IA32_MCG_EAX 0x00000180
MSR_IA32_MCG_EBX 0x00000181
MSR_IA32_MCG_ECX 0x00000182
MSR_IA32_MCG_EDX 0x00000183
MSR_IA32_MCG_ESI 0x00000184
MSR_IA32_MCG_EDI 0x00000185
MSR_IA32_MCG_EBP 0x00000186
MSR_IA32_MCG_ESP 0x00000187
MSR_IA32_MCG_EFLAGS 0x00000188
MSR_IA32_MCG_EIP 0x00000189
MSR_IA32_MCG_RESERVED 0x0000018a
MSR_P4_BPU_PERFCTR0 0x00000300
MSR_P4_BPU_PERFCTR1 0x00000301
MSR_P4_BPU_PERFCTR2 0x00000302
MSR_P4_BPU_PERFCTR3 0x00000303
MSR_P4_MS_PERFCTR0 0x00000304
MSR_P4_MS_PERFCTR1 0x00000305
MSR_P4_MS_PERFCTR2 0x00000306
MSR_P4_MS_PERFCTR3 0x00000307
MSR_P4_FLAME_PERFCTR0 0x00000308
MSR_P4_FLAME_PERFCTR1 0x00000309
MSR_P4_FLAME_PERFCTR2 0x0000030a
MSR_P4_FLAME_PERFCTR3 0x0000030b
MSR_P4_IQ_PERFCTR0 0x0000030c
MSR_P4_IQ_PERFCTR1 0x0000030d
MSR_P4_IQ_PERFCTR2 0x0000030e
MSR_P4_IQ_PERFCTR3 0x0000030f
MSR_P4_IQ_PERFCTR4 0x00000310
MSR_P4_IQ_PERFCTR5 0x00000311
MSR_P4_BPU_CCCR0 0x00000360
MSR_P4_BPU_CCCR1 0x00000361
MSR_P4_BPU_CCCR2 0x00000362
MSR_P4_BPU_CCCR3 0x00000363
MSR_P4_MS_CCCR0 0x00000364
MSR_P4_MS_CCCR1 0x00000365
MSR_P4_MS_CCCR2 0x00000366
MSR_P4_MS_CCCR3 0x00000367
MSR_P4_FLAME_CCCR0 0x00000368
MSR_P4_FLAME_CCCR1 0x00000369
MSR_P4_FLAME_CCCR2 0x0000036a
MSR_P4_FLAME_CCCR3 0x0000036b
MSR_P4_IQ_CCCR0 0x0000036c
MSR_P4_IQ_CCCR1 0x0000036d
MSR_P4_IQ_CCCR2 0x0000036e
MSR_P4_IQ_CCCR3 0x0000036f
MSR_P4_IQ_CCCR4 0x00000370
MSR_P4_IQ_CCCR5 0x00000371
MSR_P4_ALF_ESCR0 0x000003ca
MSR_P4_ALF_ESCR1 0x000003cb
MSR_P4_BPU_ESCR0 0x000003b2
MSR_P4_BPU_ESCR1 0x000003b3
MSR_P4_BSU_ESCR0 0x000003a0
MSR_P4_BSU_ESCR1 0x000003a1
MSR_P4_CRU_ESCR0 0x000003b8
MSR_P4_CRU_ESCR1 0x000003b9
MSR_P4_CRU_ESCR2 0x000003cc
MSR_P4_CRU_ESCR3 0x000003cd
MSR_P4_CRU_ESCR4 0x000003e0
MSR_P4_CRU_ESCR5 0x000003e1
MSR_P4_DAC_ESCR0 0x000003a8
MSR_P4_DAC_ESCR1 0x000003a9
MSR_P4_FIRM_ESCR0 0x000003a4
MSR_P4_FIRM_ESCR1 0x000003a5
MSR_P4_FLAME_ESCR0 0x000003a6
MSR_P4_FLAME_ESCR1 0x000003a7
MSR_P4_FSB_ESCR0 0x000003a2
MSR_P4_FSB_ESCR1 0x000003a3
MSR_P4_IQ_ESCR0 0x000003ba
MSR_P4_IQ_ESCR1 0x000003bb
MSR_P4_IS_ESCR0 0x000003b4
MSR_P4_IS_ESCR1 0x000003b5
MSR_P4_ITLB_ESCR0 0x000003b6
MSR_P4_ITLB_ESCR1 0x000003b7
MSR_P4_IX_ESCR0 0x000003c8
MSR_P4_IX_ESCR1 0x000003c9
MSR_P4_MOB_ESCR0 0x000003aa
MSR_P4_MOB_ESCR1 0x000003ab
MSR_P4_MS_ESCR0 0x000003c0
MSR_P4_MS_ESCR1 0x000003c1
MSR_P4_PMH_ESCR0 0x000003ac
MSR_P4_PMH_ESCR1 0x000003ad
MSR_P4_RAT_ESCR0 0x000003bc
MSR_P4_RAT_ESCR1 0x000003bd
MSR_P4_SAAT_ESCR0 0x000003ae
MSR_P4_SAAT_ESCR1 0x000003af
MSR_P4_SSU_ESCR0 0x000003be
MSR_P4_SSU_ESCR1 0x000003bf
MSR_P4_TBPU_ESCR0 0x000003c2
MSR_P4_TBPU_ESCR1 0x000003c3
MSR_P4_TC_ESCR0 0x000003c4
MSR_P4_TC_ESCR1 0x000003c5
MSR_P4_U2L_ESCR0 0x000003b0
MSR_P4_U2L_ESCR1 0x000003b1
MSR_P4_PEBS_MATRIX_VERT 0x000003f2
MSR_CORE_PERF_FIXED_CTR0 0x00000309
MSR_CORE_PERF_FIXED_CTR1 0x0000030a
MSR_CORE_PERF_FIXED_CTR2 0x0000030b
MSR_CORE_PERF_FIXED_CTR_CTRL 0x0000038d
MSR_CORE_PERF_GLOBAL_STATUS 0x0000038e
MSR_CORE_PERF_GLOBAL_CTRL 0x0000038f
MSR_CORE_PERF_GLOBAL_OVF_CTRL 0x00000390
MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT 55
MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI (1ULL << MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT)
MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF_BIT 62
MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF (1ULL << MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF_BIT)
MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD_BIT 63
MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD (1ULL << MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD_BIT)
MSR_GEODE_BUSCONT_CONF0 0x00001900
MSR_IA32_VMX_BASIC 0x00000480
MSR_IA32_VMX_PINBASED_CTLS 0x00000481
MSR_IA32_VMX_PROCBASED_CTLS 0x00000482
MSR_IA32_VMX_EXIT_CTLS 0x00000483
MSR_IA32_VMX_ENTRY_CTLS 0x00000484
MSR_IA32_VMX_MISC 0x00000485
MSR_IA32_VMX_CR0_FIXED0 0x00000486
MSR_IA32_VMX_CR0_FIXED1 0x00000487
MSR_IA32_VMX_CR4_FIXED0 0x00000488
MSR_IA32_VMX_CR4_FIXED1 0x00000489
MSR_IA32_VMX_VMCS_ENUM 0x0000048a
MSR_IA32_VMX_PROCBASED_CTLS2 0x0000048b
MSR_IA32_VMX_EPT_VPID_CAP 0x0000048c
MSR_IA32_VMX_TRUE_PINBASED_CTLS 0x0000048d
MSR_IA32_VMX_TRUE_PROCBASED_CTLS 0x0000048e
MSR_IA32_VMX_TRUE_EXIT_CTLS 0x0000048f
MSR_IA32_VMX_TRUE_ENTRY_CTLS 0x00000490
MSR_IA32_VMX_VMFUNC 0x00000491
VMX_BASIC_VMCS_SIZE_SHIFT 32
VMX_BASIC_TRUE_CTLS (1ULL << 55)
VMX_BASIC_64 0x0001000000000000LLU
VMX_BASIC_MEM_TYPE_SHIFT 50
VMX_BASIC_MEM_TYPE_MASK 0x003c000000000000LLU
VMX_BASIC_MEM_TYPE_WB 6LLU
VMX_BASIC_INOUT 0x0040000000000000LLU
MSR_IA32_VMX_MISC_INTEL_PT (1ULL << 14)
MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS (1ULL << 29)
MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE 0x1F
MSR_VM_CR 0xc0010114
MSR_VM_IGNNE 0xc0010115
MSR_VM_HSAVE_PA 0xc0010117
ORC_REG_UNDEFINED 0
ORC_REG_PREV_SP 1
ORC_REG_DX 2
ORC_REG_DI 3
ORC_REG_BP 4
ORC_REG_SP 5
ORC_REG_R10 6
ORC_REG_R13 7
ORC_REG_BP_INDIRECT 8
ORC_REG_SP_INDIRECT 9
ORC_REG_MAX 15
ORC_TYPE_CALL 0
ORC_TYPE_REGS 1
ORC_TYPE_REGS_IRET 2
UNWIND_HINT_TYPE_SAVE 3
UNWIND_HINT_TYPE_RESTORE 4
UNWIND_HINT(,,,) "987: \n\t" ".pushsection .discard.unwind_hints\n\t" /* struct unwind_hint */ ".long 987b - .\n\t" ".short " __stringify() "\n\t" ".byte " __stringify() "\n\t" ".byte " __stringify() "\n\t" ".byte " __stringify() "\n\t" ".balign 4 \n\t" ".popsection\n\t"
UNWIND_HINT_SAVE UNWIND_HINT(0, 0, UNWIND_HINT_TYPE_SAVE, 0)
UNWIND_HINT_RESTORE UNWIND_HINT(0, 0, UNWIND_HINT_TYPE_RESTORE, 0)
ANNOTATE_NOSPEC_ALTERNATIVE ANNOTATE_IGNORE_ALTERNATIVE
RSB_CLEAR_LOOPS 32
RSB_FILL_LOOPS 16
__FILL_RETURN_BUFFER(,,) mov $(/2), ; \
771: call 772f; \
773: /* speculation trap */ pause; lfence; jmp 773b; \
772: call 774f; \
775: /* speculation trap */ pause; lfence; jmp 775b; \
774: add $(BITS_PER_LONG/8) * 2, ; dec ; jnz 771b; /* barrier for jnz misprediction */ lfence;
ANNOTATE_RETPOLINE_SAFE "999:\n\t" ".pushsection .discard.retpoline_safe\n\t" _ASM_PTR " 999b\n\t" ".popsection\n\t"
CALL_NOSPEC ANNOTATE_NOSPEC_ALTERNATIVE ALTERNATIVE_2( ANNOTATE_RETPOLINE_SAFE "call *%[thunk_target]\n", "call __x86_indirect_thunk_%V[thunk_target]\n", X86_FEATURE_RETPOLINE, "lfence;\n" ANNOTATE_RETPOLINE_SAFE "call *%[thunk_target]\n", X86_FEATURE_RETPOLINE_LFENCE)
THUNK_TARGET() [thunk_target] "r" ()
firmware_restrict_branch_speculation_start() do { preempt_disable(); alternative_msr_write(MSR_IA32_SPEC_CTRL, spec_ctrl_current() | SPEC_CTRL_IBRS, X86_FEATURE_USE_IBRS_FW); \
} while (0)
firmware_restrict_branch_speculation_end() do { alternative_msr_write(MSR_IA32_SPEC_CTRL, spec_ctrl_current(), X86_FEATURE_USE_IBRS_FW); preempt_enable(); \
} while (0)
RETPOLINE_RAX_BPF_JIT_SIZE 17
RETPOLINE_RAX_BPF_JIT() do { EMIT1_off32(0xE8, 7); /* callq do_rop */ /* spec_trap: */ EMIT2(0xF3, 0x90); /* pause */ EMIT3(0x0F, 0xAE, 0xE8); /* lfence */ EMIT2(0xEB, 0xF9); /* jmp spec_trap */ /* do_rop: */ EMIT4(0x48, 0x89, 0x04, 0x24); /* mov %rax,(%rsp) */ EMIT1(0xC3); /* retq */ \
} while (0)
__TICKET_LOCK_INC 2
TICKET_SLOWPATH_FLAG ((__ticket_t)1)
TICKET_LOCK_INC ((__ticket_t)__TICKET_LOCK_INC)
TICKET_SHIFT (sizeof(__ticket_t) * 8)
__ARCH_SPIN_LOCK_UNLOCKED { { .val = ATOMIC_INIT(0) } }
_Q_SET_MASK() (((1U << _Q_ ##  ## _BITS) - 1) << _Q_ ##  ## _OFFSET)
_Q_LOCKED_OFFSET 0
_Q_LOCKED_BITS 8
_Q_LOCKED_MASK _Q_SET_MASK(LOCKED)
_Q_PENDING_OFFSET (_Q_LOCKED_OFFSET + _Q_LOCKED_BITS)
_Q_PENDING_BITS 8
_Q_PENDING_MASK _Q_SET_MASK(PENDING)
_Q_TAIL_IDX_OFFSET (_Q_PENDING_OFFSET + _Q_PENDING_BITS)
_Q_TAIL_IDX_BITS 2
_Q_TAIL_IDX_MASK _Q_SET_MASK(TAIL_IDX)
_Q_TAIL_CPU_OFFSET (_Q_TAIL_IDX_OFFSET + _Q_TAIL_IDX_BITS)
_Q_TAIL_CPU_BITS (32 - _Q_TAIL_CPU_OFFSET)
_Q_TAIL_CPU_MASK _Q_SET_MASK(TAIL_CPU)
_Q_TAIL_OFFSET _Q_TAIL_IDX_OFFSET
_Q_TAIL_MASK (_Q_TAIL_IDX_MASK | _Q_TAIL_CPU_MASK)
_Q_LOCKED_VAL (1U << _Q_LOCKED_OFFSET)
_Q_PENDING_VAL (1U << _Q_PENDING_OFFSET)
__ARCH_RW_LOCK_UNLOCKED { { .cnts = ATOMIC_INIT(0), }, .wait_lock = __ARCH_SPIN_LOCK_UNLOCKED, \
}
PARAVIRT_PATCH() (offsetof(struct paravirt_patch_template, ) / sizeof(void *))
paravirt_type() [paravirt_typenum] "i" (PARAVIRT_PATCH()), [paravirt_opptr] "i" (&(pv_ops.))
paravirt_clobber() [paravirt_clobber] "i" ()
_paravirt_alt(,,) "771:\n\t"  "\n" "772:\n" ".pushsection .parainstructions,\"a\"\n" _ASM_ALIGN "\n" _ASM_PTR " 771b\n" "  .byte "  "\n" "  .byte 772b-771b\n" "  .short "  "\n" ".popsection\n"
paravirt_alt() _paravirt_alt(, "%c[paravirt_typenum]", "%c[paravirt_clobber]")
NATIVE_LABEL(,,) "\n\t.globl "  # "_" # "\n"  # "_" # ":\n\t"
PARAVIRT_CALL ANNOTATE_RETPOLINE_SAFE "call *%c[paravirt_opptr];"
PVOP_VCALL_ARGS unsigned long __edi = __edi, __esi = __esi, __edx = __edx, __ecx = __ecx, __eax = __eax;
PVOP_CALL_ARGS PVOP_VCALL_ARGS
PVOP_CALL_ARG1() "D" ((unsigned long)())
PVOP_CALL_ARG2() "S" ((unsigned long)())
PVOP_CALL_ARG3() "d" ((unsigned long)())
PVOP_CALL_ARG4() "c" ((unsigned long)())
PVOP_VCALL_CLOBBERS "=D" (__edi), "=S" (__esi), "=d" (__edx), "=c" (__ecx)
PVOP_CALL_CLOBBERS PVOP_VCALL_CLOBBERS, "=a" (__eax)
PVOP_VCALLEE_CLOBBERS "=a" (__eax)
PVOP_CALLEE_CLOBBERS PVOP_VCALLEE_CLOBBERS
EXTRA_CLOBBERS , "r8", "r9", "r10", "r11"
VEXTRA_CLOBBERS , "rax", "r8", "r9", "r10", "r11"
PVOP_TEST_NULL() ((void)pv_ops.)
PVOP_RETMASK() ({ unsigned long __mask = ~0UL; switch (sizeof()) { case 1: __mask = 0xffUL; break; case 2: __mask = 0xffffUL; break; case 4: __mask = 0xffffffffUL; break; default: break; } __mask; })
____PVOP_CALL(,,,,,,) ({  __ret; PVOP_CALL_ARGS; PVOP_TEST_NULL(); /* This is 32-bit specific, but is okay in 64-bit */ /* since this condition will never hold */ if (sizeof() > sizeof(unsigned long)) { asm volatile( paravirt_alt(PARAVIRT_CALL)  : , ASM_CALL_CONSTRAINT : paravirt_type(), paravirt_clobber(), ##__VA_ARGS__ : "memory", "cc" ); __ret = ()((((u64)__edx) << 32) | __eax); } else { asm volatile( paravirt_alt(PARAVIRT_CALL)  : , ASM_CALL_CONSTRAINT : paravirt_type(), paravirt_clobber(), ##__VA_ARGS__ : "memory", "cc" ); __ret = ()(__eax & PVOP_RETMASK()); } __ret; })
__PVOP_CALL (rettype, op, pre, post, ...) ____PVOP_CALL(rettype, op, CLBR_ANY, PVOP_CALL_CLOBBERS, EXTRA_CLOBBERS, pre, post, ##__VA_ARGS__)
__PVOP_CALLEESAVE(,,,) ____PVOP_CALL(, .func, CLBR_RET_REG, PVOP_CALLEE_CLOBBERS, , , , ##__VA_ARGS__)
____PVOP_VCALL(,,,,,) ({ PVOP_VCALL_ARGS; PVOP_TEST_NULL(); asm volatile( paravirt_alt(PARAVIRT_CALL)  : , ASM_CALL_CONSTRAINT : paravirt_type(), paravirt_clobber(), ##__VA_ARGS__ : "memory", "cc" ); })
__PVOP_VCALL (op, pre, post, ...) ____PVOP_VCALL(op, CLBR_ANY, PVOP_VCALL_CLOBBERS, VEXTRA_CLOBBERS, pre, post, ##__VA_ARGS__)
__PVOP_VCALLEESAVE(,,) ____PVOP_VCALL(.func, CLBR_RET_REG, PVOP_VCALLEE_CLOBBERS, , , , ##__VA_ARGS__)
PVOP_CALL0 (rettype, op) __PVOP_CALL(rettype, op, "", "")
PVOP_VCALL0 (op) __PVOP_VCALL(op, "", "")
PVOP_CALLEE0(,) __PVOP_CALLEESAVE(, , "", "")
PVOP_VCALLEE0() __PVOP_VCALLEESAVE(, "", "")
PVOP_CALL1 (rettype, op, arg1) __PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1))
PVOP_VCALL1 (op, arg1) __PVOP_VCALL(op, "", "", PVOP_CALL_ARG1(arg1))
PVOP_CALLEE1(,,) __PVOP_CALLEESAVE(, , "", "", PVOP_CALL_ARG1())
PVOP_VCALLEE1(,) __PVOP_VCALLEESAVE(, "", "", PVOP_CALL_ARG1())
PVOP_CALL2 (rettype, op, arg1, arg2) __PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2))
PVOP_VCALL2 (op, arg1, arg2) __PVOP_VCALL(op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2))
PVOP_CALLEE2(,,,) __PVOP_CALLEESAVE(, , "", "", PVOP_CALL_ARG1(), PVOP_CALL_ARG2())
PVOP_VCALLEE2(,,) __PVOP_VCALLEESAVE(, "", "", PVOP_CALL_ARG1(), PVOP_CALL_ARG2())
PVOP_CALL3 (rettype, op, arg1, arg2, arg3) __PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3))
PVOP_VCALL3 (op, arg1, arg2, arg3) __PVOP_VCALL(op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3))
PVOP_CALL4 (rettype, op, arg1, arg2, arg3, arg4) __PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3), PVOP_CALL_ARG4(arg4))
PVOP_VCALL4 (op, arg1, arg2, arg3, arg4) __PVOP_VCALL(op, "", "", PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3), PVOP_CALL_ARG4(arg4))
paravirt_nop ((void *)_paravirt_nop)
current_user_stack_pointer() current_pt_regs()->sp
compat_user_stack_pointer() current_pt_regs()->sp
MAX_REG_OFFSET (offsetof(struct pt_regs, ss))
NR_REG_ARGUMENTS 6
arch_has_single_step() (1)
arch_has_block_step() (1)
ARCH_HAS_USER_SINGLE_STEP_REPORT 
arch_ptrace_stop_needed(,) \
({ force_iret(); false; \
})
FP_XSTATE_MAGIC1 0x46505853U
FP_XSTATE_MAGIC2 0x46505845U
FP_XSTATE_MAGIC2_SIZE sizeof(FP_XSTATE_MAGIC2)
X86_FXSR_MAGIC 0x0000
_fpstate _fpstate_64
sigcontext sigcontext_64
__HAVE_ARCH_MEMCPY 1
__HAVE_ARCH_MEMSET 
__HAVE_ARCH_MEMSET16 
__HAVE_ARCH_MEMSET32 
__HAVE_ARCH_MEMSET64 
__HAVE_ARCH_MEMMOVE 
__HAVE_ARCH_MEMCPY_MCSAFE 1
__HAVE_ARCH_MEMCPY_FLUSHCACHE 1
memcat_p(,) ({ BUILD_BUG_ON_MSG(!__same_type(*(), *()), "type mismatch in memcat_p()"); (typeof(*) *)__memcat_p((void **)(), (void **)()); \
})
sysfs_match_string(,) __sysfs_match_string(, ARRAY_SIZE(), )
__FORTIFY_INLINE extern __always_inline __attribute__((gnu_inline))
__RENAME() __asm__(#)
__underlying_memchr __builtin_memchr
__underlying_memcmp __builtin_memcmp
__underlying_memcpy __builtin_memcpy
__underlying_memmove __builtin_memmove
__underlying_memset __builtin_memset
__underlying_strcat __builtin_strcat
__underlying_strcpy __builtin_strcpy
__underlying_strlen __builtin_strlen
__underlying_strncat __builtin_strncat
__underlying_strncpy __builtin_strncpy
bitmap_copy_le bitmap_copy
BITMAP_FIRST_WORD_MASK() (~0UL << (() & (BITS_PER_LONG - 1)))
BITMAP_LAST_WORD_MASK() (~0UL >> (-() & (BITS_PER_LONG - 1)))
small_const_nbits() (__builtin_constant_p() && () <= BITS_PER_LONG && () > 0)
BITMAP_MEM_ALIGNMENT 8
BITMAP_MEM_MASK (BITMAP_MEM_ALIGNMENT - 1)
BITMAP_FROM_U64() ()
__X86_CASE_B 1
__X86_CASE_W 2
__X86_CASE_L 4
__X86_CASE_Q 8
__xchg_op(,,,) ({ __typeof__ (*()) __ret = (); switch (sizeof(*())) { case __X86_CASE_B: asm volatile ( # "b %b0, %1\n" : "+q" (__ret), "+m" (*()) : : "memory", "cc"); break; case __X86_CASE_W: asm volatile ( # "w %w0, %1\n" : "+r" (__ret), "+m" (*()) : : "memory", "cc"); break; case __X86_CASE_L: asm volatile ( # "l %0, %1\n" : "+r" (__ret), "+m" (*()) : : "memory", "cc"); break; case __X86_CASE_Q: asm volatile ( # "q %q0, %1\n" : "+r" (__ret), "+m" (*()) : : "memory", "cc"); break; default: __ ##  ## _wrong_size(); } __ret; })
arch_xchg(,) __xchg_op((), (), xchg, "")
__raw_cmpxchg(,,,,) \
({ __typeof__(*()) __ret; __typeof__(*()) __old = (); __typeof__(*()) __new = (); switch () { case __X86_CASE_B: { volatile u8 *__ptr = (volatile u8 *)(); asm volatile( "cmpxchgb %2,%1" : "=a" (__ret), "+m" (*__ptr) : "q" (__new), "0" (__old) : "memory"); break; } case __X86_CASE_W: { volatile u16 *__ptr = (volatile u16 *)(); asm volatile( "cmpxchgw %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case __X86_CASE_L: { volatile u32 *__ptr = (volatile u32 *)(); asm volatile( "cmpxchgl %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case __X86_CASE_Q: { volatile u64 *__ptr = (volatile u64 *)(); asm volatile( "cmpxchgq %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } default: __cmpxchg_wrong_size(); } __ret; \
})
__cmpxchg(,,,) __raw_cmpxchg((), (), (), (), LOCK_PREFIX)
__sync_cmpxchg(,,,) __raw_cmpxchg((), (), (), (), "lock; ")
__cmpxchg_local(,,,) __raw_cmpxchg((), (), (), (), "")
arch_cmpxchg64(,,) \
({ BUILD_BUG_ON(sizeof(*()) != 8); arch_cmpxchg((), (), ()); \
})
arch_cmpxchg64_local(,,) \
({ BUILD_BUG_ON(sizeof(*()) != 8); arch_cmpxchg_local((), (), ()); \
})
system_has_cmpxchg_double() boot_cpu_has(X86_FEATURE_CX16)
arch_cmpxchg(,,) __cmpxchg(, , , sizeof(*()))
arch_sync_cmpxchg(,,) __sync_cmpxchg(, , , sizeof(*()))
arch_cmpxchg_local(,,) __cmpxchg_local(, , , sizeof(*()))
__raw_try_cmpxchg(,,,,) \
({ bool success; __typeof__() _old = (__typeof__())(); __typeof__(*()) __old = *_old; __typeof__(*()) __new = (); switch () { case __X86_CASE_B: { volatile u8 *__ptr = (volatile u8 *)(); asm volatile( "cmpxchgb %[new], %[ptr]" CC_SET(z) : CC_OUT(z) (success), [ptr] "+m" (*__ptr), [old] "+a" (__old) : [new] "q" (__new) : "memory"); break; } case __X86_CASE_W: { volatile u16 *__ptr = (volatile u16 *)(); asm volatile( "cmpxchgw %[new], %[ptr]" CC_SET(z) : CC_OUT(z) (success), [ptr] "+m" (*__ptr), [old] "+a" (__old) : [new] "r" (__new) : "memory"); break; } case __X86_CASE_L: { volatile u32 *__ptr = (volatile u32 *)(); asm volatile( "cmpxchgl %[new], %[ptr]" CC_SET(z) : CC_OUT(z) (success), [ptr] "+m" (*__ptr), [old] "+a" (__old) : [new] "r" (__new) : "memory"); break; } case __X86_CASE_Q: { volatile u64 *__ptr = (volatile u64 *)(); asm volatile( "cmpxchgq %[new], %[ptr]" CC_SET(z) : CC_OUT(z) (success), [ptr] "+m" (*__ptr), [old] "+a" (__old) : [new] "r" (__new) : "memory"); break; } default: __cmpxchg_wrong_size(); } if (unlikely(!success)) *_old = __old; likely(success); \
})
__try_cmpxchg(,,,) __raw_try_cmpxchg((), (), (), (), LOCK_PREFIX)
try_cmpxchg(,,) __try_cmpxchg((), (), (), sizeof(*()))
__xadd(,,) __xchg_op((), (), xadd, )
xadd(,) __xadd((), (), LOCK_PREFIX)
__cmpxchg_double(,,,,,,) \
({ bool __ret; __typeof__(*()) __old1 = (), __new1 = (); __typeof__(*()) __old2 = (), __new2 = (); BUILD_BUG_ON(sizeof(*()) != sizeof(long)); BUILD_BUG_ON(sizeof(*()) != sizeof(long)); VM_BUG_ON((unsigned long)() % (2 * sizeof(long))); VM_BUG_ON((unsigned long)(() + 1) != (unsigned long)()); asm volatile( "cmpxchg%c5b %1" CC_SET(e) : CC_OUT(e) (__ret), "+m" (*()), "+m" (*()), "+a" (__old1), "+d" (__old2) : "i" (2 * sizeof(long)), "b" (__new1), "c" (__new2)); __ret; \
})
arch_cmpxchg_double(,,,,,) __cmpxchg_double(LOCK_PREFIX, , , , , , )
arch_cmpxchg_double_local(,,,,,) __cmpxchg_double(, , , , , , )
ATOMIC_INIT() { () }
arch_atomic_sub_and_test arch_atomic_sub_and_test
arch_atomic_inc arch_atomic_inc
arch_atomic_dec arch_atomic_dec
arch_atomic_dec_and_test arch_atomic_dec_and_test
arch_atomic_inc_and_test arch_atomic_inc_and_test
arch_atomic_add_negative arch_atomic_add_negative
arch_atomic_try_cmpxchg arch_atomic_try_cmpxchg
ATOMIC64_INIT() { () }
arch_atomic64_sub_and_test arch_atomic64_sub_and_test
arch_atomic64_inc arch_atomic64_inc
arch_atomic64_dec arch_atomic64_dec
arch_atomic64_dec_and_test arch_atomic64_dec_and_test
arch_atomic64_inc_and_test arch_atomic64_inc_and_test
arch_atomic64_add_negative arch_atomic64_add_negative
arch_atomic64_try_cmpxchg arch_atomic64_try_cmpxchg
atomic_read atomic_read
atomic_set atomic_set
atomic_add atomic_add
atomic_add_return atomic_add_return
atomic_fetch_add atomic_fetch_add
atomic_sub atomic_sub
atomic_sub_return atomic_sub_return
atomic_fetch_sub atomic_fetch_sub
atomic_inc atomic_inc
atomic_dec atomic_dec
atomic_and atomic_and
atomic_fetch_and atomic_fetch_and
atomic_or atomic_or
atomic_fetch_or atomic_fetch_or
atomic_xor atomic_xor
atomic_fetch_xor atomic_fetch_xor
atomic_xchg atomic_xchg
atomic_cmpxchg atomic_cmpxchg
atomic_try_cmpxchg atomic_try_cmpxchg
atomic_sub_and_test atomic_sub_and_test
atomic_dec_and_test atomic_dec_and_test
atomic_inc_and_test atomic_inc_and_test
atomic_add_negative atomic_add_negative
atomic64_read atomic64_read
atomic64_set atomic64_set
atomic64_add atomic64_add
atomic64_add_return atomic64_add_return
atomic64_fetch_add atomic64_fetch_add
atomic64_sub atomic64_sub
atomic64_sub_return atomic64_sub_return
atomic64_fetch_sub atomic64_fetch_sub
atomic64_inc atomic64_inc
atomic64_dec atomic64_dec
atomic64_and atomic64_and
atomic64_fetch_and atomic64_fetch_and
atomic64_or atomic64_or
atomic64_fetch_or atomic64_fetch_or
atomic64_xor atomic64_xor
atomic64_fetch_xor atomic64_fetch_xor
atomic64_xchg atomic64_xchg
atomic64_cmpxchg atomic64_cmpxchg
atomic64_try_cmpxchg atomic64_try_cmpxchg
atomic64_sub_and_test atomic64_sub_and_test
atomic64_dec_and_test atomic64_dec_and_test
atomic64_inc_and_test atomic64_inc_and_test
atomic64_add_negative atomic64_add_negative
xchg() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_xchg(__ai_ptr, __VA_ARGS__); \
})
cmpxchg() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_cmpxchg(__ai_ptr, __VA_ARGS__); \
})
cmpxchg64() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_cmpxchg64(__ai_ptr, __VA_ARGS__); \
})
cmpxchg_local() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_cmpxchg_local(__ai_ptr, __VA_ARGS__); \
})
cmpxchg64_local() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_cmpxchg64_local(__ai_ptr, __VA_ARGS__); \
})
sync_cmpxchg() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, sizeof(*__ai_ptr)); arch_sync_cmpxchg(__ai_ptr, __VA_ARGS__); \
})
cmpxchg_double() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, 2 * sizeof(*__ai_ptr)); arch_cmpxchg_double(__ai_ptr, __VA_ARGS__); \
})
cmpxchg_double_local() \
({ typeof() __ai_ptr = (); kasan_check_write(__ai_ptr, 2 * sizeof(*__ai_ptr)); arch_cmpxchg_double_local(__ai_ptr, __VA_ARGS__); \
})
__atomic_acquire_fence smp_mb__after_atomic
__atomic_release_fence smp_mb__before_atomic
__atomic_pre_full_fence smp_mb__before_atomic
__atomic_post_full_fence smp_mb__after_atomic
__atomic_op_acquire(,) \
({ typeof(##_relaxed()) __ret = ##_relaxed(); __atomic_acquire_fence(); __ret; \
})
__atomic_op_release(,) \
({ __atomic_release_fence(); ##_relaxed(); \
})
__atomic_op_fence(,) \
({ typeof(##_relaxed()) __ret; __atomic_pre_full_fence(); __ret = ##_relaxed(); __atomic_post_full_fence(); __ret; \
})
xchg_relaxed xchg
xchg_acquire xchg
xchg_release xchg
cmpxchg_relaxed cmpxchg
cmpxchg_acquire cmpxchg
cmpxchg_release cmpxchg
cmpxchg64_relaxed cmpxchg64
cmpxchg64_acquire cmpxchg64
cmpxchg64_release cmpxchg64
atomic_read_acquire atomic_read_acquire
atomic_set_release atomic_set_release
atomic_add_return_acquire atomic_add_return
atomic_add_return_release atomic_add_return
atomic_add_return_relaxed atomic_add_return
atomic_fetch_add_acquire atomic_fetch_add
atomic_fetch_add_release atomic_fetch_add
atomic_fetch_add_relaxed atomic_fetch_add
atomic_sub_return_acquire atomic_sub_return
atomic_sub_return_release atomic_sub_return
atomic_sub_return_relaxed atomic_sub_return
atomic_fetch_sub_acquire atomic_fetch_sub
atomic_fetch_sub_release atomic_fetch_sub
atomic_fetch_sub_relaxed atomic_fetch_sub
atomic_inc_return atomic_inc_return
atomic_inc_return_acquire atomic_inc_return_acquire
atomic_inc_return_release atomic_inc_return_release
atomic_inc_return_relaxed atomic_inc_return_relaxed
atomic_fetch_inc atomic_fetch_inc
atomic_fetch_inc_acquire atomic_fetch_inc_acquire
atomic_fetch_inc_release atomic_fetch_inc_release
atomic_fetch_inc_relaxed atomic_fetch_inc_relaxed
atomic_dec_return atomic_dec_return
atomic_dec_return_acquire atomic_dec_return_acquire
atomic_dec_return_release atomic_dec_return_release
atomic_dec_return_relaxed atomic_dec_return_relaxed
atomic_fetch_dec atomic_fetch_dec
atomic_fetch_dec_acquire atomic_fetch_dec_acquire
atomic_fetch_dec_release atomic_fetch_dec_release
atomic_fetch_dec_relaxed atomic_fetch_dec_relaxed
atomic_fetch_and_acquire atomic_fetch_and
atomic_fetch_and_release atomic_fetch_and
atomic_fetch_and_relaxed atomic_fetch_and
atomic_andnot atomic_andnot
atomic_fetch_andnot atomic_fetch_andnot
atomic_fetch_andnot_acquire atomic_fetch_andnot_acquire
atomic_fetch_andnot_release atomic_fetch_andnot_release
atomic_fetch_andnot_relaxed atomic_fetch_andnot_relaxed
atomic_fetch_or_acquire atomic_fetch_or
atomic_fetch_or_release atomic_fetch_or
atomic_fetch_or_relaxed atomic_fetch_or
atomic_fetch_xor_acquire atomic_fetch_xor
atomic_fetch_xor_release atomic_fetch_xor
atomic_fetch_xor_relaxed atomic_fetch_xor
atomic_xchg_acquire atomic_xchg
atomic_xchg_release atomic_xchg
atomic_xchg_relaxed atomic_xchg
atomic_cmpxchg_acquire atomic_cmpxchg
atomic_cmpxchg_release atomic_cmpxchg
atomic_cmpxchg_relaxed atomic_cmpxchg
atomic_try_cmpxchg_acquire atomic_try_cmpxchg
atomic_try_cmpxchg_release atomic_try_cmpxchg
atomic_try_cmpxchg_relaxed atomic_try_cmpxchg
atomic_fetch_add_unless atomic_fetch_add_unless
atomic_add_unless atomic_add_unless
atomic_inc_not_zero atomic_inc_not_zero
atomic_inc_unless_negative atomic_inc_unless_negative
atomic_dec_unless_positive atomic_dec_unless_positive
atomic_dec_if_positive atomic_dec_if_positive
atomic_cond_read_acquire(,) smp_cond_load_acquire(&()->counter, ())
atomic_cond_read_relaxed(,) smp_cond_load_relaxed(&()->counter, ())
atomic64_read_acquire atomic64_read_acquire
atomic64_set_release atomic64_set_release
atomic64_add_return_acquire atomic64_add_return
atomic64_add_return_release atomic64_add_return
atomic64_add_return_relaxed atomic64_add_return
atomic64_fetch_add_acquire atomic64_fetch_add
atomic64_fetch_add_release atomic64_fetch_add
atomic64_fetch_add_relaxed atomic64_fetch_add
atomic64_sub_return_acquire atomic64_sub_return
atomic64_sub_return_release atomic64_sub_return
atomic64_sub_return_relaxed atomic64_sub_return
atomic64_fetch_sub_acquire atomic64_fetch_sub
atomic64_fetch_sub_release atomic64_fetch_sub
atomic64_fetch_sub_relaxed atomic64_fetch_sub
atomic64_inc_return atomic64_inc_return
atomic64_inc_return_acquire atomic64_inc_return_acquire
atomic64_inc_return_release atomic64_inc_return_release
atomic64_inc_return_relaxed atomic64_inc_return_relaxed
atomic64_fetch_inc atomic64_fetch_inc
atomic64_fetch_inc_acquire atomic64_fetch_inc_acquire
atomic64_fetch_inc_release atomic64_fetch_inc_release
atomic64_fetch_inc_relaxed atomic64_fetch_inc_relaxed
atomic64_dec_return atomic64_dec_return
atomic64_dec_return_acquire atomic64_dec_return_acquire
atomic64_dec_return_release atomic64_dec_return_release
atomic64_dec_return_relaxed atomic64_dec_return_relaxed
atomic64_fetch_dec atomic64_fetch_dec
atomic64_fetch_dec_acquire atomic64_fetch_dec_acquire
atomic64_fetch_dec_release atomic64_fetch_dec_release
atomic64_fetch_dec_relaxed atomic64_fetch_dec_relaxed
atomic64_fetch_and_acquire atomic64_fetch_and
atomic64_fetch_and_release atomic64_fetch_and
atomic64_fetch_and_relaxed atomic64_fetch_and
atomic64_andnot atomic64_andnot
atomic64_fetch_andnot atomic64_fetch_andnot
atomic64_fetch_andnot_acquire atomic64_fetch_andnot_acquire
atomic64_fetch_andnot_release atomic64_fetch_andnot_release
atomic64_fetch_andnot_relaxed atomic64_fetch_andnot_relaxed
atomic64_fetch_or_acquire atomic64_fetch_or
atomic64_fetch_or_release atomic64_fetch_or
atomic64_fetch_or_relaxed atomic64_fetch_or
atomic64_fetch_xor_acquire atomic64_fetch_xor
atomic64_fetch_xor_release atomic64_fetch_xor
atomic64_fetch_xor_relaxed atomic64_fetch_xor
atomic64_xchg_acquire atomic64_xchg
atomic64_xchg_release atomic64_xchg
atomic64_xchg_relaxed atomic64_xchg
atomic64_cmpxchg_acquire atomic64_cmpxchg
atomic64_cmpxchg_release atomic64_cmpxchg
atomic64_cmpxchg_relaxed atomic64_cmpxchg
atomic64_try_cmpxchg_acquire atomic64_try_cmpxchg
atomic64_try_cmpxchg_release atomic64_try_cmpxchg
atomic64_try_cmpxchg_relaxed atomic64_try_cmpxchg
atomic64_fetch_add_unless atomic64_fetch_add_unless
atomic64_add_unless atomic64_add_unless
atomic64_inc_not_zero atomic64_inc_not_zero
atomic64_inc_unless_negative atomic64_inc_unless_negative
atomic64_dec_unless_positive atomic64_dec_unless_positive
atomic64_dec_if_positive atomic64_dec_if_positive
atomic64_cond_read_acquire(,) smp_cond_load_acquire(&()->counter, ())
atomic64_cond_read_relaxed(,) smp_cond_load_relaxed(&()->counter, ())
ATOMIC_LONG_INIT() ATOMIC64_INIT()
atomic_long_cond_read_acquire atomic64_cond_read_acquire
atomic_long_cond_read_relaxed atomic64_cond_read_relaxed
cpumask_bits() (()->bits)
cpumask_pr_args() nr_cpu_ids, cpumask_bits()
nr_cpumask_bits nr_cpu_ids
cpu_possible_mask ((const struct cpumask *)&__cpu_possible_mask)
cpu_online_mask ((const struct cpumask *)&__cpu_online_mask)
cpu_present_mask ((const struct cpumask *)&__cpu_present_mask)
cpu_active_mask ((const struct cpumask *)&__cpu_active_mask)
num_possible_cpus() cpumask_weight(cpu_possible_mask)
num_present_cpus() cpumask_weight(cpu_present_mask)
num_active_cpus() cpumask_weight(cpu_active_mask)
cpu_online() cpumask_test_cpu((), cpu_online_mask)
cpu_possible() cpumask_test_cpu((), cpu_possible_mask)
cpu_present() cpumask_test_cpu((), cpu_present_mask)
cpu_active() cpumask_test_cpu((), cpu_active_mask)
for_each_cpu(,) for (() = -1; () = cpumask_next((), ()), () < nr_cpu_ids;)
for_each_cpu_not(,) for (() = -1; () = cpumask_next_zero((), ()), () < nr_cpu_ids;)
for_each_cpu_wrap(,,) for (() = cpumask_next_wrap(()-1, (), (), false); () < nr_cpumask_bits; () = cpumask_next_wrap((), (), (), true))
for_each_cpu_and(,,) for (() = -1; () = cpumask_next_and((), (), ()), () < nr_cpu_ids;)
CPU_BITS_NONE \
{ [0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL \
}
CPU_BITS_CPU0 \
{ [0] = 1UL \
}
cpumask_any() cpumask_first()
cpumask_first_and(,) cpumask_next_and(-1, (), ())
cpumask_any_and(,) cpumask_first_and((), ())
cpumask_of() (get_cpu_mask())
this_cpu_cpumask_var_ptr() this_cpu_read()
__cpumask_var_read_mostly __read_mostly
cpu_all_mask to_cpumask(cpu_all_bits)
cpu_none_mask to_cpumask(cpu_bit_bitmap[0])
for_each_possible_cpu() for_each_cpu((), cpu_possible_mask)
for_each_online_cpu() for_each_cpu((), cpu_online_mask)
for_each_present_cpu() for_each_cpu((), cpu_present_mask)
to_cpumask() ((struct cpumask *)(1 ? () : (void *)sizeof(__check_is_bitmap())))
cpu_is_offline() unlikely(!cpu_online())
CPU_BITS_ALL \
{ [0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL, [BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS) \
}
CPU_MASK_ALL \
(cpumask_t) { { [0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL, [BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS) \
} }
CPU_MASK_NONE \
(cpumask_t) { { [0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL \
} }
CPU_MASK_CPU0 \
(cpumask_t) { { [0] = 1UL \
} }
X86_IOC_RDMSR_REGS _IOWR('c', 0xA0, __u32[8])
X86_IOC_WRMSR_REGS _IOWR('c', 0xA1, __u32[8])
DECLARE_ARGS(,,) unsigned long , 
EAX_EDX_VAL(,,) (() | () << 32)
EAX_EDX_RET(,,) "=a" (), "=d" ()
msr_tracepoint_active() static_key_false(&().key)
native_rdmsr(,,) do { u64 __val = __rdmsr(()); (void)(() = (u32)__val); (void)(() = (u32)(__val >> 32)); \
} while (0)
native_wrmsr(,,) __wrmsr(, , )
native_wrmsrl(,) __wrmsr((), (u32)((u64)()), (u32)((u64)() >> 32))
FRAME_BEGIN "push %" _ASM_BP "\n" _ASM_MOV "%" _ASM_SP ", %" _ASM_BP "\n"
FRAME_END "pop %" _ASM_BP "\n"
ENCODE_FRAME_POINTER "lea 1(%rsp), %rbp\n\t"
FRAME_OFFSET __ASM_SEL(4, 8)
get_debugreg(,)  = paravirt_get_debugreg()
get_kernel_rpl() (pv_info.kernel_rpl)
rdmsr(,,) do { u64 _l = paravirt_read_msr();  = (u32)_l;  = _l >> 32; \
} while (0)
wrmsr(,,) do { paravirt_write_msr(, , ); \
} while (0)
rdmsrl(,) do {  = paravirt_read_msr(); \
} while (0)
wrmsr_safe(,,) paravirt_write_msr_safe(, , )
rdmsr_safe(,,) \
({ int _err; u64 _l = paravirt_read_msr_safe(, &_err); (*) = (u32)_l; (*) = _l >> 32; _err; \
})
rdpmc(,,) do { u64 _l = paravirt_read_pmc();  = (u32)_l;  = _l >> 32; \
} while (0)
rdpmcl(,) (() = paravirt_read_pmc())
store_tr() (() = paravirt_store_tr())
__HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION 
__HAVE_ARCH_START_CONTEXT_SWITCH 
__HAVE_ARCH_ENTER_LAZY_MMU_MODE 
PV_SAVE_ALL_CALLER_REGS "push %rcx;" "push %rdx;" "push %rsi;" "push %rdi;" "push %r8;" "push %r9;" "push %r10;" "push %r11;"
PV_RESTORE_ALL_CALLER_REGS "pop %r11;" "pop %r10;" "pop %r9;" "pop %r8;" "pop %rdi;" "pop %rsi;" "pop %rdx;" "pop %rcx;"
PV_SAVE_REGS "pushq %%rdi;"
PV_RESTORE_REGS "popq %%rdi;"
PV_EXTRA_CLOBBERS EXTRA_CLOBBERS, "rcx" , "rdx", "rsi"
PV_VEXTRA_CLOBBERS EXTRA_CLOBBERS, "rdi", "rcx" , "rdx", "rsi"
PV_FLAGS_ARG "D"
PV_THUNK_NAME() "__raw_callee_save_" #
PV_CALLEE_SAVE_REGS_THUNK() extern typeof() __raw_callee_save_##; asm(".pushsection .text;" ".globl " PV_THUNK_NAME() ";" ".type " PV_THUNK_NAME() ", @function;" PV_THUNK_NAME() ":" FRAME_BEGIN PV_SAVE_ALL_CALLER_REGS "call " # ";" PV_RESTORE_ALL_CALLER_REGS FRAME_END "ret;" ".size " PV_THUNK_NAME() ", .-" PV_THUNK_NAME() ";" ".popsection")
PV_CALLEE_SAVE() ((struct paravirt_callee_save) { __raw_callee_save_## })
__PV_IS_CALLEE_SAVE() ((struct paravirt_callee_save) {  })
write_tsc(,) wrmsr(MSR_IA32_TSC, (), ())
write_rdtscp_aux() wrmsr(MSR_TSC_AUX, (), 0)
__FORCE_ORDER "m"(*(unsigned int *)0x1000UL)
nop() asm volatile ("nop")
MXCSR_DEFAULT 0x1f80
MXCSR_AND_FLAGS_SIZE sizeof(u64)
XFEATURE_MASK_FP (1 << XFEATURE_FP)
XFEATURE_MASK_SSE (1 << XFEATURE_SSE)
XFEATURE_MASK_YMM (1 << XFEATURE_YMM)
XFEATURE_MASK_BNDREGS (1 << XFEATURE_BNDREGS)
XFEATURE_MASK_BNDCSR (1 << XFEATURE_BNDCSR)
XFEATURE_MASK_OPMASK (1 << XFEATURE_OPMASK)
XFEATURE_MASK_ZMM_Hi256 (1 << XFEATURE_ZMM_Hi256)
XFEATURE_MASK_Hi16_ZMM (1 << XFEATURE_Hi16_ZMM)
XFEATURE_MASK_PT (1 << XFEATURE_PT_UNIMPLEMENTED_SO_FAR)
XFEATURE_MASK_PKRU (1 << XFEATURE_PKRU)
XFEATURE_MASK_FPSSE (XFEATURE_MASK_FP | XFEATURE_MASK_SSE)
XFEATURE_MASK_AVX512 (XFEATURE_MASK_OPMASK | XFEATURE_MASK_ZMM_Hi256 | XFEATURE_MASK_Hi16_ZMM)
FIRST_EXTENDED_XFEATURE XFEATURE_YMM
XCOMP_BV_COMPACTED_FORMAT ((u64)1 << 63)
PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC | ADDR_NO_RANDOMIZE | ADDR_COMPAT_LAYOUT | MMAP_PAGE_ZERO)
personality() ( & PER_MASK)
set_personality() (current->personality = ())
MAX_ERRNO 4095
IS_ERR_VALUE() unlikely((unsigned long)(void *)() >= (unsigned long)-MAX_ERRNO)
PTR_RET() PTR_ERR_OR_ZERO()
__cpuidle __attribute__((__section__(".cpuidle.text")))
trace_hardirqs_on() do { } while (0)
trace_hardirqs_off() do { } while (0)
trace_hardirq_context() 0
trace_softirq_context() 0
trace_hardirqs_enabled() 0
trace_softirqs_enabled() 0
trace_hardirq_enter() do { } while (0)
trace_hardirq_exit() do { } while (0)
lockdep_softirq_enter() do { } while (0)
lockdep_softirq_exit() do { } while (0)
stop_critical_timings() do { } while (0)
start_critical_timings() do { } while (0)
raw_local_irq_disable() arch_local_irq_disable()
raw_local_irq_enable() arch_local_irq_enable()
raw_local_irq_save() do { typecheck(unsigned long, );  = arch_local_irq_save(); } while (0)
raw_local_irq_restore() do { typecheck(unsigned long, ); arch_local_irq_restore(); } while (0)
raw_local_save_flags() do { typecheck(unsigned long, );  = arch_local_save_flags(); } while (0)
raw_irqs_disabled_flags() ({ typecheck(unsigned long, ); arch_irqs_disabled_flags(); })
raw_irqs_disabled() (arch_irqs_disabled())
raw_safe_halt() arch_safe_halt()
local_irq_enable() do { raw_local_irq_enable(); } while (0)
local_irq_disable() do { raw_local_irq_disable(); } while (0)
local_irq_save() do { raw_local_irq_save(); } while (0)
local_irq_restore() do { raw_local_irq_restore(); } while (0)
safe_halt() do { raw_safe_halt(); } while (0)
local_save_flags() raw_local_save_flags()
irqs_disabled() ({ unsigned long _flags; raw_local_save_flags(_flags); raw_irqs_disabled_flags(_flags); })
irqs_disabled_flags() raw_irqs_disabled_flags()
NET_IP_ALIGN 0
HBP_NUM 4
ARCH_MIN_TASKALIGN __alignof__(union fpregs_state)
ARCH_MIN_MMSTRUCT_ALIGN 0
X86_VENDOR_INTEL 0
X86_VENDOR_CYRIX 1
X86_VENDOR_AMD 2
X86_VENDOR_UMC 3
X86_VENDOR_CENTAUR 5
X86_VENDOR_TRANSMETA 7
X86_VENDOR_NSC 8
X86_VENDOR_HYGON 9
X86_VENDOR_ZHAOXIN 10
X86_VENDOR_NUM 11
X86_VENDOR_UNKNOWN 0xff
cpu_data() per_cpu(cpu_info, )
cache_line_size() (boot_cpu_data.x86_cache_alignment)
native_cpuid_reg() static inline unsigned int native_cpuid_##(unsigned int op) \
{ unsigned int eax = op, ebx, ecx = 0, edx; native_cpuid(&eax, &ebx, &ecx, &edx); return ; \
}
IO_BITMAP_BITS 65536
IO_BITMAP_BYTES (IO_BITMAP_BITS/8)
IO_BITMAP_LONGS (IO_BITMAP_BYTES/sizeof(long))
IO_BITMAP_OFFSET (offsetof(struct tss_struct, io_bitmap) - offsetof(struct tss_struct, x86_tss))
INVALID_IO_BITMAP_OFFSET 0x8000
__KERNEL_TSS_LIMIT (IO_BITMAP_OFFSET + IO_BITMAP_BYTES + sizeof(unsigned long) - 1)
cpu_current_top_of_stack cpu_tss_rw.x86_tss.sp1
HAVE_ARCH_PICK_MMAP_LAYOUT 1
ARCH_HAS_PREFETCHW 
ARCH_HAS_SPINLOCK_PREFETCH 
BASE_PREFETCH "prefetcht0 %P1"
TOP_OF_INIT_STACK ((unsigned long)&init_stack + sizeof(init_stack) - TOP_OF_KERNEL_STACK_PADDING)
task_top_of_stack() ((unsigned long)(task_pt_regs() + 1))
task_pt_regs() \
({ unsigned long __ptr = (unsigned long)task_stack_page(); __ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING; ((struct pt_regs *)__ptr) - 1; \
})
TASK_SIZE_MAX ((1UL << __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)
DEFAULT_MAP_WINDOW ((1UL << 47) - PAGE_SIZE)
IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
TASK_SIZE_LOW (test_thread_flag(TIF_ADDR32) ? IA32_PAGE_OFFSET : DEFAULT_MAP_WINDOW)
TASK_SIZE (test_thread_flag(TIF_ADDR32) ? IA32_PAGE_OFFSET : TASK_SIZE_MAX)
TASK_SIZE_OF() ((test_tsk_thread_flag(, TIF_ADDR32)) ? IA32_PAGE_OFFSET : TASK_SIZE_MAX)
STACK_TOP TASK_SIZE_LOW
STACK_TOP_MAX TASK_SIZE_MAX
INIT_THREAD { .addr_limit = KERNEL_DS, \
}
__TASK_UNMAPPED_BASE() (PAGE_ALIGN( / 3))
TASK_UNMAPPED_BASE __TASK_UNMAPPED_BASE(TASK_SIZE_LOW)
KSTK_EIP() (task_pt_regs()->ip)
GET_TSC_CTL() get_tsc_mode(())
SET_TSC_CTL() set_tsc_mode(())
MPX_ENABLE_MANAGEMENT() mpx_enable_management()
MPX_DISABLE_MANAGEMENT() mpx_disable_management()
X86_CAP_FMT "%s"
x86_cap_flag() x86_cap_flags[]
test_cpu_cap(,) arch_test_bit(, (unsigned long *)(()->x86_capability))
CHECK_BIT_IN_MASK_WORD(,,) ((()>>5)==() && (1UL<<(()&31) & ## ))
REQUIRED_MASK_BIT_SET() ( CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 0, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 1, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 2, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 3, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 4, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 5, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 6, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 7, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 8, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 9, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 10, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 11, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 12, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 13, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 14, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 15, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 16, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 17, ) || CHECK_BIT_IN_MASK_WORD(REQUIRED_MASK, 18, ) || REQUIRED_MASK_CHECK || BUILD_BUG_ON_ZERO(NCAPINTS != 19))
DISABLED_MASK_BIT_SET() ( CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 0, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 1, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 2, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 3, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 4, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 5, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 6, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 7, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 8, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 9, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 10, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 11, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 12, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 13, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 14, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 15, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 16, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 17, ) || CHECK_BIT_IN_MASK_WORD(DISABLED_MASK, 18, ) || DISABLED_MASK_CHECK || BUILD_BUG_ON_ZERO(NCAPINTS != 19))
cpu_has(,) (__builtin_constant_p() && REQUIRED_MASK_BIT_SET() ? 1 : test_cpu_cap(, ))
this_cpu_has() (__builtin_constant_p() && REQUIRED_MASK_BIT_SET() ? 1 : x86_this_cpu_test_bit(, (unsigned long __percpu *)&cpu_info.x86_capability))
cpu_feature_enabled() (__builtin_constant_p() && DISABLED_MASK_BIT_SET() ? 0 : static_cpu_has())
boot_cpu_has() cpu_has(&boot_cpu_data, )
set_cpu_cap(,) set_bit(, (unsigned long *)(()->x86_capability))
setup_force_cpu_cap() do { set_cpu_cap(&boot_cpu_data, ); set_bit(, (unsigned long *)cpu_caps_set); \
} while (0)
setup_force_cpu_bug() setup_force_cpu_cap()
static_cpu_has() \
( __builtin_constant_p(boot_cpu_has()) ? boot_cpu_has() : _static_cpu_has() \
)
cpu_has_bug(,) cpu_has(, ())
set_cpu_bug(,) set_cpu_cap(, ())
clear_cpu_bug(,) clear_cpu_cap(, ())
static_cpu_has_bug() static_cpu_has(())
boot_cpu_has_bug() cpu_has_bug(&boot_cpu_data, ())
boot_cpu_set_bug() set_cpu_cap(&boot_cpu_data, ())
MAX_CPU_FEATURES (NCAPINTS * 32)
cpu_have_feature boot_cpu_has
CPU_FEATURE_TYPEFMT "x86,ven%04Xfam%04Xmod%04X"
CPU_FEATURE_TYPEVAL boot_cpu_data.x86_vendor, boot_cpu_data.x86, boot_cpu_data.x86_model
INIT_THREAD_INFO() \
{ .flags = 0, \
}
TIF_SYSCALL_TRACE 0
TIF_NOTIFY_RESUME 1
TIF_SIGPENDING 2
TIF_NEED_RESCHED 3
TIF_SINGLESTEP 4
TIF_SSBD 5
TIF_SYSCALL_EMU 6
TIF_SYSCALL_AUDIT 7
TIF_SECCOMP 8
TIF_SPEC_IB 9
TIF_SPEC_FORCE_UPDATE 10
TIF_USER_RETURN_NOTIFY 11
TIF_UPROBE 12
TIF_PATCH_PENDING 13
TIF_NEED_FPU_LOAD 14
TIF_NOCPUID 15
TIF_NOTSC 16
TIF_IA32 17
TIF_NOHZ 19
TIF_MEMDIE 20
TIF_POLLING_NRFLAG 21
TIF_IO_BITMAP 22
TIF_FORCED_TF 24
TIF_BLOCKSTEP 25
TIF_LAZY_MMU_UPDATES 27
TIF_SYSCALL_TRACEPOINT 28
TIF_ADDR32 29
TIF_X32 30
TIF_FSCHECK 31
_TIF_SYSCALL_TRACE (1 << TIF_SYSCALL_TRACE)
_TIF_NOTIFY_RESUME (1 << TIF_NOTIFY_RESUME)
_TIF_SIGPENDING (1 << TIF_SIGPENDING)
_TIF_NEED_RESCHED (1 << TIF_NEED_RESCHED)
_TIF_SINGLESTEP (1 << TIF_SINGLESTEP)
_TIF_SSBD (1 << TIF_SSBD)
_TIF_SYSCALL_EMU (1 << TIF_SYSCALL_EMU)
_TIF_SYSCALL_AUDIT (1 << TIF_SYSCALL_AUDIT)
_TIF_SECCOMP (1 << TIF_SECCOMP)
_TIF_SPEC_IB (1 << TIF_SPEC_IB)
_TIF_SPEC_FORCE_UPDATE (1 << TIF_SPEC_FORCE_UPDATE)
_TIF_USER_RETURN_NOTIFY (1 << TIF_USER_RETURN_NOTIFY)
_TIF_UPROBE (1 << TIF_UPROBE)
_TIF_PATCH_PENDING (1 << TIF_PATCH_PENDING)
_TIF_NEED_FPU_LOAD (1 << TIF_NEED_FPU_LOAD)
_TIF_NOCPUID (1 << TIF_NOCPUID)
_TIF_NOTSC (1 << TIF_NOTSC)
_TIF_IA32 (1 << TIF_IA32)
_TIF_NOHZ (1 << TIF_NOHZ)
_TIF_POLLING_NRFLAG (1 << TIF_POLLING_NRFLAG)
_TIF_IO_BITMAP (1 << TIF_IO_BITMAP)
_TIF_FORCED_TF (1 << TIF_FORCED_TF)
_TIF_BLOCKSTEP (1 << TIF_BLOCKSTEP)
_TIF_LAZY_MMU_UPDATES (1 << TIF_LAZY_MMU_UPDATES)
_TIF_SYSCALL_TRACEPOINT (1 << TIF_SYSCALL_TRACEPOINT)
_TIF_ADDR32 (1 << TIF_ADDR32)
_TIF_X32 (1 << TIF_X32)
_TIF_FSCHECK (1 << TIF_FSCHECK)
_TIF_WORK_SYSCALL_ENTRY (_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT | _TIF_SECCOMP | _TIF_SYSCALL_TRACEPOINT | _TIF_NOHZ)
_TIF_WORK_CTXSW_BASE (_TIF_IO_BITMAP|_TIF_NOCPUID|_TIF_NOTSC|_TIF_BLOCKSTEP| _TIF_SSBD | _TIF_SPEC_FORCE_UPDATE)
_TIF_WORK_CTXSW (_TIF_WORK_CTXSW_BASE | _TIF_SPEC_IB)
_TIF_WORK_CTXSW_PREV (_TIF_WORK_CTXSW|_TIF_USER_RETURN_NOTIFY)
_TIF_WORK_CTXSW_NEXT (_TIF_WORK_CTXSW)
STACK_WARN (THREAD_SIZE/8)
TS_COMPAT 0x0002
TS_I386_REGS_POKED 0x0004
TS_COMPAT_RESTART 0x0008
arch_set_restart_data arch_set_restart_data
in_ia32_syscall() (IS_ENABLED(CONFIG_IA32_EMULATION) && current_thread_info()->status & TS_COMPAT)
force_iret() set_thread_flag(TIF_NOTIFY_RESUME)
arch_setup_new_exec arch_setup_new_exec
THREAD_ALIGN THREAD_SIZE
THREADINFO_GFP (GFP_KERNEL_ACCOUNT | __GFP_ZERO)
set_thread_flag() set_ti_thread_flag(current_thread_info(), )
clear_thread_flag() clear_ti_thread_flag(current_thread_info(), )
update_thread_flag(,) update_ti_thread_flag(current_thread_info(), , )
test_and_set_thread_flag() test_and_set_ti_thread_flag(current_thread_info(), )
test_and_clear_thread_flag() test_and_clear_ti_thread_flag(current_thread_info(), )
test_thread_flag() test_ti_thread_flag(current_thread_info(), )
tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)
PREEMPT_NEED_RESCHED 0x80000000
PREEMPT_ENABLED (0 + PREEMPT_NEED_RESCHED)
init_task_preempt_count() do { } while (0)
init_idle_preempt_count(,) do { per_cpu(__preempt_count, ()) = PREEMPT_ENABLED; \
} while (0)
hardirq_count() (preempt_count() & HARDIRQ_MASK)
softirq_count() (preempt_count() & SOFTIRQ_MASK)
irq_count() (preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK | NMI_MASK))
in_irq() (hardirq_count())
in_softirq() (softirq_count())
in_interrupt() (irq_count())
in_serving_softirq() (softirq_count() & SOFTIRQ_OFFSET)
in_nmi() (preempt_count() & NMI_MASK)
in_task() (!(preempt_count() & (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))
PREEMPT_DISABLE_OFFSET 0
PREEMPT_LOCK_OFFSET PREEMPT_DISABLE_OFFSET
SOFTIRQ_LOCK_OFFSET (SOFTIRQ_DISABLE_OFFSET + PREEMPT_LOCK_OFFSET)
in_atomic() (preempt_count() != 0)
in_atomic_preempt_off() (preempt_count() != PREEMPT_DISABLE_OFFSET)
preempt_count_add() __preempt_count_add()
preempt_count_sub() __preempt_count_sub()
preempt_count_dec_and_test() __preempt_count_dec_and_test()
__preempt_count_inc() __preempt_count_add(1)
__preempt_count_dec() __preempt_count_sub(1)
preempt_count_inc() preempt_count_add(1)
preempt_count_dec() preempt_count_sub(1)
preempt_disable() barrier()
sched_preempt_enable_no_resched() barrier()
preempt_enable_no_resched() barrier()
preempt_enable() barrier()
preempt_check_resched() do { } while (0)
preempt_disable_notrace() barrier()
preempt_enable_no_resched_notrace() barrier()
preempt_enable_notrace() barrier()
preemptible() 0
preempt_set_need_resched() do { set_preempt_need_resched(); \
} while (0)
preempt_fold_need_resched() do { if (tif_need_resched()) set_preempt_need_resched(); \
} while (0)
mmiowb_set_pending() do { } while (0)
mmiowb_spin_lock() do { } while (0)
mmiowb_spin_unlock() do { } while (0)
LOCK_SECTION_NAME ".text..lock."KBUILD_BASENAME
LOCK_SECTION_START() ".subsection 1\n\t"  ".ifndef " LOCK_SECTION_NAME "\n\t" LOCK_SECTION_NAME ":\n\t" ".endif\n"
LOCK_SECTION_END ".previous\n\t"
__lockfunc __attribute__((section(".spinlock.text")))
MAX_LOCKDEP_SUBCLASSES 8UL
lock_acquire(,,,,,,) do { } while (0)
lock_release(,,) do { } while (0)
lock_downgrade(,) do { } while (0)
lock_set_class(,,,,) do { } while (0)
lock_set_subclass(,,) do { } while (0)
lockdep_init() do { } while (0)
lockdep_init_map(,,,) do { (void)(); (void)(); } while (0)
lockdep_set_class(,) do { (void)(); } while (0)
lockdep_set_class_and_name(,,) do { (void)(); (void)(); } while (0)
lockdep_set_class_and_subclass(,,) do { (void)(); } while (0)
lockdep_set_subclass(,) do { } while (0)
lockdep_set_novalidate_class() do { } while (0)
lockdep_reset() do { debug_locks = 1; } while (0)
lockdep_free_key_range(,) do { } while (0)
lockdep_sys_exit() do { } while (0)
lockdep_depth() (0)
lockdep_is_held() (1)
lockdep_is_held_type(,) (1)
lockdep_assert_held() do { (void)(); } while (0)
lockdep_assert_held_write() do { (void)(); } while (0)
lockdep_assert_held_read() do { (void)(); } while (0)
lockdep_assert_held_once() do { (void)(); } while (0)
lockdep_recursing() (0)
NIL_COOKIE (struct pin_cookie){ }
lockdep_pin_lock() ({ struct pin_cookie cookie = { }; cookie; })
lockdep_repin_lock(,) do { (void)(); (void)(); } while (0)
lockdep_unpin_lock(,) do { (void)(); (void)(); } while (0)
lockdep_init_map_crosslock(,,,) do {} while (0)
STATIC_LOCKDEP_MAP_INIT(,) { .name = (), .key = (void *)(), }
lock_contended(,) do {} while (0)
lock_acquired(,) do {} while (0)
LOCK_CONTENDED(,,) ()
LOCK_CONTENDED_RETURN(,,) ()
LOCK_CONTENDED_FLAGS(,,,,) ((), ())
SINGLE_DEPTH_NESTING 1
lock_acquire_exclusive(,,,,) lock_acquire(, , , 0, 1, , )
lock_acquire_shared(,,,,) lock_acquire(, , , 1, 1, , )
lock_acquire_shared_recursive(,,,,) lock_acquire(, , , 2, 1, , )
spin_acquire(,,,) lock_acquire_exclusive(, , , NULL, )
spin_acquire_nest(,,,,) lock_acquire_exclusive(, , , , )
spin_release(,,) lock_release(, , )
rwlock_acquire(,,,) lock_acquire_exclusive(, , , NULL, )
rwlock_acquire_read(,,,) lock_acquire_shared_recursive(, , , NULL, )
rwlock_release(,,) lock_release(, , )
seqcount_acquire(,,,) lock_acquire_exclusive(, , , NULL, )
seqcount_acquire_read(,,,) lock_acquire_shared_recursive(, , , NULL, )
seqcount_release(,,) lock_release(, , )
mutex_acquire(,,,) lock_acquire_exclusive(, , , NULL, )
mutex_acquire_nest(,,,,) lock_acquire_exclusive(, , , , )
mutex_release(,,) lock_release(, , )
rwsem_acquire(,,,) lock_acquire_exclusive(, , , NULL, )
rwsem_acquire_nest(,,,,) lock_acquire_exclusive(, , , , )
rwsem_acquire_read(,,,) lock_acquire_shared(, , , NULL, )
rwsem_release(,,) lock_release(, , )
lock_map_acquire() lock_acquire_exclusive(, 0, 0, NULL, _THIS_IP_)
lock_map_acquire_read() lock_acquire_shared_recursive(, 0, 0, NULL, _THIS_IP_)
lock_map_acquire_tryread() lock_acquire_shared_recursive(, 0, 1, NULL, _THIS_IP_)
lock_map_release() lock_release(, 1, _THIS_IP_)
might_lock() do { } while (0)
might_lock_read() do { } while (0)
lockdep_assert_irqs_enabled() do { } while (0)
lockdep_assert_irqs_disabled() do { } while (0)
lockdep_assert_in_irq() do { } while (0)
SPINLOCK_MAGIC 0xdead4ead
SPINLOCK_OWNER_INIT ((void *)-1L)
SPIN_DEP_MAP_INIT() 
SPIN_DEBUG_INIT() 
__RAW_SPIN_LOCK_INITIALIZER() { .raw_lock = __ARCH_SPIN_LOCK_UNLOCKED, SPIN_DEBUG_INIT() SPIN_DEP_MAP_INIT() }
__RAW_SPIN_LOCK_UNLOCKED() (raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER()
DEFINE_RAW_SPINLOCK() raw_spinlock_t  = __RAW_SPIN_LOCK_UNLOCKED()
__SPIN_LOCK_INITIALIZER() { { .rlock = __RAW_SPIN_LOCK_INITIALIZER() } }
__SPIN_LOCK_UNLOCKED() (spinlock_t ) __SPIN_LOCK_INITIALIZER()
DEFINE_SPINLOCK() spinlock_t  = __SPIN_LOCK_UNLOCKED()
RWLOCK_MAGIC 0xdeaf1eed
RW_DEP_MAP_INIT() 
__RW_LOCK_UNLOCKED() (rwlock_t) { .raw_lock = __ARCH_RW_LOCK_UNLOCKED, RW_DEP_MAP_INIT() }
DEFINE_RWLOCK() rwlock_t  = __RW_LOCK_UNLOCKED()
SPIN_THRESHOLD (1 << 15)
_Q_PENDING_LOOPS (1 << 9)
queued_fetch_set_pending_acquire queued_fetch_set_pending_acquire
queued_spin_unlock queued_spin_unlock
vcpu_is_preempted vcpu_is_preempted
virt_spin_lock virt_spin_lock
arch_spin_is_locked() queued_spin_is_locked()
arch_spin_is_contended() queued_spin_is_contended()
arch_spin_value_unlocked() queued_spin_value_unlocked()
arch_spin_lock() queued_spin_lock()
arch_spin_trylock() queued_spin_trylock()
arch_spin_unlock() queued_spin_unlock()
_QW_WAITING 0x100
_QW_LOCKED 0x0ff
_QW_WMASK 0x1ff
_QR_SHIFT 9
_QR_BIAS (1U << _QR_SHIFT)
arch_read_lock() queued_read_lock()
arch_write_lock() queued_write_lock()
arch_read_trylock() queued_read_trylock()
arch_write_trylock() queued_write_trylock()
arch_read_unlock() queued_read_unlock()
arch_write_unlock() queued_write_unlock()
raw_spin_lock_init() do { *() = __RAW_SPIN_LOCK_UNLOCKED(); } while (0)
raw_spin_is_locked() arch_spin_is_locked(&()->raw_lock)
raw_spin_is_contended() arch_spin_is_contended(&()->raw_lock)
smp_mb__after_spinlock() do { } while (0)
arch_spin_lock_flags(,) arch_spin_lock()
raw_spin_trylock() __cond_lock(, _raw_spin_trylock())
raw_spin_lock() _raw_spin_lock()
raw_spin_lock_nested(,) _raw_spin_lock(((void)(), ()))
raw_spin_lock_nest_lock(,) _raw_spin_lock()
raw_spin_lock_irqsave(,) do { typecheck(unsigned long, );  = _raw_spin_lock_irqsave(); } while (0)
raw_spin_lock_irqsave_nested(,,) do { typecheck(unsigned long, );  = _raw_spin_lock_irqsave(); } while (0)
raw_spin_lock_irq() _raw_spin_lock_irq()
raw_spin_lock_bh() _raw_spin_lock_bh()
raw_spin_unlock() _raw_spin_unlock()
raw_spin_unlock_irq() _raw_spin_unlock_irq()
raw_spin_unlock_irqrestore(,) do { typecheck(unsigned long, ); _raw_spin_unlock_irqrestore(, ); } while (0)
raw_spin_unlock_bh() _raw_spin_unlock_bh()
raw_spin_trylock_bh() __cond_lock(, _raw_spin_trylock_bh())
raw_spin_trylock_irq() \
({ local_irq_disable(); raw_spin_trylock() ? 1 : ({ local_irq_enable(); 0; }); \
})
raw_spin_trylock_irqsave(,) \
({ local_irq_save(); raw_spin_trylock() ? 1 : ({ local_irq_restore(); 0; }); \
})
rwlock_init() do { *() = __RW_LOCK_UNLOCKED(); } while (0)
arch_read_lock_flags(,) arch_read_lock()
arch_write_lock_flags(,) arch_write_lock()
do_raw_read_lock() do {__acquire(lock); arch_read_lock(&()->raw_lock); } while (0)
do_raw_read_lock_flags(,) do {__acquire(); arch_read_lock_flags(&()->raw_lock, *()); } while (0)
do_raw_read_trylock() arch_read_trylock(&()->raw_lock)
do_raw_read_unlock() do {arch_read_unlock(&()->raw_lock); __release(lock); } while (0)
do_raw_write_lock() do {__acquire(lock); arch_write_lock(&()->raw_lock); } while (0)
do_raw_write_lock_flags(,) do {__acquire(); arch_write_lock_flags(&()->raw_lock, *()); } while (0)
do_raw_write_trylock() arch_write_trylock(&()->raw_lock)
do_raw_write_unlock() do {arch_write_unlock(&()->raw_lock); __release(lock); } while (0)
read_trylock() __cond_lock(, _raw_read_trylock())
write_trylock() __cond_lock(, _raw_write_trylock())
write_lock() _raw_write_lock()
read_lock() _raw_read_lock()
read_lock_irqsave(,) do { typecheck(unsigned long, );  = _raw_read_lock_irqsave(); } while (0)
write_lock_irqsave(,) do { typecheck(unsigned long, );  = _raw_write_lock_irqsave(); } while (0)
read_lock_irq() _raw_read_lock_irq()
read_lock_bh() _raw_read_lock_bh()
write_lock_irq() _raw_write_lock_irq()
write_lock_bh() _raw_write_lock_bh()
read_unlock() _raw_read_unlock()
write_unlock() _raw_write_unlock()
read_unlock_irq() _raw_read_unlock_irq()
write_unlock_irq() _raw_write_unlock_irq()
read_unlock_irqrestore(,) do { typecheck(unsigned long, ); _raw_read_unlock_irqrestore(, ); } while (0)
read_unlock_bh() _raw_read_unlock_bh()
write_unlock_irqrestore(,) do { typecheck(unsigned long, ); _raw_write_unlock_irqrestore(, ); } while (0)
write_unlock_bh() _raw_write_unlock_bh()
write_trylock_irqsave(,) \
({ local_irq_save(); write_trylock() ? 1 : ({ local_irq_restore(); 0; }); \
})
assert_raw_spin_locked() BUG_ON(!raw_spin_is_locked())
_raw_spin_unlock() __raw_spin_unlock()
_raw_spin_unlock_irq() __raw_spin_unlock_irq()
_raw_read_unlock() __raw_read_unlock()
_raw_write_unlock() __raw_write_unlock()
_raw_read_unlock_irq() __raw_read_unlock_irq()
_raw_write_unlock_irq() __raw_write_unlock_irq()
spin_lock_init() do { spinlock_check(); raw_spin_lock_init(&()->rlock); \
} while (0)
spin_lock_nested(,) do { raw_spin_lock_nested(spinlock_check(), ); \
} while (0)
spin_lock_nest_lock(,) do { raw_spin_lock_nest_lock(spinlock_check(), ); \
} while (0)
spin_lock_irqsave(,) do { raw_spin_lock_irqsave(spinlock_check(), ); \
} while (0)
spin_lock_irqsave_nested(,,) do { raw_spin_lock_irqsave_nested(spinlock_check(), , ); \
} while (0)
spin_trylock_irqsave(,) \
({ raw_spin_trylock_irqsave(spinlock_check(), ); \
})
assert_spin_locked() assert_raw_spin_locked(&()->rlock)
atomic_dec_and_lock(,) __cond_lock(, _atomic_dec_and_lock(, ))
atomic_dec_and_lock_irqsave(,,) __cond_lock(, _atomic_dec_and_lock_irqsave(, , &()))
alloc_bucket_spinlocks(,,,,) ({ static struct lock_class_key key; int ret; ret = __alloc_bucket_spinlocks(, , , , , #, &key); ret; })
SEQCOUNT_DEP_MAP_INIT() 
seqcount_init() __seqcount_init(, NULL, NULL)
seqcount_lockdep_reader_access() 
SEQCNT_ZERO() { .sequence = 0, SEQCOUNT_DEP_MAP_INIT()}
__SEQLOCK_UNLOCKED() { .seqcount = SEQCNT_ZERO(), .lock = __SPIN_LOCK_UNLOCKED() }
seqlock_init() do { seqcount_init(&()->seqcount); spin_lock_init(&()->lock); } while (0)
DEFINE_SEQLOCK() seqlock_t  = __SEQLOCK_UNLOCKED()
write_seqlock_irqsave(,) do {  = __write_seqlock_irqsave(); } while (0)
read_seqlock_excl_irqsave(,) do {  = __read_seqlock_excl_irqsave(); } while (0)
NTP_API 4
ADJ_OFFSET 0x0001
ADJ_FREQUENCY 0x0002
ADJ_MAXERROR 0x0004
ADJ_ESTERROR 0x0008
ADJ_STATUS 0x0010
ADJ_TIMECONST 0x0020
ADJ_TAI 0x0080
ADJ_SETOFFSET 0x0100
ADJ_MICRO 0x1000
ADJ_NANO 0x2000
ADJ_TICK 0x4000
MOD_OFFSET ADJ_OFFSET
MOD_FREQUENCY ADJ_FREQUENCY
MOD_MAXERROR ADJ_MAXERROR
MOD_ESTERROR ADJ_ESTERROR
MOD_STATUS ADJ_STATUS
MOD_TIMECONST ADJ_TIMECONST
MOD_TAI ADJ_TAI
MOD_MICRO ADJ_MICRO
MOD_NANO ADJ_NANO
STA_PLL 0x0001
STA_PPSFREQ 0x0002
STA_PPSTIME 0x0004
STA_FLL 0x0008
STA_INS 0x0010
STA_DEL 0x0020
STA_UNSYNC 0x0040
STA_FREQHOLD 0x0080
STA_PPSSIGNAL 0x0100
STA_PPSJITTER 0x0200
STA_PPSWANDER 0x0400
STA_PPSERROR 0x0800
STA_CLOCKERR 0x1000
STA_NANO 0x2000
STA_MODE 0x4000
STA_CLK 0x8000
STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
TIME_OK 0
TIME_INS 1
TIME_DEL 2
TIME_OOP 3
TIME_WAIT 4
TIME_ERROR 5
TIME_BAD TIME_ERROR
ADJ_ADJTIME 0x8000
ADJ_OFFSET_SINGLESHOT 0x0001
ADJ_OFFSET_READONLY 0x2000
HZ 100
EXEC_PAGESIZE 4096
NOGROUP (-1)
MAXHOSTNAMELEN 64
HZ CONFIG_HZ
USER_HZ 100
CLOCKS_PER_SEC (USER_HZ)
NS_SCALE 10
US_SCALE 32
get_cycles get_cycles
random_get_entropy random_get_entropy
CLOCK_TICK_RATE PIT_TICK_RATE
ARCH_HAS_READ_CURRENT_TIMER 
SHIFT_PLL 2
SHIFT_FLL 2
MAXTC 10
SHIFT_USEC 16
PPM_SCALE ((s64)NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
PPM_SCALE_INV_SHIFT 19
PPM_SCALE_INV ((1LL << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / PPM_SCALE + 1)
MAXPHASE 500000000L
MAXFREQ 500000
MAXFREQ_SCALED ((s64)MAXFREQ << NTP_SCALE_SHIFT)
MINSEC 256
MAXSEC 2048
NTP_PHASE_LIMIT ((MAXPHASE / NSEC_PER_USEC) << 5)
shift_right(,) ({ __typeof__() __x = (); __typeof__() __s = (); __x < 0 ? -(-__x >> __s) : __x >> __s; \
})
NTP_SCALE_SHIFT 32
NTP_INTERVAL_FREQ (HZ)
NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
PIT_TICK_RATE 1193182ul
TIME_T_MAX (time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
compat_time_t old_time32_t
compat_timeval old_timeval32
compat_timespec old_timespec32
compat_itimerspec old_itimerspec32
ns_to_compat_timeval ns_to_old_timeval32
get_compat_itimerspec64 get_old_itimerspec32
put_compat_itimerspec64 put_old_itimerspec32
compat_get_timespec64 get_old_timespec32
compat_put_timespec64 put_old_timespec32
time_after32(,) ((s32)((u32)() - (u32)()) < 0)
time_before32(,) time_after32(, )
time_between32(,,) ((u32)() - (u32)() >= (u32)() - (u32)())
DEFAULT_OVERFLOWUID 65534
DEFAULT_OVERFLOWGID 65534
high2lowuid() (() & ~0xFFFF ? (old_uid_t)overflowuid : (old_uid_t)())
high2lowgid() (() & ~0xFFFF ? (old_gid_t)overflowgid : (old_gid_t)())
low2highuid() (() == (old_uid_t)-1 ? (uid_t)-1 : (uid_t)())
low2highgid() (() == (old_gid_t)-1 ? (gid_t)-1 : (gid_t)())
__convert_uid(,) ( >= sizeof() ? () : high2lowuid())
__convert_gid(,) ( >= sizeof() ? () : high2lowgid())
SET_UID(,) do { () = __convert_uid(sizeof(), ()); } while (0)
SET_GID(,) do { () = __convert_gid(sizeof(), ()); } while (0)
DEFAULT_FS_OVERFLOWUID 65534
DEFAULT_FS_OVERFLOWGID 65534
fs_high2lowuid() (() & ~0xFFFF ? (uid16_t)fs_overflowuid : (uid16_t)())
fs_high2lowgid() (() & ~0xFFFF ? (gid16_t)fs_overflowgid : (gid16_t)())
low_16_bits() (() & 0xFFFF)
high_16_bits() ((() & 0xFFFF0000) >> 16)
KUIDT_INIT() (kuid_t){  }
KGIDT_INIT() (kgid_t){  }
GLOBAL_ROOT_UID KUIDT_INIT(0)
GLOBAL_ROOT_GID KGIDT_INIT(0)
INVALID_UID KUIDT_INIT(-1)
INVALID_GID KGIDT_INIT(-1)
KSTAT_QUERY_FLAGS (AT_STATX_SYNC_TYPE)
KSTAT_ATTR_FS_IOC_FLAGS (STATX_ATTR_COMPRESSED | STATX_ATTR_IMMUTABLE | STATX_ATTR_APPEND | STATX_ATTR_NODUMP | STATX_ATTR_ENCRYPTED )
VM_BUG_ON() BUILD_BUG_ON_INVALID()
VM_BUG_ON_PAGE(,) VM_BUG_ON()
VM_BUG_ON_VMA(,) VM_BUG_ON()
VM_BUG_ON_MM(,) VM_BUG_ON()
VM_WARN_ON() BUILD_BUG_ON_INVALID()
VM_WARN_ON_ONCE() BUILD_BUG_ON_INVALID()
VM_WARN_ON_ONCE_PAGE(,) BUILD_BUG_ON_INVALID()
VM_WARN_ONCE(,) BUILD_BUG_ON_INVALID()
VM_WARN(,) BUILD_BUG_ON_INVALID()
VIRTUAL_BUG_ON() do { } while (0)
VM_BUG_ON_PGFLAGS(,) BUILD_BUG_ON_INVALID()
WNOHANG 0x00000001
WUNTRACED 0x00000002
WSTOPPED WUNTRACED
WEXITED 0x00000004
WCONTINUED 0x00000008
WNOWAIT 0x01000000
__WNOTHREAD 0x20000000
__WALL 0x40000000
__WCLONE 0x80000000
P_ALL 0
P_PID 1
P_PGID 2
P_PIDFD 3
WQ_FLAG_EXCLUSIVE 0x01
WQ_FLAG_WOKEN 0x02
WQ_FLAG_BOOKMARK 0x04
__WAITQUEUE_INITIALIZER(,) { .private = , .func = default_wake_function, .entry = { NULL, NULL } }
DECLARE_WAITQUEUE(,) struct wait_queue_entry  = __WAITQUEUE_INITIALIZER(, )
__WAIT_QUEUE_HEAD_INITIALIZER() { .lock = __SPIN_LOCK_UNLOCKED(.lock), .head = { &().head, &().head } }
DECLARE_WAIT_QUEUE_HEAD() struct wait_queue_head  = __WAIT_QUEUE_HEAD_INITIALIZER()
init_waitqueue_head() do { static struct lock_class_key __key; __init_waitqueue_head((), #, &__key); } while (0)
DECLARE_WAIT_QUEUE_HEAD_ONSTACK() DECLARE_WAIT_QUEUE_HEAD()
wake_up() __wake_up(, TASK_NORMAL, 1, NULL)
wake_up_nr(,) __wake_up(, TASK_NORMAL, , NULL)
wake_up_all() __wake_up(, TASK_NORMAL, 0, NULL)
wake_up_locked() __wake_up_locked((), TASK_NORMAL, 1)
wake_up_all_locked() __wake_up_locked((), TASK_NORMAL, 0)
wake_up_interruptible() __wake_up(, TASK_INTERRUPTIBLE, 1, NULL)
wake_up_interruptible_nr(,) __wake_up(, TASK_INTERRUPTIBLE, , NULL)
wake_up_interruptible_all() __wake_up(, TASK_INTERRUPTIBLE, 0, NULL)
wake_up_interruptible_sync() __wake_up_sync((), TASK_INTERRUPTIBLE, 1)
poll_to_key() ((void *)(__force uintptr_t)(__poll_t)())
key_to_poll() ((__force __poll_t)(uintptr_t)(void *)())
wake_up_poll(,) __wake_up(, TASK_NORMAL, 1, poll_to_key())
wake_up_locked_poll(,) __wake_up_locked_key((), TASK_NORMAL, poll_to_key())
wake_up_interruptible_poll(,) __wake_up(, TASK_INTERRUPTIBLE, 1, poll_to_key())
wake_up_interruptible_sync_poll(,) __wake_up_sync_key((), TASK_INTERRUPTIBLE, 1, poll_to_key())
___wait_cond_timeout() \
({ bool __cond = (); if (__cond && !__ret) __ret = 1; __cond || !__ret; \
})
___wait_is_interruptible() (!__builtin_constant_p() ||  == TASK_INTERRUPTIBLE ||  == TASK_KILLABLE)
___wait_event(,,,,,) \
({ __label__ __out; struct wait_queue_entry __wq_entry; long __ret = ; /* explicit shadow */ init_wait_entry(&__wq_entry,  ? WQ_FLAG_EXCLUSIVE : 0); for (;;) { long __int = prepare_to_wait_event(&, &__wq_entry, ); if () break; if (___wait_is_interruptible() && __int) { __ret = __int; goto __out; } ; } finish_wait(&, &__wq_entry); __out: __ret; \
})
__wait_event(,) (void)___wait_event(, , TASK_UNINTERRUPTIBLE, 0, 0, schedule())
wait_event(,) do { might_sleep(); if () break; __wait_event(, ); \
} while (0)
__io_wait_event(,) (void)___wait_event(, , TASK_UNINTERRUPTIBLE, 0, 0, io_schedule())
io_wait_event(,) do { might_sleep(); if () break; __io_wait_event(, ); \
} while (0)
__wait_event_freezable(,) ___wait_event(, , TASK_INTERRUPTIBLE, 0, 0, freezable_schedule())
wait_event_freezable(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_freezable(, ); __ret; \
})
__wait_event_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_UNINTERRUPTIBLE, 0, , __ret = schedule_timeout(__ret))
wait_event_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_timeout(, , ); __ret; \
})
__wait_event_freezable_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_INTERRUPTIBLE, 0, , __ret = freezable_schedule_timeout(__ret))
wait_event_freezable_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_freezable_timeout(, , ); __ret; \
})
__wait_event_exclusive_cmd(,,,) (void)___wait_event(, , TASK_UNINTERRUPTIBLE, 1, 0, ; schedule(); )
wait_event_exclusive_cmd(,,,) do { if () break; __wait_event_exclusive_cmd(, , , ); \
} while (0)
__wait_event_cmd(,,,) (void)___wait_event(, , TASK_UNINTERRUPTIBLE, 0, 0, ; schedule(); )
wait_event_cmd(,,,) do { if () break; __wait_event_cmd(, , , ); \
} while (0)
__wait_event_interruptible(,) ___wait_event(, , TASK_INTERRUPTIBLE, 0, 0, schedule())
wait_event_interruptible(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_interruptible(, ); __ret; \
})
__wait_event_interruptible_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_INTERRUPTIBLE, 0, , __ret = schedule_timeout(__ret))
wait_event_interruptible_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_interruptible_timeout(, , ); __ret; \
})
__wait_event_hrtimeout(,,,) \
({ int __ret = 0; struct hrtimer_sleeper __t; hrtimer_init_sleeper_on_stack(&__t, CLOCK_MONOTONIC, HRTIMER_MODE_REL); if (() != KTIME_MAX) { hrtimer_set_expires_range_ns(&__t.timer, , current->timer_slack_ns); hrtimer_sleeper_start_expires(&__t, HRTIMER_MODE_REL); } __ret = ___wait_event(, , , 0, 0, if (!__t.task) { __ret = -ETIME; break; } schedule()); hrtimer_cancel(&__t.timer); destroy_hrtimer_on_stack(&__t.timer); __ret; \
})
wait_event_hrtimeout(,,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_hrtimeout(, , , TASK_UNINTERRUPTIBLE); __ret; \
})
wait_event_interruptible_hrtimeout(,,) \
({ long __ret = 0; might_sleep(); if (!()) __ret = __wait_event_hrtimeout(, , , TASK_INTERRUPTIBLE); __ret; \
})
__wait_event_interruptible_exclusive(,) ___wait_event(, , TASK_INTERRUPTIBLE, 1, 0, schedule())
wait_event_interruptible_exclusive(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_interruptible_exclusive(, ); __ret; \
})
__wait_event_killable_exclusive(,) ___wait_event(, , TASK_KILLABLE, 1, 0, schedule())
wait_event_killable_exclusive(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_killable_exclusive(, ); __ret; \
})
__wait_event_freezable_exclusive(,) ___wait_event(, , TASK_INTERRUPTIBLE, 1, 0, freezable_schedule())
wait_event_freezable_exclusive(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_freezable_exclusive(, ); __ret; \
})
wait_event_idle(,) do { might_sleep(); if (!()) ___wait_event(, , TASK_IDLE, 0, 0, schedule()); \
} while (0)
wait_event_idle_exclusive(,) do { might_sleep(); if (!()) ___wait_event(, , TASK_IDLE, 1, 0, schedule()); \
} while (0)
__wait_event_idle_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_IDLE, 0, , __ret = schedule_timeout(__ret))
wait_event_idle_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_idle_timeout(, , ); __ret; \
})
__wait_event_idle_exclusive_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_IDLE, 1, , __ret = schedule_timeout(__ret))
wait_event_idle_exclusive_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_idle_exclusive_timeout(, , ); __ret; \
})
__wait_event_interruptible_locked(,,,) \
({ int __ret; DEFINE_WAIT(__wait); if () __wait.flags |= WQ_FLAG_EXCLUSIVE; do { __ret = (&(), &__wait); if (__ret) break; } while (!()); __remove_wait_queue(&(), &__wait); __set_current_state(TASK_RUNNING); __ret; \
})
wait_event_interruptible_locked(,) (() ? 0 : __wait_event_interruptible_locked(, , 0, do_wait_intr))
wait_event_interruptible_locked_irq(,) (() ? 0 : __wait_event_interruptible_locked(, , 0, do_wait_intr_irq))
wait_event_interruptible_exclusive_locked(,) (() ? 0 : __wait_event_interruptible_locked(, , 1, do_wait_intr))
wait_event_interruptible_exclusive_locked_irq(,) (() ? 0 : __wait_event_interruptible_locked(, , 1, do_wait_intr_irq))
__wait_event_killable(,) ___wait_event(, , TASK_KILLABLE, 0, 0, schedule())
wait_event_killable(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_event_killable(, ); __ret; \
})
__wait_event_killable_timeout(,,) ___wait_event(, ___wait_cond_timeout(), TASK_KILLABLE, 0, , __ret = schedule_timeout(__ret))
wait_event_killable_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_event_killable_timeout(, , ); __ret; \
})
__wait_event_lock_irq(,,,) (void)___wait_event(, , TASK_UNINTERRUPTIBLE, 0, 0, spin_unlock_irq(&); ; schedule(); spin_lock_irq(&))
wait_event_lock_irq_cmd(,,,) do { if () break; __wait_event_lock_irq(, , , ); \
} while (0)
wait_event_lock_irq(,,) do { if () break; __wait_event_lock_irq(, , , ); \
} while (0)
__wait_event_interruptible_lock_irq(,,,) ___wait_event(, , TASK_INTERRUPTIBLE, 0, 0, spin_unlock_irq(&); ; schedule(); spin_lock_irq(&))
wait_event_interruptible_lock_irq_cmd(,,,) \
({ int __ret = 0; if (!()) __ret = __wait_event_interruptible_lock_irq(, , , ); __ret; \
})
wait_event_interruptible_lock_irq(,,) \
({ int __ret = 0; if (!()) __ret = __wait_event_interruptible_lock_irq(, , ,); __ret; \
})
__wait_event_lock_irq_timeout(,,,,) ___wait_event(, ___wait_cond_timeout(), , 0, , spin_unlock_irq(&); __ret = schedule_timeout(__ret); spin_lock_irq(&));
wait_event_interruptible_lock_irq_timeout(,,,) \
({ long __ret = ; if (!___wait_cond_timeout()) __ret = __wait_event_lock_irq_timeout( , , , , TASK_INTERRUPTIBLE); __ret; \
})
wait_event_lock_irq_timeout(,,,) \
({ long __ret = ; if (!___wait_cond_timeout()) __ret = __wait_event_lock_irq_timeout( , , , , TASK_UNINTERRUPTIBLE); __ret; \
})
DEFINE_WAIT_FUNC(,) struct wait_queue_entry  = { .private = current, .func = , .entry = LIST_HEAD_INIT(().entry), }
DEFINE_WAIT() DEFINE_WAIT_FUNC(, autoremove_wake_function)
init_wait() do { ()->private = current; ()->func = autoremove_wake_function; INIT_LIST_HEAD(&()->entry); ()->flags = 0; } while (0)
NODES_SHIFT CONFIG_NODES_SHIFT
MAX_NUMNODES (1 << NODES_SHIFT)
NUMA_NO_NODE (-1)
nodemask_pr_args() __nodemask_pr_numnodes(), __nodemask_pr_bits()
node_set(,) __node_set((), &())
node_clear(,) __node_clear((), &())
nodes_setall() __nodes_setall(&(), MAX_NUMNODES)
nodes_clear() __nodes_clear(&(), MAX_NUMNODES)
node_isset(,) test_bit((), ().bits)
node_test_and_set(,) __node_test_and_set((), &())
nodes_and(,,) __nodes_and(&(), &(), &(), MAX_NUMNODES)
nodes_or(,,) __nodes_or(&(), &(), &(), MAX_NUMNODES)
nodes_xor(,,) __nodes_xor(&(), &(), &(), MAX_NUMNODES)
nodes_andnot(,,) __nodes_andnot(&(), &(), &(), MAX_NUMNODES)
nodes_complement(,) __nodes_complement(&(), &(), MAX_NUMNODES)
nodes_equal(,) __nodes_equal(&(), &(), MAX_NUMNODES)
nodes_intersects(,) __nodes_intersects(&(), &(), MAX_NUMNODES)
nodes_subset(,) __nodes_subset(&(), &(), MAX_NUMNODES)
nodes_empty() __nodes_empty(&(), MAX_NUMNODES)
nodes_full() __nodes_full(&(), MAX_NUMNODES)
nodes_weight() __nodes_weight(&(), MAX_NUMNODES)
nodes_shift_right(,,) __nodes_shift_right(&(), &(), (), MAX_NUMNODES)
nodes_shift_left(,,) __nodes_shift_left(&(), &(), (), MAX_NUMNODES)
first_node() __first_node(&())
next_node(,) __next_node((), &())
next_node_in(,) __next_node_in((), &())
nodemask_of_node() \
({ typeof(_unused_nodemask_arg_) m; if (sizeof(m) == sizeof(unsigned long)) { m.bits[0] = 1UL << (); } else { init_nodemask_of_node(&m, ()); } m; \
})
first_unset_node() __first_unset_node(&())
NODE_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(MAX_NUMNODES)
NODE_MASK_ALL \
((nodemask_t) { { [0 ... BITS_TO_LONGS(MAX_NUMNODES)-2] = ~0UL, [BITS_TO_LONGS(MAX_NUMNODES)-1] = NODE_MASK_LAST_WORD \
} })
NODE_MASK_NONE \
((nodemask_t) { { [0 ... BITS_TO_LONGS(MAX_NUMNODES)-1] = 0UL \
} })
nodes_addr() (().bits)
nodemask_parse_user(,,) __nodemask_parse_user((), (), &(), MAX_NUMNODES)
nodelist_parse(,) __nodelist_parse((), &(), MAX_NUMNODES)
node_remap(,,) __node_remap((), &(), &(), MAX_NUMNODES)
nodes_remap(,,,) __nodes_remap(&(), &(), &(), &(), MAX_NUMNODES)
nodes_onto(,,) __nodes_onto(&(), &(), &(), MAX_NUMNODES)
nodes_fold(,,) __nodes_fold(&(), &(), , MAX_NUMNODES)
for_each_node_mask(,) for (() = first_node(); ( >= 0) && () < MAX_NUMNODES; () = next_node((), ()))
for_each_node_state(,) for_each_node_mask((), node_states[])
first_online_node first_node(node_states[N_ONLINE])
first_memory_node first_node(node_states[N_MEMORY])
node_online_map node_states[N_ONLINE]
node_possible_map node_states[N_POSSIBLE]
num_online_nodes() num_node_state(N_ONLINE)
num_possible_nodes() num_node_state(N_POSSIBLE)
node_online() node_state((), N_ONLINE)
node_possible() node_state((), N_POSSIBLE)
for_each_node() for_each_node_state(, N_POSSIBLE)
for_each_online_node() for_each_node_state(, N_ONLINE)
NODEMASK_ALLOC(,,)  * = kmalloc(sizeof(*), )
NODEMASK_FREE() kfree()
NODEMASK_SCRATCH() NODEMASK_ALLOC(struct nodemask_scratch, , GFP_KERNEL | __GFP_NORETRY)
NODEMASK_SCRATCH_FREE() NODEMASK_FREE()
PB_migratetype_bits 3
pageblock_order HUGETLB_PAGE_ORDER
pageblock_nr_pages (1UL << pageblock_order)
get_pageblock_flags_group(,,) get_pfnblock_flags_mask(, page_to_pfn(), , (1 << ( -  + 1)) - 1)
set_pageblock_flags_group(,,,) set_pfnblock_flags_mask(, , page_to_pfn(), , (1 << ( -  + 1)) - 1)
get_pageblock_skip() get_pageblock_flags_group(, PB_migrate_skip, PB_migrate_skip)
clear_pageblock_skip() set_pageblock_flags_group(, 0, PB_migrate_skip, PB_migrate_skip)
set_pageblock_skip() set_pageblock_flags_group(, 1, PB_migrate_skip, PB_migrate_skip)
NR_PAGEFLAGS 26
MAX_NR_ZONES 5
NR_CPUS_BITS 13
SPINLOCK_SIZE 4
ZONES_SHIFT 3
SECTIONS_SHIFT (MAX_PHYSMEM_BITS - SECTION_SIZE_BITS)
SECTIONS_WIDTH 0
ZONES_WIDTH ZONES_SHIFT
NODES_WIDTH NODES_SHIFT
LAST__PID_SHIFT 8
LAST__PID_MASK ((1 << LAST__PID_SHIFT)-1)
LAST__CPU_SHIFT NR_CPUS_BITS
LAST__CPU_MASK ((1 << LAST__CPU_SHIFT)-1)
LAST_CPUPID_SHIFT (LAST__PID_SHIFT+LAST__CPU_SHIFT)
KASAN_TAG_WIDTH 0
LAST_CPUPID_WIDTH LAST_CPUPID_SHIFT
USE_SPLIT_PTE_PTLOCKS (NR_CPUS >= CONFIG_SPLIT_PTLOCK_CPUS)
USE_SPLIT_PMD_PTLOCKS (USE_SPLIT_PTE_PTLOCKS && IS_ENABLED(CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK))
ALLOC_SPLIT_PTLOCKS (SPINLOCK_SIZE > BITS_PER_LONG/8)
VMACACHE_BITS 2
VMACACHE_SIZE (1U << VMACACHE_BITS)
VMACACHE_MASK (VMACACHE_SIZE - 1)
SPLIT_RSS_COUNTING 
AT_SYSINFO_EHDR 33
AT_VECTOR_SIZE_ARCH 2
AT_NULL 0
AT_IGNORE 1
AT_EXECFD 2
AT_PHDR 3
AT_PHENT 4
AT_PHNUM 5
AT_PAGESZ 6
AT_BASE 7
AT_FLAGS 8
AT_ENTRY 9
AT_NOTELF 10
AT_UID 11
AT_EUID 12
AT_GID 13
AT_EGID 14
AT_PLATFORM 15
AT_HWCAP 16
AT_CLKTCK 17
AT_SECURE 23
AT_BASE_PLATFORM 24
AT_RANDOM 25
AT_HWCAP2 26
AT_EXECFN 31
AT_VECTOR_SIZE_BASE 20
ULONG_CMP_GE(,) (ULONG_MAX / 2 >= () - ())
ULONG_CMP_LT(,) (ULONG_MAX / 2 < () - ())
ulong2long() (*(long *)(&()))
RCU_NONIDLE() do { rcu_irq_enter_irqson(); do { ; } while (0); rcu_irq_exit_irqson(); } while (0)
rcu_tasks_qs() do { if (READ_ONCE(()->rcu_tasks_holdout)) WRITE_ONCE(()->rcu_tasks_holdout, false); } while (0)
rcu_note_voluntary_context_switch() rcu_tasks_qs()
cond_resched_tasks_rcu_qs() do { rcu_tasks_qs(current); cond_resched(); \
} while (0)
rcu_lock_acquire() do { } while (0)
rcu_lock_release() do { } while (0)
RCU_LOCKDEP_WARN(,) do { } while (0)
rcu_sleep_check() do { } while (0)
rcu_check_sparse(,) 
__rcu_access_pointer(,) \
({ typeof(*) *_________p1 = (typeof(*) *__force)READ_ONCE(); rcu_check_sparse(, ); ((typeof(*) __force __kernel *)(_________p1)); \
})
__rcu_dereference_check(,,) \
({ /* Dependency order vs. p above. */ typeof(*) *________p1 = (typeof(*) *__force)READ_ONCE(); RCU_LOCKDEP_WARN(!(), "suspicious rcu_dereference_check() usage"); rcu_check_sparse(, ); ((typeof(*) __force __kernel *)(________p1)); \
})
__rcu_dereference_protected(,,) \
({ RCU_LOCKDEP_WARN(!(), "suspicious rcu_dereference_protected() usage"); rcu_check_sparse(, ); ((typeof(*) __force __kernel *)()); \
})
rcu_dereference_raw() \
({ /* Dependency order vs. p above. */ typeof() ________p1 = READ_ONCE(); ((typeof(*) __force __kernel *)(________p1)); \
})
RCU_INITIALIZER() (typeof(*()) __force __rcu *)()
rcu_assign_pointer(,) do { uintptr_t _r_a_p__v = (uintptr_t)(); rcu_check_sparse(, __rcu); if (__builtin_constant_p() && (_r_a_p__v) == (uintptr_t)NULL) WRITE_ONCE((), (typeof())(_r_a_p__v)); else smp_store_release(&, RCU_INITIALIZER((typeof())_r_a_p__v)); \
} while (0)
rcu_replace_pointer(,,) \
({ typeof() __tmp = rcu_dereference_protected((), ()); rcu_assign_pointer((), ()); __tmp; \
})
rcu_swap_protected(,,) do { typeof() __tmp = rcu_dereference_protected((), ()); rcu_assign_pointer((), ()); () = __tmp; \
} while (0)
rcu_access_pointer() __rcu_access_pointer((), __rcu)
rcu_dereference_check(,) __rcu_dereference_check((), () || rcu_read_lock_held(), __rcu)
rcu_dereference_bh_check(,) __rcu_dereference_check((), () || rcu_read_lock_bh_held(), __rcu)
rcu_dereference_sched_check(,) __rcu_dereference_check((), () || rcu_read_lock_sched_held(), __rcu)
rcu_dereference_raw_check() __rcu_dereference_check((), 1, __rcu)
rcu_dereference_protected(,) __rcu_dereference_protected((), (), __rcu)
rcu_dereference() rcu_dereference_check(, 0)
rcu_dereference_bh() rcu_dereference_bh_check(, 0)
rcu_dereference_sched() rcu_dereference_sched_check(, 0)
rcu_pointer_handoff() ()
RCU_INIT_POINTER(,) do { rcu_check_sparse(, __rcu); WRITE_ONCE(, RCU_INITIALIZER()); } while (0)
RCU_POINTER_INITIALIZER(,) . = RCU_INITIALIZER()
__is_kfree_rcu_offset() (() < 4096)
__kfree_rcu(,) do { BUILD_BUG_ON(!__is_kfree_rcu_offset()); kfree_call_rcu(, (rcu_callback_t)(unsigned long)()); } while (0)
kfree_rcu(,) do { typeof () ___p = (); if (___p) __kfree_rcu(&((___p)->), offsetof(typeof(*()), )); \
} while (0)
smp_mb__after_unlock_lock() do { } while (0)
rb_parent() ((struct rb_node *)(()->__rb_parent_color & ~3))
RB_ROOT (struct rb_root) { NULL, }
rb_entry(,,) container_of(, , )
RB_EMPTY_ROOT() (READ_ONCE(()->rb_node) == NULL)
RB_EMPTY_NODE() (()->__rb_parent_color == (unsigned long)())
RB_CLEAR_NODE() (()->__rb_parent_color = (unsigned long)())
rb_entry_safe(,,) ({ typeof() ____ptr = (); ____ptr ? rb_entry(____ptr, , ) : NULL; })
rbtree_postorder_for_each_entry_safe(,,,) for ( = rb_entry_safe(rb_first_postorder(), typeof(*), );  && ({  = rb_entry_safe(rb_next_postorder(&->), typeof(*), ); 1; });  = )
RB_ROOT_CACHED (struct rb_root_cached) { {NULL, }, NULL }
rb_first_cached() ()->rb_leftmost
OSQ_UNLOCKED_VAL (0)
OSQ_LOCK_UNLOCKED { ATOMIC_INIT(OSQ_UNLOCKED_VAL) }
RWSEM_OWNER_UNKNOWN (-2L)
RWSEM_UNLOCKED_VALUE 0L
__RWSEM_INIT_COUNT() .count = ATOMIC_LONG_INIT(RWSEM_UNLOCKED_VALUE)
__RWSEM_DEP_MAP_INIT() 
__DEBUG_RWSEM_INITIALIZER() 
__RWSEM_OPT_INIT() , .osq = OSQ_LOCK_UNLOCKED
__RWSEM_INITIALIZER() { __RWSEM_INIT_COUNT(), .owner = ATOMIC_LONG_INIT(0), .wait_list = LIST_HEAD_INIT(().wait_list), .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(.wait_lock) __RWSEM_OPT_INIT() __DEBUG_RWSEM_INITIALIZER() __RWSEM_DEP_MAP_INIT() }
DECLARE_RWSEM() struct rw_semaphore  = __RWSEM_INITIALIZER()
init_rwsem() do { static struct lock_class_key __key; __init_rwsem((), #, &__key); \
} while (0)
down_read_nested(,) down_read()
down_read_killable_nested(,) down_read_killable()
down_write_nest_lock(,) down_write()
down_write_nested(,) down_write()
down_write_killable_nested(,) down_write_killable()
down_read_non_owner() down_read()
up_read_non_owner() up_read()
init_completion_map(,) __init_completion()
init_completion() __init_completion()
COMPLETION_INITIALIZER() { 0, __WAIT_QUEUE_HEAD_INITIALIZER(().wait) }
COMPLETION_INITIALIZER_ONSTACK_MAP(,) (*({ init_completion_map(&(), &()); &(); }))
COMPLETION_INITIALIZER_ONSTACK() (*({ init_completion(&); &; }))
DECLARE_COMPLETION() struct completion  = COMPLETION_INITIALIZER()
DECLARE_COMPLETION_ONSTACK() DECLARE_COMPLETION()
DECLARE_COMPLETION_ONSTACK_MAP(,) DECLARE_COMPLETION()
UPROBE_HANDLER_REMOVE 1
UPROBE_HANDLER_MASK 1
MAX_URETPROBE_DEPTH 64
DEBUG_LOCKS_WARN_ON() \
({ int __ret = 0; if (!oops_in_progress && unlikely()) { if (debug_locks_off() && !debug_locks_silent) WARN(1, "DEBUG_LOCKS_WARN_ON(%s)", #); __ret = 1; } __ret; \
})
SMP_DEBUG_LOCKS_WARN_ON() DEBUG_LOCKS_WARN_ON()
locking_selftest() do { } while (0)
__DEBUG_MUTEX_INITIALIZER() 
mutex_init() do { static struct lock_class_key __key; __mutex_init((), #, &__key); \
} while (0)
__DEP_MAP_MUTEX_INITIALIZER() 
__MUTEX_INITIALIZER() { .owner = ATOMIC_LONG_INIT(0) , .wait_lock = __SPIN_LOCK_UNLOCKED(.wait_lock) , .wait_list = LIST_HEAD_INIT(.wait_list) __DEBUG_MUTEX_INITIALIZER() __DEP_MAP_MUTEX_INITIALIZER() }
DEFINE_MUTEX() struct mutex  = __MUTEX_INITIALIZER()
mutex_lock_nested(,) mutex_lock()
mutex_lock_interruptible_nested(,) mutex_lock_interruptible()
mutex_lock_killable_nested(,) mutex_lock_killable()
mutex_lock_nest_lock(,) mutex_lock()
mutex_lock_io_nested(,) mutex_lock_io()
HZ_TO_MSEC_MUL32 U64_C(0x80000000)
HZ_TO_MSEC_ADJ32 U64_C(0x0)
HZ_TO_MSEC_SHR32 29
MSEC_TO_HZ_MUL32 U64_C(0x80000000)
MSEC_TO_HZ_ADJ32 U64_C(0x180000000)
MSEC_TO_HZ_SHR32 33
HZ_TO_MSEC_NUM 4
HZ_TO_MSEC_DEN 1
MSEC_TO_HZ_NUM 1
MSEC_TO_HZ_DEN 4
HZ_TO_USEC_MUL32 U64_C(0xFA000000)
HZ_TO_USEC_ADJ32 U64_C(0x0)
HZ_TO_USEC_SHR32 20
USEC_TO_HZ_MUL32 U64_C(0x83126E98)
USEC_TO_HZ_ADJ32 U64_C(0x7FF7CED9168)
USEC_TO_HZ_SHR32 43
HZ_TO_USEC_NUM 4000
HZ_TO_USEC_DEN 1
USEC_TO_HZ_NUM 1
USEC_TO_HZ_DEN 4000
HZ_TO_NSEC_NUM 4000000
HZ_TO_NSEC_DEN 1
NSEC_TO_HZ_NUM 1
NSEC_TO_HZ_DEN 4000000
SHIFT_HZ 8
SH_DIV(,,) ( ((() / ()) << ()) + (((() % ()) << ()) + () / 2) / ())
LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ)
TICK_NSEC ((NSEC_PER_SEC+HZ/2)/HZ)
TICK_USEC ((USEC_PER_SEC + HZ/2) / HZ)
USER_TICK_USEC ((1000000UL + USER_HZ/2) / USER_HZ)
__jiffy_arch_data 
time_after(,) (typecheck(unsigned long, ) && typecheck(unsigned long, ) && ((long)(() - ()) < 0))
time_before(,) time_after(,)
time_after_eq(,) (typecheck(unsigned long, ) && typecheck(unsigned long, ) && ((long)(() - ()) >= 0))
time_before_eq(,) time_after_eq(,)
time_in_range(,,) (time_after_eq(,) && time_before_eq(,))
time_in_range_open(,,) (time_after_eq(,) && time_before(,))
time_after64(,) (typecheck(__u64, ) && typecheck(__u64, ) && ((__s64)(() - ()) < 0))
time_before64(,) time_after64(,)
time_after_eq64(,) (typecheck(__u64, ) && typecheck(__u64, ) && ((__s64)(() - ()) >= 0))
time_before_eq64(,) time_after_eq64(,)
time_in_range64(,,) (time_after_eq64(, ) && time_before_eq64(, ))
time_is_before_jiffies() time_after(jiffies, )
time_is_before_jiffies64() time_after64(get_jiffies_64(), )
time_is_after_jiffies() time_before(jiffies, )
time_is_after_jiffies64() time_before64(get_jiffies_64(), )
time_is_before_eq_jiffies() time_after_eq(jiffies, )
time_is_before_eq_jiffies64() time_after_eq64(get_jiffies_64(), )
time_is_after_eq_jiffies() time_before_eq(jiffies, )
time_is_after_eq_jiffies64() time_before_eq64(get_jiffies_64(), )
INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
MAX_JIFFY_OFFSET ((LONG_MAX >> 1)-1)
SEC_JIFFIE_SC (31 - SHIFT_HZ)
SEC_JIFFIE_SC (32 - SHIFT_HZ)
NSEC_JIFFIE_SC (SEC_JIFFIE_SC + 29)
SEC_CONVERSION ((unsigned long)((((u64)NSEC_PER_SEC << SEC_JIFFIE_SC) + TICK_NSEC -1) / (u64)TICK_NSEC))
NSEC_CONVERSION ((unsigned long)((((u64)1 << NSEC_JIFFIE_SC) + TICK_NSEC -1) / (u64)TICK_NSEC))
MAX_SEC_IN_JIFFIES (SH_DIV((MAX_JIFFY_OFFSET >> SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)
TIMESTAMP_SIZE 30
ktime_sub(,) (() - ())
ktime_add(,) (() + ())
ktime_add_unsafe(,) ((u64) () + ())
ktime_add_ns(,) (() + ())
ktime_sub_ns(,) (() - ())
ktime_to_timespec() ns_to_timespec(())
ktime_to_timespec64() ns_to_timespec64(())
ktime_to_timeval() ns_to_timeval(())
LOW_RES_NSEC TICK_NSEC
KTIME_LOW_RES (LOW_RES_NSEC)
__TIMER_LOCKDEP_MAP_INITIALIZER() 
TIMER_CPUMASK 0x0003FFFF
TIMER_MIGRATING 0x00040000
TIMER_BASEMASK (TIMER_CPUMASK | TIMER_MIGRATING)
TIMER_DEFERRABLE 0x00080000
TIMER_PINNED 0x00100000
TIMER_IRQSAFE 0x00200000
TIMER_ARRAYSHIFT 22
TIMER_ARRAYMASK 0xFFC00000
TIMER_TRACE_FLAGMASK (TIMER_MIGRATING | TIMER_DEFERRABLE | TIMER_PINNED | TIMER_IRQSAFE)
__TIMER_INITIALIZER(,) { .entry = { .next = TIMER_ENTRY_STATIC }, .function = (), .flags = (), __TIMER_LOCKDEP_MAP_INITIALIZER( __FILE__ ":" __stringify(__LINE__)) }
DEFINE_TIMER(,) struct timer_list  = __TIMER_INITIALIZER(, 0)
__init_timer(,,) init_timer_key((), (), (), NULL, NULL)
__init_timer_on_stack(,,) init_timer_on_stack_key((), (), (), NULL, NULL)
timer_setup(,,) __init_timer((), (), ())
timer_setup_on_stack(,,) __init_timer_on_stack((), (), ())
from_timer(,,) container_of(, typeof(*), )
NEXT_TIMER_MAX_DELTA ((1UL << 30) - 1)
del_singleshot_timer_sync() del_timer_sync()
work_data_bits() ((unsigned long *)(&()->data))
WORK_DATA_INIT() ATOMIC_LONG_INIT((unsigned long)WORK_STRUCT_NO_POOL)
WORK_DATA_STATIC_INIT() ATOMIC_LONG_INIT((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC))
__WORK_INIT_LOCKDEP_MAP(,) 
__WORK_INITIALIZER(,) { .data = WORK_DATA_STATIC_INIT(), .entry = { &().entry, &().entry }, .func = (), __WORK_INIT_LOCKDEP_MAP(#, &()) }
__DELAYED_WORK_INITIALIZER(,,) { .work = __WORK_INITIALIZER(().work, ()), .timer = __TIMER_INITIALIZER(delayed_work_timer_fn, () | TIMER_IRQSAFE), }
DECLARE_WORK(,) struct work_struct  = __WORK_INITIALIZER(, )
DECLARE_DELAYED_WORK(,) struct delayed_work  = __DELAYED_WORK_INITIALIZER(, , 0)
DECLARE_DEFERRABLE_WORK(,) struct delayed_work  = __DELAYED_WORK_INITIALIZER(, , TIMER_DEFERRABLE)
__INIT_WORK(,,) do { __init_work((), ); ()->data = (atomic_long_t) WORK_DATA_INIT(); INIT_LIST_HEAD(&()->entry); ()->func = (); } while (0)
INIT_WORK(,) __INIT_WORK((), (), 0)
INIT_WORK_ONSTACK(,) __INIT_WORK((), (), 1)
__INIT_DELAYED_WORK(,,) do { INIT_WORK(&()->work, ()); __init_timer(&()->timer, delayed_work_timer_fn, () | TIMER_IRQSAFE); } while (0)
__INIT_DELAYED_WORK_ONSTACK(,,) do { INIT_WORK_ONSTACK(&()->work, ()); __init_timer_on_stack(&()->timer, delayed_work_timer_fn, () | TIMER_IRQSAFE); } while (0)
INIT_DELAYED_WORK(,) __INIT_DELAYED_WORK(, , 0)
INIT_DELAYED_WORK_ONSTACK(,) __INIT_DELAYED_WORK_ONSTACK(, , 0)
INIT_DEFERRABLE_WORK(,) __INIT_DELAYED_WORK(, , TIMER_DEFERRABLE)
INIT_DEFERRABLE_WORK_ONSTACK(,) __INIT_DELAYED_WORK_ONSTACK(, , TIMER_DEFERRABLE)
INIT_RCU_WORK(,) INIT_WORK(&()->work, ())
INIT_RCU_WORK_ONSTACK(,) INIT_WORK_ONSTACK(&()->work, ())
work_pending() test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits())
delayed_work_pending() work_pending(&()->work)
WQ_UNBOUND_MAX_ACTIVE max_t(int, WQ_MAX_ACTIVE, num_possible_cpus() * WQ_MAX_UNBOUND_PER_CPU)
alloc_ordered_workqueue(,,) alloc_workqueue(, WQ_UNBOUND | __WQ_ORDERED | __WQ_ORDERED_EXPLICIT | (), 1, ##)
create_workqueue() alloc_workqueue("%s", __WQ_LEGACY | WQ_MEM_RECLAIM, 1, ())
create_freezable_workqueue() alloc_workqueue("%s", __WQ_LEGACY | WQ_FREEZABLE | WQ_UNBOUND | WQ_MEM_RECLAIM, 1, ())
create_singlethread_workqueue() alloc_ordered_workqueue("%s", __WQ_LEGACY | WQ_MEM_RECLAIM, )
RCU_CBLIST_INITIALIZER() { .head = NULL, .tail = &.head }
RCU_DONE_TAIL 0
RCU_WAIT_TAIL 1
RCU_NEXT_READY_TAIL 2
RCU_NEXT_TAIL 3
RCU_CBLIST_NSEGS 4
RCU_SEGCBLIST_INITIALIZER() \
{ .head = NULL, .tails[RCU_DONE_TAIL] = &.head, .tails[RCU_WAIT_TAIL] = &.head, .tails[RCU_NEXT_READY_TAIL] = &.head, .tails[RCU_NEXT_TAIL] = &.head, \
}
__SRCU_DEP_MAP_INIT() 
RCU_FANOUT 64
RCU_FANOUT_LEAF 16
RCU_FANOUT_1 (RCU_FANOUT_LEAF)
RCU_FANOUT_2 (RCU_FANOUT_1 * RCU_FANOUT)
RCU_FANOUT_3 (RCU_FANOUT_2 * RCU_FANOUT)
RCU_FANOUT_4 (RCU_FANOUT_3 * RCU_FANOUT)
RCU_NUM_LVLS 3
NUM_RCU_LVL_0 1
NUM_RCU_LVL_1 DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_2)
NUM_RCU_LVL_2 DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_1)
NUM_RCU_NODES (NUM_RCU_LVL_0 + NUM_RCU_LVL_1 + NUM_RCU_LVL_2)
NUM_RCU_LVL_INIT { NUM_RCU_LVL_0, NUM_RCU_LVL_1, NUM_RCU_LVL_2 }
RCU_NODE_NAME_INIT { "rcu_node_0", "rcu_node_1", "rcu_node_2" }
RCU_FQS_NAME_INIT { "rcu_node_fqs_0", "rcu_node_fqs_1", "rcu_node_fqs_2" }
SRCU_STATE_IDLE 0
SRCU_STATE_SCAN1 1
SRCU_STATE_SCAN2 2
__SRCU_STRUCT_INIT(,) \
{ .sda = &, .lock = __SPIN_LOCK_UNLOCKED(.lock), .srcu_gp_seq_needed = -1UL, .work = __DELAYED_WORK_INITIALIZER(.work, NULL, 0), __SRCU_DEP_MAP_INIT() \
}
__DEFINE_SRCU(,) static DEFINE_PER_CPU(struct srcu_data, ##_srcu_data);  struct srcu_struct  = __SRCU_STRUCT_INIT(, ##_srcu_data)
DEFINE_SRCU() __DEFINE_SRCU(, /* not static */)
DEFINE_STATIC_SRCU() __DEFINE_SRCU(, static)
srcu_dereference_check(,,) __rcu_dereference_check((), () || srcu_read_lock_held(), __rcu)
srcu_dereference(,) srcu_dereference_check((), (), 0)
srcu_dereference_notrace(,) srcu_dereference_check((), (), 1)
ATOMIC_INIT_NOTIFIER_HEAD() do { spin_lock_init(&()->lock); ()->head = NULL; } while (0)
BLOCKING_INIT_NOTIFIER_HEAD() do { init_rwsem(&()->rwsem); ()->head = NULL; } while (0)
RAW_INIT_NOTIFIER_HEAD() do { ()->head = NULL; } while (0)
srcu_cleanup_notifier_head() cleanup_srcu_struct(&()->srcu);
ATOMIC_NOTIFIER_INIT() { .lock = __SPIN_LOCK_UNLOCKED(.lock), .head = NULL }
BLOCKING_NOTIFIER_INIT() { .rwsem = __RWSEM_INITIALIZER(().rwsem), .head = NULL }
RAW_NOTIFIER_INIT() { .head = NULL }
SRCU_NOTIFIER_INIT(,) { .mutex = __MUTEX_INITIALIZER(.mutex), .head = NULL, .srcu = __SRCU_STRUCT_INIT(.srcu, ), }
ATOMIC_NOTIFIER_HEAD() struct atomic_notifier_head  = ATOMIC_NOTIFIER_INIT()
BLOCKING_NOTIFIER_HEAD() struct blocking_notifier_head  = BLOCKING_NOTIFIER_INIT()
RAW_NOTIFIER_HEAD() struct raw_notifier_head  = RAW_NOTIFIER_INIT()
_SRCU_NOTIFIER_HEAD(,) static DEFINE_PER_CPU(struct srcu_data, ##_head_srcu_data);  struct srcu_notifier_head  = SRCU_NOTIFIER_INIT(, ##_head_srcu_data)
SRCU_NOTIFIER_HEAD() _SRCU_NOTIFIER_HEAD(, /* not static */)
SRCU_NOTIFIER_HEAD_STATIC() _SRCU_NOTIFIER_HEAD(, static)
NOTIFY_DONE 0x0000
NOTIFY_OK 0x0001
NOTIFY_STOP_MASK 0x8000
NOTIFY_BAD (NOTIFY_STOP_MASK|0x0002)
NOTIFY_STOP (NOTIFY_OK|NOTIFY_STOP_MASK)
NETLINK_URELEASE 0x0001
KBD_KEYCODE 0x0001
KBD_UNBOUND_KEYCODE 0x0002
KBD_UNICODE 0x0003
KBD_KEYSYM 0x0004
KBD_POST_KEYSYM 0x0005
MAX_UINSN_BYTES 16
UPROBE_XOL_SLOT_BYTES 128
UPROBE_SWBP_INSN 0xcc
UPROBE_SWBP_INSN_SIZE 1
INIT_MM_CONTEXT() .context = { .ctx_id = 1, .lock = __MUTEX_INITIALIZER(.context.lock), }
AT_VECTOR_SIZE (2*(AT_VECTOR_SIZE_ARCH + AT_VECTOR_SIZE_BASE + 1))
_struct_page_alignment __aligned(2 * sizeof(unsigned long))
STRUCT_PAGE_MAX_SHIFT (order_base_2(sizeof(struct page)))
PAGE_FRAG_CACHE_MAX_SIZE __ALIGN_MASK(32768, ~PAGE_MASK)
PAGE_FRAG_CACHE_MAX_ORDER get_order(PAGE_FRAG_CACHE_MAX_SIZE)
page_private() (()->private)
set_page_private(,) (()->private = ())
NULL_VM_UFFD_CTX ((struct vm_userfaultfd_ctx) { NULL, })
VM_FAULT_SET_HINDEX() ((__force vm_fault_t)(() << 16))
VM_FAULT_GET_HINDEX() (((__force unsigned int)() >> 16) & 0xf)
VM_FAULT_ERROR (VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE | VM_FAULT_FALLBACK)
VM_FAULT_RESULT_TRACE { VM_FAULT_OOM, "OOM" }, { VM_FAULT_SIGBUS, "SIGBUS" }, { VM_FAULT_MAJOR, "MAJOR" }, { VM_FAULT_WRITE, "WRITE" }, { VM_FAULT_HWPOISON, "HWPOISON" }, { VM_FAULT_HWPOISON_LARGE, "HWPOISON_LARGE" }, { VM_FAULT_SIGSEGV, "SIGSEGV" }, { VM_FAULT_NOPAGE, "NOPAGE" }, { VM_FAULT_LOCKED, "LOCKED" }, { VM_FAULT_RETRY, "RETRY" }, { VM_FAULT_FALLBACK, "FALLBACK" }, { VM_FAULT_DONE_COW, "DONE_COW" }, { VM_FAULT_NEEDDSYNC, "NEEDDSYNC" }
PAGE_POISON_PATTERN -1l
PF_POISONED_CHECK() ({ VM_BUG_ON_PGFLAGS(PagePoisoned(), ); ; })
PF_ANY (page, enforce) PF_POISONED_CHECK(page)
PF_HEAD (page, enforce) PF_POISONED_CHECK(compound_head(page))
PF_ONLY_HEAD (page, enforce) ({ VM_BUG_ON_PGFLAGS(PageTail(page), page); PF_POISONED_CHECK(page); })
PF_NO_TAIL (page, enforce) ({ VM_BUG_ON_PGFLAGS(enforce && PageTail(page), page); PF_POISONED_CHECK(compound_head(page)); })
PF_NO_COMPOUND (page, enforce) ({ VM_BUG_ON_PGFLAGS(enforce && PageCompound(page), page); PF_POISONED_CHECK(page); })
TESTPAGEFLAG(,,) static __always_inline int Page##(struct page *page) { return test_bit(PG_##, &(page, 0)->flags); }
SETPAGEFLAG(,,) static __always_inline void SetPage##(struct page *page) { set_bit(PG_##, &(page, 1)->flags); }
CLEARPAGEFLAG(,,) static __always_inline void ClearPage##(struct page *page) { clear_bit(PG_##, &(page, 1)->flags); }
__SETPAGEFLAG(,,) static __always_inline void __SetPage##(struct page *page) { __set_bit(PG_##, &(page, 1)->flags); }
__CLEARPAGEFLAG(,,) static __always_inline void __ClearPage##(struct page *page) { __clear_bit(PG_##, &(page, 1)->flags); }
TESTSETFLAG(,,) static __always_inline int TestSetPage##(struct page *page) { return test_and_set_bit(PG_##, &(page, 1)->flags); }
TESTCLEARFLAG(,,) static __always_inline int TestClearPage##(struct page *page) { return test_and_clear_bit(PG_##, &(page, 1)->flags); }
PAGEFLAG(,,) TESTPAGEFLAG(, , ) SETPAGEFLAG(, , ) CLEARPAGEFLAG(, , )
__PAGEFLAG(,,) TESTPAGEFLAG(, , ) __SETPAGEFLAG(, , ) __CLEARPAGEFLAG(, , )
TESTSCFLAG(,,) TESTSETFLAG(, , ) TESTCLEARFLAG(, , )
TESTPAGEFLAG_FALSE() static inline int Page##(const struct page *page) { return 0; }
SETPAGEFLAG_NOOP() static inline void SetPage##(struct page *page) { }
CLEARPAGEFLAG_NOOP() static inline void ClearPage##(struct page *page) { }
__CLEARPAGEFLAG_NOOP() static inline void __ClearPage##(struct page *page) { }
TESTSETFLAG_FALSE() static inline int TestSetPage##(struct page *page) { return 0; }
TESTCLEARFLAG_FALSE() static inline int TestClearPage##(struct page *page) { return 0; }
PAGEFLAG_FALSE() TESTPAGEFLAG_FALSE() SETPAGEFLAG_NOOP() CLEARPAGEFLAG_NOOP()
TESTSCFLAG_FALSE() TESTSETFLAG_FALSE() TESTCLEARFLAG_FALSE()
__PG_HWPOISON (1UL << PG_hwpoison)
PAGE_MAPPING_ANON 0x1
PAGE_MAPPING_MOVABLE 0x2
PAGE_MAPPING_KSM (PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)
PAGE_MAPPING_FLAGS (PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)
test_set_page_writeback() __test_set_page_writeback(, false)
test_set_page_writeback_keepwrite() __test_set_page_writeback(, true)
PG_head_mask ((1UL << PG_head))
PAGE_TYPE_BASE 0xf0000000
PAGE_MAPCOUNT_RESERVE -128
PG_buddy 0x00000080
PG_offline 0x00000100
PG_kmemcg 0x00000200
PG_table 0x00000400
PG_guard 0x00000800
PageType(,) ((->page_type & (PAGE_TYPE_BASE | )) == PAGE_TYPE_BASE)
PAGE_TYPE_OPS(,) static __always_inline int Page##(struct page *page) \
{ return PageType(page, PG_##); \
} static __always_inline void __SetPage##(struct page *page) \
{ VM_BUG_ON_PAGE(!PageType(page, 0), page); page->page_type &= ~PG_##; \
} static __always_inline void __ClearPage##(struct page *page) \
{ VM_BUG_ON_PAGE(!Page##(page), page); page->page_type |= PG_##; \
}
__PG_MLOCKED (1UL << PG_mlocked)
PAGE_FLAGS_CHECK_AT_FREE (1UL << PG_lru | 1UL << PG_locked | 1UL << PG_private | 1UL << PG_private_2 | 1UL << PG_writeback | 1UL << PG_reserved | 1UL << PG_slab | 1UL << PG_active | 1UL << PG_unevictable | __PG_MLOCKED)
PAGE_FLAGS_CHECK_AT_PREP (((1UL << NR_PAGEFLAGS) - 1) & ~__PG_HWPOISON)
PAGE_FLAGS_PRIVATE (1UL << PG_private | 1UL << PG_private_2)
MAX_ORDER 11
MAX_ORDER_NR_PAGES (1 << (MAX_ORDER - 1))
PAGE_ALLOC_COSTLY_ORDER 3
is_migrate_cma() unlikely(() == MIGRATE_CMA)
is_migrate_cma_page() (get_pageblock_migratetype() == MIGRATE_CMA)
for_each_migratetype_order(,) for ( = 0;  < MAX_ORDER; ++) for ( = 0;  < MIGRATE_TYPES; ++)
NR_MIGRATETYPE_BITS (PB_migrate_end - PB_migrate + 1)
MIGRATETYPE_MASK ((1UL << NR_MIGRATETYPE_BITS) - 1)
get_pageblock_migratetype() get_pfnblock_flags_mask(, page_to_pfn(), PB_migrate_end, MIGRATETYPE_MASK)
ZONE_PADDING() struct zone_padding ;
LRU_BASE 0
LRU_ACTIVE 1
LRU_FILE 2
for_each_lru() for ( = 0;  < NR_LRU_LISTS; ++)
for_each_evictable_lru() for ( = 0;  <= LRU_ACTIVE_FILE; ++)
ISOLATE_UNMAPPED ((__force isolate_mode_t)0x2)
ISOLATE_ASYNC_MIGRATE ((__force isolate_mode_t)0x4)
ISOLATE_UNEVICTABLE ((__force isolate_mode_t)0x8)
min_wmark_pages() (->_watermark[WMARK_MIN] + ->watermark_boost)
low_wmark_pages() (->_watermark[WMARK_LOW] + ->watermark_boost)
high_wmark_pages() (->_watermark[WMARK_HIGH] + ->watermark_boost)
wmark_pages(,) (->_watermark[] + ->watermark_boost)
DEF_PRIORITY 12
MAX_ZONES_PER_ZONELIST (MAX_NUMNODES * MAX_NR_ZONES)
node_present_pages() (NODE_DATA()->node_present_pages)
node_spanned_pages() (NODE_DATA()->node_spanned_pages)
pgdat_page_nr(,) pfn_to_page(()->node_start_pfn + ())
nid_page_nr(,) pgdat_page_nr(NODE_DATA(),())
node_start_pfn() (NODE_DATA()->node_start_pfn)
node_end_pfn() pgdat_end_pfn(NODE_DATA())
pfn_to_online_page() \
({ struct page *___page = NULL; unsigned long ___pfn = ; unsigned long ___nr = pfn_to_section_nr(___pfn); if (___nr < NR_MEM_SECTIONS && online_section_nr(___nr) && pfn_valid_within(___pfn)) ___page = pfn_to_page(___pfn); ___page; \
})
arch_alloc_nodedata() generic_alloc_nodedata()
arch_free_nodedata() generic_free_nodedata()
generic_alloc_nodedata() \
({ kzalloc(sizeof(pg_data_t), GFP_KERNEL); \
})
generic_free_nodedata() kfree()
zone_idx() (() - ()->zone_pgdat->node_zones)
NUMA_ZONELIST_ORDER_LEN 16
SMP_MAGIC_IDENT (('_'<<24) | ('P'<<16) | ('M'<<8) | '_')
MPC_SIGNATURE "PCMP"
MP_PROCESSOR 0
MP_BUS 1
MP_IOAPIC 2
MP_INTSRC 3
MP_LINTSRC 4
MP_TRANSLATION 192
CPU_ENABLED 1
CPU_BOOTPROCESSOR 2
CPU_STEPPING_MASK 0x000F
CPU_MODEL_MASK 0x00F0
CPU_FAMILY_MASK 0x0F00
BUSTYPE_EISA "EISA"
BUSTYPE_ISA "ISA"
BUSTYPE_INTERN "INTERN"
BUSTYPE_MCA "MCA"
BUSTYPE_VL "VL"
BUSTYPE_PCI "PCI"
BUSTYPE_PCMCIA "PCMCIA"
BUSTYPE_CBUS "CBUS"
BUSTYPE_CBUSII "CBUSII"
BUSTYPE_FUTURE "FUTURE"
BUSTYPE_MBI "MBI"
BUSTYPE_MBII "MBII"
BUSTYPE_MPI "MPI"
BUSTYPE_MPSA "MPSA"
BUSTYPE_NUBUS "NUBUS"
BUSTYPE_TC "TC"
BUSTYPE_VME "VME"
BUSTYPE_XPRESS "XPRESS"
MPC_APIC_USABLE 0x01
MP_IRQPOL_DEFAULT 0x0
MP_IRQPOL_ACTIVE_HIGH 0x1
MP_IRQPOL_RESERVED 0x2
MP_IRQPOL_ACTIVE_LOW 0x3
MP_IRQPOL_MASK 0x3
MP_IRQTRIG_DEFAULT 0x0
MP_IRQTRIG_EDGE 0x4
MP_IRQTRIG_RESERVED 0x8
MP_IRQTRIG_LEVEL 0xc
MP_IRQTRIG_MASK 0xc
MP_APIC_ALL 0xFF
MPC_OEM_SIGNATURE "_OEM"
IO_APIC_DEFAULT_PHYS_BASE 0xfec00000
APIC_DEFAULT_PHYS_BASE 0xfee00000
IO_APIC_SLOT_SIZE 1024
APIC_ID 0x20
APIC_LVR 0x30
APIC_LVR_MASK 0xFF00FF
APIC_LVR_DIRECTED_EOI (1 << 24)
GET_APIC_VERSION() (() & 0xFFu)
GET_APIC_MAXLVT() ((() >> 16) & 0xFFu)
APIC_INTEGRATED() (1)
APIC_XAPIC() (() >= 0x14)
APIC_EXT_SPACE() (() & 0x80000000)
APIC_TASKPRI 0x80
APIC_TPRI_MASK 0xFFu
APIC_ARBPRI 0x90
APIC_ARBPRI_MASK 0xFFu
APIC_PROCPRI 0xA0
APIC_EOI 0xB0
APIC_EOI_ACK 0x0
APIC_RRR 0xC0
APIC_LDR 0xD0
APIC_LDR_MASK (0xFFu << 24)
GET_APIC_LOGICAL_ID() ((() >> 24) & 0xFFu)
SET_APIC_LOGICAL_ID() ((() << 24))
APIC_ALL_CPUS 0xFFu
APIC_DFR 0xE0
APIC_DFR_CLUSTER 0x0FFFFFFFul
APIC_DFR_FLAT 0xFFFFFFFFul
APIC_SPIV 0xF0
APIC_SPIV_DIRECTED_EOI (1 << 12)
APIC_SPIV_FOCUS_DISABLED (1 << 9)
APIC_SPIV_APIC_ENABLED (1 << 8)
APIC_ISR 0x100
APIC_ISR_NR 0x8
APIC_TMR 0x180
APIC_IRR 0x200
APIC_ESR 0x280
APIC_ESR_SEND_CS 0x00001
APIC_ESR_RECV_CS 0x00002
APIC_ESR_SEND_ACC 0x00004
APIC_ESR_RECV_ACC 0x00008
APIC_ESR_SENDILL 0x00020
APIC_ESR_RECVILL 0x00040
APIC_ESR_ILLREGA 0x00080
APIC_LVTCMCI 0x2f0
APIC_ICR 0x300
APIC_DEST_SELF 0x40000
APIC_DEST_ALLINC 0x80000
APIC_DEST_ALLBUT 0xC0000
APIC_ICR_RR_MASK 0x30000
APIC_ICR_RR_INVALID 0x00000
APIC_ICR_RR_INPROG 0x10000
APIC_ICR_RR_VALID 0x20000
APIC_INT_LEVELTRIG 0x08000
APIC_INT_ASSERT 0x04000
APIC_ICR_BUSY 0x01000
APIC_DEST_LOGICAL 0x00800
APIC_DEST_PHYSICAL 0x00000
APIC_DM_FIXED 0x00000
APIC_DM_FIXED_MASK 0x00700
APIC_DM_LOWEST 0x00100
APIC_DM_SMI 0x00200
APIC_DM_REMRD 0x00300
APIC_DM_NMI 0x00400
APIC_DM_INIT 0x00500
APIC_DM_STARTUP 0x00600
APIC_DM_EXTINT 0x00700
APIC_VECTOR_MASK 0x000FF
APIC_ICR2 0x310
GET_APIC_DEST_FIELD() ((() >> 24) & 0xFF)
SET_APIC_DEST_FIELD() (() << 24)
APIC_LVTT 0x320
APIC_LVTTHMR 0x330
APIC_LVTPC 0x340
APIC_LVT0 0x350
APIC_LVT_TIMER_BASE_MASK (0x3 << 18)
GET_APIC_TIMER_BASE() ((() >> 18) & 0x3)
SET_APIC_TIMER_BASE() ((() << 18))
APIC_TIMER_BASE_CLKIN 0x0
APIC_TIMER_BASE_TMBASE 0x1
APIC_TIMER_BASE_DIV 0x2
APIC_LVT_TIMER_ONESHOT (0 << 17)
APIC_LVT_TIMER_PERIODIC (1 << 17)
APIC_LVT_TIMER_TSCDEADLINE (2 << 17)
APIC_LVT_MASKED (1 << 16)
APIC_LVT_LEVEL_TRIGGER (1 << 15)
APIC_LVT_REMOTE_IRR (1 << 14)
APIC_INPUT_POLARITY (1 << 13)
APIC_SEND_PENDING (1 << 12)
APIC_MODE_MASK 0x700
GET_APIC_DELIVERY_MODE() ((() >> 8) & 0x7)
SET_APIC_DELIVERY_MODE(,) ((() & ~0x700) | (() << 8))
APIC_MODE_FIXED 0x0
APIC_MODE_NMI 0x4
APIC_MODE_EXTINT 0x7
APIC_LVT1 0x360
APIC_LVTERR 0x370
APIC_TMICT 0x380
APIC_TMCCT 0x390
APIC_TDCR 0x3E0
APIC_SELF_IPI 0x3F0
APIC_TDR_DIV_TMBASE (1 << 2)
APIC_TDR_DIV_1 0xB
APIC_TDR_DIV_2 0x0
APIC_TDR_DIV_4 0x1
APIC_TDR_DIV_8 0x2
APIC_TDR_DIV_16 0x3
APIC_TDR_DIV_32 0x8
APIC_TDR_DIV_64 0x9
APIC_TDR_DIV_128 0xA
APIC_EFEAT 0x400
APIC_ECTRL 0x410
APIC_EILVTn() (0x500 + 0x10 * )
APIC_EILVT_NR_AMD_K8 1
APIC_EILVT_NR_AMD_10H 4
APIC_EILVT_NR_MAX APIC_EILVT_NR_AMD_10H
APIC_EILVT_LVTOFF() ((() >> 4) & 0xF)
APIC_EILVT_MSG_FIX 0x0
APIC_EILVT_MSG_SMI 0x2
APIC_EILVT_MSG_NMI 0x4
APIC_EILVT_MSG_EXT 0x7
APIC_EILVT_MASKED (1 << 16)
APIC_BASE (fix_to_virt(FIX_APIC_BASE))
APIC_BASE_MSR 0x800
XAPIC_ENABLE (1UL << 11)
X2APIC_ENABLE (1UL << 10)
MAX_IO_APICS 128
MAX_LOCAL_APIC 32768
XAPIC_DEST_CPUS_SHIFT 4
XAPIC_DEST_CPUS_MASK ((1u << XAPIC_DEST_CPUS_SHIFT) - 1)
XAPIC_DEST_CLUSTER_MASK (XAPIC_DEST_CPUS_MASK << XAPIC_DEST_CPUS_SHIFT)
APIC_CLUSTER() (() & XAPIC_DEST_CLUSTER_MASK)
APIC_CLUSTERID() (APIC_CLUSTER() >> XAPIC_DEST_CPUS_SHIFT)
APIC_CPUID() (() & XAPIC_DEST_CPUS_MASK)
NUM_APIC_CLUSTERS ((BAD_APICID + 1) >> XAPIC_DEST_CPUS_SHIFT)
u32 unsigned int
BAD_APICID 0xFFFFu
MAX_MP_BUSSES 256
MAX_IRQ_SOURCES (MAX_MP_BUSSES * 4)
PHYSID_ARRAY_SIZE BITS_TO_LONGS(MAX_LOCAL_APIC)
physid_set(,) set_bit(, ().mask)
physid_clear(,) clear_bit(, ().mask)
physid_isset(,) test_bit(, ().mask)
physid_test_and_set(,) test_and_set_bit(, ().mask)
physids_and(,,) bitmap_and(().mask, ().mask, ().mask, MAX_LOCAL_APIC)
physids_or(,,) bitmap_or(().mask, ().mask, ().mask, MAX_LOCAL_APIC)
physids_clear() bitmap_zero(().mask, MAX_LOCAL_APIC)
physids_complement(,) bitmap_complement(().mask, ().mask, MAX_LOCAL_APIC)
physids_empty() bitmap_empty(().mask, MAX_LOCAL_APIC)
physids_equal(,) bitmap_equal(().mask, ().mask, MAX_LOCAL_APIC)
physids_weight() bitmap_weight(().mask, MAX_LOCAL_APIC)
physids_shift_right(,,) bitmap_shift_right(().mask, ().mask, , MAX_LOCAL_APIC)
physids_shift_left(,,) bitmap_shift_left(().mask, ().mask, , MAX_LOCAL_APIC)
PHYSID_MASK_ALL { {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }
PHYSID_MASK_NONE { {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }
FIXMAP_PMD_NUM 2
FIXMAP_PMD_TOP 507
ACPI_PDC_P_FFH (0x0001)
ACPI_PDC_C_C1_HALT (0x0002)
ACPI_PDC_T_FFH (0x0004)
ACPI_PDC_SMP_C1PT (0x0008)
ACPI_PDC_SMP_C2C3 (0x0010)
ACPI_PDC_SMP_P_SWCOORD (0x0020)
ACPI_PDC_SMP_C_SWCOORD (0x0040)
ACPI_PDC_SMP_T_SWCOORD (0x0080)
ACPI_PDC_C_C1_FFH (0x0100)
ACPI_PDC_C_C2C3_FFH (0x0200)
ACPI_PDC_SMP_P_HWCOORD (0x0800)
ACPI_PDC_EST_CAPABILITY_SMP (ACPI_PDC_SMP_C1PT | ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH)
ACPI_PDC_EST_CAPABILITY_SWSMP (ACPI_PDC_SMP_C1PT | ACPI_PDC_C_C1_HALT | ACPI_PDC_SMP_P_SWCOORD | ACPI_PDC_SMP_P_HWCOORD | ACPI_PDC_P_FFH)
ACPI_PDC_C_CAPABILITY_SMP (ACPI_PDC_SMP_C2C3 | ACPI_PDC_SMP_C1PT | ACPI_PDC_C_C1_HALT | ACPI_PDC_C_C1_FFH | ACPI_PDC_C_C2C3_FFH)
pcibus_to_node() __pcibus_to_node()
node_distance(,) __node_distance(, )
set_numa_mem() 
set_cpu_numa_mem(,) 
topology_logical_package_id() (cpu_data().logical_proc_id)
topology_physical_package_id() (cpu_data().phys_proc_id)
topology_logical_die_id() (cpu_data().logical_die_id)
topology_die_id() (cpu_data().cpu_die_id)
topology_core_id() (cpu_data().cpu_core_id)
topology_die_cpumask() (per_cpu(cpu_die_map, ))
topology_core_cpumask() (per_cpu(cpu_core_map, ))
topology_sibling_cpumask() (per_cpu(cpu_sibling_map, ))
topology_max_packages() (__max_logical_packages)
NR_NODE_MEMBLKS (MAX_NUMNODES*2)
NODE_MIN_SIZE (4*1024*1024)
TH_FLAGS_SME_ACTIVE_BIT 0
TH_FLAGS_SME_ACTIVE BIT(TH_FLAGS_SME_ACTIVE_BIT)
ARCH_HAS_IOREMAP_WC 
ARCH_HAS_IOREMAP_WT 
build_mmio_read(,,,,) static inline  (const volatile void __iomem *addr) \
{  ret; asm volatile("mov"  " %1,%0": (ret) \
:"m" (*(volatile  __force *)addr) ); return ret; }
build_mmio_write(,,,,) static inline void ( val, volatile void __iomem *addr) \
{ asm volatile("mov"  " %0,%1": : (val), \
"m" (*(volatile  __force *)addr) ); }
readb readb
readw readw
readl readl
readb_relaxed() __readb()
readw_relaxed() __readw()
readl_relaxed() __readl()
__raw_readb __readb
__raw_readw __readw
__raw_readl __readl
writeb writeb
writew writew
writel writel
writeb_relaxed(,) __writeb(, )
writew_relaxed(,) __writew(, )
writel_relaxed(,) __writel(, )
__raw_writeb __writeb
__raw_writew __writew
__raw_writel __writel
readq_relaxed() __readq()
writeq_relaxed(,) __writeq(, )
__raw_readq __readq
__raw_writeq __writeq
readq readq
writeq writeq
ARCH_HAS_VALID_PHYS_ADDR_RANGE 
virt_to_phys virt_to_phys
phys_to_virt phys_to_virt
page_to_phys() ((dma_addr_t)page_to_pfn() << PAGE_SHIFT)
isa_bus_to_virt phys_to_virt
virt_to_bus virt_to_phys
bus_to_virt phys_to_virt
ioremap_nocache ioremap_nocache
ioremap_uc ioremap_uc
ioremap_cache ioremap_cache
ioremap_prot ioremap_prot
ioremap_encrypted ioremap_encrypted
ioremap ioremap
iounmap iounmap
memcpy_fromio memcpy_fromio
memcpy_toio memcpy_toio
memset_io memset_io
ioread64_lo_hi ioread64_lo_hi
ioread64_hi_lo ioread64_hi_lo
ioread64be_lo_hi ioread64be_lo_hi
ioread64be_hi_lo ioread64be_hi_lo
iowrite64_lo_hi iowrite64_lo_hi
iowrite64_hi_lo iowrite64_hi_lo
iowrite64be_lo_hi iowrite64be_lo_hi
iowrite64be_hi_lo iowrite64be_hi_lo
__pci_ioport_map(,,) ioport_map((), ())
__ISA_IO_base ((char __iomem *)(PAGE_OFFSET))
BUILDIO(,,) static inline void out##(unsigned  value, int port) \
{ asm volatile("out" # " %" # "0, %w1" : : "a"(value), "Nd"(port)); \
} static inline unsigned  in##(int port) \
{ unsigned  value; asm volatile("in" # " %w1, %" # "0" : "=a"(value) : "Nd"(port)); return value; \
} static inline void out####_p(unsigned  value, int port) \
{ out##(value, port); slow_down_io(); \
} static inline unsigned  in####_p(int port) \
{ unsigned  value = in##(port); slow_down_io(); return value; \
} static inline void outs##(int port, const void *addr, unsigned long count) \
{ if (sev_key_active()) { unsigned  *value = (unsigned  *)addr; while (count) { out##(*value, port); value++; count--; } } else { asm volatile("rep; outs" # : "+S"(addr), "+c"(count) : "d"(port) : "memory"); } \
} static inline void ins##(int port, void *addr, unsigned long count) \
{ if (sev_key_active()) { unsigned  *value = (unsigned  *)addr; while (count) { *value = in##(port); value++; count--; } } else { asm volatile("rep; ins" # : "+D"(addr), "+c"(count) : "d"(port) : "memory"); } \
}
inb inb
inw inw
inl inl
inb_p inb_p
inw_p inw_p
inl_p inl_p
insb insb
insw insw
insl insl
outb outb
outw outw
outl outl
outb_p outb_p
outw_p outw_p
outl_p outl_p
outsb outsb
outsw outsw
outsl outsl
xlate_dev_mem_ptr xlate_dev_mem_ptr
unxlate_dev_mem_ptr unxlate_dev_mem_ptr
ioremap_wc ioremap_wc
ioremap_wt ioremap_wt
IO_SPACE_LIMIT 0xffff
__io_br() barrier()
__io_ar() rmb()
__io_bw() wmb()
__io_aw() mmiowb_set_pending()
__io_pbw() __io_bw()
__io_paw() __io_aw()
__io_pbr() __io_br()
__io_par() __io_ar()
readsb readsb
readsw readsw
readsl readsl
readsq readsq
writesb writesb
writesw writesw
writesl writesl
writesq writesq
PCI_IOBASE ((void __iomem *)0)
NR_FWNODE_REFERENCE_ARGS 8
fwnode_has_op(,) (() && ()->ops && ()->ops->)
fwnode_call_int_op(,) ( ? (fwnode_has_op(, ) ? ()->ops->(, ## __VA_ARGS__) : -ENXIO) : -EINVAL)
fwnode_call_bool_op(,) (fwnode_has_op(, ) ? ()->ops->(, ## __VA_ARGS__) : false)
fwnode_call_ptr_op(,) (fwnode_has_op(, ) ? ()->ops->(, ## __VA_ARGS__) : NULL)
fwnode_call_void_op(,) do { if (fwnode_has_op(, )) ()->ops->(, ## __VA_ARGS__); } while (false)
MMIO_UPPER_LIMIT IO_SPACE_LIMIT
insb_p insb_p
insw_p insw_p
insl_p insl_p
outsb_p outsb_p
outsw_p outsw_p
outsl_p outsl_p
LLIST_HEAD_INIT() { NULL }
LLIST_HEAD() struct llist_head  = LLIST_HEAD_INIT()
llist_entry(,,) container_of(, , )
member_address_is_nonnull(,) ((uintptr_t)() + offsetof(typeof(*()), ) != 0)
llist_for_each(,) for (() = (); ; () = ()->next)
llist_for_each_safe(,,) for (() = (); () && (() = ()->next, true); () = ())
llist_for_each_entry(,,) for (() = llist_entry((), typeof(*()), ); member_address_is_nonnull(, ); () = llist_entry(()->.next, typeof(*()), ))
llist_for_each_entry_safe(,,,) for ( = llist_entry((), typeof(*), ); member_address_is_nonnull(, ) && ( = llist_entry(->.next, typeof(*), ), true);  = )
is_signed_type() ((()(-1)) < ()1)
__type_half_max() (()1 << (8*sizeof() - 1 - is_signed_type()))
type_max() (()((__type_half_max() - 1) + __type_half_max()))
type_min() (()(()-type_max()-()1))
is_non_negative() (() > 0 || () == 0)
is_negative() (!(is_non_negative()))
check_add_overflow(,,) ({ typeof() __a = (); typeof() __b = (); typeof() __d = (); (void) (&__a == &__b); (void) (&__a == __d); __builtin_add_overflow(__a, __b, __d); \
})
check_sub_overflow(,,) ({ typeof() __a = (); typeof() __b = (); typeof() __d = (); (void) (&__a == &__b); (void) (&__a == __d); __builtin_sub_overflow(__a, __b, __d); \
})
check_mul_overflow(,,) ({ typeof() __a = (); typeof() __b = (); typeof() __d = (); (void) (&__a == &__b); (void) (&__a == __d); __builtin_mul_overflow(__a, __b, __d); \
})
check_shl_overflow(,,) ({ typeof() _a = ; typeof() _s = ; typeof() _d = ; u64 _a_full = _a; unsigned int _to_shift = is_non_negative(_s) && _s < 8 * sizeof(*) ? _s : 0; *_d = (_a_full << _to_shift); (_to_shift != _s || is_negative(*_d) || is_negative(_a) || (*_d >> _to_shift) != _a); \
})
struct_size(,,) __ab_c_size(, sizeof(*()->) + __must_be_array(()->), sizeof(*()))
VM_IOREMAP 0x00000001
VM_ALLOC 0x00000002
VM_MAP 0x00000004
VM_USERMAP 0x00000008
VM_DMA_COHERENT 0x00000010
VM_UNINITIALIZED 0x00000020
VM_NO_GUARD 0x00000040
VM_KASAN 0x00000080
VM_FLUSH_RESET_PERMS 0x00000100
VMALLOC_TOTAL (VMALLOC_END - VMALLOC_START)
__io_virt() ((void __force *)())
xlate_dev_kmem_ptr xlate_dev_kmem_ptr
arch_phys_wc_index arch_phys_wc_index
arch_phys_wc_add arch_phys_wc_add
arch_io_reserve_memtype_wc arch_io_reserve_memtype_wc
arch_memremap_can_ram_remap arch_memremap_can_ram_remap
acpi_wakeup_address ((unsigned long)(real_mode_header->wakeup_start))
ACPI_HAVE_ARCH_SET_ROOT_POINTER 
ACPI_HAVE_ARCH_GET_ROOT_POINTER 
ARCH_HAS_POWER_INIT 1
acpi_unlazy_tlb() leave_mm()
ACPI_TABLE_UPGRADE_MAX_PHYS (max_low_pfn_mapped << PAGE_SHIFT)
VSYSCALL_ADDR (-10UL << 20)
FIXADDR_TOP (round_up(VSYSCALL_ADDR + PAGE_SIZE, 1<<PMD_SHIFT) - PAGE_SIZE)
NR_FIX_BTMAPS 64
FIX_BTMAPS_SLOTS 8
TOTAL_FIX_BTMAPS (NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
FIXADDR_SIZE (__end_of_permanent_fixed_addresses << PAGE_SHIFT)
FIXADDR_START (FIXADDR_TOP - FIXADDR_SIZE)
FIXADDR_TOT_SIZE (__end_of_fixed_addresses << PAGE_SHIFT)
FIXADDR_TOT_START (FIXADDR_TOP - FIXADDR_TOT_SIZE)
kmap_prot PAGE_KERNEL
FIXMAP_PAGE_NOCACHE PAGE_KERNEL_IO_NOCACHE
__fix_to_virt() (FIXADDR_TOP - (() << PAGE_SHIFT))
__virt_to_fix() ((FIXADDR_TOP - (()&PAGE_MASK)) >> PAGE_SHIFT)
FIXMAP_PAGE_NORMAL PAGE_KERNEL
FIXMAP_PAGE_RO PAGE_KERNEL_RO
FIXMAP_PAGE_IO PAGE_KERNEL_IO
FIXMAP_PAGE_CLEAR __pgprot(0)
set_fixmap(,) __set_fixmap(, , FIXMAP_PAGE_NORMAL)
clear_fixmap() __set_fixmap(, 0, FIXMAP_PAGE_CLEAR)
__set_fixmap_offset(,,) \
({ unsigned long ________addr; __set_fixmap(, , ); ________addr = fix_to_virt() + (() & (PAGE_SIZE - 1)); ________addr; \
})
set_fixmap_offset(,) __set_fixmap_offset(, , FIXMAP_PAGE_NORMAL)
set_fixmap_nocache(,) __set_fixmap(, , FIXMAP_PAGE_NOCACHE)
set_fixmap_offset_nocache(,) __set_fixmap_offset(, , FIXMAP_PAGE_NOCACHE)
set_fixmap_io(,) __set_fixmap(, , FIXMAP_PAGE_IO)
set_fixmap_offset_io(,) __set_fixmap_offset(, , FIXMAP_PAGE_IO)
__late_set_fixmap(,,) __set_fixmap(, , )
__late_clear_fixmap() __set_fixmap(, 0, __pgprot(0))
__ARCH_IRQ_STAT 
inc_irq_stat() this_cpu_inc(irq_stat.)
arch_irq_stat_cpu arch_irq_stat_cpu
arch_irq_stat arch_irq_stat
ARCH_APICTIMER_STOPS_ON_C3 1
APIC_QUIET 0
APIC_VERBOSE 1
APIC_DEBUG 2
APIC_EXTNMI_BSP 0
APIC_EXTNMI_ALL 1
APIC_EXTNMI_NONE 2
apic_printk(,,) do { if (() <= apic_verbosity) printk(, ##); } while (0)
x2apic_supported() (boot_cpu_has(X86_FEATURE_X2APIC))
apic_driver() static const struct apic *__apicdrivers_## __used __aligned(sizeof(struct apic *)) __section(.apicdrivers) = { & }
apic_drivers(,) static struct apic *__apicdrivers_####[2] __used __aligned(sizeof(struct apic *)) __section(.apicdrivers) = { &, & }
TRAMPOLINE_PHYS_LOW 0x467
TRAMPOLINE_PHYS_HIGH 0x469
APIC_DFR_VALUE (APIC_DFR_FLAT)
NMI_VECTOR 0x02
MCE_VECTOR 0x12
FIRST_EXTERNAL_VECTOR 0x20
IRQ_MOVE_CLEANUP_VECTOR FIRST_EXTERNAL_VECTOR
IA32_SYSCALL_VECTOR 0x80
ISA_IRQ_VECTOR() (((FIRST_EXTERNAL_VECTOR + 16) & ~15) + )
SPURIOUS_APIC_VECTOR 0xff
ERROR_APIC_VECTOR 0xfe
RESCHEDULE_VECTOR 0xfd
CALL_FUNCTION_VECTOR 0xfc
CALL_FUNCTION_SINGLE_VECTOR 0xfb
THERMAL_APIC_VECTOR 0xfa
THRESHOLD_APIC_VECTOR 0xf9
REBOOT_VECTOR 0xf8
X86_PLATFORM_IPI_VECTOR 0xf7
IRQ_WORK_VECTOR 0xf6
UV_BAU_MESSAGE 0xf5
DEFERRED_ERROR_VECTOR 0xf4
HYPERVISOR_CALLBACK_VECTOR 0xf3
POSTED_INTR_VECTOR 0xf2
POSTED_INTR_WAKEUP_VECTOR 0xf1
POSTED_INTR_NESTED_VECTOR 0xf0
MANAGED_IRQ_SHUTDOWN_VECTOR 0xef
HYPERV_REENLIGHTENMENT_VECTOR 0xee
HYPERV_STIMER0_VECTOR 0xed
LOCAL_TIMER_VECTOR 0xec
NR_VECTORS 256
FIRST_SYSTEM_VECTOR LOCAL_TIMER_VECTOR
NR_IRQS_LEGACY 16
CPU_VECTOR_LIMIT (64 * NR_CPUS)
IO_APIC_VECTOR_LIMIT (32 * MAX_IO_APICS)
NR_IRQS (CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ? (NR_VECTORS + CPU_VECTOR_LIMIT) : (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
IO_APIC_REDIR_VECTOR_MASK 0x000FF
IO_APIC_REDIR_DEST_LOGICAL 0x00800
IO_APIC_REDIR_DEST_PHYSICAL 0x00000
IO_APIC_REDIR_SEND_PENDING (1 << 12)
IO_APIC_REDIR_REMOTE_IRR (1 << 14)
IO_APIC_REDIR_LEVEL_TRIGGER (1 << 15)
IO_APIC_REDIR_MASKED (1 << 16)
IOAPIC_AUTO -1
IOAPIC_EDGE 0
IOAPIC_LEVEL 1
IOAPIC_MASKED 1
IOAPIC_UNMASKED 0
IOAPIC_POL_HIGH 0
IOAPIC_POL_LOW 1
IOAPIC_DEST_MODE_PHYSICAL 0
IOAPIC_DEST_MODE_LOGICAL 1
IOAPIC_MAP_ALLOC 0x1
IOAPIC_MAP_CHECK 0x2
IO_APIC_IRQ() ((() >= NR_IRQS_LEGACY) || ((1 << ()) & io_apic_irqs))
io_apic_assign_pci_irqs (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
cpu_physical_id() per_cpu(x86_cpu_to_apicid, )
cpu_acpi_id() per_cpu(x86_cpu_to_acpiid, )
raw_smp_processor_id() this_cpu_read(cpu_number)
__smp_processor_id() __this_cpu_read(cpu_number)
safe_smp_processor_id() smp_processor_id()
nmi_selftest() do { } while (0)
NODE_DATA() (node_data[])
for_each_online_pgdat() for ( = first_online_pgdat(); ;  = next_online_pgdat())
for_each_zone() for ( = (first_online_pgdat())->node_zones; ;  = next_zone())
for_each_populated_zone() for ( = (first_online_pgdat())->node_zones; ;  = next_zone()) if (!populated_zone()) ; /* do nothing */ else
for_each_zone_zonelist_nodemask(,,,,) for ( = first_zones_zonelist(, , ),  = zonelist_zone(); ;  = next_zones_zonelist(++, , ),  = zonelist_zone())
for_next_zone_zonelist_nodemask(,,,,) for ( = ->; ;  = next_zones_zonelist(++, , ),  = zonelist_zone())
for_each_zone_zonelist(,,,) for_each_zone_zonelist_nodemask(, , , , NULL)
PA_SECTION_SHIFT (SECTION_SIZE_BITS)
PFN_SECTION_SHIFT (SECTION_SIZE_BITS - PAGE_SHIFT)
NR_MEM_SECTIONS (1UL << SECTIONS_SHIFT)
PAGES_PER_SECTION (1UL << PFN_SECTION_SHIFT)
PAGE_SECTION_MASK (~(PAGES_PER_SECTION-1))
SECTION_BLOCKFLAGS_BITS ((1UL << (PFN_SECTION_SHIFT - pageblock_order)) * NR_PAGEBLOCK_BITS)
SECTION_ALIGN_UP() ((() + PAGES_PER_SECTION - 1) & PAGE_SECTION_MASK)
SECTION_ALIGN_DOWN() (() & PAGE_SECTION_MASK)
SUBSECTION_SHIFT 21
PFN_SUBSECTION_SHIFT (SUBSECTION_SHIFT - PAGE_SHIFT)
PAGES_PER_SUBSECTION (1UL << PFN_SUBSECTION_SHIFT)
PAGE_SUBSECTION_MASK (~(PAGES_PER_SUBSECTION-1))
SUBSECTIONS_PER_SECTION (1UL << (SECTION_SIZE_BITS - SUBSECTION_SHIFT))
SUBSECTION_ALIGN_UP() ALIGN((), PAGES_PER_SUBSECTION)
SUBSECTION_ALIGN_DOWN() (() & PAGE_SUBSECTION_MASK)
SECTIONS_PER_ROOT (PAGE_SIZE / sizeof (struct mem_section))
SECTION_NR_TO_ROOT() (() / SECTIONS_PER_ROOT)
NR_SECTION_ROOTS DIV_ROUND_UP(NR_MEM_SECTIONS, SECTIONS_PER_ROOT)
SECTION_ROOT_MASK (SECTIONS_PER_ROOT - 1)
SECTION_MARKED_PRESENT (1UL<<0)
SECTION_HAS_MEM_MAP (1UL<<1)
SECTION_IS_ONLINE (1UL<<2)
SECTION_IS_EARLY (1UL<<3)
SECTION_MAP_LAST_BIT (1UL<<4)
SECTION_MAP_MASK (~(SECTION_MAP_LAST_BIT-1))
SECTION_NID_SHIFT 3
pfn_to_nid() \
({ unsigned long __pfn_to_nid_pfn = (); page_to_nid(pfn_to_page(__pfn_to_nid_pfn)); \
})
early_pfn_valid() pfn_valid()
pfn_valid_within() (1)
generic_smp_call_function_interrupt generic_smp_call_function_single_interrupt
smp_processor_id() __smp_processor_id()
get_cpu() ({ preempt_disable(); __smp_processor_id(); })
put_cpu() preempt_enable()
PERCPU_MODULE_RESERVE (8 << 10)
PCPU_MIN_UNIT_SIZE PFN_ALIGN(32 << 10)
PCPU_MIN_ALLOC_SHIFT 2
PCPU_MIN_ALLOC_SIZE (1 << PCPU_MIN_ALLOC_SHIFT)
PCPU_BITMAP_BLOCK_SIZE PAGE_SIZE
PCPU_BITMAP_BLOCK_BITS (PCPU_BITMAP_BLOCK_SIZE >> PCPU_MIN_ALLOC_SHIFT)
PERCPU_DYNAMIC_EARLY_SLOTS 128
PERCPU_DYNAMIC_EARLY_SIZE (12 << 10)
PERCPU_DYNAMIC_RESERVE (28 << 10)
alloc_percpu_gfp(,) (typeof() __percpu *)__alloc_percpu_gfp(sizeof(), __alignof__(), )
alloc_percpu() (typeof() __percpu *)__alloc_percpu(sizeof(), __alignof__())
nr_cpus_node() cpumask_weight(cpumask_of_node())
for_each_node_with_cpus() for_each_online_node() if (nr_cpus_node())
LOCAL_DISTANCE 10
REMOTE_DISTANCE 20
DISTANCE_BITS 8
RECLAIM_DISTANCE 30
PENALTY_FOR_NODE_WITH_CPUS (1)
___GFP_DMA 0x01u
___GFP_HIGHMEM 0x02u
___GFP_DMA32 0x04u
___GFP_MOVABLE 0x08u
___GFP_RECLAIMABLE 0x10u
___GFP_HIGH 0x20u
___GFP_IO 0x40u
___GFP_FS 0x80u
___GFP_ZERO 0x100u
___GFP_ATOMIC 0x200u
___GFP_DIRECT_RECLAIM 0x400u
___GFP_KSWAPD_RECLAIM 0x800u
___GFP_WRITE 0x1000u
___GFP_NOWARN 0x2000u
___GFP_RETRY_MAYFAIL 0x4000u
___GFP_NOFAIL 0x8000u
___GFP_NORETRY 0x10000u
___GFP_MEMALLOC 0x20000u
___GFP_COMP 0x40000u
___GFP_NOMEMALLOC 0x80000u
___GFP_HARDWALL 0x100000u
___GFP_THISNODE 0x200000u
___GFP_ACCOUNT 0x400000u
___GFP_NOLOCKDEP 0
__GFP_DMA ((__force gfp_t)___GFP_DMA)
__GFP_HIGHMEM ((__force gfp_t)___GFP_HIGHMEM)
__GFP_DMA32 ((__force gfp_t)___GFP_DMA32)
__GFP_MOVABLE ((__force gfp_t)___GFP_MOVABLE)
GFP_ZONEMASK (__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)
__GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)
__GFP_WRITE ((__force gfp_t)___GFP_WRITE)
__GFP_HARDWALL ((__force gfp_t)___GFP_HARDWALL)
__GFP_THISNODE ((__force gfp_t)___GFP_THISNODE)
__GFP_ACCOUNT ((__force gfp_t)___GFP_ACCOUNT)
__GFP_ATOMIC ((__force gfp_t)___GFP_ATOMIC)
__GFP_HIGH ((__force gfp_t)___GFP_HIGH)
__GFP_MEMALLOC ((__force gfp_t)___GFP_MEMALLOC)
__GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)
__GFP_IO ((__force gfp_t)___GFP_IO)
__GFP_FS ((__force gfp_t)___GFP_FS)
__GFP_DIRECT_RECLAIM ((__force gfp_t)___GFP_DIRECT_RECLAIM)
__GFP_KSWAPD_RECLAIM ((__force gfp_t)___GFP_KSWAPD_RECLAIM)
__GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))
__GFP_RETRY_MAYFAIL ((__force gfp_t)___GFP_RETRY_MAYFAIL)
__GFP_NOFAIL ((__force gfp_t)___GFP_NOFAIL)
__GFP_NORETRY ((__force gfp_t)___GFP_NORETRY)
__GFP_NOWARN ((__force gfp_t)___GFP_NOWARN)
__GFP_COMP ((__force gfp_t)___GFP_COMP)
__GFP_ZERO ((__force gfp_t)___GFP_ZERO)
__GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)
__GFP_BITS_SHIFT (23 + IS_ENABLED(CONFIG_LOCKDEP))
__GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
GFP_ATOMIC (__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)
GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)
GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)
GFP_NOWAIT (__GFP_KSWAPD_RECLAIM)
GFP_NOIO (__GFP_RECLAIM)
GFP_NOFS (__GFP_RECLAIM | __GFP_IO)
GFP_USER (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
GFP_DMA __GFP_DMA
GFP_DMA32 __GFP_DMA32
GFP_HIGHUSER (GFP_USER | __GFP_HIGHMEM)
GFP_HIGHUSER_MOVABLE (GFP_HIGHUSER | __GFP_MOVABLE)
GFP_TRANSHUGE_LIGHT ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) & ~__GFP_RECLAIM)
GFP_TRANSHUGE (GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)
GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)
GFP_MOVABLE_SHIFT 3
OPT_ZONE_HIGHMEM ZONE_NORMAL
OPT_ZONE_DMA ZONE_DMA
OPT_ZONE_DMA32 ZONE_DMA32
GFP_ZONES_SHIFT 2
GFP_ZONE_TABLE ( (ZONE_NORMAL << 0 * GFP_ZONES_SHIFT) | (OPT_ZONE_DMA << ___GFP_DMA * GFP_ZONES_SHIFT) | (OPT_ZONE_HIGHMEM << ___GFP_HIGHMEM * GFP_ZONES_SHIFT) | (OPT_ZONE_DMA32 << ___GFP_DMA32 * GFP_ZONES_SHIFT) | (ZONE_NORMAL << ___GFP_MOVABLE * GFP_ZONES_SHIFT) | (OPT_ZONE_DMA << (___GFP_MOVABLE | ___GFP_DMA) * GFP_ZONES_SHIFT) | (ZONE_MOVABLE << (___GFP_MOVABLE | ___GFP_HIGHMEM) * GFP_ZONES_SHIFT) | (OPT_ZONE_DMA32 << (___GFP_MOVABLE | ___GFP_DMA32) * GFP_ZONES_SHIFT)\
)
GFP_ZONE_BAD ( 1 << (___GFP_DMA | ___GFP_HIGHMEM) | 1 << (___GFP_DMA | ___GFP_DMA32) | 1 << (___GFP_DMA32 | ___GFP_HIGHMEM) | 1 << (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM) | 1 << (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA) | 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA) | 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM) | 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM) \
)
alloc_hugepage_vma(,,,) alloc_pages_vma(, , , , numa_node_id(), true)
alloc_page() alloc_pages(, 0)
alloc_page_vma(,,) alloc_pages_vma(, 0, , , numa_node_id(), false)
alloc_page_vma_node(,,,) alloc_pages_vma(, 0, , , , false)
__get_free_page() __get_free_pages((), 0)
__get_dma_pages(,) __get_free_pages(() | GFP_DMA, ())
__free_page() __free_pages((), 0)
free_page() free_pages((), 0)
CTL_MAXNAME 10
SYSCTL_ZERO ((void *)&sysctl_vals[0])
SYSCTL_ONE ((void *)&sysctl_vals[1])
SYSCTL_INT_MAX ((void *)&sysctl_vals[2])
__CTL_TABLE_POLL_INITIALIZER() { .event = ATOMIC_INIT(0), .wait = __WAIT_QUEUE_HEAD_INITIALIZER(.wait) }
DEFINE_CTL_TABLE_POLL() struct ctl_table_poll  = __CTL_TABLE_POLL_INITIALIZER()
register_sysctl_init(,) __register_sysctl_init(, , #)
UMH_NO_WAIT 0
UMH_WAIT_EXEC 1
UMH_WAIT_PROC 2
UMH_KILLABLE 4
KMOD_PATH_LEN 256
request_module() __request_module(true, )
request_module_nowait() __request_module(false, )
try_then_request_module(,) (() ?: (__request_module(true, ), ()))
NBPG PAGE_SIZE
UPAGES 1
HOST_TEXT_START_ADDR (u.start_code)
HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
USER_XSTATE_FX_SW_WORDS 6
USER_XSTATE_XCR0_WORD 0
ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
R_X86_64_NONE 0
R_X86_64_64 1
R_X86_64_PC32 2
R_X86_64_GOT32 3
R_X86_64_PLT32 4
R_X86_64_COPY 5
R_X86_64_GLOB_DAT 6
R_X86_64_JUMP_SLOT 7
R_X86_64_RELATIVE 8
R_X86_64_GOTPCREL 9
R_X86_64_32 10
R_X86_64_32S 11
R_X86_64_16 12
R_X86_64_PC16 13
R_X86_64_8 14
R_X86_64_PC8 15
R_X86_64_PC64 24
ELF_CLASS ELFCLASS64
ELF_DATA ELFDATA2LSB
ELF_ARCH EM_X86_64
elf_check_arch_ia32() ((()->e_machine == EM_386) || (()->e_machine == EM_486))
elf_check_arch() (()->e_machine == EM_X86_64)
compat_elf_check_arch() (elf_check_arch_ia32() || (IS_ENABLED(CONFIG_X86_X32_ABI) && ()->e_machine == EM_X86_64))
ELF_PLAT_INIT(,) elf_common_init(&current->thread, , 0)
COMPAT_ELF_PLAT_INIT(,) elf_common_init(&current->thread, , __USER_DS)
compat_start_thread compat_start_thread
COMPAT_SET_PERSONALITY() set_personality_ia32(().e_machine == EM_X86_64)
COMPAT_ELF_PLATFORM ("i686")
ELF_CORE_COPY_REGS(,) do { unsigned v; ()[0] = ()->r15; ()[1] = ()->r14; ()[2] = ()->r13; ()[3] = ()->r12; ()[4] = ()->bp; ()[5] = ()->bx; ()[6] = ()->r11; ()[7] = ()->r10; ()[8] = ()->r9; ()[9] = ()->r8; ()[10] = ()->ax; ()[11] = ()->cx; ()[12] = ()->dx; ()[13] = ()->si; ()[14] = ()->di; ()[15] = ()->orig_ax; ()[16] = ()->ip; ()[17] = ()->cs; ()[18] = ()->flags; ()[19] = ()->sp; ()[20] = ()->ss; ()[21] = x86_fsbase_read_cpu(); ()[22] = x86_gsbase_read_cpu_inactive(); asm("movl %%ds,%0" : "=r" (v)); ()[23] = v; asm("movl %%es,%0" : "=r" (v)); ()[24] = v; asm("movl %%fs,%0" : "=r" (v)); ()[25] = v; asm("movl %%gs,%0" : "=r" (v)); ()[26] = v; \
} while (0);
ELF_PLATFORM ("x86_64")
CORE_DUMP_USE_REGSET 
ELF_EXEC_PAGESIZE 4096
ELF_ET_DYN_BASE (mmap_is_ia32() ? 0x000400000UL : (DEFAULT_MAP_WINDOW / 3 * 2))
ELF_HWCAP (boot_cpu_data.x86_capability[CPUID_1_EDX])
ELF_HWCAP2 (elf_hwcap2)
SET_PERSONALITY() set_personality_64bit()
elf_read_implies_exec(,) ( != EXSTACK_DISABLE_X)
ARCH_DLINFO_IA32 do { if (VDSO_CURRENT_BASE) { NEW_AUX_ENT(AT_SYSINFO, VDSO_ENTRY); NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE); } \
} while (0)
__STACK_RND_MASK() (() ? 0x7ff : 0x3fffff)
STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())
ARCH_DLINFO do { if (vdso64_enabled) NEW_AUX_ENT(AT_SYSINFO_EHDR, (unsigned long __force)current->mm->context.vdso); \
} while (0)
ARCH_DLINFO_X32 do { if (vdso64_enabled) NEW_AUX_ENT(AT_SYSINFO_EHDR, (unsigned long __force)current->mm->context.vdso); \
} while (0)
AT_SYSINFO 32
COMPAT_ARCH_DLINFO if (test_thread_flag(TIF_X32)) ARCH_DLINFO_X32; else ARCH_DLINFO_IA32
COMPAT_ELF_ET_DYN_BASE (TASK_UNMAPPED_BASE + 0x1000000)
VDSO_CURRENT_BASE ((unsigned long)current->mm->context.vdso)
VDSO_ENTRY ((unsigned long)current->mm->context.vdso + vdso_image_32.sym___kernel_vsyscall)
ARCH_HAS_SETUP_ADDITIONAL_PAGES 1
compat_arch_setup_additional_pages compat_arch_setup_additional_pages
EM_NONE 0
EM_M32 1
EM_SPARC 2
EM_386 3
EM_68K 4
EM_88K 5
EM_486 6
EM_860 7
EM_MIPS 8
EM_MIPS_RS3_LE 10
EM_MIPS_RS4_BE 10
EM_PARISC 15
EM_SPARC32PLUS 18
EM_PPC 20
EM_PPC64 21
EM_SPU 23
EM_ARM 40
EM_SH 42
EM_SPARCV9 43
EM_H8_300 46
EM_IA_64 50
EM_X86_64 62
EM_S390 22
EM_CRIS 76
EM_M32R 88
EM_MN10300 89
EM_OPENRISC 92
EM_ARCOMPACT 93
EM_XTENSA 94
EM_BLACKFIN 106
EM_UNICORE 110
EM_ALTERA_NIOS2 113
EM_TI_C6000 140
EM_HEXAGON 164
EM_NDS32 167
EM_AARCH64 183
EM_TILEPRO 188
EM_MICROBLAZE 189
EM_TILEGX 191
EM_ARCV2 195
EM_RISCV 243
EM_BPF 247
EM_CSKY 252
EM_FRV 0x5441
EM_ALPHA 0x9026
EM_CYGNUS_M32R 0x9041
EM_S390_OLD 0xA390
EM_CYGNUS_MN10300 0xbeef
PT_NULL 0
PT_LOAD 1
PT_DYNAMIC 2
PT_INTERP 3
PT_NOTE 4
PT_SHLIB 5
PT_PHDR 6
PT_TLS 7
PT_LOOS 0x60000000
PT_HIOS 0x6fffffff
PT_LOPROC 0x70000000
PT_HIPROC 0x7fffffff
PT_GNU_EH_FRAME 0x6474e550
PT_GNU_STACK (PT_LOOS + 0x474e551)
PN_XNUM 0xffff
ET_NONE 0
ET_REL 1
ET_EXEC 2
ET_DYN 3
ET_CORE 4
ET_LOPROC 0xff00
ET_HIPROC 0xffff
DT_NULL 0
DT_NEEDED 1
DT_PLTRELSZ 2
DT_PLTGOT 3
DT_HASH 4
DT_STRTAB 5
DT_SYMTAB 6
DT_RELA 7
DT_RELASZ 8
DT_RELAENT 9
DT_STRSZ 10
DT_SYMENT 11
DT_INIT 12
DT_FINI 13
DT_SONAME 14
DT_RPATH 15
DT_SYMBOLIC 16
DT_REL 17
DT_RELSZ 18
DT_RELENT 19
DT_PLTREL 20
DT_DEBUG 21
DT_TEXTREL 22
DT_JMPREL 23
DT_ENCODING 32
OLD_DT_LOOS 0x60000000
DT_LOOS 0x6000000d
DT_HIOS 0x6ffff000
DT_VALRNGLO 0x6ffffd00
DT_VALRNGHI 0x6ffffdff
DT_ADDRRNGLO 0x6ffffe00
DT_ADDRRNGHI 0x6ffffeff
DT_VERSYM 0x6ffffff0
DT_RELACOUNT 0x6ffffff9
DT_RELCOUNT 0x6ffffffa
DT_FLAGS_1 0x6ffffffb
DT_VERDEF 0x6ffffffc
DT_VERDEFNUM 0x6ffffffd
DT_VERNEED 0x6ffffffe
DT_VERNEEDNUM 0x6fffffff
OLD_DT_HIOS 0x6fffffff
DT_LOPROC 0x70000000
DT_HIPROC 0x7fffffff
STB_LOCAL 0
STB_GLOBAL 1
STB_WEAK 2
STT_NOTYPE 0
STT_OBJECT 1
STT_FUNC 2
STT_SECTION 3
STT_FILE 4
STT_COMMON 5
STT_TLS 6
ELF_ST_BIND() (() >> 4)
ELF_ST_TYPE() (((unsigned int) ) & 0xf)
ELF32_ST_BIND() ELF_ST_BIND()
ELF32_ST_TYPE() ELF_ST_TYPE()
ELF64_ST_BIND() ELF_ST_BIND()
ELF64_ST_TYPE() ELF_ST_TYPE()
ELF32_R_SYM() (() >> 8)
ELF32_R_TYPE() (() & 0xff)
ELF64_R_SYM() (() >> 32)
ELF64_R_TYPE() (() & 0xffffffff)
EI_NIDENT 16
PF_R 0x4
PF_W 0x2
PF_X 0x1
SHT_NULL 0
SHT_PROGBITS 1
SHT_SYMTAB 2
SHT_STRTAB 3
SHT_RELA 4
SHT_HASH 5
SHT_DYNAMIC 6
SHT_NOTE 7
SHT_NOBITS 8
SHT_REL 9
SHT_SHLIB 10
SHT_DYNSYM 11
SHT_NUM 12
SHT_LOPROC 0x70000000
SHT_HIPROC 0x7fffffff
SHT_LOUSER 0x80000000
SHT_HIUSER 0xffffffff
SHF_WRITE 0x1
SHF_ALLOC 0x2
SHF_EXECINSTR 0x4
SHF_RELA_LIVEPATCH 0x00100000
SHF_RO_AFTER_INIT 0x00200000
SHF_MASKPROC 0xf0000000
SHN_UNDEF 0
SHN_LORESERVE 0xff00
SHN_LOPROC 0xff00
SHN_HIPROC 0xff1f
SHN_LIVEPATCH 0xff20
SHN_ABS 0xfff1
SHN_COMMON 0xfff2
SHN_HIRESERVE 0xffff
EI_MAG0 0
EI_MAG1 1
EI_MAG2 2
EI_MAG3 3
EI_CLASS 4
EI_DATA 5
EI_VERSION 6
EI_OSABI 7
EI_PAD 8
ELFMAG0 0x7f
ELFMAG1 'E'
ELFMAG2 'L'
ELFMAG3 'F'
ELFMAG "\177ELF"
SELFMAG 4
ELFCLASSNONE 0
ELFCLASS32 1
ELFCLASS64 2
ELFCLASSNUM 3
ELFDATANONE 0
ELFDATA2LSB 1
ELFDATA2MSB 2
EV_NONE 0
EV_CURRENT 1
EV_NUM 2
ELFOSABI_NONE 0
ELFOSABI_LINUX 3
ELF_OSABI ELFOSABI_NONE
NT_PRSTATUS 1
NT_PRFPREG 2
NT_PRPSINFO 3
NT_TASKSTRUCT 4
NT_AUXV 6
NT_SIGINFO 0x53494749
NT_FILE 0x46494c45
NT_PRXFPREG 0x46e62b7f
NT_PPC_VMX 0x100
NT_PPC_SPE 0x101
NT_PPC_VSX 0x102
NT_PPC_TAR 0x103
NT_PPC_PPR 0x104
NT_PPC_DSCR 0x105
NT_PPC_EBB 0x106
NT_PPC_PMU 0x107
NT_PPC_TM_CGPR 0x108
NT_PPC_TM_CFPR 0x109
NT_PPC_TM_CVMX 0x10a
NT_PPC_TM_CVSX 0x10b
NT_PPC_TM_SPR 0x10c
NT_PPC_TM_CTAR 0x10d
NT_PPC_TM_CPPR 0x10e
NT_PPC_TM_CDSCR 0x10f
NT_PPC_PKEY 0x110
NT_386_TLS 0x200
NT_386_IOPERM 0x201
NT_X86_XSTATE 0x202
NT_S390_HIGH_GPRS 0x300
NT_S390_TIMER 0x301
NT_S390_TODCMP 0x302
NT_S390_TODPREG 0x303
NT_S390_CTRS 0x304
NT_S390_PREFIX 0x305
NT_S390_LAST_BREAK 0x306
NT_S390_SYSTEM_CALL 0x307
NT_S390_TDB 0x308
NT_S390_VXRS_LOW 0x309
NT_S390_VXRS_HIGH 0x30a
NT_S390_GS_CB 0x30b
NT_S390_GS_BC 0x30c
NT_S390_RI_CB 0x30d
NT_ARM_VFP 0x400
NT_ARM_TLS 0x401
NT_ARM_HW_BREAK 0x402
NT_ARM_HW_WATCH 0x403
NT_ARM_SYSTEM_CALL 0x404
NT_ARM_SVE 0x405
NT_ARM_PAC_MASK 0x406
NT_ARM_PACA_KEYS 0x407
NT_ARM_PACG_KEYS 0x408
NT_ARC_V2 0x600
NT_VMCOREDD 0x700
NT_MIPS_DSP 0x800
NT_MIPS_FP_MODE 0x801
NT_MIPS_MSA 0x802
SET_PERSONALITY2(,) SET_PERSONALITY()
elfhdr elf64_hdr
elf_phdr elf64_phdr
elf_shdr elf64_shdr
elf_note elf64_note
elf_addr_t Elf64_Off
Elf_Half Elf64_Half
Elf_Word Elf64_Word
BITS_PER_XA_VALUE (BITS_PER_LONG - 1)
XA_ZERO_ENTRY xa_mk_internal(257)
XA_LIMIT(,) (struct xa_limit) { .min = , .max =  }
xa_limit_32b XA_LIMIT(0, UINT_MAX)
xa_limit_31b XA_LIMIT(0, INT_MAX)
XA_MARK_0 ((__force xa_mark_t)0U)
XA_MARK_1 ((__force xa_mark_t)1U)
XA_MARK_2 ((__force xa_mark_t)2U)
XA_PRESENT ((__force xa_mark_t)8U)
XA_MARK_MAX XA_MARK_2
XA_FREE_MARK XA_MARK_0
XA_FLAGS_LOCK_IRQ ((__force gfp_t)XA_LOCK_IRQ)
XA_FLAGS_LOCK_BH ((__force gfp_t)XA_LOCK_BH)
XA_FLAGS_TRACK_FREE ((__force gfp_t)4U)
XA_FLAGS_ZERO_BUSY ((__force gfp_t)8U)
XA_FLAGS_ALLOC_WRAPPED ((__force gfp_t)16U)
XA_FLAGS_ACCOUNT ((__force gfp_t)32U)
XA_FLAGS_MARK() ((__force gfp_t)((1U << __GFP_BITS_SHIFT) << (__force unsigned)()))
XA_FLAGS_ALLOC (XA_FLAGS_TRACK_FREE | XA_FLAGS_MARK(XA_FREE_MARK))
XA_FLAGS_ALLOC1 (XA_FLAGS_TRACK_FREE | XA_FLAGS_ZERO_BUSY)
XARRAY_INIT(,) { .xa_lock = __SPIN_LOCK_UNLOCKED(.xa_lock), .xa_flags = , .xa_head = NULL, \
}
DEFINE_XARRAY_FLAGS(,) struct xarray  = XARRAY_INIT(, )
DEFINE_XARRAY() DEFINE_XARRAY_FLAGS(, 0)
DEFINE_XARRAY_ALLOC() DEFINE_XARRAY_FLAGS(, XA_FLAGS_ALLOC)
DEFINE_XARRAY_ALLOC1() DEFINE_XARRAY_FLAGS(, XA_FLAGS_ALLOC1)
xa_for_each_start(,,,) for ( = ,  = xa_find(, &, ULONG_MAX, XA_PRESENT); ;  = xa_find_after(, &, ULONG_MAX, XA_PRESENT))
xa_for_each(,,) xa_for_each_start(, , , 0)
xa_for_each_marked(,,,) for ( = 0,  = xa_find(, &, ULONG_MAX, ); ;  = xa_find_after(, &, ULONG_MAX, ))
xa_trylock() spin_trylock(&()->xa_lock)
xa_lock() spin_lock(&()->xa_lock)
xa_unlock() spin_unlock(&()->xa_lock)
xa_lock_bh() spin_lock_bh(&()->xa_lock)
xa_unlock_bh() spin_unlock_bh(&()->xa_lock)
xa_lock_irq() spin_lock_irq(&()->xa_lock)
xa_unlock_irq() spin_unlock_irq(&()->xa_lock)
xa_lock_irqsave(,) spin_lock_irqsave(&()->xa_lock, )
xa_unlock_irqrestore(,) spin_unlock_irqrestore(&()->xa_lock, )
XA_CHUNK_SHIFT (CONFIG_BASE_SMALL ? 4 : 6)
XA_CHUNK_SIZE (1UL << XA_CHUNK_SHIFT)
XA_CHUNK_MASK (XA_CHUNK_SIZE - 1)
XA_MAX_MARKS 3
XA_MARK_LONGS DIV_ROUND_UP(XA_CHUNK_SIZE, BITS_PER_LONG)
XA_BUG_ON(,) do { } while (0)
XA_NODE_BUG_ON(,) do { } while (0)
XA_RETRY_ENTRY xa_mk_internal(256)
XA_ERROR() ((struct xa_node *)(((unsigned long) << 2) | 2UL))
XAS_BOUNDS ((struct xa_node *)1UL)
XAS_RESTART ((struct xa_node *)3UL)
__XA_STATE(,,,) { .xa = , .xa_index = , .xa_shift = , .xa_sibs = , .xa_offset = 0, .xa_pad = 0, .xa_node = XAS_RESTART, .xa_alloc = NULL, .xa_update = NULL \
}
XA_STATE(,,) struct xa_state  = __XA_STATE(, , 0, 0)
XA_STATE_ORDER(,,,) struct xa_state  = __XA_STATE(, ( >> ) << ,  - ( % XA_CHUNK_SHIFT), (1U << ( % XA_CHUNK_SHIFT)) - 1)
xas_marked(,) xa_marked(()->xa, ())
xas_trylock() xa_trylock(()->xa)
xas_lock() xa_lock(()->xa)
xas_unlock() xa_unlock(()->xa)
xas_lock_bh() xa_lock_bh(()->xa)
xas_unlock_bh() xa_unlock_bh(()->xa)
xas_lock_irq() xa_lock_irq(()->xa)
xas_unlock_irq() xa_unlock_irq(()->xa)
xas_lock_irqsave(,) xa_lock_irqsave(()->xa, )
xas_unlock_irqrestore(,) xa_unlock_irqrestore(()->xa, )
xas_for_each(,,) for ( = xas_find(, ); ;  = xas_next_entry(, ))
xas_for_each_marked(,,,) for ( = xas_find_marked(, , ); ;  = xas_next_marked(, , ))
xas_for_each_conflict(,) while (( = xas_find_conflict()))
radix_tree_root xarray
radix_tree_node xa_node
RADIX_TREE_ENTRY_MASK 3UL
RADIX_TREE_INTERNAL_NODE 2UL
RADIX_TREE_MAP_SHIFT XA_CHUNK_SHIFT
RADIX_TREE_MAP_SIZE (1UL << RADIX_TREE_MAP_SHIFT)
RADIX_TREE_MAP_MASK (RADIX_TREE_MAP_SIZE-1)
RADIX_TREE_MAX_TAGS XA_MAX_MARKS
RADIX_TREE_TAG_LONGS XA_MARK_LONGS
RADIX_TREE_INDEX_BITS (8 /* CHAR_BIT */ * sizeof(unsigned long))
RADIX_TREE_MAX_PATH (DIV_ROUND_UP(RADIX_TREE_INDEX_BITS, RADIX_TREE_MAP_SHIFT))
ROOT_IS_IDR ((__force gfp_t)4)
ROOT_TAG_SHIFT (__GFP_BITS_SHIFT)
RADIX_TREE_INIT(,) XARRAY_INIT(, )
RADIX_TREE(,) struct radix_tree_root  = RADIX_TREE_INIT(, )
INIT_RADIX_TREE(,) xa_init_flags(, )
radix_tree_for_each_slot(,,,) for ( = radix_tree_iter_init(, ) ;  || ( = radix_tree_next_chunk(, , 0)) ;  = radix_tree_next_slot(, , 0))
radix_tree_for_each_tagged(,,,,) for ( = radix_tree_iter_init(, ) ;  || ( = radix_tree_next_chunk(, , RADIX_TREE_ITER_TAGGED | )) ;  = radix_tree_next_slot(, , RADIX_TREE_ITER_TAGGED | ))
IDR_FREE 0
IDR_RT_MARKER (ROOT_IS_IDR | (__force gfp_t) (1 << (ROOT_TAG_SHIFT + IDR_FREE)))
IDR_INIT_BASE(,) { .idr_rt = RADIX_TREE_INIT(, IDR_RT_MARKER), .idr_base = (), .idr_next = 0, \
}
IDR_INIT() IDR_INIT_BASE(, 0)
DEFINE_IDR() struct idr  = IDR_INIT()
idr_lock() xa_lock(&()->idr_rt)
idr_unlock() xa_unlock(&()->idr_rt)
idr_lock_bh() xa_lock_bh(&()->idr_rt)
idr_unlock_bh() xa_unlock_bh(&()->idr_rt)
idr_lock_irq() xa_lock_irq(&()->idr_rt)
idr_unlock_irq() xa_unlock_irq(&()->idr_rt)
idr_lock_irqsave(,) xa_lock_irqsave(&()->idr_rt, )
idr_unlock_irqrestore(,) xa_unlock_irqrestore(&()->idr_rt, )
idr_for_each_entry(,,) for ( = 0; (() = idr_get_next(, &())) != NULL;  += 1U)
idr_for_each_entry_ul(,,,) for ( = 0,  = 0;  <=  && (() = idr_get_next_ul(, &())) != NULL;  = , ++)
idr_for_each_entry_continue(,,) for (() = idr_get_next((), &()); ; ++, () = idr_get_next((), &()))
idr_for_each_entry_continue_ul(,,,) for ( = ;  <=  && (() = idr_get_next_ul(, &())) != NULL;  = , ++)
IDA_CHUNK_SIZE 128
IDA_BITMAP_LONGS (IDA_CHUNK_SIZE / sizeof(long))
IDA_BITMAP_BITS (IDA_BITMAP_LONGS * sizeof(long) * 8)
IDA_INIT_FLAGS (XA_FLAGS_LOCK_IRQ | XA_FLAGS_ALLOC)
IDA_INIT() { .xa = XARRAY_INIT(, IDA_INIT_FLAGS) \
}
DEFINE_IDA() struct ida  = IDA_INIT()
ida_simple_get(,,,) ida_alloc_range(, , () - 1, )
ida_simple_remove(,) ida_free(, )
KERNFS_TYPE_MASK 0x000f
KERNFS_FLAG_MASK ~KERNFS_TYPE_MASK
sysfs_attr_init() do {} while (0)
SYSFS_PREALLOC 010000
__ATTR(,,,) { .attr = {.name = __stringify(), .mode = VERIFY_OCTAL_PERMISSIONS() }, .show = , .store = , \
}
__ATTR_PREALLOC(,,,) { .attr = {.name = __stringify(), .mode = SYSFS_PREALLOC | VERIFY_OCTAL_PERMISSIONS() }, .show = , .store = , \
}
__ATTR_RO() { .attr = { .name = __stringify(), .mode = 0444 }, .show = ##_show, \
}
__ATTR_RO_MODE(,) { .attr = { .name = __stringify(), .mode = VERIFY_OCTAL_PERMISSIONS() }, .show = ##_show, \
}
__ATTR_WO() { .attr = { .name = __stringify(), .mode = 0200 }, .store = ##_store, \
}
__ATTR_RW() __ATTR(, 0644, ##_show, ##_store)
__ATTR_NULL { .attr = { .name = NULL } }
__ATTR_IGNORE_LOCKDEP __ATTR
__ATTRIBUTE_GROUPS() static const struct attribute_group *##_groups[] = { &##_group, NULL, \
}
ATTRIBUTE_GROUPS() static const struct attribute_group ##_group = { .attrs = ##_attrs, \
}; __ATTRIBUTE_GROUPS()
sysfs_bin_attr_init() sysfs_attr_init(&()->attr)
__BIN_ATTR(,,,,) { .attr = { .name = __stringify(), .mode =  }, .read = , .write = , .size = , \
}
__BIN_ATTR_RO(,) { .attr = { .name = __stringify(), .mode = 0444 }, .read = ##_read, .size = , \
}
__BIN_ATTR_WO(,) { .attr = { .name = __stringify(), .mode = 0200 }, .write = ##_write, .size = , \
}
__BIN_ATTR_RW(,) __BIN_ATTR(, 0644, ##_read, ##_write, )
__BIN_ATTR_NULL __ATTR_NULL
BIN_ATTR(,,,,) struct bin_attribute bin_attr_## = __BIN_ATTR(, , , , )
BIN_ATTR_RO(,) struct bin_attribute bin_attr_## = __BIN_ATTR_RO(, )
BIN_ATTR_WO(,) struct bin_attribute bin_attr_## = __BIN_ATTR_WO(, )
BIN_ATTR_RW(,) struct bin_attribute bin_attr_## = __BIN_ATTR_RW(, )
REFCOUNT_INIT() { .refs = ATOMIC_INIT(), }
REFCOUNT_MAX INT_MAX
REFCOUNT_SATURATED (INT_MIN / 2)
KREF_INIT() { .refcount = REFCOUNT_INIT(), }
UEVENT_HELPER_PATH_LEN 256
UEVENT_NUM_ENVP 32
UEVENT_BUFFER_SIZE 2048
MODULE_PARAM_PREFIX KBUILD_MODNAME "."
__MODULE_INFO_PREFIX KBUILD_MODNAME "."
MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
__MODULE_INFO(,,) static const char __UNIQUE_ID()[] __used __attribute__((section(".modinfo"), unused, aligned(1))) = __MODULE_INFO_PREFIX __stringify() "=" 
__MODULE_PARM_TYPE(,) __MODULE_INFO(parmtype, ##type, # ":" )
MODULE_PARM_DESC(,) __MODULE_INFO(parm, , # ":" )
module_param(,,) module_param_named(, , , )
module_param_unsafe(,,) module_param_named_unsafe(, , , )
module_param_named(,,,) param_check_##(, &()); module_param_cb(, &param_ops_##, &, ); __MODULE_PARM_TYPE(, #)
module_param_named_unsafe(,,,) param_check_##(, &()); module_param_cb_unsafe(, &param_ops_##, &, ); __MODULE_PARM_TYPE(, #)
module_param_cb(,,,) __module_param_call(MODULE_PARAM_PREFIX, , , , , -1, 0)
module_param_cb_unsafe(,,,) __module_param_call(MODULE_PARAM_PREFIX, , , , , -1, KERNEL_PARAM_FL_UNSAFE)
__level_param_cb(,,,,) __module_param_call(MODULE_PARAM_PREFIX, , , , , , 0)
core_param_cb(,,,) __level_param_cb(, , , , 1)
postcore_param_cb(,,,) __level_param_cb(, , , , 2)
arch_param_cb(,,,) __level_param_cb(, , , , 3)
subsys_param_cb(,,,) __level_param_cb(, , , , 4)
fs_param_cb(,,,) __level_param_cb(, , , , 5)
device_param_cb(,,,) __level_param_cb(, , , , 6)
late_param_cb(,,,) __level_param_cb(, , , , 7)
__moduleparam_const const
__module_param_call(,,,,,,) /* Default value instead of permissions? */ static const char __param_str_##[] =  #; static struct kernel_param __moduleparam_const __param_## __used __attribute__ ((unused,__section__ ("__param"),aligned(sizeof(void *)))) = { __param_str_##, THIS_MODULE, , VERIFY_OCTAL_PERMISSIONS(), , , {  } }
module_param_call(,,,,) static const struct kernel_param_ops __param_ops_## = { .flags = 0, .set = , .get =  }; __module_param_call(MODULE_PARAM_PREFIX, , &__param_ops_##, , , -1, 0)
core_param(,,,) param_check_##(, &()); __module_param_call("", , &param_ops_##, &, , -1, 0)
core_param_unsafe(,,,) param_check_##(, &()); __module_param_call("", , &param_ops_##, &, , -1, KERNEL_PARAM_FL_UNSAFE)
module_param_string(,,,) static const struct kparam_string __param_string_## = { ,  }; __module_param_call(MODULE_PARAM_PREFIX, , &param_ops_string, .str = &__param_string_##, , -1, 0); __MODULE_PARM_TYPE(, "string")
__param_check(,,) static inline  __always_unused *__check_##(void) { return(); }
param_check_byte(,) __param_check(, , unsigned char)
param_check_short(,) __param_check(, , short)
param_check_ushort(,) __param_check(, , unsigned short)
param_check_int(,) __param_check(, , int)
param_check_uint(,) __param_check(, , unsigned int)
param_check_long(,) __param_check(, , long)
param_check_ulong(,) __param_check(, , unsigned long)
param_check_ullong(,) __param_check(, , unsigned long long)
param_check_charp(,) __param_check(, , char *)
param_check_bool(,) __param_check(, , bool)
param_check_bool_enable_only param_check_bool
param_check_invbool(,) __param_check(, , bool)
param_get_bint param_get_int
param_check_bint param_check_int
module_param_array(,,,) module_param_array_named(, , , , )
module_param_array_named(,,,,) param_check_##(, &()[0]); static const struct kparam_array __param_arr_## = { .max = ARRAY_SIZE(), .num = , .ops = &param_ops_##, .elemsize = sizeof([0]), .elem =  }; __module_param_call(MODULE_PARAM_PREFIX, , &param_array_ops, .arr = &__param_arr_##, , -1, 0); __MODULE_PARM_TYPE(, "array of " #)
module_param_hw_named(,,,,) param_check_##(, &()); __module_param_call(MODULE_PARAM_PREFIX, , &param_ops_##, &, , -1, KERNEL_PARAM_FL_HWPARAM | (hwparam_## & 0)); __MODULE_PARM_TYPE(, #)
module_param_hw(,,,) module_param_hw_named(, , , , )
module_param_hw_array(,,,,) param_check_##(, &()[0]); static const struct kparam_array __param_arr_## = { .max = ARRAY_SIZE(), .num = , .ops = &param_ops_##, .elemsize = sizeof([0]), .elem =  }; __module_param_call(MODULE_PARAM_PREFIX, , &param_array_ops, .arr = &__param_arr_##, , -1, KERNEL_PARAM_FL_HWPARAM | (hwparam_## & 0)); __MODULE_PARM_TYPE(, "array of " #)
ALLOW_ERROR_INJECTION(,) static struct error_injection_entry __used __attribute__((__section__("_error_injection_whitelist"))) _eil_addr_## = { .addr = (unsigned long), .etype = EI_ETYPE_##, };
Elf_Shdr Elf64_Shdr
Elf_Phdr Elf64_Phdr
Elf_Sym Elf64_Sym
Elf_Dyn Elf64_Dyn
Elf_Ehdr Elf64_Ehdr
Elf_Addr Elf64_Addr
Elf_Rela Elf64_Rela
ELF_R_TYPE() ELF64_R_TYPE()
ELF_R_SYM() ELF64_R_SYM()
MODULE_SUPPORTED_DEVICE() 
MODULE_NAME_LEN MAX_PARAM_PREFIX_LEN
module_init() __initcall();
module_exit() __exitcall();
__init_or_module 
__initdata_or_module 
__initconst_or_module 
__INIT_OR_MODULE .text
__INITDATA_OR_MODULE .data
__INITRODATA_OR_MODULE .section ".rodata","a",%progbits
MODULE_INFO(,) __MODULE_INFO(, , )
MODULE_ALIAS() MODULE_INFO(alias, )
MODULE_SOFTDEP() MODULE_INFO(softdep, )
MODULE_LICENSE() MODULE_INFO(license, )
MODULE_AUTHOR() MODULE_INFO(author, )
MODULE_DESCRIPTION() MODULE_INFO(description, )
MODULE_DEVICE_TABLE(,) 
MODULE_VERSION() MODULE_INFO(version, ); static struct module_version_attribute ___modver_attr = { .mattr = { .attr = { .name = "version", .mode = S_IRUGO, }, .show = __modver_version_show, }, .module_name = KBUILD_MODNAME, .version = , }; static const struct module_version_attribute __used __attribute__ ((__section__ ("__modver"))) * __moduleparam_const __modver_attr = &___modver_attr
MODULE_FIRMWARE() MODULE_INFO(firmware, )
MODULE_IMPORT_NS() MODULE_INFO(import_ns, #)
symbol_get() ((typeof(&))(__symbol_get(__stringify())))
__module_layout_align ____cacheline_aligned
MODULE_ARCH_INIT {}
module_put_and_exit() __module_put_and_exit(THIS_MODULE, )
symbol_put() __symbol_put(__stringify())
module_name() \
({ struct module *__mod = (); __mod ? __mod->name : "kernel"; \
})
symbol_request() try_then_request_module(symbol_get(), "symbol:" #)
__MODULE_STRING() __stringify()
IORESOURCE_BITS 0x000000ff
IORESOURCE_TYPE_BITS 0x00001f00
IORESOURCE_IO 0x00000100
IORESOURCE_MEM 0x00000200
IORESOURCE_REG 0x00000300
IORESOURCE_IRQ 0x00000400
IORESOURCE_DMA 0x00000800
IORESOURCE_BUS 0x00001000
IORESOURCE_PREFETCH 0x00002000
IORESOURCE_READONLY 0x00004000
IORESOURCE_CACHEABLE 0x00008000
IORESOURCE_RANGELENGTH 0x00010000
IORESOURCE_SHADOWABLE 0x00020000
IORESOURCE_SIZEALIGN 0x00040000
IORESOURCE_STARTALIGN 0x00080000
IORESOURCE_MEM_64 0x00100000
IORESOURCE_WINDOW 0x00200000
IORESOURCE_MUXED 0x00400000
IORESOURCE_EXT_TYPE_BITS 0x01000000
IORESOURCE_SYSRAM 0x01000000
IORESOURCE_EXCLUSIVE 0x08000000
IORESOURCE_DISABLED 0x10000000
IORESOURCE_UNSET 0x20000000
IORESOURCE_AUTO 0x40000000
IORESOURCE_BUSY 0x80000000
IORESOURCE_SYSTEM_RAM (IORESOURCE_MEM|IORESOURCE_SYSRAM)
IORESOURCE_IRQ_HIGHEDGE (1<<0)
IORESOURCE_IRQ_LOWEDGE (1<<1)
IORESOURCE_IRQ_HIGHLEVEL (1<<2)
IORESOURCE_IRQ_LOWLEVEL (1<<3)
IORESOURCE_IRQ_SHAREABLE (1<<4)
IORESOURCE_IRQ_OPTIONAL (1<<5)
IORESOURCE_DMA_TYPE_MASK (3<<0)
IORESOURCE_DMA_8BIT (0<<0)
IORESOURCE_DMA_8AND16BIT (1<<0)
IORESOURCE_DMA_16BIT (2<<0)
IORESOURCE_DMA_MASTER (1<<2)
IORESOURCE_DMA_BYTE (1<<3)
IORESOURCE_DMA_WORD (1<<4)
IORESOURCE_DMA_SPEED_MASK (3<<6)
IORESOURCE_DMA_COMPATIBLE (0<<6)
IORESOURCE_DMA_TYPEA (1<<6)
IORESOURCE_DMA_TYPEB (2<<6)
IORESOURCE_DMA_TYPEF (3<<6)
IORESOURCE_MEM_WRITEABLE (1<<0)
IORESOURCE_MEM_CACHEABLE (1<<1)
IORESOURCE_MEM_RANGELENGTH (1<<2)
IORESOURCE_MEM_TYPE_MASK (3<<3)
IORESOURCE_MEM_8BIT (0<<3)
IORESOURCE_MEM_16BIT (1<<3)
IORESOURCE_MEM_8AND16BIT (2<<3)
IORESOURCE_MEM_32BIT (3<<3)
IORESOURCE_MEM_SHADOWABLE (1<<5)
IORESOURCE_MEM_EXPANSIONROM (1<<6)
IORESOURCE_IO_16BIT_ADDR (1<<0)
IORESOURCE_IO_FIXED (1<<1)
IORESOURCE_IO_SPARSE (1<<2)
IORESOURCE_ROM_ENABLE (1<<0)
IORESOURCE_ROM_SHADOW (1<<1)
IORESOURCE_PCI_FIXED (1<<4)
IORESOURCE_PCI_EA_BEI (1<<5)
DEFINE_RES_NAMED(,,,) { .start = (), .end = () + () - 1, .name = (), .flags = (), .desc = IORES_DESC_NONE, }
DEFINE_RES_IO_NAMED(,,) DEFINE_RES_NAMED((), (), (), IORESOURCE_IO)
DEFINE_RES_IO(,) DEFINE_RES_IO_NAMED((), (), NULL)
DEFINE_RES_MEM_NAMED(,,) DEFINE_RES_NAMED((), (), (), IORESOURCE_MEM)
DEFINE_RES_MEM(,) DEFINE_RES_MEM_NAMED((), (), NULL)
DEFINE_RES_IRQ_NAMED(,) DEFINE_RES_NAMED((), 1, (), IORESOURCE_IRQ)
DEFINE_RES_IRQ() DEFINE_RES_IRQ_NAMED((), NULL)
DEFINE_RES_DMA_NAMED(,) DEFINE_RES_NAMED((), 1, (), IORESOURCE_DMA)
DEFINE_RES_DMA() DEFINE_RES_DMA_NAMED((), NULL)
request_region(,,) __request_region(&ioport_resource, (), (), (), 0)
request_muxed_region(,,) __request_region(&ioport_resource, (), (), (), IORESOURCE_MUXED)
__request_mem_region(,,,) __request_region(&iomem_resource, (), (), (), )
request_mem_region(,,) __request_region(&iomem_resource, (), (), (), 0)
request_mem_region_exclusive(,,) __request_region(&iomem_resource, (), (), (), IORESOURCE_EXCLUSIVE)
rename_region(,) do { ()->name = (); } while (0)
release_region(,) __release_region(&ioport_resource, (), ())
release_mem_region(,) __release_region(&iomem_resource, (), ())
devm_request_region(,,,) __devm_request_region(, &ioport_resource, (), (), ())
devm_request_mem_region(,,,) __devm_request_region(, &iomem_resource, (), (), ())
devm_release_region(,,) __devm_release_region(, &ioport_resource, (), ())
devm_release_mem_region(,,) __devm_release_region(, &iomem_resource, (), ())
GUID_INIT(,,,,,,,,,,) \
((guid_t) \
{{ () & 0xff, (() >> 8) & 0xff, (() >> 16) & 0xff, (() >> 24) & 0xff, () & 0xff, (() >> 8) & 0xff, () & 0xff, (() >> 8) & 0xff, (), (), (), (), (), (), (), () }})
UUID_LE(,,,,,,,,,,) GUID_INIT(, , , , , , , , , , )
NULL_UUID_LE UUID_LE(0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
UUID_SIZE 16
UUID_INIT(,,,,,,,,,,) \
((uuid_t) \
{{ (() >> 24) & 0xff, (() >> 16) & 0xff, (() >> 8) & 0xff, () & 0xff, (() >> 8) & 0xff, () & 0xff, (() >> 8) & 0xff, () & 0xff, (), (), (), (), (), (), (), () }})
UUID_STRING_LEN 36
uuid_le_gen() guid_gen()
uuid_le_to_bin(,) guid_parse(, )
PCI_ANY_ID (~0)
IEEE1394_MATCH_VENDOR_ID 0x0001
IEEE1394_MATCH_MODEL_ID 0x0002
IEEE1394_MATCH_SPECIFIER_ID 0x0004
IEEE1394_MATCH_VERSION 0x0008
USB_DEVICE_ID_MATCH_VENDOR 0x0001
USB_DEVICE_ID_MATCH_PRODUCT 0x0002
USB_DEVICE_ID_MATCH_DEV_LO 0x0004
USB_DEVICE_ID_MATCH_DEV_HI 0x0008
USB_DEVICE_ID_MATCH_DEV_CLASS 0x0010
USB_DEVICE_ID_MATCH_DEV_SUBCLASS 0x0020
USB_DEVICE_ID_MATCH_DEV_PROTOCOL 0x0040
USB_DEVICE_ID_MATCH_INT_CLASS 0x0080
USB_DEVICE_ID_MATCH_INT_SUBCLASS 0x0100
USB_DEVICE_ID_MATCH_INT_PROTOCOL 0x0200
USB_DEVICE_ID_MATCH_INT_NUMBER 0x0400
HID_ANY_ID (~0)
HID_BUS_ANY 0xffff
HID_GROUP_ANY 0x0000
CCW_DEVICE_ID_MATCH_CU_TYPE 0x01
CCW_DEVICE_ID_MATCH_CU_MODEL 0x02
CCW_DEVICE_ID_MATCH_DEVICE_TYPE 0x04
CCW_DEVICE_ID_MATCH_DEVICE_MODEL 0x08
AP_DEVICE_ID_MATCH_CARD_TYPE 0x01
AP_DEVICE_ID_MATCH_QUEUE_TYPE 0x02
ACPI_ID_LEN 9
PNP_ID_LEN 8
PNP_MAX_DEVICES 8
SERIO_ANY 0xff
PCMCIA_DEV_ID_MATCH_MANF_ID 0x0001
PCMCIA_DEV_ID_MATCH_CARD_ID 0x0002
PCMCIA_DEV_ID_MATCH_FUNC_ID 0x0004
PCMCIA_DEV_ID_MATCH_FUNCTION 0x0008
PCMCIA_DEV_ID_MATCH_PROD_ID1 0x0010
PCMCIA_DEV_ID_MATCH_PROD_ID2 0x0020
PCMCIA_DEV_ID_MATCH_PROD_ID3 0x0040
PCMCIA_DEV_ID_MATCH_PROD_ID4 0x0080
PCMCIA_DEV_ID_MATCH_DEVICE_NO 0x0100
PCMCIA_DEV_ID_MATCH_FAKE_CIS 0x0200
PCMCIA_DEV_ID_MATCH_ANONYMOUS 0x0400
INPUT_DEVICE_ID_EV_MAX 0x1f
INPUT_DEVICE_ID_KEY_MIN_INTERESTING 0x71
INPUT_DEVICE_ID_KEY_MAX 0x2ff
INPUT_DEVICE_ID_REL_MAX 0x0f
INPUT_DEVICE_ID_ABS_MAX 0x3f
INPUT_DEVICE_ID_MSC_MAX 0x07
INPUT_DEVICE_ID_LED_MAX 0x0f
INPUT_DEVICE_ID_SND_MAX 0x07
INPUT_DEVICE_ID_FF_MAX 0x7f
INPUT_DEVICE_ID_SW_MAX 0x10
INPUT_DEVICE_ID_PROP_MAX 0x1f
INPUT_DEVICE_ID_MATCH_BUS 1
INPUT_DEVICE_ID_MATCH_VENDOR 2
INPUT_DEVICE_ID_MATCH_PRODUCT 4
INPUT_DEVICE_ID_MATCH_VERSION 8
INPUT_DEVICE_ID_MATCH_EVBIT 0x0010
INPUT_DEVICE_ID_MATCH_KEYBIT 0x0020
INPUT_DEVICE_ID_MATCH_RELBIT 0x0040
INPUT_DEVICE_ID_MATCH_ABSBIT 0x0080
INPUT_DEVICE_ID_MATCH_MSCIT 0x0100
INPUT_DEVICE_ID_MATCH_LEDBIT 0x0200
INPUT_DEVICE_ID_MATCH_SNDBIT 0x0400
INPUT_DEVICE_ID_MATCH_FFBIT 0x0800
INPUT_DEVICE_ID_MATCH_SWBIT 0x1000
INPUT_DEVICE_ID_MATCH_PROPBIT 0x2000
EISA_SIG_LEN 8
EISA_DEVICE_MODALIAS_FMT "eisa:s%s"
PA_HWTYPE_ANY_ID 0xff
PA_HVERSION_REV_ANY_ID 0xff
PA_HVERSION_ANY_ID 0xffff
PA_SVERSION_ANY_ID 0xffffffff
SDIO_ANY_ID (~0)
SSB_DEVICE(,,) { .vendor = , .coreid = , .revision = , }
SSB_ANY_VENDOR 0xFFFF
SSB_ANY_ID 0xFFFF
SSB_ANY_REV 0xFF
BCMA_CORE(,,,) { .manuf = , .id = , .rev = , .class = , }
BCMA_ANY_MANUF 0xFFFF
BCMA_ANY_ID 0xFFFF
BCMA_ANY_REV 0xFF
BCMA_ANY_CLASS 0xFF
VIRTIO_DEV_ANY_ID 0xffffffff
RPMSG_NAME_SIZE 32
RPMSG_DEVICE_MODALIAS_FMT "rpmsg:%s"
I2C_NAME_SIZE 20
I2C_MODULE_PREFIX "i2c:"
PCI_EPF_NAME_SIZE 20
PCI_EPF_MODULE_PREFIX "pci_epf:"
I3C_MATCH_DCR 0x1
I3C_MATCH_MANUF 0x2
I3C_MATCH_PART 0x4
I3C_MATCH_EXTRA_INFO 0x8
SPI_NAME_SIZE 32
SPI_MODULE_PREFIX "spi:"
SLIMBUS_NAME_SIZE 32
SLIMBUS_MODULE_PREFIX "slim:"
APR_NAME_SIZE 32
APR_MODULE_PREFIX "apr:"
SPMI_NAME_SIZE 32
SPMI_MODULE_PREFIX "spmi:"
dmi_device_id dmi_system_id
DMI_MATCH(,) { .slot = , .substr =  }
DMI_EXACT_MATCH(,) { .slot = , .substr = , .exact_match = 1 }
PLATFORM_NAME_SIZE 20
PLATFORM_MODULE_PREFIX "platform:"
MDIO_NAME_SIZE 32
MDIO_MODULE_PREFIX "mdio:"
MDIO_ID_FMT "%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u"
MDIO_ID_ARGS() (()>>31) & 1, (()>>30) & 1, (()>>29) & 1, (()>>28) & 1, (()>>27) & 1, (()>>26) & 1, (()>>25) & 1, (()>>24) & 1, (()>>23) & 1, (()>>22) & 1, (()>>21) & 1, (()>>20) & 1, (()>>19) & 1, (()>>18) & 1, (()>>17) & 1, (()>>16) & 1, (()>>15) & 1, (()>>14) & 1, (()>>13) & 1, (()>>12) & 1, (()>>11) & 1, (()>>10) & 1, (()>>9) & 1, (()>>8) & 1, (()>>7) & 1, (()>>6) & 1, (()>>5) & 1, (()>>4) & 1, (()>>3) & 1, (()>>2) & 1, (()>>1) & 1, () & 1
ZORRO_WILDCARD (0xffffffff)
ZORRO_DEVICE_MODALIAS_FMT "zorro:i%08X"
ISAPNP_ANY_ID 0xffff
x86cpu_device_id x86_cpu_id
X86_VENDOR_ANY 0xffff
X86_FAMILY_ANY 0
X86_MODEL_ANY 0
X86_STEPPING_ANY 0
X86_FEATURE_ANY 0
IPACK_ANY_FORMAT 0xff
IPACK_ANY_ID (~0)
MEI_CL_MODULE_PREFIX "mei:"
MEI_CL_NAME_SIZE 32
MEI_CL_VERSION_ANY 0xff
RIO_ANY_ID 0xffff
TBSVC_MATCH_PROTOCOL_KEY 0x0001
TBSVC_MATCH_PROTOCOL_ID 0x0002
TBSVC_MATCH_PROTOCOL_VERSION 0x0004
TBSVC_MATCH_PROTOCOL_REVISION 0x0008
TYPEC_ANY_MODE 0x7
WMI_MODULE_PREFIX "wmi:"
fwnode_for_each_child_node(,) for ( = fwnode_get_next_child_node(, NULL); ;  = fwnode_get_next_child_node(, ))
fwnode_for_each_available_child_node(,) for ( = fwnode_get_next_available_child_node(, NULL); ;  = fwnode_get_next_available_child_node(, ))
device_for_each_child_node(,) for ( = device_get_next_child_node(, NULL); ;  = device_get_next_child_node(, ))
PROPERTY_ENTRY_INTEGER_ARRAY(,,,) \
(struct property_entry) { .name = , .length = ARRAY_SIZE() * sizeof(), .is_array = true, .type = DEV_PROP_##, { .pointer = { .##_data =  } }, \
}
PROPERTY_ENTRY_U8_ARRAY(,) PROPERTY_ENTRY_INTEGER_ARRAY(, u8, U8, )
PROPERTY_ENTRY_U16_ARRAY(,) PROPERTY_ENTRY_INTEGER_ARRAY(, u16, U16, )
PROPERTY_ENTRY_U32_ARRAY(,) PROPERTY_ENTRY_INTEGER_ARRAY(, u32, U32, )
PROPERTY_ENTRY_U64_ARRAY(,) PROPERTY_ENTRY_INTEGER_ARRAY(, u64, U64, )
PROPERTY_ENTRY_STRING_ARRAY(,) \
(struct property_entry) { .name = , .length = ARRAY_SIZE() * sizeof(const char *), .is_array = true, .type = DEV_PROP_STRING, { .pointer = { .str =  } }, \
}
PROPERTY_ENTRY_INTEGER(,,,) \
(struct property_entry) { .name = , .length = sizeof(), .type = DEV_PROP_##, { .value = { .##_data =  } }, \
}
PROPERTY_ENTRY_U8(,) PROPERTY_ENTRY_INTEGER(, u8, U8, )
PROPERTY_ENTRY_U16(,) PROPERTY_ENTRY_INTEGER(, u16, U16, )
PROPERTY_ENTRY_U32(,) PROPERTY_ENTRY_INTEGER(, u32, U32, )
PROPERTY_ENTRY_U64(,) PROPERTY_ENTRY_INTEGER(, u64, U64, )
PROPERTY_ENTRY_STRING(,) \
(struct property_entry) { .name = , .length = sizeof(const char *), .type = DEV_PROP_STRING, { .value = { .str =  } }, \
}
PROPERTY_ENTRY_BOOL() \
(struct property_entry) { .name = , \
}
FWNODE_GRAPH_ENDPOINT_NEXT BIT(0)
FWNODE_GRAPH_DEVICE_DISABLED BIT(1)
fwnode_graph_for_each_endpoint(,) for ( = NULL; ( = fwnode_graph_get_next_endpoint(, )); )
MAX_PHANDLE_ARGS 16
of_node_kobj() NULL
OF_DYNAMIC 1
OF_DETACHED 2
OF_POPULATED 3
OF_POPULATED_BUS 4
OF_OVERLAY 5
OF_OVERLAY_FREE_CSET 6
OF_BAD_ADDR ((u64)-1)
of_fwnode_handle() NULL
of_match_ptr() NULL
of_match_node(,) NULL
of_compat_cmp(,,) strcasecmp((), ())
of_prop_cmp(,) strcmp((), ())
of_node_cmp(,) strcasecmp((), ())
of_for_each_phandle(,,,,,) for (of_phandle_iterator_init((), (), (), (), ()),  = of_phandle_iterator_next();  == 0;  = of_phandle_iterator_next())
of_property_for_each_u32(,,,,) for ( = of_find_property(, , NULL),  = of_prop_next_u32(, NULL, &); ;  = of_prop_next_u32(, , &))
of_property_for_each_string(,,,) for ( = of_find_property(, , NULL),  = of_prop_next_string(, NULL); ;  = of_prop_next_string(, ))
for_each_node_by_name(,) for ( = of_find_node_by_name(NULL, ); ;  = of_find_node_by_name(, ))
for_each_node_by_type(,) for ( = of_find_node_by_type(NULL, ); ;  = of_find_node_by_type(, ))
for_each_compatible_node(,,) for ( = of_find_compatible_node(NULL, , ); ;  = of_find_compatible_node(, , ))
for_each_matching_node(,) for ( = of_find_matching_node(NULL, ); ;  = of_find_matching_node(, ))
for_each_matching_node_and_match(,,) for ( = of_find_matching_node_and_match(NULL, , ); ;  = of_find_matching_node_and_match(, , ))
for_each_child_of_node(,) for ( = of_get_next_child(, NULL);  != NULL;  = of_get_next_child(, ))
for_each_available_child_of_node(,) for ( = of_get_next_available_child(, NULL);  != NULL;  = of_get_next_available_child(, ))
for_each_of_cpu_node() for ( = of_get_next_cpu_node(NULL);  != NULL;  = of_get_next_cpu_node())
for_each_node_with_property(,) for ( = of_find_node_with_property(NULL, ); ;  = of_find_node_with_property(, ))
_OF_DECLARE(,,,,) static const struct of_device_id __of_table_## __attribute__((unused)) = { .compatible = , .data = ( == ()NULL) ?  :  }
OF_DECLARE_1(,,,) _OF_DECLARE(, , , , of_init_fn_1)
OF_DECLARE_1_RET(,,,) _OF_DECLARE(, , , , of_init_fn_1_ret)
OF_DECLARE_2(,,,) _OF_DECLARE(, , , , of_init_fn_2)
NUM_ISA_INTERRUPTS 16
IRQ_DOMAIN_IRQ_SPEC_PARAMS 16
SLAB_CONSISTENCY_CHECKS ((slab_flags_t __force)0x00000100U)
SLAB_RED_ZONE ((slab_flags_t __force)0x00000400U)
SLAB_POISON ((slab_flags_t __force)0x00000800U)
SLAB_HWCACHE_ALIGN ((slab_flags_t __force)0x00002000U)
SLAB_CACHE_DMA ((slab_flags_t __force)0x00004000U)
SLAB_CACHE_DMA32 ((slab_flags_t __force)0x00008000U)
SLAB_STORE_USER ((slab_flags_t __force)0x00010000U)
SLAB_PANIC ((slab_flags_t __force)0x00040000U)
SLAB_TYPESAFE_BY_RCU ((slab_flags_t __force)0x00080000U)
SLAB_MEM_SPREAD ((slab_flags_t __force)0x00100000U)
SLAB_TRACE ((slab_flags_t __force)0x00200000U)
SLAB_DEBUG_OBJECTS 0
SLAB_NOLEAKTRACE ((slab_flags_t __force)0x00800000U)
SLAB_FAILSLAB 0
SLAB_ACCOUNT ((slab_flags_t __force)0x04000000U)
SLAB_KASAN 0
SLAB_RECLAIM_ACCOUNT ((slab_flags_t __force)0x00020000U)
SLAB_TEMPORARY SLAB_RECLAIM_ACCOUNT
SLAB_DEACTIVATED ((slab_flags_t __force)0x10000000U)
ZERO_SIZE_PTR ((void *)16)
ZERO_OR_NULL_PTR() ((unsigned long)() <= (unsigned long)ZERO_SIZE_PTR)
KMEM_CACHE(,) kmem_cache_create(#, sizeof(struct ), __alignof__(struct ), (), NULL)
KMEM_CACHE_USERCOPY(,,) kmem_cache_create_usercopy(#, sizeof(struct ), __alignof__(struct ), (), offsetof(struct , ), sizeof_field(struct , ), NULL)
ARCH_KMALLOC_MINALIGN __alignof__(unsigned long long)
ARCH_SLAB_MINALIGN __alignof__(unsigned long long)
__assume_kmalloc_alignment __assume_aligned(ARCH_KMALLOC_MINALIGN)
__assume_slab_alignment __assume_aligned(ARCH_SLAB_MINALIGN)
__assume_page_alignment __assume_aligned(PAGE_SIZE)
KMALLOC_SHIFT_HIGH (PAGE_SHIFT + 1)
KMALLOC_SHIFT_MAX (MAX_ORDER + PAGE_SHIFT - 1)
KMALLOC_SHIFT_LOW 3
KMALLOC_MAX_SIZE (1UL << KMALLOC_SHIFT_MAX)
KMALLOC_MAX_CACHE_SIZE (1UL << KMALLOC_SHIFT_HIGH)
KMALLOC_MAX_ORDER (KMALLOC_SHIFT_MAX - PAGE_SHIFT)
KMALLOC_MIN_SIZE (1 << KMALLOC_SHIFT_LOW)
SLAB_OBJ_MIN_SIZE (KMALLOC_MIN_SIZE < 16 ? (KMALLOC_MIN_SIZE) : 16)
kmalloc_track_caller(,) __kmalloc_track_caller(, , _RET_IP_)
kmalloc_node_track_caller(,,) __kmalloc_node_track_caller(, , , _RET_IP_)
slab_prepare_cpu NULL
slab_dead_cpu NULL
resource_list_for_each_entry(,) list_for_each_entry((), (), node)
resource_list_for_each_entry_safe(,,) list_for_each_entry_safe((), (), (), node)
KLIST_INIT(,,) { .k_lock = __SPIN_LOCK_UNLOCKED(.k_lock), .k_list = LIST_HEAD_INIT(.k_list), .get = , .put = , }
DEFINE_KLIST(,,) struct klist  = KLIST_INIT(, , )
HIGH_RES_NSEC 1
KTIME_HIGH_RES (HIGH_RES_NSEC)
MONOTONIC_RES_NSEC HIGH_RES_NSEC
KTIME_MONOTONIC_RES KTIME_HIGH_RES
HRTIMER_STATE_INACTIVE 0x00
HRTIMER_STATE_ENQUEUED 0x01
__hrtimer_clock_base_align ____cacheline_aligned
SET_SYSTEM_SLEEP_PM_OPS(,) .suspend = , .resume = , .freeze = , .thaw = , .poweroff = , .restore = ,
SET_LATE_SYSTEM_SLEEP_PM_OPS(,) .suspend_late = , .resume_early = , .freeze_late = , .thaw_early = , .poweroff_late = , .restore_early = ,
SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(,) .suspend_noirq = , .resume_noirq = , .freeze_noirq = , .thaw_noirq = , .poweroff_noirq = , .restore_noirq = ,
SET_RUNTIME_PM_OPS(,,) .runtime_suspend = , .runtime_resume = , .runtime_idle = ,
SIMPLE_DEV_PM_OPS(,,) const struct dev_pm_ops  = { SET_SYSTEM_SLEEP_PM_OPS(, ) \
}
UNIVERSAL_DEV_PM_OPS(,,,) const struct dev_pm_ops  = { SET_SYSTEM_SLEEP_PM_OPS(, ) SET_RUNTIME_PM_OPS(, , ) \
}
PM_EVENT_INVALID (-1)
PM_EVENT_ON 0x0000
PM_EVENT_FREEZE 0x0001
PM_EVENT_SUSPEND 0x0002
PM_EVENT_HIBERNATE 0x0004
PM_EVENT_QUIESCE 0x0008
PM_EVENT_RESUME 0x0010
PM_EVENT_THAW 0x0020
PM_EVENT_RESTORE 0x0040
PM_EVENT_RECOVER 0x0080
PM_EVENT_USER 0x0100
PM_EVENT_REMOTE 0x0200
PM_EVENT_AUTO 0x0400
PM_EVENT_SLEEP (PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
PM_EVENT_USER_SUSPEND (PM_EVENT_USER | PM_EVENT_SUSPEND)
PM_EVENT_USER_RESUME (PM_EVENT_USER | PM_EVENT_RESUME)
PM_EVENT_REMOTE_RESUME (PM_EVENT_REMOTE | PM_EVENT_RESUME)
PM_EVENT_AUTO_SUSPEND (PM_EVENT_AUTO | PM_EVENT_SUSPEND)
PM_EVENT_AUTO_RESUME (PM_EVENT_AUTO | PM_EVENT_RESUME)
PMSG_INVALID ((struct pm_message){ .event = PM_EVENT_INVALID, })
PMSG_ON ((struct pm_message){ .event = PM_EVENT_ON, })
PMSG_FREEZE ((struct pm_message){ .event = PM_EVENT_FREEZE, })
PMSG_QUIESCE ((struct pm_message){ .event = PM_EVENT_QUIESCE, })
PMSG_SUSPEND ((struct pm_message){ .event = PM_EVENT_SUSPEND, })
PMSG_HIBERNATE ((struct pm_message){ .event = PM_EVENT_HIBERNATE, })
PMSG_RESUME ((struct pm_message){ .event = PM_EVENT_RESUME, })
PMSG_THAW ((struct pm_message){ .event = PM_EVENT_THAW, })
PMSG_RESTORE ((struct pm_message){ .event = PM_EVENT_RESTORE, })
PMSG_RECOVER ((struct pm_message){ .event = PM_EVENT_RECOVER, })
PMSG_USER_SUSPEND ((struct pm_message) { .event = PM_EVENT_USER_SUSPEND, })
PMSG_USER_RESUME ((struct pm_message) { .event = PM_EVENT_USER_RESUME, })
PMSG_REMOTE_RESUME ((struct pm_message) { .event = PM_EVENT_REMOTE_RESUME, })
PMSG_AUTO_SUSPEND ((struct pm_message) { .event = PM_EVENT_AUTO_SUSPEND, })
PMSG_AUTO_RESUME ((struct pm_message) { .event = PM_EVENT_AUTO_RESUME, })
PMSG_IS_AUTO() ((().event & PM_EVENT_AUTO) != 0)
DPM_FLAG_NEVER_SKIP BIT(0)
DPM_FLAG_SMART_PREPARE BIT(1)
DPM_FLAG_SMART_SUSPEND BIT(2)
DPM_FLAG_LEAVE_SUSPENDED BIT(3)
PM_EVENT_PRETHAW PM_EVENT_QUIESCE
suspend_report_result(,) do { __suspend_report_result(__func__, , ); } while (0)
CSIGNAL 0x000000ff
CLONE_VM 0x00000100
CLONE_FS 0x00000200
CLONE_FILES 0x00000400
CLONE_SIGHAND 0x00000800
CLONE_PIDFD 0x00001000
CLONE_PTRACE 0x00002000
CLONE_VFORK 0x00004000
CLONE_PARENT 0x00008000
CLONE_THREAD 0x00010000
CLONE_NEWNS 0x00020000
CLONE_SYSVSEM 0x00040000
CLONE_SETTLS 0x00080000
CLONE_PARENT_SETTID 0x00100000
CLONE_CHILD_CLEARTID 0x00200000
CLONE_DETACHED 0x00400000
CLONE_UNTRACED 0x00800000
CLONE_CHILD_SETTID 0x01000000
CLONE_NEWCGROUP 0x02000000
CLONE_NEWUTS 0x04000000
CLONE_NEWIPC 0x08000000
CLONE_NEWUSER 0x10000000
CLONE_NEWPID 0x20000000
CLONE_NEWNET 0x40000000
CLONE_IO 0x80000000
CLONE_ARGS_SIZE_VER0 64
SCHED_NORMAL 0
SCHED_FIFO 1
SCHED_RR 2
SCHED_BATCH 3
SCHED_IDLE 5
SCHED_DEADLINE 6
SCHED_RESET_ON_FORK 0x40000000
SCHED_FLAG_RESET_ON_FORK 0x01
SCHED_FLAG_RECLAIM 0x02
SCHED_FLAG_DL_OVERRUN 0x04
SCHED_FLAG_KEEP_POLICY 0x08
SCHED_FLAG_KEEP_PARAMS 0x10
SCHED_FLAG_UTIL_CLAMP_MIN 0x20
SCHED_FLAG_UTIL_CLAMP_MAX 0x40
SCHED_FLAG_KEEP_ALL (SCHED_FLAG_KEEP_POLICY | SCHED_FLAG_KEEP_PARAMS)
SCHED_FLAG_UTIL_CLAMP (SCHED_FLAG_UTIL_CLAMP_MIN | SCHED_FLAG_UTIL_CLAMP_MAX)
SCHED_FLAG_ALL (SCHED_FLAG_RESET_ON_FORK | SCHED_FLAG_RECLAIM | SCHED_FLAG_DL_OVERRUN | SCHED_FLAG_KEEP_ALL | SCHED_FLAG_UTIL_CLAMP)
list_next_rcu() (*((struct list_head __rcu **)(&()->next)))
check_arg_count_one() 
__list_check_rcu(,,) ({ check_arg_count_one(); })
list_entry_rcu(,,) container_of(READ_ONCE(), , )
list_first_or_null_rcu(,,) \
({ struct list_head *__ptr = (); struct list_head *__next = READ_ONCE(__ptr->next); likely(__ptr != __next) ? list_entry_rcu(__next, , ) : NULL; \
})
list_next_or_null_rcu(,,,) \
({ struct list_head *__head = (); struct list_head *__ptr = (); struct list_head *__next = READ_ONCE(__ptr->next); likely(__next != __head) ? list_entry_rcu(__next, , ) : NULL; \
})
list_for_each_entry_rcu(,,,) for (__list_check_rcu(dummy, ## , 0),  = list_entry_rcu(()->next, typeof(*), ); &-> != ();  = list_entry_rcu(->.next, typeof(*), ))
list_entry_lockless(,,) container_of((typeof())READ_ONCE(), , )
list_for_each_entry_lockless(,,) for ( = list_entry_lockless(()->next, typeof(*), ); &-> != ();  = list_entry_lockless(->.next, typeof(*), ))
list_for_each_entry_continue_rcu(,,) for ( = list_entry_rcu(->.next, typeof(*), ); &-> != ();  = list_entry_rcu(->.next, typeof(*), ))
list_for_each_entry_from_rcu(,,) for (; &()-> != ();  = list_entry_rcu(->.next, typeof(*()), ))
hlist_first_rcu() (*((struct hlist_node __rcu **)(&()->first)))
hlist_next_rcu() (*((struct hlist_node __rcu **)(&()->next)))
hlist_pprev_rcu() (*((struct hlist_node __rcu **)(()->pprev)))
__hlist_for_each_rcu(,) for ( = rcu_dereference(hlist_first_rcu()); ;  = rcu_dereference(hlist_next_rcu()))
hlist_for_each_entry_rcu(,,,) for (__list_check_rcu(dummy, ## , 0),  = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu()), typeof(*()), ); ;  = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu( &()->)), typeof(*()), ))
hlist_for_each_entry_rcu_notrace(,,) for ( = hlist_entry_safe(rcu_dereference_raw_check(hlist_first_rcu()), typeof(*()), ); ;  = hlist_entry_safe(rcu_dereference_raw_check(hlist_next_rcu( &()->)), typeof(*()), ))
hlist_for_each_entry_rcu_bh(,,) for ( = hlist_entry_safe(rcu_dereference_bh(hlist_first_rcu()), typeof(*()), ); ;  = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu( &()->)), typeof(*()), ))
hlist_for_each_entry_continue_rcu(,) for ( = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu( &()->)), typeof(*()), ); ;  = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu( &()->)), typeof(*()), ))
hlist_for_each_entry_continue_rcu_bh(,) for ( = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu( &()->)), typeof(*()), ); ;  = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu( &()->)), typeof(*()), ))
hlist_for_each_entry_from_rcu(,) for (; ;  = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu( &()->)), typeof(*()), ))
do_each_pid_task(,,) do { if (() != NULL) hlist_for_each_entry_rcu((), &()->tasks[], pid_links[]) {
while_each_pid_task(,,) if ( == PIDTYPE_PID) break; } } while (0)
do_each_pid_thread(,,) do_each_pid_task(, , ) { struct task_struct *tg___ = ; for_each_thread(tg___, ) {
while_each_pid_thread(,,) }  = tg___; } while_each_pid_task(, , )
IPC_PRIVATE ((__kernel_key_t) 0)
IPC_CREAT 00001000
IPC_EXCL 00002000
IPC_NOWAIT 00004000
IPC_DIPC 00010000
IPC_OWN 00020000
IPC_RMID 0
IPC_SET 1
IPC_STAT 2
IPC_INFO 3
IPC_OLD 0
IPC_64 0x0100
SEMOP 1
SEMGET 2
SEMCTL 3
SEMTIMEDOP 4
MSGSND 11
MSGRCV 12
MSGGET 13
MSGCTL 14
SHMAT 21
SHMDT 22
SHMGET 23
SHMCTL 24
DIPC 25
IPCCALL(,) (()<<16 | ())
SEM_UNDO 0x1000
GETPID 11
GETVAL 12
GETALL 13
GETNCNT 14
GETZCNT 15
SETVAL 16
SETALL 17
SEM_STAT 18
SEM_INFO 19
SEM_STAT_ANY 20
SEMMNI 32000
SEMMSL 32000
SEMMNS (SEMMNI*SEMMSL)
SEMOPM 500
SEMVMX 32767
SEMAEM SEMVMX
SEMUME SEMOPM
SEMMNU SEMMNS
SEMMAP SEMMNS
SEMUSZ 20
HUGETLB_FLAG_ENCODE_SHIFT 26
HUGETLB_FLAG_ENCODE_MASK 0x3f
HUGETLB_FLAG_ENCODE_64KB (16 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_512KB (19 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_1MB (20 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_2MB (21 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_8MB (23 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_16MB (24 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_32MB (25 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_256MB (28 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_512MB (29 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_1GB (30 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_2GB (31 << HUGETLB_FLAG_ENCODE_SHIFT)
HUGETLB_FLAG_ENCODE_16GB (34 << HUGETLB_FLAG_ENCODE_SHIFT)
SHMMIN 1
SHMMNI 4096
SHMMAX (ULONG_MAX - (1UL << 24))
SHMALL (ULONG_MAX - (1UL << 24))
SHMSEG SHMMNI
SHM_R 0400
SHM_W 0200
SHM_HUGETLB 04000
SHM_NORESERVE 010000
SHM_HUGE_SHIFT HUGETLB_FLAG_ENCODE_SHIFT
SHM_HUGE_MASK HUGETLB_FLAG_ENCODE_MASK
SHM_HUGE_64KB HUGETLB_FLAG_ENCODE_64KB
SHM_HUGE_512KB HUGETLB_FLAG_ENCODE_512KB
SHM_HUGE_1MB HUGETLB_FLAG_ENCODE_1MB
SHM_HUGE_2MB HUGETLB_FLAG_ENCODE_2MB
SHM_HUGE_8MB HUGETLB_FLAG_ENCODE_8MB
SHM_HUGE_16MB HUGETLB_FLAG_ENCODE_16MB
SHM_HUGE_32MB HUGETLB_FLAG_ENCODE_32MB
SHM_HUGE_256MB HUGETLB_FLAG_ENCODE_256MB
SHM_HUGE_512MB HUGETLB_FLAG_ENCODE_512MB
SHM_HUGE_1GB HUGETLB_FLAG_ENCODE_1GB
SHM_HUGE_2GB HUGETLB_FLAG_ENCODE_2GB
SHM_HUGE_16GB HUGETLB_FLAG_ENCODE_16GB
SHM_RDONLY 010000
SHM_RND 020000
SHM_REMAP 040000
SHM_EXEC 0100000
SHM_LOCK 11
SHM_UNLOCK 12
SHM_STAT 13
SHM_INFO 14
SHM_STAT_ANY 15
SHMLBA PAGE_SIZE
shm_init_task() INIT_LIST_HEAD(&()->sysvshm.shm_clist)
KCOV_INIT_TRACE _IOR('c', 1, unsigned long)
KCOV_ENABLE _IO('c', 100)
KCOV_DISABLE _IO('c', 101)
KCOV_CMP_CONST (1 << 0)
KCOV_CMP_SIZE() (() << 1)
KCOV_CMP_MASK KCOV_CMP_SIZE(3)
PLIST_HEAD_INIT() \
{ .node_list = LIST_HEAD_INIT(().node_list) \
}
PLIST_HEAD() struct plist_head  = PLIST_HEAD_INIT()
PLIST_NODE_INIT(,) \
{ .prio = (), .prio_list = LIST_HEAD_INIT(().prio_list), .node_list = LIST_HEAD_INIT(().node_list), \
}
plist_for_each(,) list_for_each_entry(, &()->node_list, node_list)
plist_for_each_continue(,) list_for_each_entry_continue(, &()->node_list, node_list)
plist_for_each_safe(,,) list_for_each_entry_safe(, , &()->node_list, node_list)
plist_for_each_entry(,,) list_for_each_entry(, &()->node_list, .node_list)
plist_for_each_entry_continue(,,) list_for_each_entry_continue(, &()->node_list, .node_list)
plist_for_each_entry_safe(,,,) list_for_each_entry_safe(, , &()->node_list, .node_list)
plist_first_entry(,,) container_of(plist_first(), , )
plist_last_entry(,,) container_of(plist_last(), , )
plist_next() list_next_entry(, node_list)
plist_prev() list_prev_entry(, node_list)
SECCOMP_MODE_DISABLED 0
SECCOMP_MODE_STRICT 1
SECCOMP_MODE_FILTER 2
SECCOMP_SET_MODE_STRICT 0
SECCOMP_SET_MODE_FILTER 1
SECCOMP_GET_ACTION_AVAIL 2
SECCOMP_GET_NOTIF_SIZES 3
SECCOMP_FILTER_FLAG_TSYNC (1UL << 0)
SECCOMP_FILTER_FLAG_LOG (1UL << 1)
SECCOMP_FILTER_FLAG_SPEC_ALLOW (1UL << 2)
SECCOMP_FILTER_FLAG_NEW_LISTENER (1UL << 3)
SECCOMP_RET_KILL_PROCESS 0x80000000U
SECCOMP_RET_KILL_THREAD 0x00000000U
SECCOMP_RET_KILL SECCOMP_RET_KILL_THREAD
SECCOMP_RET_TRAP 0x00030000U
SECCOMP_RET_ERRNO 0x00050000U
SECCOMP_RET_USER_NOTIF 0x7fc00000U
SECCOMP_RET_TRACE 0x7ff00000U
SECCOMP_RET_LOG 0x7ffc0000U
SECCOMP_RET_ALLOW 0x7fff0000U
SECCOMP_RET_ACTION_FULL 0xffff0000U
SECCOMP_RET_ACTION 0x7fff0000U
SECCOMP_RET_DATA 0x0000ffffU
SECCOMP_USER_NOTIF_FLAG_CONTINUE (1UL << 0)
SECCOMP_IOC_MAGIC '!'
SECCOMP_IO() _IO(SECCOMP_IOC_MAGIC, )
SECCOMP_IOR(,) _IOR(SECCOMP_IOC_MAGIC, , )
SECCOMP_IOW(,) _IOW(SECCOMP_IOC_MAGIC, , )
SECCOMP_IOWR(,) _IOWR(SECCOMP_IOC_MAGIC, , )
SECCOMP_IOCTL_NOTIF_RECV SECCOMP_IOWR(0, struct seccomp_notif)
SECCOMP_IOCTL_NOTIF_SEND SECCOMP_IOWR(1, struct seccomp_notif_resp)
SECCOMP_IOCTL_NOTIF_ID_VALID SECCOMP_IOW(2, __u64)
SECCOMP_FILTER_FLAG_MASK (SECCOMP_FILTER_FLAG_TSYNC | SECCOMP_FILTER_FLAG_LOG | SECCOMP_FILTER_FLAG_SPEC_ALLOW | SECCOMP_FILTER_FLAG_NEW_LISTENER)
__X32_SYSCALL_BIT 0x40000000
__NR_read 0
__NR_write 1
__NR_open 2
__NR_close 3
__NR_stat 4
__NR_fstat 5
__NR_lstat 6
__NR_poll 7
__NR_lseek 8
__NR_mmap 9
__NR_mprotect 10
__NR_munmap 11
__NR_brk 12
__NR_rt_sigaction 13
__NR_rt_sigprocmask 14
__NR_rt_sigreturn 15
__NR_ioctl 16
__NR_pread64 17
__NR_pwrite64 18
__NR_readv 19
__NR_writev 20
__NR_access 21
__NR_pipe 22
__NR_select 23
__NR_sched_yield 24
__NR_mremap 25
__NR_msync 26
__NR_mincore 27
__NR_madvise 28
__NR_shmget 29
__NR_shmat 30
__NR_shmctl 31
__NR_dup 32
__NR_dup2 33
__NR_pause 34
__NR_nanosleep 35
__NR_getitimer 36
__NR_alarm 37
__NR_setitimer 38
__NR_getpid 39
__NR_sendfile 40
__NR_socket 41
__NR_connect 42
__NR_accept 43
__NR_sendto 44
__NR_recvfrom 45
__NR_sendmsg 46
__NR_recvmsg 47
__NR_shutdown 48
__NR_bind 49
__NR_listen 50
__NR_getsockname 51
__NR_getpeername 52
__NR_socketpair 53
__NR_setsockopt 54
__NR_getsockopt 55
__NR_clone 56
__NR_fork 57
__NR_vfork 58
__NR_execve 59
__NR_exit 60
__NR_wait4 61
__NR_kill 62
__NR_uname 63
__NR_semget 64
__NR_semop 65
__NR_semctl 66
__NR_shmdt 67
__NR_msgget 68
__NR_msgsnd 69
__NR_msgrcv 70
__NR_msgctl 71
__NR_fcntl 72
__NR_flock 73
__NR_fsync 74
__NR_fdatasync 75
__NR_truncate 76
__NR_ftruncate 77
__NR_getdents 78
__NR_getcwd 79
__NR_chdir 80
__NR_fchdir 81
__NR_rename 82
__NR_mkdir 83
__NR_rmdir 84
__NR_creat 85
__NR_link 86
__NR_unlink 87
__NR_symlink 88
__NR_readlink 89
__NR_chmod 90
__NR_fchmod 91
__NR_chown 92
__NR_fchown 93
__NR_lchown 94
__NR_umask 95
__NR_gettimeofday 96
__NR_getrlimit 97
__NR_getrusage 98
__NR_sysinfo 99
__NR_times 100
__NR_ptrace 101
__NR_getuid 102
__NR_syslog 103
__NR_getgid 104
__NR_setuid 105
__NR_setgid 106
__NR_geteuid 107
__NR_getegid 108
__NR_setpgid 109
__NR_getppid 110
__NR_getpgrp 111
__NR_setsid 112
__NR_setreuid 113
__NR_setregid 114
__NR_getgroups 115
__NR_setgroups 116
__NR_setresuid 117
__NR_getresuid 118
__NR_setresgid 119
__NR_getresgid 120
__NR_getpgid 121
__NR_setfsuid 122
__NR_setfsgid 123
__NR_getsid 124
__NR_capget 125
__NR_capset 126
__NR_rt_sigpending 127
__NR_rt_sigtimedwait 128
__NR_rt_sigqueueinfo 129
__NR_rt_sigsuspend 130
__NR_sigaltstack 131
__NR_utime 132
__NR_mknod 133
__NR_uselib 134
__NR_personality 135
__NR_ustat 136
__NR_statfs 137
__NR_fstatfs 138
__NR_sysfs 139
__NR_getpriority 140
__NR_setpriority 141
__NR_sched_setparam 142
__NR_sched_getparam 143
__NR_sched_setscheduler 144
__NR_sched_getscheduler 145
__NR_sched_get_priority_max 146
__NR_sched_get_priority_min 147
__NR_sched_rr_get_interval 148
__NR_mlock 149
__NR_munlock 150
__NR_mlockall 151
__NR_munlockall 152
__NR_vhangup 153
__NR_modify_ldt 154
__NR_pivot_root 155
__NR__sysctl 156
__NR_prctl 157
__NR_arch_prctl 158
__NR_adjtimex 159
__NR_setrlimit 160
__NR_chroot 161
__NR_sync 162
__NR_acct 163
__NR_settimeofday 164
__NR_mount 165
__NR_umount2 166
__NR_swapon 167
__NR_swapoff 168
__NR_reboot 169
__NR_sethostname 170
__NR_setdomainname 171
__NR_iopl 172
__NR_ioperm 173
__NR_create_module 174
__NR_init_module 175
__NR_delete_module 176
__NR_get_kernel_syms 177
__NR_query_module 178
__NR_quotactl 179
__NR_nfsservctl 180
__NR_getpmsg 181
__NR_putpmsg 182
__NR_afs_syscall 183
__NR_tuxcall 184
__NR_security 185
__NR_gettid 186
__NR_readahead 187
__NR_setxattr 188
__NR_lsetxattr 189
__NR_fsetxattr 190
__NR_getxattr 191
__NR_lgetxattr 192
__NR_fgetxattr 193
__NR_listxattr 194
__NR_llistxattr 195
__NR_flistxattr 196
__NR_removexattr 197
__NR_lremovexattr 198
__NR_fremovexattr 199
__NR_tkill 200
__NR_time 201
__NR_futex 202
__NR_sched_setaffinity 203
__NR_sched_getaffinity 204
__NR_set_thread_area 205
__NR_io_setup 206
__NR_io_destroy 207
__NR_io_getevents 208
__NR_io_submit 209
__NR_io_cancel 210
__NR_get_thread_area 211
__NR_lookup_dcookie 212
__NR_epoll_create 213
__NR_epoll_ctl_old 214
__NR_epoll_wait_old 215
__NR_remap_file_pages 216
__NR_getdents64 217
__NR_set_tid_address 218
__NR_restart_syscall 219
__NR_semtimedop 220
__NR_fadvise64 221
__NR_timer_create 222
__NR_timer_settime 223
__NR_timer_gettime 224
__NR_timer_getoverrun 225
__NR_timer_delete 226
__NR_clock_settime 227
__NR_clock_gettime 228
__NR_clock_getres 229
__NR_clock_nanosleep 230
__NR_exit_group 231
__NR_epoll_wait 232
__NR_epoll_ctl 233
__NR_tgkill 234
__NR_utimes 235
__NR_vserver 236
__NR_mbind 237
__NR_set_mempolicy 238
__NR_get_mempolicy 239
__NR_mq_open 240
__NR_mq_unlink 241
__NR_mq_timedsend 242
__NR_mq_timedreceive 243
__NR_mq_notify 244
__NR_mq_getsetattr 245
__NR_kexec_load 246
__NR_waitid 247
__NR_add_key 248
__NR_request_key 249
__NR_keyctl 250
__NR_ioprio_set 251
__NR_ioprio_get 252
__NR_inotify_init 253
__NR_inotify_add_watch 254
__NR_inotify_rm_watch 255
__NR_migrate_pages 256
__NR_openat 257
__NR_mkdirat 258
__NR_mknodat 259
__NR_fchownat 260
__NR_futimesat 261
__NR_newfstatat 262
__NR_unlinkat 263
__NR_renameat 264
__NR_linkat 265
__NR_symlinkat 266
__NR_readlinkat 267
__NR_fchmodat 268
__NR_faccessat 269
__NR_pselect6 270
__NR_ppoll 271
__NR_unshare 272
__NR_set_robust_list 273
__NR_get_robust_list 274
__NR_splice 275
__NR_tee 276
__NR_sync_file_range 277
__NR_vmsplice 278
__NR_move_pages 279
__NR_utimensat 280
__NR_epoll_pwait 281
__NR_signalfd 282
__NR_timerfd_create 283
__NR_eventfd 284
__NR_fallocate 285
__NR_timerfd_settime 286
__NR_timerfd_gettime 287
__NR_accept4 288
__NR_signalfd4 289
__NR_eventfd2 290
__NR_epoll_create1 291
__NR_dup3 292
__NR_pipe2 293
__NR_inotify_init1 294
__NR_preadv 295
__NR_pwritev 296
__NR_rt_tgsigqueueinfo 297
__NR_perf_event_open 298
__NR_recvmmsg 299
__NR_fanotify_init 300
__NR_fanotify_mark 301
__NR_prlimit64 302
__NR_name_to_handle_at 303
__NR_open_by_handle_at 304
__NR_clock_adjtime 305
__NR_syncfs 306
__NR_sendmmsg 307
__NR_setns 308
__NR_getcpu 309
__NR_process_vm_readv 310
__NR_process_vm_writev 311
__NR_kcmp 312
__NR_finit_module 313
__NR_sched_setattr 314
__NR_sched_getattr 315
__NR_renameat2 316
__NR_seccomp 317
__NR_getrandom 318
__NR_memfd_create 319
__NR_kexec_file_load 320
__NR_bpf 321
__NR_execveat 322
__NR_userfaultfd 323
__NR_membarrier 324
__NR_mlock2 325
__NR_copy_file_range 326
__NR_preadv2 327
__NR_pwritev2 328
__NR_pkey_mprotect 329
__NR_pkey_alloc 330
__NR_pkey_free 331
__NR_statx 332
__NR_io_pgetevents 333
__NR_rseq 334
__NR_pidfd_send_signal 424
__NR_io_uring_setup 425
__NR_io_uring_enter 426
__NR_io_uring_register 427
__NR_open_tree 428
__NR_move_mount 429
__NR_fsopen 430
__NR_fsconfig 431
__NR_fsmount 432
__NR_fspick 433
__NR_pidfd_open 434
__NR_clone3 435
__NR_x32_rt_sigaction 512
__NR_x32_rt_sigreturn 513
__NR_x32_ioctl 514
__NR_x32_readv 515
__NR_x32_writev 516
__NR_x32_recvfrom 517
__NR_x32_sendmsg 518
__NR_x32_recvmsg 519
__NR_x32_execve 520
__NR_x32_ptrace 521
__NR_x32_rt_sigpending 522
__NR_x32_rt_sigtimedwait 523
__NR_x32_rt_sigqueueinfo 524
__NR_x32_sigaltstack 525
__NR_x32_timer_create 526
__NR_x32_mq_notify 527
__NR_x32_kexec_load 528
__NR_x32_waitid 529
__NR_x32_set_robust_list 530
__NR_x32_get_robust_list 531
__NR_x32_vmsplice 532
__NR_x32_move_pages 533
__NR_x32_preadv 534
__NR_x32_pwritev 535
__NR_x32_rt_tgsigqueueinfo 536
__NR_x32_recvmmsg 537
__NR_x32_sendmmsg 538
__NR_x32_process_vm_readv 539
__NR_x32_process_vm_writev 540
__NR_x32_setsockopt 541
__NR_x32_getsockopt 542
__NR_x32_io_setup 543
__NR_x32_io_submit 544
__NR_x32_execveat 545
__NR_x32_preadv2 546
__NR_x32_pwritev2 547
__ARCH_WANT_SYS_TIME 
__ARCH_WANT_SYS_UTIME 
__ARCH_WANT_COMPAT_SYS_PREADV64 
__ARCH_WANT_COMPAT_SYS_PWRITEV64 
__ARCH_WANT_COMPAT_SYS_PREADV64V2 
__ARCH_WANT_COMPAT_SYS_PWRITEV64V2 
__ARCH_WANT_NEW_STAT 
__ARCH_WANT_OLD_READDIR 
__ARCH_WANT_OLD_STAT 
__ARCH_WANT_SYS_ALARM 
__ARCH_WANT_SYS_FADVISE64 
__ARCH_WANT_SYS_GETHOSTNAME 
__ARCH_WANT_SYS_GETPGRP 
__ARCH_WANT_SYS_NICE 
__ARCH_WANT_SYS_OLDUMOUNT 
__ARCH_WANT_SYS_OLD_GETRLIMIT 
__ARCH_WANT_SYS_OLD_UNAME 
__ARCH_WANT_SYS_PAUSE 
__ARCH_WANT_SYS_SIGNAL 
__ARCH_WANT_SYS_SIGPENDING 
__ARCH_WANT_SYS_SIGPROCMASK 
__ARCH_WANT_SYS_SOCKETCALL 
__ARCH_WANT_SYS_TIME32 
__ARCH_WANT_SYS_UTIME32 
__ARCH_WANT_SYS_WAITPID 
__ARCH_WANT_SYS_FORK 
__ARCH_WANT_SYS_VFORK 
__ARCH_WANT_SYS_CLONE 
__ARCH_WANT_SYS_CLONE3 
__SYSCALL_ia32_NR() ()
__NR_ia32_restart_syscall 0
__NR_ia32_exit 1
__NR_ia32_fork 2
__NR_ia32_read 3
__NR_ia32_write 4
__NR_ia32_open 5
__NR_ia32_close 6
__NR_ia32_waitpid 7
__NR_ia32_creat 8
__NR_ia32_link 9
__NR_ia32_unlink 10
__NR_ia32_execve 11
__NR_ia32_chdir 12
__NR_ia32_time 13
__NR_ia32_mknod 14
__NR_ia32_chmod 15
__NR_ia32_lchown 16
__NR_ia32_break 17
__NR_ia32_oldstat 18
__NR_ia32_lseek 19
__NR_ia32_getpid 20
__NR_ia32_mount 21
__NR_ia32_umount 22
__NR_ia32_setuid 23
__NR_ia32_getuid 24
__NR_ia32_stime 25
__NR_ia32_ptrace 26
__NR_ia32_alarm 27
__NR_ia32_oldfstat 28
__NR_ia32_pause 29
__NR_ia32_utime 30
__NR_ia32_stty 31
__NR_ia32_gtty 32
__NR_ia32_access 33
__NR_ia32_nice 34
__NR_ia32_ftime 35
__NR_ia32_sync 36
__NR_ia32_kill 37
__NR_ia32_rename 38
__NR_ia32_mkdir 39
__NR_ia32_rmdir 40
__NR_ia32_dup 41
__NR_ia32_pipe 42
__NR_ia32_times 43
__NR_ia32_prof 44
__NR_ia32_brk 45
__NR_ia32_setgid 46
__NR_ia32_getgid 47
__NR_ia32_signal 48
__NR_ia32_geteuid 49
__NR_ia32_getegid 50
__NR_ia32_acct 51
__NR_ia32_umount2 52
__NR_ia32_lock 53
__NR_ia32_ioctl 54
__NR_ia32_fcntl 55
__NR_ia32_mpx 56
__NR_ia32_setpgid 57
__NR_ia32_ulimit 58
__NR_ia32_oldolduname 59
__NR_ia32_umask 60
__NR_ia32_chroot 61
__NR_ia32_ustat 62
__NR_ia32_dup2 63
__NR_ia32_getppid 64
__NR_ia32_getpgrp 65
__NR_ia32_setsid 66
__NR_ia32_sigaction 67
__NR_ia32_sgetmask 68
__NR_ia32_ssetmask 69
__NR_ia32_setreuid 70
__NR_ia32_setregid 71
__NR_ia32_sigsuspend 72
__NR_ia32_sigpending 73
__NR_ia32_sethostname 74
__NR_ia32_setrlimit 75
__NR_ia32_getrlimit 76
__NR_ia32_getrusage 77
__NR_ia32_gettimeofday 78
__NR_ia32_settimeofday 79
__NR_ia32_getgroups 80
__NR_ia32_setgroups 81
__NR_ia32_select 82
__NR_ia32_symlink 83
__NR_ia32_oldlstat 84
__NR_ia32_readlink 85
__NR_ia32_uselib 86
__NR_ia32_swapon 87
__NR_ia32_reboot 88
__NR_ia32_readdir 89
__NR_ia32_mmap 90
__NR_ia32_munmap 91
__NR_ia32_truncate 92
__NR_ia32_ftruncate 93
__NR_ia32_fchmod 94
__NR_ia32_fchown 95
__NR_ia32_getpriority 96
__NR_ia32_setpriority 97
__NR_ia32_profil 98
__NR_ia32_statfs 99
__NR_ia32_fstatfs 100
__NR_ia32_ioperm 101
__NR_ia32_socketcall 102
__NR_ia32_syslog 103
__NR_ia32_setitimer 104
__NR_ia32_getitimer 105
__NR_ia32_stat 106
__NR_ia32_lstat 107
__NR_ia32_fstat 108
__NR_ia32_olduname 109
__NR_ia32_iopl 110
__NR_ia32_vhangup 111
__NR_ia32_idle 112
__NR_ia32_vm86old 113
__NR_ia32_wait4 114
__NR_ia32_swapoff 115
__NR_ia32_sysinfo 116
__NR_ia32_ipc 117
__NR_ia32_fsync 118
__NR_ia32_sigreturn 119
__NR_ia32_clone 120
__NR_ia32_setdomainname 121
__NR_ia32_uname 122
__NR_ia32_modify_ldt 123
__NR_ia32_adjtimex 124
__NR_ia32_mprotect 125
__NR_ia32_sigprocmask 126
__NR_ia32_create_module 127
__NR_ia32_init_module 128
__NR_ia32_delete_module 129
__NR_ia32_get_kernel_syms 130
__NR_ia32_quotactl 131
__NR_ia32_getpgid 132
__NR_ia32_fchdir 133
__NR_ia32_bdflush 134
__NR_ia32_sysfs 135
__NR_ia32_personality 136
__NR_ia32_afs_syscall 137
__NR_ia32_setfsuid 138
__NR_ia32_setfsgid 139
__NR_ia32__llseek 140
__NR_ia32_getdents 141
__NR_ia32__newselect 142
__NR_ia32_flock 143
__NR_ia32_msync 144
__NR_ia32_readv 145
__NR_ia32_writev 146
__NR_ia32_getsid 147
__NR_ia32_fdatasync 148
__NR_ia32__sysctl 149
__NR_ia32_mlock 150
__NR_ia32_munlock 151
__NR_ia32_mlockall 152
__NR_ia32_munlockall 153
__NR_ia32_sched_setparam 154
__NR_ia32_sched_getparam 155
__NR_ia32_sched_setscheduler 156
__NR_ia32_sched_getscheduler 157
__NR_ia32_sched_yield 158
__NR_ia32_sched_get_priority_max 159
__NR_ia32_sched_get_priority_min 160
__NR_ia32_sched_rr_get_interval 161
__NR_ia32_nanosleep 162
__NR_ia32_mremap 163
__NR_ia32_setresuid 164
__NR_ia32_getresuid 165
__NR_ia32_vm86 166
__NR_ia32_query_module 167
__NR_ia32_poll 168
__NR_ia32_nfsservctl 169
__NR_ia32_setresgid 170
__NR_ia32_getresgid 171
__NR_ia32_prctl 172
__NR_ia32_rt_sigreturn 173
__NR_ia32_rt_sigaction 174
__NR_ia32_rt_sigprocmask 175
__NR_ia32_rt_sigpending 176
__NR_ia32_rt_sigtimedwait 177
__NR_ia32_rt_sigqueueinfo 178
__NR_ia32_rt_sigsuspend 179
__NR_ia32_pread64 180
__NR_ia32_pwrite64 181
__NR_ia32_chown 182
__NR_ia32_getcwd 183
__NR_ia32_capget 184
__NR_ia32_capset 185
__NR_ia32_sigaltstack 186
__NR_ia32_sendfile 187
__NR_ia32_getpmsg 188
__NR_ia32_putpmsg 189
__NR_ia32_vfork 190
__NR_ia32_ugetrlimit 191
__NR_ia32_mmap2 192
__NR_ia32_truncate64 193
__NR_ia32_ftruncate64 194
__NR_ia32_stat64 195
__NR_ia32_lstat64 196
__NR_ia32_fstat64 197
__NR_ia32_lchown32 198
__NR_ia32_getuid32 199
__NR_ia32_getgid32 200
__NR_ia32_geteuid32 201
__NR_ia32_getegid32 202
__NR_ia32_setreuid32 203
__NR_ia32_setregid32 204
__NR_ia32_getgroups32 205
__NR_ia32_setgroups32 206
__NR_ia32_fchown32 207
__NR_ia32_setresuid32 208
__NR_ia32_getresuid32 209
__NR_ia32_setresgid32 210
__NR_ia32_getresgid32 211
__NR_ia32_chown32 212
__NR_ia32_setuid32 213
__NR_ia32_setgid32 214
__NR_ia32_setfsuid32 215
__NR_ia32_setfsgid32 216
__NR_ia32_pivot_root 217
__NR_ia32_mincore 218
__NR_ia32_madvise 219
__NR_ia32_getdents64 220
__NR_ia32_fcntl64 221
__NR_ia32_gettid 224
__NR_ia32_readahead 225
__NR_ia32_setxattr 226
__NR_ia32_lsetxattr 227
__NR_ia32_fsetxattr 228
__NR_ia32_getxattr 229
__NR_ia32_lgetxattr 230
__NR_ia32_fgetxattr 231
__NR_ia32_listxattr 232
__NR_ia32_llistxattr 233
__NR_ia32_flistxattr 234
__NR_ia32_removexattr 235
__NR_ia32_lremovexattr 236
__NR_ia32_fremovexattr 237
__NR_ia32_tkill 238
__NR_ia32_sendfile64 239
__NR_ia32_futex 240
__NR_ia32_sched_setaffinity 241
__NR_ia32_sched_getaffinity 242
__NR_ia32_set_thread_area 243
__NR_ia32_get_thread_area 244
__NR_ia32_io_setup 245
__NR_ia32_io_destroy 246
__NR_ia32_io_getevents 247
__NR_ia32_io_submit 248
__NR_ia32_io_cancel 249
__NR_ia32_fadvise64 250
__NR_ia32_exit_group 252
__NR_ia32_lookup_dcookie 253
__NR_ia32_epoll_create 254
__NR_ia32_epoll_ctl 255
__NR_ia32_epoll_wait 256
__NR_ia32_remap_file_pages 257
__NR_ia32_set_tid_address 258
__NR_ia32_timer_create 259
__NR_ia32_timer_settime 260
__NR_ia32_timer_gettime 261
__NR_ia32_timer_getoverrun 262
__NR_ia32_timer_delete 263
__NR_ia32_clock_settime 264
__NR_ia32_clock_gettime 265
__NR_ia32_clock_getres 266
__NR_ia32_clock_nanosleep 267
__NR_ia32_statfs64 268
__NR_ia32_fstatfs64 269
__NR_ia32_tgkill 270
__NR_ia32_utimes 271
__NR_ia32_fadvise64_64 272
__NR_ia32_vserver 273
__NR_ia32_mbind 274
__NR_ia32_get_mempolicy 275
__NR_ia32_set_mempolicy 276
__NR_ia32_mq_open 277
__NR_ia32_mq_unlink 278
__NR_ia32_mq_timedsend 279
__NR_ia32_mq_timedreceive 280
__NR_ia32_mq_notify 281
__NR_ia32_mq_getsetattr 282
__NR_ia32_kexec_load 283
__NR_ia32_waitid 284
__NR_ia32_add_key 286
__NR_ia32_request_key 287
__NR_ia32_keyctl 288
__NR_ia32_ioprio_set 289
__NR_ia32_ioprio_get 290
__NR_ia32_inotify_init 291
__NR_ia32_inotify_add_watch 292
__NR_ia32_inotify_rm_watch 293
__NR_ia32_migrate_pages 294
__NR_ia32_openat 295
__NR_ia32_mkdirat 296
__NR_ia32_mknodat 297
__NR_ia32_fchownat 298
__NR_ia32_futimesat 299
__NR_ia32_fstatat64 300
__NR_ia32_unlinkat 301
__NR_ia32_renameat 302
__NR_ia32_linkat 303
__NR_ia32_symlinkat 304
__NR_ia32_readlinkat 305
__NR_ia32_fchmodat 306
__NR_ia32_faccessat 307
__NR_ia32_pselect6 308
__NR_ia32_ppoll 309
__NR_ia32_unshare 310
__NR_ia32_set_robust_list 311
__NR_ia32_get_robust_list 312
__NR_ia32_splice 313
__NR_ia32_sync_file_range 314
__NR_ia32_tee 315
__NR_ia32_vmsplice 316
__NR_ia32_move_pages 317
__NR_ia32_getcpu 318
__NR_ia32_epoll_pwait 319
__NR_ia32_utimensat 320
__NR_ia32_signalfd 321
__NR_ia32_timerfd_create 322
__NR_ia32_eventfd 323
__NR_ia32_fallocate 324
__NR_ia32_timerfd_settime 325
__NR_ia32_timerfd_gettime 326
__NR_ia32_signalfd4 327
__NR_ia32_eventfd2 328
__NR_ia32_epoll_create1 329
__NR_ia32_dup3 330
__NR_ia32_pipe2 331
__NR_ia32_inotify_init1 332
__NR_ia32_preadv 333
__NR_ia32_pwritev 334
__NR_ia32_rt_tgsigqueueinfo 335
__NR_ia32_perf_event_open 336
__NR_ia32_recvmmsg 337
__NR_ia32_fanotify_init 338
__NR_ia32_fanotify_mark 339
__NR_ia32_prlimit64 340
__NR_ia32_name_to_handle_at 341
__NR_ia32_open_by_handle_at 342
__NR_ia32_clock_adjtime 343
__NR_ia32_syncfs 344
__NR_ia32_sendmmsg 345
__NR_ia32_setns 346
__NR_ia32_process_vm_readv 347
__NR_ia32_process_vm_writev 348
__NR_ia32_kcmp 349
__NR_ia32_finit_module 350
__NR_ia32_sched_setattr 351
__NR_ia32_sched_getattr 352
__NR_ia32_renameat2 353
__NR_ia32_seccomp 354
__NR_ia32_getrandom 355
__NR_ia32_memfd_create 356
__NR_ia32_bpf 357
__NR_ia32_execveat 358
__NR_ia32_socket 359
__NR_ia32_socketpair 360
__NR_ia32_bind 361
__NR_ia32_connect 362
__NR_ia32_listen 363
__NR_ia32_accept4 364
__NR_ia32_getsockopt 365
__NR_ia32_setsockopt 366
__NR_ia32_getsockname 367
__NR_ia32_getpeername 368
__NR_ia32_sendto 369
__NR_ia32_sendmsg 370
__NR_ia32_recvfrom 371
__NR_ia32_recvmsg 372
__NR_ia32_shutdown 373
__NR_ia32_userfaultfd 374
__NR_ia32_membarrier 375
__NR_ia32_mlock2 376
__NR_ia32_copy_file_range 377
__NR_ia32_preadv2 378
__NR_ia32_pwritev2 379
__NR_ia32_pkey_mprotect 380
__NR_ia32_pkey_alloc 381
__NR_ia32_pkey_free 382
__NR_ia32_statx 383
__NR_ia32_arch_prctl 384
__NR_ia32_io_pgetevents 385
__NR_ia32_rseq 386
__NR_ia32_semget 393
__NR_ia32_semctl 394
__NR_ia32_shmget 395
__NR_ia32_shmctl 396
__NR_ia32_shmat 397
__NR_ia32_shmdt 398
__NR_ia32_msgget 399
__NR_ia32_msgsnd 400
__NR_ia32_msgrcv 401
__NR_ia32_msgctl 402
__NR_ia32_clock_gettime64 403
__NR_ia32_clock_settime64 404
__NR_ia32_clock_adjtime64 405
__NR_ia32_clock_getres_time64 406
__NR_ia32_clock_nanosleep_time64 407
__NR_ia32_timer_gettime64 408
__NR_ia32_timer_settime64 409
__NR_ia32_timerfd_gettime64 410
__NR_ia32_timerfd_settime64 411
__NR_ia32_utimensat_time64 412
__NR_ia32_pselect6_time64 413
__NR_ia32_ppoll_time64 414
__NR_ia32_io_pgetevents_time64 416
__NR_ia32_recvmmsg_time64 417
__NR_ia32_mq_timedsend_time64 418
__NR_ia32_mq_timedreceive_time64 419
__NR_ia32_semtimedop_time64 420
__NR_ia32_rt_sigtimedwait_time64 421
__NR_ia32_futex_time64 422
__NR_ia32_sched_rr_get_interval_time64 423
__NR_ia32_pidfd_send_signal 424
__NR_ia32_io_uring_setup 425
__NR_ia32_io_uring_enter 426
__NR_ia32_io_uring_register 427
__NR_ia32_open_tree 428
__NR_ia32_move_mount 429
__NR_ia32_fsopen 430
__NR_ia32_fsconfig 431
__NR_ia32_fsmount 432
__NR_ia32_fspick 433
__NR_ia32_pidfd_open 434
__NR_ia32_clone3 435
__NR_seccomp_read_32 __NR_ia32_read
__NR_seccomp_write_32 __NR_ia32_write
__NR_seccomp_exit_32 __NR_ia32_exit
__NR_seccomp_sigreturn_32 __NR_ia32_sigreturn
__NR_seccomp_read __NR_read
__NR_seccomp_write __NR_write
__NR_seccomp_exit __NR_exit
__NR_seccomp_sigreturn __NR_rt_sigreturn
RUSAGE_SELF 0
RUSAGE_CHILDREN (-1)
RUSAGE_BOTH (-2)
RUSAGE_THREAD 1
RLIM64_INFINITY (~0ULL)
PRIO_MIN (-20)
PRIO_MAX 20
PRIO_PROCESS 0
PRIO_PGRP 1
PRIO_USER 2
_STK_LIM (8*1024*1024)
MLOCK_LIMIT ((PAGE_SIZE > 64*1024) ? PAGE_SIZE : 64*1024)
RLIMIT_CPU 0
RLIMIT_FSIZE 1
RLIMIT_DATA 2
RLIMIT_STACK 3
RLIMIT_CORE 4
RLIMIT_RSS 5
RLIMIT_NPROC 6
RLIMIT_NOFILE 7
RLIMIT_MEMLOCK 8
RLIMIT_AS 9
RLIMIT_LOCKS 10
RLIMIT_SIGPENDING 11
RLIMIT_MSGQUEUE 12
RLIMIT_NICE 13
RLIMIT_RTPRIO 14
RLIMIT_RTTIME 15
RLIM_NLIMITS 16
RLIM_INFINITY (~0UL)
INIT_RLIMITS \
{ [RLIMIT_CPU] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_FSIZE] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_DATA] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_STACK] = { _STK_LIM, RLIM_INFINITY }, [RLIMIT_CORE] = { 0, RLIM_INFINITY }, [RLIMIT_RSS] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_NPROC] = { 0, 0 }, [RLIMIT_NOFILE] = { INR_OPEN_CUR, INR_OPEN_MAX }, [RLIMIT_MEMLOCK] = { MLOCK_LIMIT, MLOCK_LIMIT }, [RLIMIT_AS] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_LOCKS] = { RLIM_INFINITY, RLIM_INFINITY }, [RLIMIT_SIGPENDING] = { 0, 0 }, [RLIMIT_MSGQUEUE] = { MQ_BYTES_MAX, MQ_BYTES_MAX }, [RLIMIT_NICE] = { 0, 0 }, [RLIMIT_RTPRIO] = { 0, 0 }, [RLIMIT_RTTIME] = { RLIM_INFINITY, RLIM_INFINITY }, \
}
MAX_NICE 19
MIN_NICE -20
NICE_WIDTH (MAX_NICE - MIN_NICE + 1)
MAX_USER_RT_PRIO 100
MAX_RT_PRIO MAX_USER_RT_PRIO
MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)
DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2)
NICE_TO_PRIO() (() + DEFAULT_PRIO)
PRIO_TO_NICE() (() - DEFAULT_PRIO)
USER_PRIO() (()-MAX_RT_PRIO)
TASK_USER_PRIO() USER_PRIO(()->static_prio)
MAX_USER_PRIO (USER_PRIO(MAX_PRIO))
_NSIG 64
_NSIG_BPW 64
_NSIG_WORDS (_NSIG / _NSIG_BPW)
SA_IA32_ABI 0x02000000u
SA_X32_ABI 0x01000000u
SIGHUP 1
SIGINT 2
SIGQUIT 3
SIGILL 4
SIGTRAP 5
SIGABRT 6
SIGIOT 6
SIGBUS 7
SIGFPE 8
SIGKILL 9
SIGUSR1 10
SIGSEGV 11
SIGUSR2 12
SIGPIPE 13
SIGALRM 14
SIGTERM 15
SIGSTKFLT 16
SIGCHLD 17
SIGCONT 18
SIGSTOP 19
SIGTSTP 20
SIGTTIN 21
SIGTTOU 22
SIGURG 23
SIGXCPU 24
SIGXFSZ 25
SIGVTALRM 26
SIGPROF 27
SIGWINCH 28
SIGIO 29
SIGPOLL SIGIO
SIGPWR 30
SIGSYS 31
SIGUNUSED 31
SIGRTMIN 32
SIGRTMAX _NSIG
SA_NOCLDSTOP 0x00000001u
SA_NOCLDWAIT 0x00000002u
SA_SIGINFO 0x00000004u
SA_ONSTACK 0x08000000u
SA_RESTART 0x10000000u
SA_NODEFER 0x40000000u
SA_RESETHAND 0x80000000u
SA_NOMASK SA_NODEFER
SA_ONESHOT SA_RESETHAND
SA_RESTORER 0x04000000
MINSIGSTKSZ 2048
SIGSTKSZ 8192
SIG_BLOCK 0
SIG_UNBLOCK 1
SIG_SETMASK 2
SIG_DFL ((__force __sighandler_t)0)
SIG_IGN ((__force __sighandler_t)1)
SIG_ERR ((__force __sighandler_t)-1)
__ARCH_HAS_SA_RESTORER 
SI_MAX_SIZE 128
__ARCH_SI_BAND_T long
__ARCH_SI_CLOCK_T __kernel_clock_t
__ARCH_SI_ATTRIBUTES 
__ADDR_BND_PKEY_PAD (__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))
__SIGINFO struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; \
}
si_pid _sifields._kill._pid
si_uid _sifields._kill._uid
si_tid _sifields._timer._tid
si_overrun _sifields._timer._overrun
si_sys_private _sifields._timer._sys_private
si_status _sifields._sigchld._status
si_utime _sifields._sigchld._utime
si_stime _sifields._sigchld._stime
si_value _sifields._rt._sigval
si_int _sifields._rt._sigval.sival_int
si_ptr _sifields._rt._sigval.sival_ptr
si_addr _sifields._sigfault._addr
si_addr_lsb _sifields._sigfault._addr_lsb
si_lower _sifields._sigfault._addr_bnd._lower
si_upper _sifields._sigfault._addr_bnd._upper
si_pkey _sifields._sigfault._addr_pkey._pkey
si_band _sifields._sigpoll._band
si_fd _sifields._sigpoll._fd
si_call_addr _sifields._sigsys._call_addr
si_syscall _sifields._sigsys._syscall
si_arch _sifields._sigsys._arch
SI_USER 0
SI_KERNEL 0x80
SI_QUEUE -1
SI_TIMER -2
SI_MESGQ -3
SI_ASYNCIO -4
SI_SIGIO -5
SI_TKILL -6
SI_DETHREAD -7
SI_ASYNCNL -60
SI_FROMUSER() (()->si_code <= 0)
SI_FROMKERNEL() (()->si_code > 0)
ILL_ILLOPC 1
ILL_ILLOPN 2
ILL_ILLADR 3
ILL_ILLTRP 4
ILL_PRVOPC 5
ILL_PRVREG 6
ILL_COPROC 7
ILL_BADSTK 8
ILL_BADIADDR 9
__ILL_BREAK 10
__ILL_BNDMOD 11
NSIGILL 11
FPE_INTDIV 1
FPE_INTOVF 2
FPE_FLTDIV 3
FPE_FLTOVF 4
FPE_FLTUND 5
FPE_FLTRES 6
FPE_FLTINV 7
FPE_FLTSUB 8
__FPE_DECOVF 9
__FPE_DECDIV 10
__FPE_DECERR 11
__FPE_INVASC 12
__FPE_INVDEC 13
FPE_FLTUNK 14
FPE_CONDTRAP 15
NSIGFPE 15
SEGV_MAPERR 1
SEGV_ACCERR 2
SEGV_BNDERR 3
SEGV_PKUERR 4
SEGV_ACCADI 5
SEGV_ADIDERR 6
SEGV_ADIPERR 7
NSIGSEGV 7
BUS_ADRALN 1
BUS_ADRERR 2
BUS_OBJERR 3
BUS_MCEERR_AR 4
BUS_MCEERR_AO 5
NSIGBUS 5
TRAP_BRKPT 1
TRAP_TRACE 2
TRAP_BRANCH 3
TRAP_HWBKPT 4
TRAP_UNK 5
NSIGTRAP 5
CLD_EXITED 1
CLD_KILLED 2
CLD_DUMPED 3
CLD_TRAPPED 4
CLD_STOPPED 5
CLD_CONTINUED 6
NSIGCHLD 6
POLL_IN 1
POLL_OUT 2
POLL_MSG 3
POLL_ERR 4
POLL_PRI 5
POLL_HUP 6
NSIGPOLL 6
SYS_SECCOMP 1
NSIGSYS 1
EMT_TAGOVF 1
NSIGEMT 1
SIGEV_SIGNAL 0
SIGEV_NONE 1
SIGEV_THREAD 2
SIGEV_THREAD_ID 4
__ARCH_SIGEV_PREAMBLE_SIZE (sizeof(int) * 2 + sizeof(sigval_t))
SIGEV_MAX_SIZE 64
SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE - __ARCH_SIGEV_PREAMBLE_SIZE) / sizeof(int))
sigev_notify_function _sigev_un._sigev_thread._function
sigev_notify_attributes _sigev_un._sigev_thread._attribute
sigev_notify_thread_id _sigev_un._tid
SS_ONSTACK 1
SS_DISABLE 2
SS_AUTODISARM (1U << 31)
SS_FLAG_BITS SS_AUTODISARM
SIGQUEUE_PREALLOC 1
ALARMTIMER_STATE_INACTIVE 0x00
ALARMTIMER_STATE_ENQUEUED 0x01
CPUCLOCK_PID() ((pid_t) ~(() >> 3))
CPUCLOCK_PERTHREAD() ((() & (clockid_t) CPUCLOCK_PERTHREAD_MASK) != 0)
CPUCLOCK_PERTHREAD_MASK 4
CPUCLOCK_WHICH() (() & (clockid_t) CPUCLOCK_CLOCK_MASK)
CPUCLOCK_CLOCK_MASK 3
CPUCLOCK_PROF 0
CPUCLOCK_VIRT 1
CPUCLOCK_SCHED 2
CPUCLOCK_MAX 3
CLOCKFD CPUCLOCK_MAX
CLOCKFD_MASK (CPUCLOCK_PERTHREAD_MASK|CPUCLOCK_CLOCK_MASK)
INIT_CPU_TIMERBASE() { .nextevt = U64_MAX, \
}
INIT_CPU_TIMERBASES() { INIT_CPU_TIMERBASE([0]), INIT_CPU_TIMERBASE([1]), INIT_CPU_TIMERBASE([2]), \
}
INIT_CPU_TIMERS() .posix_cputimers = { .bases = INIT_CPU_TIMERBASES(.posix_cputimers.bases), },
REQUEUE_PENDING 1
TASK_RUNNING 0x0000
TASK_INTERRUPTIBLE 0x0001
TASK_UNINTERRUPTIBLE 0x0002
__TASK_STOPPED 0x0004
__TASK_TRACED 0x0008
EXIT_DEAD 0x0010
EXIT_ZOMBIE 0x0020
EXIT_TRACE (EXIT_ZOMBIE | EXIT_DEAD)
TASK_PARKED 0x0040
TASK_DEAD 0x0080
TASK_WAKEKILL 0x0100
TASK_WAKING 0x0200
TASK_NOLOAD 0x0400
TASK_NEW 0x0800
TASK_STATE_MAX 0x1000
TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)
TASK_STOPPED (TASK_WAKEKILL | __TASK_STOPPED)
TASK_TRACED (TASK_WAKEKILL | __TASK_TRACED)
TASK_IDLE (TASK_UNINTERRUPTIBLE | TASK_NOLOAD)
TASK_NORMAL (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)
TASK_REPORT (TASK_RUNNING | TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE | __TASK_STOPPED | __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | TASK_PARKED)
task_is_traced() ((->state & __TASK_TRACED) != 0)
task_is_stopped() ((->state & __TASK_STOPPED) != 0)
task_is_stopped_or_traced() ((->state & (__TASK_STOPPED | __TASK_TRACED)) != 0)
task_contributes_to_load() ((->state & TASK_UNINTERRUPTIBLE) != 0 && (->flags & PF_FROZEN) == 0 && (->state & TASK_NOLOAD) == 0)
__set_current_state() current->state = ()
set_current_state() smp_store_mb(current->state, ())
set_special_state() do { unsigned long flags; /* may shadow */ raw_spin_lock_irqsave(&current->pi_lock, flags); current->state = (); raw_spin_unlock_irqrestore(&current->pi_lock, flags); } while (0)
TASK_COMM_LEN 16
MAX_SCHEDULE_TIMEOUT LONG_MAX
SCHED_FIXEDPOINT_SHIFT 10
SCHED_FIXEDPOINT_SCALE (1L << SCHED_FIXEDPOINT_SHIFT)
SCHED_CAPACITY_SHIFT SCHED_FIXEDPOINT_SHIFT
SCHED_CAPACITY_SCALE (1L << SCHED_CAPACITY_SHIFT)
UTIL_EST_WEIGHT_SHIFT 2
UCLAMP_BUCKETS CONFIG_UCLAMP_BUCKETS_COUNT
TASK_REPORT_IDLE (TASK_REPORT + 1)
TASK_REPORT_MAX (TASK_REPORT_IDLE << 1)
PF_IDLE 0x00000002
PF_EXITING 0x00000004
PF_VCPU 0x00000010
PF_WQ_WORKER 0x00000020
PF_FORKNOEXEC 0x00000040
PF_MCE_PROCESS 0x00000080
PF_SUPERPRIV 0x00000100
PF_DUMPCORE 0x00000200
PF_SIGNALED 0x00000400
PF_MEMALLOC 0x00000800
PF_NPROC_EXCEEDED 0x00001000
PF_USED_MATH 0x00002000
PF_NOFREEZE 0x00008000
PF_FROZEN 0x00010000
PF_KSWAPD 0x00020000
PF_MEMALLOC_NOFS 0x00040000
PF_MEMALLOC_NOIO 0x00080000
PF_LESS_THROTTLE 0x00100000
PF_KTHREAD 0x00200000
PF_RANDOMIZE 0x00400000
PF_SWAPWRITE 0x00800000
PF_MEMSTALL 0x01000000
PF_UMH 0x02000000
PF_NO_SETAFFINITY 0x04000000
PF_MCE_EARLY 0x08000000
PF_MEMALLOC_NOCMA 0x10000000
PF_FREEZER_SKIP 0x40000000
PF_SUSPEND_TASK 0x80000000
clear_stopped_child_used_math() do { ()->flags &= ~PF_USED_MATH; } while (0)
set_stopped_child_used_math() do { ()->flags |= PF_USED_MATH; } while (0)
clear_used_math() clear_stopped_child_used_math(current)
set_used_math() set_stopped_child_used_math(current)
conditional_stopped_child_used_math(,) do { ()->flags &= ~PF_USED_MATH, ()->flags |= () ? PF_USED_MATH : 0; } while (0)
conditional_used_math() conditional_stopped_child_used_math(, current)
copy_to_stopped_child_used_math() do { ()->flags &= ~PF_USED_MATH, ()->flags |= current->flags & PF_USED_MATH; } while (0)
tsk_used_math() (()->flags & PF_USED_MATH)
used_math() tsk_used_math(current)
PFA_NO_NEW_PRIVS 0
PFA_SPREAD_PAGE 1
PFA_SPREAD_SLAB 2
PFA_SPEC_SSB_DISABLE 3
PFA_SPEC_SSB_FORCE_DISABLE 4
PFA_SPEC_IB_DISABLE 5
PFA_SPEC_IB_FORCE_DISABLE 6
PFA_SPEC_SSB_NOEXEC 7
TASK_PFA_TEST(,) static inline bool task_##(struct task_struct *p) { return test_bit(PFA_##, &p->atomic_flags); }
TASK_PFA_SET(,) static inline void task_set_##(struct task_struct *p) { set_bit(PFA_##, &p->atomic_flags); }
TASK_PFA_CLEAR(,) static inline void task_clear_##(struct task_struct *p) { clear_bit(PFA_##, &p->atomic_flags); }
get_task_comm(,) ({ BUILD_BUG_ON(sizeof() != TASK_COMM_LEN); __get_task_comm(, sizeof(), ); \
})
cond_resched() ({ ___might_sleep(__FILE__, __LINE__, 0); _cond_resched(); \
})
cond_resched_lock() ({ ___might_sleep(__FILE__, __LINE__, PREEMPT_LOCK_OFFSET); __cond_resched_lock(); \
})
DEFAULT_RATELIMIT_INTERVAL (5 * HZ)
DEFAULT_RATELIMIT_BURST 10
RATELIMIT_MSG_ON_RELEASE BIT(0)
RATELIMIT_STATE_INIT_FLAGS(,,,) { .lock = __RAW_SPIN_LOCK_UNLOCKED(.lock), .interval = , .burst = , .flags = , }
RATELIMIT_STATE_INIT(,,) RATELIMIT_STATE_INIT_FLAGS(, , , 0)
RATELIMIT_STATE_INIT_DISABLED RATELIMIT_STATE_INIT(ratelimit_state, 0, DEFAULT_RATELIMIT_BURST)
DEFINE_RATELIMIT_STATE(,,) struct ratelimit_state  = RATELIMIT_STATE_INIT(, , )
__ratelimit() ___ratelimit(, __func__)
WARN_ON_RATELIMIT(,) ({ bool __rtn_cond = !!(); WARN_ON(__rtn_cond && __ratelimit()); __rtn_cond; \
})
WARN_RATELIMIT(,) \
({ static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL, DEFAULT_RATELIMIT_BURST); int rtn = !!(); if (unlikely(rtn && __ratelimit(&_rs))) WARN(rtn, , ##__VA_ARGS__); rtn; \
})
BUS_ATTR_RW() struct bus_attribute bus_attr_## = __ATTR_RW()
BUS_ATTR_RO() struct bus_attribute bus_attr_## = __ATTR_RO()
BUS_ATTR_WO() struct bus_attribute bus_attr_## = __ATTR_WO()
BUS_NOTIFY_ADD_DEVICE 0x00000001
BUS_NOTIFY_DEL_DEVICE 0x00000002
BUS_NOTIFY_REMOVED_DEVICE 0x00000003
BUS_NOTIFY_BIND_DRIVER 0x00000004
BUS_NOTIFY_BOUND_DRIVER 0x00000005
BUS_NOTIFY_UNBIND_DRIVER 0x00000006
BUS_NOTIFY_UNBOUND_DRIVER 0x00000007
BUS_NOTIFY_DRIVER_NOT_BOUND 0x00000008
DRIVER_ATTR_RW() struct driver_attribute driver_attr_## = __ATTR_RW()
DRIVER_ATTR_RO() struct driver_attribute driver_attr_## = __ATTR_RO()
DRIVER_ATTR_WO() struct driver_attribute driver_attr_## = __ATTR_WO()
class_register() \
({ static struct lock_class_key __key; __class_register(, &__key); \
})
CLASS_ATTR_RW() struct class_attribute class_attr_## = __ATTR_RW()
CLASS_ATTR_RO() struct class_attribute class_attr_## = __ATTR_RO()
CLASS_ATTR_WO() struct class_attribute class_attr_## = __ATTR_WO()
_CLASS_ATTR_STRING(,,) { __ATTR(, , show_class_attr_string, NULL),  }
CLASS_ATTR_STRING(,,) struct class_attribute_string class_attr_## = _CLASS_ATTR_STRING(, , )
class_create(,) \
({ static struct lock_class_key __key; __class_create(, , &__key); \
})
DEVICE_ATTR(,,,) struct device_attribute dev_attr_## = __ATTR(, , , )
DEVICE_ATTR_PREALLOC(,,,) struct device_attribute dev_attr_## = __ATTR_PREALLOC(, , , )
DEVICE_ATTR_RW() struct device_attribute dev_attr_## = __ATTR_RW()
DEVICE_ATTR_RO() struct device_attribute dev_attr_## = __ATTR_RO()
DEVICE_ATTR_WO() struct device_attribute dev_attr_## = __ATTR_WO()
DEVICE_ULONG_ATTR(,,) struct dev_ext_attribute dev_attr_## = { __ATTR(, , device_show_ulong, device_store_ulong), &() }
DEVICE_INT_ATTR(,,) struct dev_ext_attribute dev_attr_## = { __ATTR(, , device_show_int, device_store_int), &() }
DEVICE_BOOL_ATTR(,,) struct dev_ext_attribute dev_attr_## = { __ATTR(, , device_show_bool, device_store_bool), &() }
DEVICE_ATTR_IGNORE_LOCKDEP(,,,) struct device_attribute dev_attr_## = __ATTR_IGNORE_LOCKDEP(, , , )
devm_alloc_percpu(,) ((typeof() __percpu *)__devm_alloc_percpu((), sizeof(), __alignof__()))
DL_FLAG_STATELESS BIT(0)
DL_FLAG_AUTOREMOVE_CONSUMER BIT(1)
DL_FLAG_PM_RUNTIME BIT(2)
DL_FLAG_RPM_ACTIVE BIT(3)
DL_FLAG_AUTOREMOVE_SUPPLIER BIT(4)
DL_FLAG_AUTOPROBE_CONSUMER BIT(5)
DL_FLAG_MANAGED BIT(6)
root_device_register() __root_device_register(, THIS_MODULE)
dev_fmt() 
dev_emerg(,) _dev_emerg(, dev_fmt(), ##__VA_ARGS__)
dev_crit(,) _dev_crit(, dev_fmt(), ##__VA_ARGS__)
dev_alert(,) _dev_alert(, dev_fmt(), ##__VA_ARGS__)
dev_err(,) _dev_err(, dev_fmt(), ##__VA_ARGS__)
dev_warn(,) _dev_warn(, dev_fmt(), ##__VA_ARGS__)
dev_notice(,) _dev_notice(, dev_fmt(), ##__VA_ARGS__)
dev_info(,) _dev_info(, dev_fmt(), ##__VA_ARGS__)
dev_dbg(,) dynamic_dev_dbg(, dev_fmt(), ##__VA_ARGS__)
dev_level_once(,,) do { static bool __print_once __read_mostly; if (!__print_once) { __print_once = true; (, , ##__VA_ARGS__); } \
} while (0)
dev_emerg_once(,) dev_level_once(dev_emerg, , , ##__VA_ARGS__)
dev_alert_once(,) dev_level_once(dev_alert, , , ##__VA_ARGS__)
dev_crit_once(,) dev_level_once(dev_crit, , , ##__VA_ARGS__)
dev_err_once(,) dev_level_once(dev_err, , , ##__VA_ARGS__)
dev_warn_once(,) dev_level_once(dev_warn, , , ##__VA_ARGS__)
dev_notice_once(,) dev_level_once(dev_notice, , , ##__VA_ARGS__)
dev_info_once(,) dev_level_once(dev_info, , , ##__VA_ARGS__)
dev_dbg_once(,) dev_level_once(dev_dbg, , , ##__VA_ARGS__)
dev_level_ratelimited(,,) do { static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL, DEFAULT_RATELIMIT_BURST); if (__ratelimit(&_rs)) (, , ##__VA_ARGS__); \
} while (0)
dev_emerg_ratelimited(,) dev_level_ratelimited(dev_emerg, , , ##__VA_ARGS__)
dev_alert_ratelimited(,) dev_level_ratelimited(dev_alert, , , ##__VA_ARGS__)
dev_crit_ratelimited(,) dev_level_ratelimited(dev_crit, , , ##__VA_ARGS__)
dev_err_ratelimited(,) dev_level_ratelimited(dev_err, , , ##__VA_ARGS__)
dev_warn_ratelimited(,) dev_level_ratelimited(dev_warn, , , ##__VA_ARGS__)
dev_notice_ratelimited(,) dev_level_ratelimited(dev_notice, , , ##__VA_ARGS__)
dev_info_ratelimited(,) dev_level_ratelimited(dev_info, , , ##__VA_ARGS__)
dev_dbg_ratelimited(,) do { static DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL, DEFAULT_RATELIMIT_BURST); DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, ); if (DYNAMIC_DEBUG_BRANCH(descriptor) && __ratelimit(&_rs)) __dynamic_dev_dbg(&descriptor, , dev_fmt(), ##__VA_ARGS__); \
} while (0)
dev_vdbg(,) \
({ if (0) dev_printk(KERN_DEBUG, , dev_fmt(), ##__VA_ARGS__); \
})
dev_WARN(,,) WARN(1, "%s %s: " , dev_driver_string(), dev_name(), ## );
dev_WARN_ONCE(,,,) WARN_ONCE(, "%s %s: " , dev_driver_string(), dev_name(), ## )
MODULE_ALIAS_CHARDEV(,) MODULE_ALIAS("char-major-" __stringify() "-" __stringify())
MODULE_ALIAS_CHARDEV_MAJOR() MODULE_ALIAS("char-major-" __stringify() "-*")
sysfs_deprecated 0
module_driver(,,) static int __init ##_init(void) \
{ return (&() , ##__VA_ARGS__); \
} module_init(##_init); static void __exit ##_exit(void) \
{ (&() , ##__VA_ARGS__); \
} module_exit(##_exit);
builtin_driver(,) static int __init ##_init(void) \
{ return (&() , ##__VA_ARGS__); \
} device_initcall(##_init);
_LINUX 
ACPI_BINARY_SEMAPHORE 0
ACPI_OSL_MUTEX 1
DEBUGGER_SINGLE_THREADED 0
DEBUGGER_MULTI_THREADED 1
ACPI_INLINE __inline__
ACPI_GET_FUNCTION_NAME __func__
ACPI_PRINTF_LIKE() __attribute__ ((__format__ (__printf__, , +1)))
ACPI_UNUSED_VAR __attribute__ ((unused))
COMPILER_VA_MACRO 1
ACPI_USE_NATIVE_MATH64 
ACPI_USE_SYSTEM_CLIBRARY 
ACPI_USE_DO_WHILE_0 
ACPI_IGNORE_PACKAGE_RESOLUTION_ERRORS 
ACPI_USE_SYSTEM_INTTYPES 
ACPI_USE_GPE_POLLING 
ACPI_PCI_CONFIGURED 
ACPI_DEBUGGER 
ACPI_MUTEX_DEBUG 
_U 0x01
_L 0x02
_D 0x04
_C 0x08
_P 0x10
_S 0x20
_X 0x40
_SP 0x80
__ismask() (_ctype[(int)(unsigned char)()])
isalnum() ((__ismask()&(_U|_L|_D)) != 0)
isalpha() ((__ismask()&(_U|_L)) != 0)
iscntrl() ((__ismask()&(_C)) != 0)
isgraph() ((__ismask()&(_P|_U|_L|_D)) != 0)
islower() ((__ismask()&(_L)) != 0)
isprint() ((__ismask()&(_P|_U|_L|_D|_SP)) != 0)
ispunct() ((__ismask()&(_P)) != 0)
isspace() ((__ismask()&(_S)) != 0)
isupper() ((__ismask()&(_U)) != 0)
isxdigit() ((__ismask()&(_D|_X)) != 0)
isascii() (((unsigned char)())<=0x7f)
toascii() (((unsigned char)())&0x7f)
tolower() __tolower()
toupper() __toupper()
ACPI_FLUSH_CPU_CACHE() do { if (!cpu_feature_enabled(X86_FEATURE_HYPERVISOR)) wbinvd(); \
} while (0)
ACPI_ACQUIRE_GLOBAL_LOCK(,) (() = __acpi_acquire_global_lock(&->global_lock))
ACPI_RELEASE_GLOBAL_LOCK(,) (() = __acpi_release_global_lock(&->global_lock))
ACPI_DIV_64_BY_32(,,,,) asm("divl %2;" : "=a"(), "=d"() : "r"(), "0"(), "1"())
ACPI_SHIFT_RIGHT_64(,) asm("shrl   $1,%2	;" "rcrl   $1,%3;" : "=r"(), "=r"() : "0"(), "1"())
ACPI_INIT_FUNCTION __init
ACPI_DEBUG_DEFAULT (ACPI_LV_INFO | ACPI_LV_REPAIR)
ACPI_MACHINE_WIDTH BITS_PER_LONG
ACPI_USE_NATIVE_MATH64 
ACPI_EXPORT_SYMBOL() EXPORT_SYMBOL();
strtoul simple_strtoul
acpi_cache_t struct kmem_cache
acpi_spinlock spinlock_t *
acpi_raw_spinlock raw_spinlock_t *
acpi_cpu_flags unsigned long
USE_NATIVE_ALLOCATE_ZEROED 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_initialize 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_terminate 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_allocate 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_allocate_zeroed 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_free 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_object 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_thread_id 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_lock 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_raw_lock 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_raw_lock 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_raw_lock 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_release_raw_lock 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_readable 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_writable 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_initialize_debugger 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_terminate_debugger 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_redirect_output 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_name 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_index 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_address 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_open_directory 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_next_filename 
ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_close_directory 
ACPI_MSG_ERROR KERN_ERR "ACPI Error: "
ACPI_MSG_EXCEPTION KERN_ERR "ACPI Exception: "
ACPI_MSG_WARNING KERN_WARNING "ACPI Warning: "
ACPI_MSG_INFO KERN_INFO "ACPI: "
ACPI_MSG_BIOS_ERROR KERN_ERR "ACPI BIOS Error (bug): "
ACPI_MSG_BIOS_WARNING KERN_WARNING "ACPI BIOS Warning (bug): "
ACPI_STRUCT_INIT(,) . = 
COMPILER_DEPENDENT_INT64 long long
COMPILER_DEPENDENT_UINT64 unsigned long long
ACPI_MUTEX_TYPE ACPI_BINARY_SEMAPHORE
ACPI_SYSTEM_XFACE 
ACPI_EXTERNAL_XFACE 
ACPI_INTERNAL_XFACE 
ACPI_INTERNAL_VAR_XFACE 
DEBUGGER_THREADING DEBUGGER_MULTI_THREADED
ACPI_FILE void *
ACPI_FILE_OUT NULL
ACPI_FILE_ERR NULL
METHOD_NAME__ADR "_ADR"
METHOD_NAME__AEI "_AEI"
METHOD_NAME__BBN "_BBN"
METHOD_NAME__CBA "_CBA"
METHOD_NAME__CID "_CID"
METHOD_NAME__CLS "_CLS"
METHOD_NAME__CRS "_CRS"
METHOD_NAME__DDN "_DDN"
METHOD_NAME__DMA "_DMA"
METHOD_NAME__HID "_HID"
METHOD_NAME__INI "_INI"
METHOD_NAME__PLD "_PLD"
METHOD_NAME__DSD "_DSD"
METHOD_NAME__PRS "_PRS"
METHOD_NAME__PRT "_PRT"
METHOD_NAME__PRW "_PRW"
METHOD_NAME__PS0 "_PS0"
METHOD_NAME__PS1 "_PS1"
METHOD_NAME__PS2 "_PS2"
METHOD_NAME__PS3 "_PS3"
METHOD_NAME__REG "_REG"
METHOD_NAME__SB_ "_SB_"
METHOD_NAME__SEG "_SEG"
METHOD_NAME__SRS "_SRS"
METHOD_NAME__STA "_STA"
METHOD_NAME__SUB "_SUB"
METHOD_NAME__UID "_UID"
METHOD_PATHNAME__PTS "\\_PTS"
METHOD_PATHNAME__SST "\\_SI._SST"
METHOD_PATHNAME__WAK "\\_WAK"
ACPI_UNKNOWN_NAME (u32) 0x3F3F3F3F
ACPI_PREFIX_MIXED (u32) 0x69706341
ACPI_PREFIX_LOWER (u32) 0x69706361
ACPI_ROOT_NAME (u32) 0x5F5F5F5C
ACPI_ROOT_PATHNAME "\\___"
ACPI_NAMESPACE_ROOT "Namespace Root"
ACPI_NS_ROOT_PATH "\\"
ACPI_UINT8_MAX (u8) (~((u8) 0))
ACPI_UINT16_MAX (u16)(~((u16) 0))
ACPI_UINT32_MAX (u32)(~((u32) 0))
ACPI_UINT64_MAX (u64)(~((u64) 0))
ACPI_ASCII_MAX 0x7F
acpi_thread_id u64
ACPI_MAX_PTR ACPI_UINT64_MAX
ACPI_SIZE_MAX ACPI_UINT64_MAX
ACPI_USE_NATIVE_DIVIDE 
ACPI_USE_NATIVE_MATH64 
acpi_mutex acpi_semaphore
acpi_os_create_mutex() acpi_os_create_semaphore (1, 1, )
acpi_os_delete_mutex() (void) acpi_os_delete_semaphore ()
acpi_os_acquire_mutex(,) acpi_os_wait_semaphore (, 1, )
acpi_os_release_mutex() (void) acpi_os_signal_semaphore (, 1)
acpi_semaphore void *
acpi_uintptr_t void *
ACPI_EXPORT_SYMBOL_INIT() 
ACPI_DEBUG_INITIALIZE() 
ACPI_ALLOCATE() acpi_os_allocate ((acpi_size) ())
ACPI_ALLOCATE_ZEROED() acpi_os_allocate_zeroed ((acpi_size) ())
ACPI_FREE() acpi_os_free ()
ACPI_MEM_TRACKING() 
ACPI_MAX_GPE_BLOCKS 2
ACPI_GPE_REGISTER_WIDTH 8
ACPI_PM1_REGISTER_WIDTH 16
ACPI_PM2_REGISTER_WIDTH 8
ACPI_PM_TIMER_WIDTH 32
ACPI_RESET_REGISTER_WIDTH 8
ACPI_NAMESEG_SIZE 4
ACPI_PATH_SEGMENT_LENGTH 5
ACPI_PATH_SEPARATOR '.'
ACPI_OEM_ID_SIZE 6
ACPI_OEM_TABLE_ID_SIZE 8
PCI_ROOT_HID_STRING "PNP0A03"
PCI_EXPRESS_ROOT_HID_STRING "PNP0A08"
ACPI_PM_TIMER_FREQUENCY 3579545
FALSE (1 == 0)
TRUE (1 == 1)
ACPI_MSEC_PER_SEC 1000L
ACPI_USEC_PER_MSEC 1000L
ACPI_USEC_PER_SEC 1000000L
ACPI_100NSEC_PER_USEC 10L
ACPI_100NSEC_PER_MSEC 10000L
ACPI_100NSEC_PER_SEC 10000000L
ACPI_NSEC_PER_USEC 1000L
ACPI_NSEC_PER_MSEC 1000000L
ACPI_NSEC_PER_SEC 1000000000L
ACPI_TIME_AFTER(,) ((s64)(() - ()) < 0)
ACPI_OWNER_ID_MAX 0xFFF
ACPI_INTEGER_BIT_SIZE 64
ACPI_MAX_DECIMAL_DIGITS 20
ACPI_MAX64_DECIMAL_DIGITS 20
ACPI_MAX32_DECIMAL_DIGITS 10
ACPI_MAX16_DECIMAL_DIGITS 5
ACPI_MAX8_DECIMAL_DIGITS 3
ACPI_ROOT_OBJECT ((acpi_handle) ACPI_TO_POINTER (ACPI_MAX_PTR))
ACPI_WAIT_FOREVER 0xFFFF
ACPI_DO_NOT_WAIT 0
ACPI_INTEGER_MAX ACPI_UINT64_MAX
ACPI_LOBYTE() ((u8) (u16)())
ACPI_HIBYTE() ((u8) (((u16)()) >> 8))
ACPI_LOWORD() ((u16) (u32)())
ACPI_HIWORD() ((u16)(((u32)()) >> 16))
ACPI_LODWORD() ((u32) (u64)())
ACPI_HIDWORD() ((u32)(((u64)()) >> 32))
ACPI_SET_BIT(,) (() |= ())
ACPI_CLEAR_BIT(,) (() &= ~())
ACPI_MIN(,) ((()<())?():())
ACPI_MAX(,) ((()>())?():())
ACPI_ARRAY_LENGTH() (sizeof() / sizeof(()[0]))
ACPI_CAST_PTR(,) (( *) (acpi_uintptr_t) ())
ACPI_CAST_INDIRECT_PTR(,) (( **) (acpi_uintptr_t) ())
ACPI_ADD_PTR(,,) ACPI_CAST_PTR (, (ACPI_CAST_PTR (u8, ()) + (acpi_size)()))
ACPI_SUB_PTR(,,) ACPI_CAST_PTR (, (ACPI_CAST_PTR (u8, ()) - (acpi_size)()))
ACPI_PTR_DIFF(,) ((acpi_size) (ACPI_CAST_PTR (u8, ()) - ACPI_CAST_PTR (u8, ())))
ACPI_TO_POINTER() ACPI_CAST_PTR (void, (acpi_size) ())
ACPI_TO_INTEGER() ACPI_PTR_DIFF (, (void *) 0)
ACPI_OFFSET(,) ACPI_PTR_DIFF (&((( *) 0)->), (void *) 0)
ACPI_PHYSADDR_TO_PTR() ACPI_TO_POINTER()
ACPI_PTR_TO_PHYSADDR() ACPI_TO_INTEGER()
ACPI_COMPARE_NAMESEG(,) (*ACPI_CAST_PTR (u32, ()) == *ACPI_CAST_PTR (u32, ()))
ACPI_COPY_NAMESEG(,) (*ACPI_CAST_PTR (u32, ()) = *ACPI_CAST_PTR (u32, ()))
ACPI_VALIDATE_RSDP_SIG() (!strncmp (ACPI_CAST_PTR (char, ()), ACPI_SIG_RSDP, 8))
ACPI_MAKE_RSDP_SIG() (memcpy (ACPI_CAST_PTR (char, ()), ACPI_SIG_RSDP, 8))
ACPI_IS_OEM_SIG() (!strncmp (ACPI_CAST_PTR (char, ()), ACPI_OEM_NAME, 3) && strnlen (, ACPI_NAMESEG_SIZE) == ACPI_NAMESEG_SIZE)
ACPI_ACCESS_BIT_SHIFT 2
ACPI_ACCESS_BYTE_SHIFT -1
ACPI_ACCESS_BIT_MAX (31 - ACPI_ACCESS_BIT_SHIFT)
ACPI_ACCESS_BYTE_MAX (31 - ACPI_ACCESS_BYTE_SHIFT)
ACPI_ACCESS_BIT_DEFAULT (8 - ACPI_ACCESS_BIT_SHIFT)
ACPI_ACCESS_BYTE_DEFAULT (8 - ACPI_ACCESS_BYTE_SHIFT)
ACPI_ACCESS_BIT_WIDTH() (1 << (() + ACPI_ACCESS_BIT_SHIFT))
ACPI_ACCESS_BYTE_WIDTH() (1 << (() + ACPI_ACCESS_BYTE_SHIFT))
ACPI_FULL_INITIALIZATION 0x0000
ACPI_NO_FACS_INIT 0x0001
ACPI_NO_ACPI_ENABLE 0x0002
ACPI_NO_HARDWARE_INIT 0x0004
ACPI_NO_EVENT_INIT 0x0008
ACPI_NO_HANDLER_INIT 0x0010
ACPI_NO_OBJECT_INIT 0x0020
ACPI_NO_DEVICE_INIT 0x0040
ACPI_NO_ADDRESS_SPACE_INIT 0x0080
ACPI_SUBSYSTEM_INITIALIZE 0x01
ACPI_INITIALIZED_OK 0x02
ACPI_STATE_UNKNOWN (u8) 0xFF
ACPI_STATE_S0 (u8) 0
ACPI_STATE_S1 (u8) 1
ACPI_STATE_S2 (u8) 2
ACPI_STATE_S3 (u8) 3
ACPI_STATE_S4 (u8) 4
ACPI_STATE_S5 (u8) 5
ACPI_S_STATES_MAX ACPI_STATE_S5
ACPI_S_STATE_COUNT 6
ACPI_STATE_D0 (u8) 0
ACPI_STATE_D1 (u8) 1
ACPI_STATE_D2 (u8) 2
ACPI_STATE_D3_HOT (u8) 3
ACPI_STATE_D3 (u8) 4
ACPI_STATE_D3_COLD ACPI_STATE_D3
ACPI_D_STATES_MAX ACPI_STATE_D3
ACPI_D_STATE_COUNT 5
ACPI_STATE_C0 (u8) 0
ACPI_STATE_C1 (u8) 1
ACPI_STATE_C2 (u8) 2
ACPI_STATE_C3 (u8) 3
ACPI_C_STATES_MAX ACPI_STATE_C3
ACPI_C_STATE_COUNT 4
ACPI_SLEEP_TYPE_MAX 0x7
ACPI_SLEEP_TYPE_INVALID 0xFF
ACPI_NOTIFY_BUS_CHECK (u8) 0x00
ACPI_NOTIFY_DEVICE_CHECK (u8) 0x01
ACPI_NOTIFY_DEVICE_WAKE (u8) 0x02
ACPI_NOTIFY_EJECT_REQUEST (u8) 0x03
ACPI_NOTIFY_DEVICE_CHECK_LIGHT (u8) 0x04
ACPI_NOTIFY_FREQUENCY_MISMATCH (u8) 0x05
ACPI_NOTIFY_BUS_MODE_MISMATCH (u8) 0x06
ACPI_NOTIFY_POWER_FAULT (u8) 0x07
ACPI_NOTIFY_CAPABILITIES_CHECK (u8) 0x08
ACPI_NOTIFY_DEVICE_PLD_CHECK (u8) 0x09
ACPI_NOTIFY_RESERVED (u8) 0x0A
ACPI_NOTIFY_LOCALITY_UPDATE (u8) 0x0B
ACPI_NOTIFY_SHUTDOWN_REQUEST (u8) 0x0C
ACPI_NOTIFY_AFFINITY_UPDATE (u8) 0x0D
ACPI_NOTIFY_MEMORY_UPDATE (u8) 0x0E
ACPI_NOTIFY_DISCONNECT_RECOVER (u8) 0x0F
ACPI_GENERIC_NOTIFY_MAX 0x0F
ACPI_SPECIFIC_NOTIFY_MAX 0x84
ACPI_TYPE_ANY 0x00
ACPI_TYPE_INTEGER 0x01
ACPI_TYPE_STRING 0x02
ACPI_TYPE_BUFFER 0x03
ACPI_TYPE_PACKAGE 0x04
ACPI_TYPE_FIELD_UNIT 0x05
ACPI_TYPE_DEVICE 0x06
ACPI_TYPE_EVENT 0x07
ACPI_TYPE_METHOD 0x08
ACPI_TYPE_MUTEX 0x09
ACPI_TYPE_REGION 0x0A
ACPI_TYPE_POWER 0x0B
ACPI_TYPE_PROCESSOR 0x0C
ACPI_TYPE_THERMAL 0x0D
ACPI_TYPE_BUFFER_FIELD 0x0E
ACPI_TYPE_DDB_HANDLE 0x0F
ACPI_TYPE_DEBUG_OBJECT 0x10
ACPI_TYPE_EXTERNAL_MAX 0x10
ACPI_NUM_TYPES (ACPI_TYPE_EXTERNAL_MAX + 1)
ACPI_TYPE_LOCAL_REGION_FIELD 0x11
ACPI_TYPE_LOCAL_BANK_FIELD 0x12
ACPI_TYPE_LOCAL_INDEX_FIELD 0x13
ACPI_TYPE_LOCAL_REFERENCE 0x14
ACPI_TYPE_LOCAL_ALIAS 0x15
ACPI_TYPE_LOCAL_METHOD_ALIAS 0x16
ACPI_TYPE_LOCAL_NOTIFY 0x17
ACPI_TYPE_LOCAL_ADDRESS_HANDLER 0x18
ACPI_TYPE_LOCAL_RESOURCE 0x19
ACPI_TYPE_LOCAL_RESOURCE_FIELD 0x1A
ACPI_TYPE_LOCAL_SCOPE 0x1B
ACPI_TYPE_NS_NODE_MAX 0x1B
ACPI_TOTAL_TYPES (ACPI_TYPE_NS_NODE_MAX + 1)
ACPI_TYPE_LOCAL_EXTRA 0x1C
ACPI_TYPE_LOCAL_DATA 0x1D
ACPI_TYPE_LOCAL_MAX 0x1D
ACPI_TYPE_INVALID 0x1E
ACPI_TYPE_NOT_FOUND 0xFF
ACPI_NUM_NS_TYPES (ACPI_TYPE_INVALID + 1)
ACPI_READ 0
ACPI_WRITE 1
ACPI_IO_MASK 1
ACPI_EVENT_PMTIMER 0
ACPI_EVENT_GLOBAL 1
ACPI_EVENT_POWER_BUTTON 2
ACPI_EVENT_SLEEP_BUTTON 3
ACPI_EVENT_RTC 4
ACPI_EVENT_MAX 4
ACPI_NUM_FIXED_EVENTS ACPI_EVENT_MAX + 1
ACPI_EVENT_FLAG_DISABLED (acpi_event_status) 0x00
ACPI_EVENT_FLAG_ENABLED (acpi_event_status) 0x01
ACPI_EVENT_FLAG_WAKE_ENABLED (acpi_event_status) 0x02
ACPI_EVENT_FLAG_STATUS_SET (acpi_event_status) 0x04
ACPI_EVENT_FLAG_ENABLE_SET (acpi_event_status) 0x08
ACPI_EVENT_FLAG_HAS_HANDLER (acpi_event_status) 0x10
ACPI_EVENT_FLAG_MASKED (acpi_event_status) 0x20
ACPI_EVENT_FLAG_SET ACPI_EVENT_FLAG_STATUS_SET
ACPI_GPE_ENABLE 0
ACPI_GPE_DISABLE 1
ACPI_GPE_CONDITIONAL_ENABLE 2
ACPI_GPE_DISPATCH_NONE (u8) 0x00
ACPI_GPE_DISPATCH_METHOD (u8) 0x01
ACPI_GPE_DISPATCH_HANDLER (u8) 0x02
ACPI_GPE_DISPATCH_NOTIFY (u8) 0x03
ACPI_GPE_DISPATCH_RAW_HANDLER (u8) 0x04
ACPI_GPE_DISPATCH_MASK (u8) 0x07
ACPI_GPE_DISPATCH_TYPE() ((u8) (() & ACPI_GPE_DISPATCH_MASK))
ACPI_GPE_LEVEL_TRIGGERED (u8) 0x08
ACPI_GPE_EDGE_TRIGGERED (u8) 0x00
ACPI_GPE_XRUPT_TYPE_MASK (u8) 0x08
ACPI_GPE_CAN_WAKE (u8) 0x10
ACPI_GPE_AUTO_ENABLED (u8) 0x20
ACPI_GPE_INITIALIZED (u8) 0x40
ACPI_NOT_ISR 0x1
ACPI_ISR 0x0
ACPI_SYSTEM_NOTIFY 0x1
ACPI_DEVICE_NOTIFY 0x2
ACPI_ALL_NOTIFY (ACPI_SYSTEM_NOTIFY | ACPI_DEVICE_NOTIFY)
ACPI_MAX_NOTIFY_HANDLER_TYPE 0x3
ACPI_NUM_NOTIFY_TYPES 2
ACPI_MAX_SYS_NOTIFY 0x7F
ACPI_MAX_DEVICE_SPECIFIC_NOTIFY 0xBF
ACPI_SYSTEM_HANDLER_LIST 0
ACPI_DEVICE_HANDLER_LIST 1
ACPI_ADR_SPACE_SYSTEM_MEMORY (acpi_adr_space_type) 0
ACPI_ADR_SPACE_SYSTEM_IO (acpi_adr_space_type) 1
ACPI_ADR_SPACE_PCI_CONFIG (acpi_adr_space_type) 2
ACPI_ADR_SPACE_EC (acpi_adr_space_type) 3
ACPI_ADR_SPACE_SMBUS (acpi_adr_space_type) 4
ACPI_ADR_SPACE_CMOS (acpi_adr_space_type) 5
ACPI_ADR_SPACE_PCI_BAR_TARGET (acpi_adr_space_type) 6
ACPI_ADR_SPACE_IPMI (acpi_adr_space_type) 7
ACPI_ADR_SPACE_GPIO (acpi_adr_space_type) 8
ACPI_ADR_SPACE_GSBUS (acpi_adr_space_type) 9
ACPI_ADR_SPACE_PLATFORM_COMM (acpi_adr_space_type) 10
ACPI_NUM_PREDEFINED_REGIONS 11
ACPI_ADR_SPACE_DATA_TABLE (acpi_adr_space_type) 0x7E
ACPI_ADR_SPACE_FIXED_HARDWARE (acpi_adr_space_type) 0x7F
ACPI_REG_DISCONNECT 0
ACPI_REG_CONNECT 1
ACPI_BITREG_TIMER_STATUS 0x00
ACPI_BITREG_BUS_MASTER_STATUS 0x01
ACPI_BITREG_GLOBAL_LOCK_STATUS 0x02
ACPI_BITREG_POWER_BUTTON_STATUS 0x03
ACPI_BITREG_SLEEP_BUTTON_STATUS 0x04
ACPI_BITREG_RT_CLOCK_STATUS 0x05
ACPI_BITREG_WAKE_STATUS 0x06
ACPI_BITREG_PCIEXP_WAKE_STATUS 0x07
ACPI_BITREG_TIMER_ENABLE 0x08
ACPI_BITREG_GLOBAL_LOCK_ENABLE 0x09
ACPI_BITREG_POWER_BUTTON_ENABLE 0x0A
ACPI_BITREG_SLEEP_BUTTON_ENABLE 0x0B
ACPI_BITREG_RT_CLOCK_ENABLE 0x0C
ACPI_BITREG_PCIEXP_WAKE_DISABLE 0x0D
ACPI_BITREG_SCI_ENABLE 0x0E
ACPI_BITREG_BUS_MASTER_RLD 0x0F
ACPI_BITREG_GLOBAL_LOCK_RELEASE 0x10
ACPI_BITREG_SLEEP_TYPE 0x11
ACPI_BITREG_SLEEP_ENABLE 0x12
ACPI_BITREG_ARB_DISABLE 0x13
ACPI_BITREG_MAX 0x13
ACPI_NUM_BITREG ACPI_BITREG_MAX + 1
ACPI_CLEAR_STATUS 1
ACPI_ENABLE_EVENT 1
ACPI_DISABLE_EVENT 0
ACPI_NO_BUFFER 0
ACPI_ALLOCATE_BUFFER (acpi_size) (-1)
ACPI_ALLOCATE_LOCAL_BUFFER (acpi_size) (-2)
ACPI_FULL_PATHNAME 0
ACPI_SINGLE_NAME 1
ACPI_FULL_PATHNAME_NO_TRAILING 2
ACPI_NAME_TYPE_MAX 2
ACPI_SYS_MODE_UNKNOWN 0x0000
ACPI_SYS_MODE_ACPI 0x0001
ACPI_SYS_MODE_LEGACY 0x0002
ACPI_SYS_MODES_MASK 0x0003
ACPI_EVENT_TYPE_GPE 0
ACPI_EVENT_TYPE_FIXED 1
ACPI_INIT_DEVICE_INI 1
ACPI_TABLE_EVENT_LOAD 0x0
ACPI_TABLE_EVENT_UNLOAD 0x1
ACPI_TABLE_EVENT_INSTALL 0x2
ACPI_TABLE_EVENT_UNINSTALL 0x3
ACPI_NUM_TABLE_EVENTS 4
ACPI_DEFAULT_HANDLER NULL
ACPI_REGION_ACTIVATE 0
ACPI_REGION_DEACTIVATE 1
ACPI_INTERRUPT_NOT_HANDLED 0x00
ACPI_INTERRUPT_HANDLED 0x01
ACPI_REENABLE_GPE 0x80
ACPI_EISAID_STRING_SIZE 8
ACPI_UUID_LENGTH 16
ACPI_PCICLS_STRING_SIZE 7
ACPI_PCI_ROOT_BRIDGE 0x01
ACPI_VALID_ADR 0x0002
ACPI_VALID_HID 0x0004
ACPI_VALID_UID 0x0008
ACPI_VALID_CID 0x0020
ACPI_VALID_CLS 0x0040
ACPI_VALID_SXDS 0x0100
ACPI_VALID_SXWS 0x0200
ACPI_STA_DEVICE_PRESENT 0x01
ACPI_STA_DEVICE_ENABLED 0x02
ACPI_STA_DEVICE_UI 0x04
ACPI_STA_DEVICE_FUNCTIONING 0x08
ACPI_STA_DEVICE_OK 0x08
ACPI_STA_BATTERY_PRESENT 0x10
ACPI_VENDOR_STRINGS 0x01
ACPI_FEATURE_STRINGS 0x02
ACPI_ENABLE_INTERFACES 0x00
ACPI_DISABLE_INTERFACES 0x04
ACPI_DISABLE_ALL_VENDOR_STRINGS (ACPI_DISABLE_INTERFACES | ACPI_VENDOR_STRINGS)
ACPI_DISABLE_ALL_FEATURE_STRINGS (ACPI_DISABLE_INTERFACES | ACPI_FEATURE_STRINGS)
ACPI_DISABLE_ALL_STRINGS (ACPI_DISABLE_INTERFACES | ACPI_VENDOR_STRINGS | ACPI_FEATURE_STRINGS)
ACPI_ENABLE_ALL_VENDOR_STRINGS (ACPI_ENABLE_INTERFACES | ACPI_VENDOR_STRINGS)
ACPI_ENABLE_ALL_FEATURE_STRINGS (ACPI_ENABLE_INTERFACES | ACPI_FEATURE_STRINGS)
ACPI_ENABLE_ALL_STRINGS (ACPI_ENABLE_INTERFACES | ACPI_VENDOR_STRINGS | ACPI_FEATURE_STRINGS)
ACPI_OSI_WIN_2000 0x01
ACPI_OSI_WIN_XP 0x02
ACPI_OSI_WIN_XP_SP1 0x03
ACPI_OSI_WINSRV_2003 0x04
ACPI_OSI_WIN_XP_SP2 0x05
ACPI_OSI_WINSRV_2003_SP1 0x06
ACPI_OSI_WIN_VISTA 0x07
ACPI_OSI_WINSRV_2008 0x08
ACPI_OSI_WIN_VISTA_SP1 0x09
ACPI_OSI_WIN_VISTA_SP2 0x0A
ACPI_OSI_WIN_7 0x0B
ACPI_OSI_WIN_8 0x0C
ACPI_OSI_WIN_8_1 0x0D
ACPI_OSI_WIN_10 0x0E
ACPI_OSI_WIN_10_RS1 0x0F
ACPI_OSI_WIN_10_RS2 0x10
ACPI_OSI_WIN_10_RS3 0x11
ACPI_OSI_WIN_10_RS4 0x12
ACPI_OSI_WIN_10_RS5 0x13
ACPI_OSI_WIN_10_19H1 0x14
ACPI_OPT_END -1
AE_CODE_ENVIRONMENTAL 0x0000
AE_CODE_PROGRAMMER 0x1000
AE_CODE_ACPI_TABLES 0x2000
AE_CODE_AML 0x3000
AE_CODE_CONTROL 0x4000
AE_CODE_MAX 0x4000
AE_CODE_MASK 0xF000
EXCEP_ENV() ((acpi_status) ( | AE_CODE_ENVIRONMENTAL))
EXCEP_PGM() ((acpi_status) ( | AE_CODE_PROGRAMMER))
EXCEP_TBL() ((acpi_status) ( | AE_CODE_ACPI_TABLES))
EXCEP_AML() ((acpi_status) ( | AE_CODE_AML))
EXCEP_CTL() ((acpi_status) ( | AE_CODE_CONTROL))
EXCEP_TXT(,) {}
ACPI_SUCCESS() (!())
ACPI_FAILURE() ()
AE_OK (acpi_status) 0x0000
ACPI_ENV_EXCEPTION() ((() & AE_CODE_MASK) == AE_CODE_ENVIRONMENTAL)
ACPI_AML_EXCEPTION() ((() & AE_CODE_MASK) == AE_CODE_AML)
ACPI_PROG_EXCEPTION() ((() & AE_CODE_MASK) == AE_CODE_PROGRAMMER)
ACPI_TABLE_EXCEPTION() ((() & AE_CODE_MASK) == AE_CODE_ACPI_TABLES)
ACPI_CNTL_EXCEPTION() ((() & AE_CODE_MASK) == AE_CODE_CONTROL)
AE_ERROR EXCEP_ENV (0x0001)
AE_NO_ACPI_TABLES EXCEP_ENV (0x0002)
AE_NO_NAMESPACE EXCEP_ENV (0x0003)
AE_NO_MEMORY EXCEP_ENV (0x0004)
AE_NOT_FOUND EXCEP_ENV (0x0005)
AE_NOT_EXIST EXCEP_ENV (0x0006)
AE_ALREADY_EXISTS EXCEP_ENV (0x0007)
AE_TYPE EXCEP_ENV (0x0008)
AE_NULL_OBJECT EXCEP_ENV (0x0009)
AE_NULL_ENTRY EXCEP_ENV (0x000A)
AE_BUFFER_OVERFLOW EXCEP_ENV (0x000B)
AE_STACK_OVERFLOW EXCEP_ENV (0x000C)
AE_STACK_UNDERFLOW EXCEP_ENV (0x000D)
AE_NOT_IMPLEMENTED EXCEP_ENV (0x000E)
AE_SUPPORT EXCEP_ENV (0x000F)
AE_LIMIT EXCEP_ENV (0x0010)
AE_TIME EXCEP_ENV (0x0011)
AE_ACQUIRE_DEADLOCK EXCEP_ENV (0x0012)
AE_RELEASE_DEADLOCK EXCEP_ENV (0x0013)
AE_NOT_ACQUIRED EXCEP_ENV (0x0014)
AE_ALREADY_ACQUIRED EXCEP_ENV (0x0015)
AE_NO_HARDWARE_RESPONSE EXCEP_ENV (0x0016)
AE_NO_GLOBAL_LOCK EXCEP_ENV (0x0017)
AE_ABORT_METHOD EXCEP_ENV (0x0018)
AE_SAME_HANDLER EXCEP_ENV (0x0019)
AE_NO_HANDLER EXCEP_ENV (0x001A)
AE_OWNER_ID_LIMIT EXCEP_ENV (0x001B)
AE_NOT_CONFIGURED EXCEP_ENV (0x001C)
AE_ACCESS EXCEP_ENV (0x001D)
AE_IO_ERROR EXCEP_ENV (0x001E)
AE_NUMERIC_OVERFLOW EXCEP_ENV (0x001F)
AE_HEX_OVERFLOW EXCEP_ENV (0x0020)
AE_DECIMAL_OVERFLOW EXCEP_ENV (0x0021)
AE_OCTAL_OVERFLOW EXCEP_ENV (0x0022)
AE_END_OF_TABLE EXCEP_ENV (0x0023)
AE_CODE_ENV_MAX 0x0023
AE_BAD_PARAMETER EXCEP_PGM (0x0001)
AE_BAD_CHARACTER EXCEP_PGM (0x0002)
AE_BAD_PATHNAME EXCEP_PGM (0x0003)
AE_BAD_DATA EXCEP_PGM (0x0004)
AE_BAD_HEX_CONSTANT EXCEP_PGM (0x0005)
AE_BAD_OCTAL_CONSTANT EXCEP_PGM (0x0006)
AE_BAD_DECIMAL_CONSTANT EXCEP_PGM (0x0007)
AE_MISSING_ARGUMENTS EXCEP_PGM (0x0008)
AE_BAD_ADDRESS EXCEP_PGM (0x0009)
AE_CODE_PGM_MAX 0x0009
AE_BAD_SIGNATURE EXCEP_TBL (0x0001)
AE_BAD_HEADER EXCEP_TBL (0x0002)
AE_BAD_CHECKSUM EXCEP_TBL (0x0003)
AE_BAD_VALUE EXCEP_TBL (0x0004)
AE_INVALID_TABLE_LENGTH EXCEP_TBL (0x0005)
AE_CODE_TBL_MAX 0x0005
AE_AML_BAD_OPCODE EXCEP_AML (0x0001)
AE_AML_NO_OPERAND EXCEP_AML (0x0002)
AE_AML_OPERAND_TYPE EXCEP_AML (0x0003)
AE_AML_OPERAND_VALUE EXCEP_AML (0x0004)
AE_AML_UNINITIALIZED_LOCAL EXCEP_AML (0x0005)
AE_AML_UNINITIALIZED_ARG EXCEP_AML (0x0006)
AE_AML_UNINITIALIZED_ELEMENT EXCEP_AML (0x0007)
AE_AML_NUMERIC_OVERFLOW EXCEP_AML (0x0008)
AE_AML_REGION_LIMIT EXCEP_AML (0x0009)
AE_AML_BUFFER_LIMIT EXCEP_AML (0x000A)
AE_AML_PACKAGE_LIMIT EXCEP_AML (0x000B)
AE_AML_DIVIDE_BY_ZERO EXCEP_AML (0x000C)
AE_AML_BAD_NAME EXCEP_AML (0x000D)
AE_AML_NAME_NOT_FOUND EXCEP_AML (0x000E)
AE_AML_INTERNAL EXCEP_AML (0x000F)
AE_AML_INVALID_SPACE_ID EXCEP_AML (0x0010)
AE_AML_STRING_LIMIT EXCEP_AML (0x0011)
AE_AML_NO_RETURN_VALUE EXCEP_AML (0x0012)
AE_AML_METHOD_LIMIT EXCEP_AML (0x0013)
AE_AML_NOT_OWNER EXCEP_AML (0x0014)
AE_AML_MUTEX_ORDER EXCEP_AML (0x0015)
AE_AML_MUTEX_NOT_ACQUIRED EXCEP_AML (0x0016)
AE_AML_INVALID_RESOURCE_TYPE EXCEP_AML (0x0017)
AE_AML_INVALID_INDEX EXCEP_AML (0x0018)
AE_AML_REGISTER_LIMIT EXCEP_AML (0x0019)
AE_AML_NO_WHILE EXCEP_AML (0x001A)
AE_AML_ALIGNMENT EXCEP_AML (0x001B)
AE_AML_NO_RESOURCE_END_TAG EXCEP_AML (0x001C)
AE_AML_BAD_RESOURCE_VALUE EXCEP_AML (0x001D)
AE_AML_CIRCULAR_REFERENCE EXCEP_AML (0x001E)
AE_AML_BAD_RESOURCE_LENGTH EXCEP_AML (0x001F)
AE_AML_ILLEGAL_ADDRESS EXCEP_AML (0x0020)
AE_AML_LOOP_TIMEOUT EXCEP_AML (0x0021)
AE_AML_UNINITIALIZED_NODE EXCEP_AML (0x0022)
AE_AML_TARGET_TYPE EXCEP_AML (0x0023)
AE_AML_PROTOCOL EXCEP_AML (0x0024)
AE_AML_BUFFER_LENGTH EXCEP_AML (0x0025)
AE_CODE_AML_MAX 0x0025
AE_CTRL_RETURN_VALUE EXCEP_CTL (0x0001)
AE_CTRL_PENDING EXCEP_CTL (0x0002)
AE_CTRL_TERMINATE EXCEP_CTL (0x0003)
AE_CTRL_TRUE EXCEP_CTL (0x0004)
AE_CTRL_FALSE EXCEP_CTL (0x0005)
AE_CTRL_DEPTH EXCEP_CTL (0x0006)
AE_CTRL_END EXCEP_CTL (0x0007)
AE_CTRL_TRANSFER EXCEP_CTL (0x0008)
AE_CTRL_BREAK EXCEP_CTL (0x0009)
AE_CTRL_CONTINUE EXCEP_CTL (0x000A)
AE_CTRL_PARSE_CONTINUE EXCEP_CTL (0x000B)
AE_CTRL_PARSE_PENDING EXCEP_CTL (0x000C)
AE_CODE_CTRL_MAX 0x000C
ACPI_SIG_DSDT "DSDT"
ACPI_SIG_FADT "FACP"
ACPI_SIG_FACS "FACS"
ACPI_SIG_OSDT "OSDT"
ACPI_SIG_PSDT "PSDT"
ACPI_SIG_RSDP "RSD PTR "
ACPI_SIG_RSDT "RSDT"
ACPI_SIG_XSDT "XSDT"
ACPI_SIG_SSDT "SSDT"
ACPI_RSDP_NAME "RSDP"
ACPI_OEM_NAME "OEM"
ACPI_RSDT_ENTRY_SIZE (sizeof (u32))
ACPI_XSDT_ENTRY_SIZE (sizeof (u64))
ACPI_GLOCK_PENDING (1)
ACPI_GLOCK_OWNED (1<<1)
ACPI_FACS_S4_BIOS_PRESENT (1)
ACPI_FACS_64BIT_WAKE (1<<1)
ACPI_FACS_64BIT_ENVIRONMENT (1)
ACPI_FADT_LEGACY_DEVICES (1)
ACPI_FADT_8042 (1<<1)
ACPI_FADT_NO_VGA (1<<2)
ACPI_FADT_NO_MSI (1<<3)
ACPI_FADT_NO_ASPM (1<<4)
ACPI_FADT_NO_CMOS_RTC (1<<5)
FADT2_REVISION_ID 3
ACPI_FADT_PSCI_COMPLIANT (1)
ACPI_FADT_PSCI_USE_HVC (1<<1)
ACPI_FADT_WBINVD (1)
ACPI_FADT_WBINVD_FLUSH (1<<1)
ACPI_FADT_C1_SUPPORTED (1<<2)
ACPI_FADT_C2_MP_SUPPORTED (1<<3)
ACPI_FADT_POWER_BUTTON (1<<4)
ACPI_FADT_SLEEP_BUTTON (1<<5)
ACPI_FADT_FIXED_RTC (1<<6)
ACPI_FADT_S4_RTC_WAKE (1<<7)
ACPI_FADT_32BIT_TIMER (1<<8)
ACPI_FADT_DOCKING_SUPPORTED (1<<9)
ACPI_FADT_RESET_REGISTER (1<<10)
ACPI_FADT_SEALED_CASE (1<<11)
ACPI_FADT_HEADLESS (1<<12)
ACPI_FADT_SLEEP_TYPE (1<<13)
ACPI_FADT_PCI_EXPRESS_WAKE (1<<14)
ACPI_FADT_PLATFORM_CLOCK (1<<15)
ACPI_FADT_S4_RTC_VALID (1<<16)
ACPI_FADT_REMOTE_POWER_ON (1<<17)
ACPI_FADT_APIC_CLUSTER (1<<18)
ACPI_FADT_APIC_PHYSICAL (1<<19)
ACPI_FADT_HW_REDUCED (1<<20)
ACPI_FADT_LOW_POWER_S0 (1<<21)
ACPI_X_WAKE_STATUS 0x80
ACPI_X_SLEEP_TYPE_MASK 0x1C
ACPI_X_SLEEP_TYPE_POSITION 0x02
ACPI_X_SLEEP_ENABLE 0x20
ACPI_MAX_TABLE_VALIDATIONS ACPI_UINT16_MAX
ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL (0)
ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL (1)
ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL (2)
ACPI_TABLE_ORIGIN_MASK (3)
ACPI_TABLE_IS_VERIFIED (4)
ACPI_TABLE_IS_LOADED (8)
ACPI_SIG_ASF "ASF!"
ACPI_SIG_BERT "BERT"
ACPI_SIG_BGRT "BGRT"
ACPI_SIG_BOOT "BOOT"
ACPI_SIG_CPEP "CPEP"
ACPI_SIG_CSRT "CSRT"
ACPI_SIG_DBG2 "DBG2"
ACPI_SIG_DBGP "DBGP"
ACPI_SIG_DMAR "DMAR"
ACPI_SIG_DRTM "DRTM"
ACPI_SIG_ECDT "ECDT"
ACPI_SIG_EINJ "EINJ"
ACPI_SIG_ERST "ERST"
ACPI_SIG_FPDT "FPDT"
ACPI_SIG_GTDT "GTDT"
ACPI_SIG_HEST "HEST"
ACPI_SIG_HMAT "HMAT"
ACPI_SIG_HPET "HPET"
ACPI_SIG_IBFT "IBFT"
ACPI_SIG_S3PT "S3PT"
ACPI_SIG_PCCS "PCC"
ACPI_SIG_MATR "MATR"
ACPI_SIG_MSDM "MSDM"
ACPI_ASF_SMBUS_PROTOCOLS (1)
ACPI_BERT_UNCORRECTABLE (1)
ACPI_BERT_CORRECTABLE (1<<1)
ACPI_BERT_MULTIPLE_UNCORRECTABLE (1<<2)
ACPI_BERT_MULTIPLE_CORRECTABLE (1<<3)
ACPI_BERT_ERROR_ENTRY_COUNT (0xFF<<4)
ACPI_BGRT_DISPLAYED (1)
ACPI_BGRT_ORIENTATION_OFFSET (3 << 1)
ACPI_CSRT_TYPE_INTERRUPT 0x0001
ACPI_CSRT_TYPE_TIMER 0x0002
ACPI_CSRT_TYPE_DMA 0x0003
ACPI_CSRT_XRUPT_LINE 0x0000
ACPI_CSRT_XRUPT_CONTROLLER 0x0001
ACPI_CSRT_TIMER 0x0000
ACPI_CSRT_DMA_CHANNEL 0x0000
ACPI_CSRT_DMA_CONTROLLER 0x0001
ACPI_DBG2_SERIAL_PORT 0x8000
ACPI_DBG2_1394_PORT 0x8001
ACPI_DBG2_USB_PORT 0x8002
ACPI_DBG2_NET_PORT 0x8003
ACPI_DBG2_16550_COMPATIBLE 0x0000
ACPI_DBG2_16550_SUBSET 0x0001
ACPI_DBG2_ARM_PL011 0x0003
ACPI_DBG2_ARM_SBSA_32BIT 0x000D
ACPI_DBG2_ARM_SBSA_GENERIC 0x000E
ACPI_DBG2_ARM_DCC 0x000F
ACPI_DBG2_BCM2835 0x0010
ACPI_DBG2_1394_STANDARD 0x0000
ACPI_DBG2_USB_XHCI 0x0000
ACPI_DBG2_USB_EHCI 0x0001
ACPI_DMAR_INTR_REMAP (1)
ACPI_DMAR_X2APIC_OPT_OUT (1<<1)
ACPI_DMAR_X2APIC_MODE (1<<2)
ACPI_DMAR_INCLUDE_ALL (1)
ACPI_DMAR_ALLOW_ALL (1)
ACPI_DMAR_ALL_PORTS (1)
ACPI_DRTM_ACCESS_ALLOWED (1)
ACPI_DRTM_ENABLE_GAP_CODE (1<<1)
ACPI_DRTM_INCOMPLETE_MEASUREMENTS (1<<2)
ACPI_DRTM_AUTHORITY_ORDER (1<<3)
ACPI_EINJ_PRESERVE (1)
ACPI_EINJ_PROCESSOR_CORRECTABLE (1)
ACPI_EINJ_PROCESSOR_UNCORRECTABLE (1<<1)
ACPI_EINJ_PROCESSOR_FATAL (1<<2)
ACPI_EINJ_MEMORY_CORRECTABLE (1<<3)
ACPI_EINJ_MEMORY_UNCORRECTABLE (1<<4)
ACPI_EINJ_MEMORY_FATAL (1<<5)
ACPI_EINJ_PCIX_CORRECTABLE (1<<6)
ACPI_EINJ_PCIX_UNCORRECTABLE (1<<7)
ACPI_EINJ_PCIX_FATAL (1<<8)
ACPI_EINJ_PLATFORM_CORRECTABLE (1<<9)
ACPI_EINJ_PLATFORM_UNCORRECTABLE (1<<10)
ACPI_EINJ_PLATFORM_FATAL (1<<11)
ACPI_EINJ_VENDOR_DEFINED (1<<31)
ACPI_ERST_PRESERVE (1)
ACPI_GTDT_INTERRUPT_MODE (1)
ACPI_GTDT_INTERRUPT_POLARITY (1<<1)
ACPI_GTDT_ALWAYS_ON (1<<2)
ACPI_GTDT_GT_IRQ_MODE (1)
ACPI_GTDT_GT_IRQ_POLARITY (1<<1)
ACPI_GTDT_GT_IS_SECURE_TIMER (1)
ACPI_GTDT_GT_ALWAYS_ON (1<<1)
ACPI_GTDT_WATCHDOG_IRQ_MODE (1)
ACPI_GTDT_WATCHDOG_IRQ_POLARITY (1<<1)
ACPI_GTDT_WATCHDOG_SECURE (1<<2)
ACPI_HEST_FIRMWARE_FIRST (1)
ACPI_HEST_GLOBAL (1<<1)
ACPI_HEST_GHES_ASSIST (1<<2)
ACPI_HEST_BUS() (() & 0xFF)
ACPI_HEST_SEGMENT() ((() >> 8) & 0xFFFF)
ACPI_HEST_TYPE (1)
ACPI_HEST_POLL_INTERVAL (1<<1)
ACPI_HEST_POLL_THRESHOLD_VALUE (1<<2)
ACPI_HEST_POLL_THRESHOLD_WINDOW (1<<3)
ACPI_HEST_ERR_THRESHOLD_VALUE (1<<4)
ACPI_HEST_ERR_THRESHOLD_WINDOW (1<<5)
ACPI_HEST_UNCORRECTABLE (1)
ACPI_HEST_CORRECTABLE (1<<1)
ACPI_HEST_MULTIPLE_UNCORRECTABLE (1<<2)
ACPI_HEST_MULTIPLE_CORRECTABLE (1<<3)
ACPI_HEST_ERROR_ENTRY_COUNT (0xFF<<4)
ACPI_HEST_GEN_ERROR_RECOVERABLE 0
ACPI_HEST_GEN_ERROR_FATAL 1
ACPI_HEST_GEN_ERROR_CORRECTED 2
ACPI_HEST_GEN_ERROR_NONE 3
ACPI_HEST_GEN_VALID_FRU_ID (1)
ACPI_HEST_GEN_VALID_FRU_STRING (1<<1)
ACPI_HEST_GEN_VALID_TIMESTAMP (1<<2)
ACPI_HMAT_PROCESSOR_PD_VALID (1)
ACPI_HMAT_MEMORY_PD_VALID (1<<1)
ACPI_HMAT_RESERVATION_HINT (1<<2)
ACPI_HMAT_MEMORY_HIERARCHY (0x0F)
ACPI_HMAT_MEMORY 0
ACPI_HMAT_LAST_LEVEL_CACHE 1
ACPI_HMAT_1ST_LEVEL_CACHE 2
ACPI_HMAT_2ND_LEVEL_CACHE 3
ACPI_HMAT_3RD_LEVEL_CACHE 4
ACPI_HMAT_ACCESS_LATENCY 0
ACPI_HMAT_READ_LATENCY 1
ACPI_HMAT_WRITE_LATENCY 2
ACPI_HMAT_ACCESS_BANDWIDTH 3
ACPI_HMAT_READ_BANDWIDTH 4
ACPI_HMAT_WRITE_BANDWIDTH 5
ACPI_HMAT_TOTAL_CACHE_LEVEL (0x0000000F)
ACPI_HMAT_CACHE_LEVEL (0x000000F0)
ACPI_HMAT_CACHE_ASSOCIATIVITY (0x00000F00)
ACPI_HMAT_WRITE_POLICY (0x0000F000)
ACPI_HMAT_CACHE_LINE_SIZE (0xFFFF0000)
ACPI_HMAT_CA_NONE (0)
ACPI_HMAT_CA_DIRECT_MAPPED (1)
ACPI_HMAT_CA_COMPLEX_CACHE_INDEXING (2)
ACPI_HMAT_CP_NONE (0)
ACPI_HMAT_CP_WB (1)
ACPI_HMAT_CP_WT (2)
ACPI_HPET_PAGE_PROTECT_MASK (3)
ACPI_SIG_IORT "IORT"
ACPI_SIG_IVRS "IVRS"
ACPI_SIG_LPIT "LPIT"
ACPI_SIG_MADT "APIC"
ACPI_SIG_MCFG "MCFG"
ACPI_SIG_MCHI "MCHI"
ACPI_SIG_MPST "MPST"
ACPI_SIG_MSCT "MSCT"
ACPI_SIG_MSDM "MSDM"
ACPI_SIG_MTMR "MTMR"
ACPI_SIG_NFIT "NFIT"
ACPI_SIG_PCCT "PCCT"
ACPI_SIG_PDTT "PDTT"
ACPI_SIG_PMTT "PMTT"
ACPI_SIG_PPTT "PPTT"
ACPI_SIG_RASF "RASF"
ACPI_SIG_SBST "SBST"
ACPI_SIG_SDEI "SDEI"
ACPI_SIG_SDEV "SDEV"
ACPI_IORT_ID_SINGLE_MAPPING (1)
ACPI_IORT_NODE_COHERENT 0x00000001
ACPI_IORT_NODE_NOT_COHERENT 0x00000000
ACPI_IORT_HT_TRANSIENT (1)
ACPI_IORT_HT_WRITE (1<<1)
ACPI_IORT_HT_READ (1<<2)
ACPI_IORT_HT_OVERRIDE (1<<3)
ACPI_IORT_MF_COHERENCY (1)
ACPI_IORT_MF_ATTRIBUTES (1<<1)
ACPI_IORT_NC_STALL_SUPPORTED (1)
ACPI_IORT_NC_PASID_BITS (31<<1)
ACPI_IORT_ATS_SUPPORTED 0x00000001
ACPI_IORT_ATS_UNSUPPORTED 0x00000000
ACPI_IORT_SMMU_V1 0x00000000
ACPI_IORT_SMMU_V2 0x00000001
ACPI_IORT_SMMU_CORELINK_MMU400 0x00000002
ACPI_IORT_SMMU_CORELINK_MMU500 0x00000003
ACPI_IORT_SMMU_CORELINK_MMU401 0x00000004
ACPI_IORT_SMMU_CAVIUM_THUNDERX 0x00000005
ACPI_IORT_SMMU_DVM_SUPPORTED (1)
ACPI_IORT_SMMU_COHERENT_WALK (1<<1)
ACPI_IORT_SMMU_V3_GENERIC 0x00000000
ACPI_IORT_SMMU_V3_HISILICON_HI161X 0x00000001
ACPI_IORT_SMMU_V3_CAVIUM_CN99XX 0x00000002
ACPI_IORT_SMMU_V3_COHACC_OVERRIDE (1)
ACPI_IORT_SMMU_V3_HTTU_OVERRIDE (3<<1)
ACPI_IORT_SMMU_V3_PXM_VALID (1<<3)
ACPI_IVRS_PHYSICAL_SIZE 0x00007F00
ACPI_IVRS_VIRTUAL_SIZE 0x003F8000
ACPI_IVRS_ATS_RESERVED 0x00400000
ACPI_IVHD_TT_ENABLE (1)
ACPI_IVHD_PASS_PW (1<<1)
ACPI_IVHD_RES_PASS_PW (1<<2)
ACPI_IVHD_ISOC (1<<3)
ACPI_IVHD_IOTLB (1<<4)
ACPI_IVMD_UNITY (1)
ACPI_IVMD_READ (1<<1)
ACPI_IVMD_WRITE (1<<2)
ACPI_IVMD_EXCLUSION_RANGE (1<<3)
ACPI_IVHD_MSI_NUMBER_MASK 0x001F
ACPI_IVHD_UNIT_ID_MASK 0x1F00
ACPI_IVHD_ENTRY_LENGTH 0xC0
ACPI_IVHD_INIT_PASS (1)
ACPI_IVHD_EINT_PASS (1<<1)
ACPI_IVHD_NMI_PASS (1<<2)
ACPI_IVHD_SYSTEM_MGMT (3<<4)
ACPI_IVHD_LINT0_PASS (1<<6)
ACPI_IVHD_LINT1_PASS (1<<7)
ACPI_IVHD_ATS_DISABLED (1<<31)
ACPI_IVHD_IOAPIC 1
ACPI_IVHD_HPET 2
ACPI_LPIT_STATE_DISABLED (1)
ACPI_LPIT_NO_COUNTER (1<<1)
ACPI_MADT_PCAT_COMPAT (1)
ACPI_MADT_DUAL_PIC 1
ACPI_MADT_MULTIPLE_APIC 0
ACPI_MADT_CPEI_OVERRIDE (1)
ACPI_MADT_PERFORMANCE_IRQ_MODE (1<<1)
ACPI_MADT_VGIC_IRQ_MODE (1<<2)
ACPI_MADT_OVERRIDE_SPI_VALUES (1)
ACPI_MADT_ENABLED (1)
ACPI_MADT_POLARITY_MASK (3)
ACPI_MADT_TRIGGER_MASK (3<<2)
ACPI_MADT_POLARITY_CONFORMS 0
ACPI_MADT_POLARITY_ACTIVE_HIGH 1
ACPI_MADT_POLARITY_RESERVED 2
ACPI_MADT_POLARITY_ACTIVE_LOW 3
ACPI_MADT_TRIGGER_CONFORMS (0)
ACPI_MADT_TRIGGER_EDGE (1<<2)
ACPI_MADT_TRIGGER_RESERVED (2<<2)
ACPI_MADT_TRIGGER_LEVEL (3<<2)
ACPI_MPST_CHANNEL_INFO u8 channel_id; u8 reserved1[3]; u16 power_node_count; u16 reserved2;
ACPI_MPST_ENABLED 1
ACPI_MPST_POWER_MANAGED 2
ACPI_MPST_HOT_PLUG_CAPABLE 4
ACPI_MPST_PRESERVE 1
ACPI_MPST_AUTOENTRY 2
ACPI_MPST_AUTOEXIT 4
ACPI_NFIT_ADD_ONLINE_ONLY (1)
ACPI_NFIT_PROXIMITY_VALID (1<<1)
ACPI_NFIT_MEM_SAVE_FAILED (1)
ACPI_NFIT_MEM_RESTORE_FAILED (1<<1)
ACPI_NFIT_MEM_FLUSH_FAILED (1<<2)
ACPI_NFIT_MEM_NOT_ARMED (1<<3)
ACPI_NFIT_MEM_HEALTH_OBSERVED (1<<4)
ACPI_NFIT_MEM_HEALTH_ENABLED (1<<5)
ACPI_NFIT_MEM_MAP_FAILED (1<<6)
ACPI_NFIT_CONTROL_BUFFERED (1)
ACPI_NFIT_CONTROL_MFG_INFO_VALID (1)
ACPI_NFIT_CAPABILITY_CACHE_FLUSH (1)
ACPI_NFIT_CAPABILITY_MEM_FLUSH (1<<1)
ACPI_NFIT_CAPABILITY_MEM_MIRRORING (1<<2)
ACPI_NFIT_DIMM_NUMBER_MASK 0x0000000F
ACPI_NFIT_CHANNEL_NUMBER_MASK 0x000000F0
ACPI_NFIT_MEMORY_ID_MASK 0x00000F00
ACPI_NFIT_SOCKET_ID_MASK 0x0000F000
ACPI_NFIT_NODE_ID_MASK 0x0FFF0000
ACPI_NFIT_DIMM_NUMBER_OFFSET 0
ACPI_NFIT_CHANNEL_NUMBER_OFFSET 4
ACPI_NFIT_MEMORY_ID_OFFSET 8
ACPI_NFIT_SOCKET_ID_OFFSET 12
ACPI_NFIT_NODE_ID_OFFSET 16
ACPI_NFIT_BUILD_DEVICE_HANDLE(,,,,) (() | (() << ACPI_NFIT_CHANNEL_NUMBER_OFFSET) | (() << ACPI_NFIT_MEMORY_ID_OFFSET) | (() << ACPI_NFIT_SOCKET_ID_OFFSET) | (() << ACPI_NFIT_NODE_ID_OFFSET))
ACPI_NFIT_GET_DIMM_NUMBER() (() & ACPI_NFIT_DIMM_NUMBER_MASK)
ACPI_NFIT_GET_CHANNEL_NUMBER() ((() & ACPI_NFIT_CHANNEL_NUMBER_MASK) >> ACPI_NFIT_CHANNEL_NUMBER_OFFSET)
ACPI_NFIT_GET_MEMORY_ID() ((() & ACPI_NFIT_MEMORY_ID_MASK) >> ACPI_NFIT_MEMORY_ID_OFFSET)
ACPI_NFIT_GET_SOCKET_ID() ((() & ACPI_NFIT_SOCKET_ID_MASK) >> ACPI_NFIT_SOCKET_ID_OFFSET)
ACPI_NFIT_GET_NODE_ID() ((() & ACPI_NFIT_NODE_ID_MASK) >> ACPI_NFIT_NODE_ID_OFFSET)
ACPI_PCCT_DOORBELL 1
ACPI_PCCT_INTERRUPT_POLARITY (1)
ACPI_PCCT_INTERRUPT_MODE (1<<1)
ACPI_PDTT_RUNTIME_TRIGGER (1)
ACPI_PDTT_WAIT_COMPLETION (1<<1)
ACPI_PDTT_TRIGGER_ORDER (1<<2)
ACPI_PMTT_TYPE_SOCKET 0
ACPI_PMTT_TYPE_CONTROLLER 1
ACPI_PMTT_TYPE_DIMM 2
ACPI_PMTT_TYPE_RESERVED 3
ACPI_PMTT_TOP_LEVEL 0x0001
ACPI_PMTT_PHYSICAL 0x0002
ACPI_PMTT_MEMORY_TYPE 0x000C
ACPI_PPTT_PHYSICAL_PACKAGE (1)
ACPI_PPTT_ACPI_PROCESSOR_ID_VALID (1<<1)
ACPI_PPTT_ACPI_PROCESSOR_IS_THREAD (1<<2)
ACPI_PPTT_ACPI_LEAF_NODE (1<<3)
ACPI_PPTT_ACPI_IDENTICAL (1<<4)
ACPI_PPTT_SIZE_PROPERTY_VALID (1)
ACPI_PPTT_NUMBER_OF_SETS_VALID (1<<1)
ACPI_PPTT_ASSOCIATIVITY_VALID (1<<2)
ACPI_PPTT_ALLOCATION_TYPE_VALID (1<<3)
ACPI_PPTT_CACHE_TYPE_VALID (1<<4)
ACPI_PPTT_WRITE_POLICY_VALID (1<<5)
ACPI_PPTT_LINE_SIZE_VALID (1<<6)
ACPI_PPTT_MASK_ALLOCATION_TYPE (0x03)
ACPI_PPTT_MASK_CACHE_TYPE (0x0C)
ACPI_PPTT_MASK_WRITE_POLICY (0x10)
ACPI_PPTT_CACHE_READ_ALLOCATE (0x0)
ACPI_PPTT_CACHE_WRITE_ALLOCATE (0x01)
ACPI_PPTT_CACHE_RW_ALLOCATE (0x02)
ACPI_PPTT_CACHE_RW_ALLOCATE_ALT (0x03)
ACPI_PPTT_CACHE_TYPE_DATA (0x0)
ACPI_PPTT_CACHE_TYPE_INSTR (1<<2)
ACPI_PPTT_CACHE_TYPE_UNIFIED (2<<2)
ACPI_PPTT_CACHE_TYPE_UNIFIED_ALT (3<<2)
ACPI_PPTT_CACHE_POLICY_WB (0x0)
ACPI_PPTT_CACHE_POLICY_WT (1<<4)
ACPI_RASF_SCRUBBER_RUNNING 1
ACPI_RASF_SPEED (7<<1)
ACPI_RASF_SPEED_SLOW (0<<1)
ACPI_RASF_SPEED_MEDIUM (4<<1)
ACPI_RASF_SPEED_FAST (7<<1)
ACPI_RASF_GENERATE_SCI (1<<15)
ACPI_RASF_COMMAND_COMPLETE (1)
ACPI_RASF_SCI_DOORBELL (1<<1)
ACPI_RASF_ERROR (1<<2)
ACPI_RASF_STATUS (0x1F<<3)
ACPI_SDEV_HANDOFF_TO_UNSECURE_OS (1)
ACPI_SIG_SLIC "SLIC"
ACPI_SIG_SLIT "SLIT"
ACPI_SIG_SPCR "SPCR"
ACPI_SIG_SPMI "SPMI"
ACPI_SIG_SRAT "SRAT"
ACPI_SIG_STAO "STAO"
ACPI_SIG_TCPA "TCPA"
ACPI_SIG_TPM2 "TPM2"
ACPI_SIG_UEFI "UEFI"
ACPI_SIG_VRTC "VRTC"
ACPI_SIG_WAET "WAET"
ACPI_SIG_WDAT "WDAT"
ACPI_SIG_WDDT "WDDT"
ACPI_SIG_WDRT "WDRT"
ACPI_SIG_WPBT "WPBT"
ACPI_SIG_WSMT "WSMT"
ACPI_SIG_XENV "XENV"
ACPI_SIG_XXXX "XXXX"
ACPI_SPCR_DO_NOT_DISABLE (1)
ACPI_SRAT_CPU_USE_AFFINITY (1)
ACPI_SRAT_MEM_ENABLED (1)
ACPI_SRAT_MEM_HOT_PLUGGABLE (1<<1)
ACPI_SRAT_MEM_NON_VOLATILE (1<<2)
ACPI_SRAT_CPU_ENABLED (1)
ACPI_SRAT_GICC_ENABLED (1)
ACPI_SRAT_GENERIC_AFFINITY_ENABLED (1)
ACPI_TCPA_CLIENT_TABLE 0
ACPI_TCPA_SERVER_TABLE 1
ACPI_TCPA_PCI_DEVICE (1)
ACPI_TCPA_BUS_PNP (1<<1)
ACPI_TCPA_ADDRESS_VALID (1<<2)
ACPI_TCPA_INTERRUPT_MODE (1)
ACPI_TCPA_INTERRUPT_POLARITY (1<<1)
ACPI_TCPA_SCI_VIA_GPE (1<<2)
ACPI_TCPA_GLOBAL_INTERRUPT (1<<3)
ACPI_TPM23_ACPI_START_METHOD 2
ACPI_TPM2_NOT_ALLOWED 0
ACPI_TPM2_RESERVED1 1
ACPI_TPM2_START_METHOD 2
ACPI_TPM2_RESERVED3 3
ACPI_TPM2_RESERVED4 4
ACPI_TPM2_RESERVED5 5
ACPI_TPM2_MEMORY_MAPPED 6
ACPI_TPM2_COMMAND_BUFFER 7
ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD 8
ACPI_TPM2_RESERVED9 9
ACPI_TPM2_RESERVED10 10
ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC 11
ACPI_TPM2_RESERVED 12
ACPI_TPM2_INTERRUPT_SUPPORT (1)
ACPI_TPM2_IDLE_SUPPORT (1)
ACPI_WAET_RTC_NO_ACK (1)
ACPI_WAET_TIMER_ONE_READ (1<<1)
ACPI_WDAT_ENABLED (1)
ACPI_WDAT_STOPPED 0x80
ACPI_WDDT_AVAILABLE (1)
ACPI_WDDT_ACTIVE (1<<1)
ACPI_WDDT_TCO_OS_OWNED (1<<2)
ACPI_WDDT_USER_RESET (1<<11)
ACPI_WDDT_WDT_RESET (1<<12)
ACPI_WDDT_POWER_FAIL (1<<13)
ACPI_WDDT_UNKNOWN_RESET (1<<14)
ACPI_WDDT_AUTO_RESET (1)
ACPI_WDDT_ALERT_SUPPORT (1<<1)
ACPI_WSMT_FIXED_COMM_BUFFERS (1)
ACPI_WSMT_COMM_BUFFER_NESTED_PTR_PROTECTION (2)
ACPI_WSMT_SYSTEM_RESOURCE_PROTECTION (4)
ACPI_FADT_OFFSET() (u16) ACPI_OFFSET (struct acpi_table_fadt, )
ACPI_FADT_V1_SIZE (u32) (ACPI_FADT_OFFSET (flags) + 4)
ACPI_FADT_V2_SIZE (u32) (ACPI_FADT_OFFSET (minor_revision) + 1)
ACPI_FADT_V3_SIZE (u32) (ACPI_FADT_OFFSET (sleep_control))
ACPI_FADT_V5_SIZE (u32) (ACPI_FADT_OFFSET (hypervisor_id))
ACPI_FADT_V6_SIZE (u32) (sizeof (struct acpi_table_fadt))
ACPI_FADT_CONFORMANCE "ACPI 6.1 (FADT version 6)"
ACPI_READ_ONLY_MEMORY (u8) 0x00
ACPI_READ_WRITE_MEMORY (u8) 0x01
ACPI_NON_CACHEABLE_MEMORY (u8) 0x00
ACPI_CACHABLE_MEMORY (u8) 0x01
ACPI_WRITE_COMBINING_MEMORY (u8) 0x02
ACPI_PREFETCHABLE_MEMORY (u8) 0x03
ACPI_NON_ISA_ONLY_RANGES (u8) 0x01
ACPI_ISA_ONLY_RANGES (u8) 0x02
ACPI_ENTIRE_RANGE (ACPI_NON_ISA_ONLY_RANGES | ACPI_ISA_ONLY_RANGES)
ACPI_SPARSE_TRANSLATION (u8) 0x01
ACPI_DECODE_10 (u8) 0x00
ACPI_DECODE_16 (u8) 0x01
ACPI_LEVEL_SENSITIVE (u8) 0x00
ACPI_EDGE_SENSITIVE (u8) 0x01
ACPI_ACTIVE_HIGH (u8) 0x00
ACPI_ACTIVE_LOW (u8) 0x01
ACPI_ACTIVE_BOTH (u8) 0x02
ACPI_EXCLUSIVE (u8) 0x00
ACPI_SHARED (u8) 0x01
ACPI_NOT_WAKE_CAPABLE (u8) 0x00
ACPI_WAKE_CAPABLE (u8) 0x01
ACPI_COMPATIBILITY (u8) 0x00
ACPI_TYPE_A (u8) 0x01
ACPI_TYPE_B (u8) 0x02
ACPI_TYPE_F (u8) 0x03
ACPI_NOT_BUS_MASTER (u8) 0x00
ACPI_BUS_MASTER (u8) 0x01
ACPI_TRANSFER_8 (u8) 0x00
ACPI_TRANSFER_8_16 (u8) 0x01
ACPI_TRANSFER_16 (u8) 0x02
ACPI_GOOD_CONFIGURATION (u8) 0x00
ACPI_ACCEPTABLE_CONFIGURATION (u8) 0x01
ACPI_SUB_OPTIMAL_CONFIGURATION (u8) 0x02
ACPI_MEMORY_RANGE (u8) 0x00
ACPI_IO_RANGE (u8) 0x01
ACPI_BUS_NUMBER_RANGE (u8) 0x02
ACPI_ADDRESS_NOT_FIXED (u8) 0x00
ACPI_ADDRESS_FIXED (u8) 0x01
ACPI_POS_DECODE (u8) 0x00
ACPI_SUB_DECODE (u8) 0x01
ACPI_PRODUCER (u8) 0x00
ACPI_CONSUMER (u8) 0x01
ACPI_DMA_WIDTH8 0
ACPI_DMA_WIDTH16 1
ACPI_DMA_WIDTH32 2
ACPI_DMA_WIDTH64 3
ACPI_DMA_WIDTH128 4
ACPI_DMA_WIDTH256 5
ACPI_RESOURCE_ADDRESS_COMMON u8 resource_type; u8 producer_consumer; u8 decode; u8 min_address_fixed; u8 max_address_fixed; union acpi_resource_attribute info;
ACPI_RESOURCE_GPIO_TYPE_INT 0
ACPI_RESOURCE_GPIO_TYPE_IO 1
ACPI_PIN_CONFIG_DEFAULT 0
ACPI_PIN_CONFIG_PULLUP 1
ACPI_PIN_CONFIG_PULLDOWN 2
ACPI_PIN_CONFIG_NOPULL 3
ACPI_IO_RESTRICT_NONE 0
ACPI_IO_RESTRICT_INPUT 1
ACPI_IO_RESTRICT_OUTPUT 2
ACPI_IO_RESTRICT_NONE_PRESERVE 3
ACPI_RESOURCE_SERIAL_COMMON u8 revision_id; u8 type; u8 producer_consumer; /* For values, see Producer/Consumer above */ u8 slave_mode; u8 connection_sharing; u8 type_revision_id; u16 type_data_length; u16 vendor_length; struct acpi_resource_source resource_source; u8 *vendor_data;
ACPI_RESOURCE_SERIAL_TYPE_I2C 1
ACPI_RESOURCE_SERIAL_TYPE_SPI 2
ACPI_RESOURCE_SERIAL_TYPE_UART 3
ACPI_CONTROLLER_INITIATED 0
ACPI_DEVICE_INITIATED 1
ACPI_I2C_7BIT_MODE 0
ACPI_I2C_10BIT_MODE 1
ACPI_SPI_4WIRE_MODE 0
ACPI_SPI_3WIRE_MODE 1
ACPI_SPI_ACTIVE_LOW 0
ACPI_SPI_ACTIVE_HIGH 1
ACPI_SPI_FIRST_PHASE 0
ACPI_SPI_SECOND_PHASE 1
ACPI_SPI_START_LOW 0
ACPI_SPI_START_HIGH 1
ACPI_UART_LITTLE_ENDIAN 0
ACPI_UART_BIG_ENDIAN 1
ACPI_UART_5_DATA_BITS 0
ACPI_UART_6_DATA_BITS 1
ACPI_UART_7_DATA_BITS 2
ACPI_UART_8_DATA_BITS 3
ACPI_UART_9_DATA_BITS 4
ACPI_UART_NO_STOP_BITS 0
ACPI_UART_1_STOP_BIT 1
ACPI_UART_1P5_STOP_BITS 2
ACPI_UART_2_STOP_BITS 3
ACPI_UART_FLOW_CONTROL_NONE 0
ACPI_UART_FLOW_CONTROL_HW 1
ACPI_UART_FLOW_CONTROL_XON_XOFF 2
ACPI_UART_PARITY_NONE 0
ACPI_UART_PARITY_EVEN 1
ACPI_UART_PARITY_ODD 2
ACPI_UART_PARITY_MARK 3
ACPI_UART_PARITY_SPACE 4
ACPI_UART_CARRIER_DETECT (1<<2)
ACPI_UART_RING_INDICATOR (1<<3)
ACPI_UART_DATA_SET_READY (1<<4)
ACPI_UART_DATA_TERMINAL_READY (1<<5)
ACPI_UART_CLEAR_TO_SEND (1<<6)
ACPI_UART_REQUEST_TO_SEND (1<<7)
ACPI_PIN_CONFIG_DEFAULT 0
ACPI_PIN_CONFIG_BIAS_PULL_UP 1
ACPI_PIN_CONFIG_BIAS_PULL_DOWN 2
ACPI_PIN_CONFIG_BIAS_DEFAULT 3
ACPI_PIN_CONFIG_BIAS_DISABLE 4
ACPI_PIN_CONFIG_BIAS_HIGH_IMPEDANCE 5
ACPI_PIN_CONFIG_BIAS_BUS_HOLD 6
ACPI_PIN_CONFIG_DRIVE_OPEN_DRAIN 7
ACPI_PIN_CONFIG_DRIVE_OPEN_SOURCE 8
ACPI_PIN_CONFIG_DRIVE_PUSH_PULL 9
ACPI_PIN_CONFIG_DRIVE_STRENGTH 10
ACPI_PIN_CONFIG_SLEW_RATE 11
ACPI_PIN_CONFIG_INPUT_DEBOUNCE 12
ACPI_PIN_CONFIG_INPUT_SCHMITT_TRIGGER 13
ACPI_RESOURCE_TYPE_IRQ 0
ACPI_RESOURCE_TYPE_DMA 1
ACPI_RESOURCE_TYPE_START_DEPENDENT 2
ACPI_RESOURCE_TYPE_END_DEPENDENT 3
ACPI_RESOURCE_TYPE_IO 4
ACPI_RESOURCE_TYPE_FIXED_IO 5
ACPI_RESOURCE_TYPE_VENDOR 6
ACPI_RESOURCE_TYPE_END_TAG 7
ACPI_RESOURCE_TYPE_MEMORY24 8
ACPI_RESOURCE_TYPE_MEMORY32 9
ACPI_RESOURCE_TYPE_FIXED_MEMORY32 10
ACPI_RESOURCE_TYPE_ADDRESS16 11
ACPI_RESOURCE_TYPE_ADDRESS32 12
ACPI_RESOURCE_TYPE_ADDRESS64 13
ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 14
ACPI_RESOURCE_TYPE_EXTENDED_IRQ 15
ACPI_RESOURCE_TYPE_GENERIC_REGISTER 16
ACPI_RESOURCE_TYPE_GPIO 17
ACPI_RESOURCE_TYPE_FIXED_DMA 18
ACPI_RESOURCE_TYPE_SERIAL_BUS 19
ACPI_RESOURCE_TYPE_PIN_FUNCTION 20
ACPI_RESOURCE_TYPE_PIN_CONFIG 21
ACPI_RESOURCE_TYPE_PIN_GROUP 22
ACPI_RESOURCE_TYPE_PIN_GROUP_FUNCTION 23
ACPI_RESOURCE_TYPE_PIN_GROUP_CONFIG 24
ACPI_RESOURCE_TYPE_MAX 24
ACPI_RS_SIZE_NO_DATA 8
ACPI_RS_SIZE_MIN (u32) ACPI_ROUND_UP_TO_NATIVE_WORD (12)
ACPI_RS_SIZE() (u32) (ACPI_RS_SIZE_NO_DATA + sizeof ())
ACPI_NEXT_RESOURCE() ACPI_ADD_PTR (struct acpi_resource, (), ()->length)
acpi_os_create_lock() ({ spinlock_t *lock = ACPI_ALLOCATE(sizeof(*lock)); if (lock) { *() = lock; spin_lock_init(*()); } lock ? AE_OK : AE_NO_MEMORY; })
acpi_os_create_raw_lock() ({ raw_spinlock_t *lock = ACPI_ALLOCATE(sizeof(*lock)); if (lock) { *() = lock; raw_spin_lock_init(*()); } lock ? AE_OK : AE_NO_MEMORY; })
ACPI_UTILITIES 0x00000001
ACPI_HARDWARE 0x00000002
ACPI_EVENTS 0x00000004
ACPI_TABLES 0x00000008
ACPI_NAMESPACE 0x00000010
ACPI_PARSER 0x00000020
ACPI_DISPATCHER 0x00000040
ACPI_EXECUTER 0x00000080
ACPI_RESOURCES 0x00000100
ACPI_CA_DEBUGGER 0x00000200
ACPI_OS_SERVICES 0x00000400
ACPI_CA_DISASSEMBLER 0x00000800
ACPI_COMPILER 0x00001000
ACPI_TOOLS 0x00002000
ACPI_EXAMPLE 0x00004000
ACPI_DRIVER 0x00008000
DT_COMPILER 0x00010000
ASL_PREPROCESSOR 0x00020000
ACPI_ALL_COMPONENTS 0x0001FFFF
ACPI_COMPONENT_DEFAULT (ACPI_ALL_COMPONENTS)
ACPI_ALL_DRIVERS 0xFFFF0000
ACPI_LV_INIT 0x00000001
ACPI_LV_DEBUG_OBJECT 0x00000002
ACPI_LV_INFO 0x00000004
ACPI_LV_REPAIR 0x00000008
ACPI_LV_TRACE_POINT 0x00000010
ACPI_LV_ALL_EXCEPTIONS 0x0000001F
ACPI_LV_INIT_NAMES 0x00000020
ACPI_LV_PARSE 0x00000040
ACPI_LV_LOAD 0x00000080
ACPI_LV_DISPATCH 0x00000100
ACPI_LV_EXEC 0x00000200
ACPI_LV_NAMES 0x00000400
ACPI_LV_OPREGION 0x00000800
ACPI_LV_BFIELD 0x00001000
ACPI_LV_TABLES 0x00002000
ACPI_LV_VALUES 0x00004000
ACPI_LV_OBJECTS 0x00008000
ACPI_LV_RESOURCES 0x00010000
ACPI_LV_USER_REQUESTS 0x00020000
ACPI_LV_PACKAGE 0x00040000
ACPI_LV_EVALUATION 0x00080000
ACPI_LV_VERBOSITY1 0x000FFF40 | ACPI_LV_ALL_EXCEPTIONS
ACPI_LV_ALLOCATIONS 0x00100000
ACPI_LV_FUNCTIONS 0x00200000
ACPI_LV_OPTIMIZATIONS 0x00400000
ACPI_LV_PARSE_TREES 0x00800000
ACPI_LV_VERBOSITY2 0x00F00000 | ACPI_LV_VERBOSITY1
ACPI_LV_ALL ACPI_LV_VERBOSITY2
ACPI_LV_MUTEX 0x01000000
ACPI_LV_THREADS 0x02000000
ACPI_LV_IO 0x04000000
ACPI_LV_INTERRUPTS 0x08000000
ACPI_LV_VERBOSITY3 0x0F000000 | ACPI_LV_VERBOSITY2
ACPI_LV_AML_DISASSEMBLE 0x10000000
ACPI_LV_VERBOSE_INFO 0x20000000
ACPI_LV_FULL_TABLES 0x40000000
ACPI_LV_EVENTS 0x80000000
ACPI_LV_VERBOSE 0xF0000000
ACPI_DEBUG_LEVEL() (u32) ,ACPI_DEBUG_PARAMETERS
ACPI_DB_INIT ACPI_DEBUG_LEVEL (ACPI_LV_INIT)
ACPI_DB_DEBUG_OBJECT ACPI_DEBUG_LEVEL (ACPI_LV_DEBUG_OBJECT)
ACPI_DB_INFO ACPI_DEBUG_LEVEL (ACPI_LV_INFO)
ACPI_DB_REPAIR ACPI_DEBUG_LEVEL (ACPI_LV_REPAIR)
ACPI_DB_TRACE_POINT ACPI_DEBUG_LEVEL (ACPI_LV_TRACE_POINT)
ACPI_DB_ALL_EXCEPTIONS ACPI_DEBUG_LEVEL (ACPI_LV_ALL_EXCEPTIONS)
ACPI_DB_INIT_NAMES ACPI_DEBUG_LEVEL (ACPI_LV_INIT_NAMES)
ACPI_DB_THREADS ACPI_DEBUG_LEVEL (ACPI_LV_THREADS)
ACPI_DB_PARSE ACPI_DEBUG_LEVEL (ACPI_LV_PARSE)
ACPI_DB_DISPATCH ACPI_DEBUG_LEVEL (ACPI_LV_DISPATCH)
ACPI_DB_LOAD ACPI_DEBUG_LEVEL (ACPI_LV_LOAD)
ACPI_DB_EXEC ACPI_DEBUG_LEVEL (ACPI_LV_EXEC)
ACPI_DB_NAMES ACPI_DEBUG_LEVEL (ACPI_LV_NAMES)
ACPI_DB_OPREGION ACPI_DEBUG_LEVEL (ACPI_LV_OPREGION)
ACPI_DB_BFIELD ACPI_DEBUG_LEVEL (ACPI_LV_BFIELD)
ACPI_DB_TABLES ACPI_DEBUG_LEVEL (ACPI_LV_TABLES)
ACPI_DB_FUNCTIONS ACPI_DEBUG_LEVEL (ACPI_LV_FUNCTIONS)
ACPI_DB_OPTIMIZATIONS ACPI_DEBUG_LEVEL (ACPI_LV_OPTIMIZATIONS)
ACPI_DB_PARSE_TREES ACPI_DEBUG_LEVEL (ACPI_LV_PARSE_TREES)
ACPI_DB_VALUES ACPI_DEBUG_LEVEL (ACPI_LV_VALUES)
ACPI_DB_OBJECTS ACPI_DEBUG_LEVEL (ACPI_LV_OBJECTS)
ACPI_DB_ALLOCATIONS ACPI_DEBUG_LEVEL (ACPI_LV_ALLOCATIONS)
ACPI_DB_RESOURCES ACPI_DEBUG_LEVEL (ACPI_LV_RESOURCES)
ACPI_DB_IO ACPI_DEBUG_LEVEL (ACPI_LV_IO)
ACPI_DB_INTERRUPTS ACPI_DEBUG_LEVEL (ACPI_LV_INTERRUPTS)
ACPI_DB_USER_REQUESTS ACPI_DEBUG_LEVEL (ACPI_LV_USER_REQUESTS)
ACPI_DB_PACKAGE ACPI_DEBUG_LEVEL (ACPI_LV_PACKAGE)
ACPI_DB_EVALUATION ACPI_DEBUG_LEVEL (ACPI_LV_EVALUATION)
ACPI_DB_MUTEX ACPI_DEBUG_LEVEL (ACPI_LV_MUTEX)
ACPI_DB_EVENTS ACPI_DEBUG_LEVEL (ACPI_LV_EVENTS)
ACPI_DB_ALL ACPI_DEBUG_LEVEL (ACPI_LV_ALL)
ACPI_NORMAL_DEFAULT (ACPI_LV_INIT | ACPI_LV_DEBUG_OBJECT | ACPI_LV_REPAIR)
ACPI_DEBUG_ALL (ACPI_LV_AML_DISASSEMBLE | ACPI_LV_ALL_EXCEPTIONS | ACPI_LV_ALL)
ACPI_TRACE_ENABLED ((u32) 4)
ACPI_TRACE_ONESHOT ((u32) 2)
ACPI_TRACE_OPCODE ((u32) 1)
ACPI_TRACE_LEVEL_ALL ACPI_LV_ALL
ACPI_TRACE_LAYER_ALL 0x000001FF
ACPI_TRACE_LEVEL_DEFAULT ACPI_LV_TRACE_POINT
ACPI_TRACE_LAYER_DEFAULT ACPI_EXECUTER
ACPI_MODULE_NAME() static const char ACPI_UNUSED_VAR _acpi_module_name[] = ;
AE_INFO _acpi_module_name, __LINE__
ACPI_INFO() acpi_info 
ACPI_WARNING() acpi_warning 
ACPI_EXCEPTION() acpi_exception 
ACPI_ERROR() acpi_error 
ACPI_BIOS_WARNING() acpi_bios_warning 
ACPI_BIOS_EXCEPTION() acpi_bios_exception 
ACPI_BIOS_ERROR() acpi_bios_error 
ACPI_DEBUG_OBJECT(,,) acpi_ex_do_debug_object(,,)
ACPI_DEBUG_PRINT() 
ACPI_DEBUG_PRINT_RAW() 
ACPI_DEBUG_EXEC() 
ACPI_DEBUG_ONLY_MEMBERS() 
ACPI_FUNCTION_NAME() 
ACPI_FUNCTION_TRACE() 
ACPI_FUNCTION_TRACE_PTR(,) 
ACPI_FUNCTION_TRACE_U32(,) 
ACPI_FUNCTION_TRACE_STR(,) 
ACPI_FUNCTION_ENTRY() 
ACPI_DUMP_STACK_ENTRY() 
ACPI_DUMP_OPERANDS(,,) 
ACPI_DUMP_ENTRY(,) 
ACPI_DUMP_PATHNAME(,,,) 
ACPI_DUMP_BUFFER(,) 
ACPI_IS_DEBUG_ENABLED(,) 0
ACPI_TRACE_POINT(,,,) 
return_VOID return
return_ACPI_STATUS() return()
return_PTR() return()
return_STR() return()
return_VALUE() return()
return_UINT8() return()
return_UINT32() return()
ACPI_NO_UNIT_LIMIT ((u32) -1)
ACPI_MUTEX_SEM 1
ACPI_SIGNAL_FATAL 0
ACPI_SIGNAL_BREAKPOINT 1
REQUEST_FILE_ONLY 0
REQUEST_DIR_ONLY 1
ACPI_CA_VERSION 0x20190816
ACPI_OS_NAME "Microsoft Windows NT"
ACPI_MAX_STATE_CACHE_DEPTH 96
ACPI_MAX_PARSE_CACHE_DEPTH 96
ACPI_MAX_EXTPARSE_CACHE_DEPTH 96
ACPI_MAX_OBJECT_CACHE_DEPTH 96
ACPI_MAX_NAMESPACE_CACHE_DEPTH 96
ACPI_MAX_COMMENT_CACHE_DEPTH 96
ACPI_CHECKSUM_ABORT FALSE
ACPI_REDUCED_HARDWARE FALSE
ACPI_CA_SUPPORT_LEVEL 5
ACPI_MAX_SEMAPHORE_COUNT 256
ACPI_MAX_REFERENCE_COUNT 0x4000
ACPI_DEFAULT_PAGE_SIZE 4096
ACPI_NUM_OWNERID_MASKS 128
ACPI_ROOT_TABLE_SIZE_INCREMENT 4
ACPI_MAX_SLEEP 2000
ACPI_ADDRESS_RANGE_MAX 2
ACPI_MAX_LOOP_TIMEOUT 30
ACPI_METHOD_NUM_LOCALS 8
ACPI_METHOD_MAX_LOCAL 7
ACPI_METHOD_NUM_ARGS 7
ACPI_METHOD_MAX_ARG 6
ACPI_OBJ_NUM_OPERANDS 8
ACPI_OBJ_MAX_OPERAND 7
ACPI_RESULTS_FRAME_OBJ_NUM 8
ACPI_RESULTS_OBJ_NUM_MAX 255
ACPI_EBDA_PTR_LOCATION 0x0000040E
ACPI_EBDA_PTR_LENGTH 2
ACPI_EBDA_WINDOW_SIZE 1024
ACPI_HI_RSDP_WINDOW_BASE 0x000E0000
ACPI_HI_RSDP_WINDOW_SIZE 0x00020000
ACPI_RSDP_SCAN_STEP 16
ACPI_USER_REGION_BEGIN 0x80
ACPI_MAX_ADDRESS_SPACE 255
ACPI_NUM_DEFAULT_SPACES 4
ACPI_MAX_MATCH_OPCODE 5
ACPI_RSDP_CHECKSUM_LENGTH 20
ACPI_RSDP_XCHECKSUM_LENGTH 36
ACPI_SERIAL_HEADER_SIZE 2
ACPI_SMBUS_DATA_SIZE 32
ACPI_SMBUS_BUFFER_SIZE ACPI_SERIAL_HEADER_SIZE + ACPI_SMBUS_DATA_SIZE
ACPI_IPMI_DATA_SIZE 64
ACPI_IPMI_BUFFER_SIZE ACPI_SERIAL_HEADER_SIZE + ACPI_IPMI_DATA_SIZE
ACPI_MAX_GSBUS_DATA_SIZE 255
ACPI_MAX_GSBUS_BUFFER_SIZE ACPI_SERIAL_HEADER_SIZE + ACPI_MAX_GSBUS_DATA_SIZE
ACPI_NUM_sx_d_METHODS 4
ACPI_NUM_sx_w_METHODS 5
UUID_BUFFER_LENGTH 16
UUID_STRING_LENGTH 36
UUID_HYPHEN1_OFFSET 8
UUID_HYPHEN2_OFFSET 13
UUID_HYPHEN3_OFFSET 18
UUID_HYPHEN4_OFFSET 23
ACPI_DEBUGGER_MAX_ARGS ACPI_METHOD_NUM_ARGS + 4
ACPI_DB_LINE_BUFFER_SIZE 512
ACPI_DEBUGGER_COMMAND_PROMPT '-'
ACPI_DEBUGGER_EXECUTE_PROMPT '%'
ACPI_PLD_REV1_BUFFER_SIZE 16
ACPI_PLD_REV2_BUFFER_SIZE 20
ACPI_PLD_BUFFER_SIZE 20
ACPI_PLD_GET_REVISION() ACPI_GET_BITS (, 0, ACPI_7BIT_MASK)
ACPI_PLD_SET_REVISION(,) ACPI_SET_BITS (, 0, ACPI_7BIT_MASK, )
ACPI_PLD_GET_IGNORE_COLOR() ACPI_GET_BITS (, 7, ACPI_1BIT_MASK)
ACPI_PLD_SET_IGNORE_COLOR(,) ACPI_SET_BITS (, 7, ACPI_1BIT_MASK, )
ACPI_PLD_GET_RED() ACPI_GET_BITS (, 8, ACPI_8BIT_MASK)
ACPI_PLD_SET_RED(,) ACPI_SET_BITS (, 8, ACPI_8BIT_MASK, )
ACPI_PLD_GET_GREEN() ACPI_GET_BITS (, 16, ACPI_8BIT_MASK)
ACPI_PLD_SET_GREEN(,) ACPI_SET_BITS (, 16, ACPI_8BIT_MASK, )
ACPI_PLD_GET_BLUE() ACPI_GET_BITS (, 24, ACPI_8BIT_MASK)
ACPI_PLD_SET_BLUE(,) ACPI_SET_BITS (, 24, ACPI_8BIT_MASK, )
ACPI_PLD_GET_WIDTH() ACPI_GET_BITS (, 0, ACPI_16BIT_MASK)
ACPI_PLD_SET_WIDTH(,) ACPI_SET_BITS (, 0, ACPI_16BIT_MASK, )
ACPI_PLD_GET_HEIGHT() ACPI_GET_BITS (, 16, ACPI_16BIT_MASK)
ACPI_PLD_SET_HEIGHT(,) ACPI_SET_BITS (, 16, ACPI_16BIT_MASK, )
ACPI_PLD_GET_USER_VISIBLE() ACPI_GET_BITS (, 0, ACPI_1BIT_MASK)
ACPI_PLD_SET_USER_VISIBLE(,) ACPI_SET_BITS (, 0, ACPI_1BIT_MASK, )
ACPI_PLD_GET_DOCK() ACPI_GET_BITS (, 1, ACPI_1BIT_MASK)
ACPI_PLD_SET_DOCK(,) ACPI_SET_BITS (, 1, ACPI_1BIT_MASK, )
ACPI_PLD_GET_LID() ACPI_GET_BITS (, 2, ACPI_1BIT_MASK)
ACPI_PLD_SET_LID(,) ACPI_SET_BITS (, 2, ACPI_1BIT_MASK, )
ACPI_PLD_GET_PANEL() ACPI_GET_BITS (, 3, ACPI_3BIT_MASK)
ACPI_PLD_SET_PANEL(,) ACPI_SET_BITS (, 3, ACPI_3BIT_MASK, )
ACPI_PLD_GET_VERTICAL() ACPI_GET_BITS (, 6, ACPI_2BIT_MASK)
ACPI_PLD_SET_VERTICAL(,) ACPI_SET_BITS (, 6, ACPI_2BIT_MASK, )
ACPI_PLD_GET_HORIZONTAL() ACPI_GET_BITS (, 8, ACPI_2BIT_MASK)
ACPI_PLD_SET_HORIZONTAL(,) ACPI_SET_BITS (, 8, ACPI_2BIT_MASK, )
ACPI_PLD_GET_SHAPE() ACPI_GET_BITS (, 10, ACPI_4BIT_MASK)
ACPI_PLD_SET_SHAPE(,) ACPI_SET_BITS (, 10, ACPI_4BIT_MASK, )
ACPI_PLD_GET_ORIENTATION() ACPI_GET_BITS (, 14, ACPI_1BIT_MASK)
ACPI_PLD_SET_ORIENTATION(,) ACPI_SET_BITS (, 14, ACPI_1BIT_MASK, )
ACPI_PLD_GET_TOKEN() ACPI_GET_BITS (, 15, ACPI_8BIT_MASK)
ACPI_PLD_SET_TOKEN(,) ACPI_SET_BITS (, 15, ACPI_8BIT_MASK, )
ACPI_PLD_GET_POSITION() ACPI_GET_BITS (, 23, ACPI_8BIT_MASK)
ACPI_PLD_SET_POSITION(,) ACPI_SET_BITS (, 23, ACPI_8BIT_MASK, )
ACPI_PLD_GET_BAY() ACPI_GET_BITS (, 31, ACPI_1BIT_MASK)
ACPI_PLD_SET_BAY(,) ACPI_SET_BITS (, 31, ACPI_1BIT_MASK, )
ACPI_PLD_GET_EJECTABLE() ACPI_GET_BITS (, 0, ACPI_1BIT_MASK)
ACPI_PLD_SET_EJECTABLE(,) ACPI_SET_BITS (, 0, ACPI_1BIT_MASK, )
ACPI_PLD_GET_OSPM_EJECT() ACPI_GET_BITS (, 1, ACPI_1BIT_MASK)
ACPI_PLD_SET_OSPM_EJECT(,) ACPI_SET_BITS (, 1, ACPI_1BIT_MASK, )
ACPI_PLD_GET_CABINET() ACPI_GET_BITS (, 2, ACPI_8BIT_MASK)
ACPI_PLD_SET_CABINET(,) ACPI_SET_BITS (, 2, ACPI_8BIT_MASK, )
ACPI_PLD_GET_CARD_CAGE() ACPI_GET_BITS (, 10, ACPI_8BIT_MASK)
ACPI_PLD_SET_CARD_CAGE(,) ACPI_SET_BITS (, 10, ACPI_8BIT_MASK, )
ACPI_PLD_GET_REFERENCE() ACPI_GET_BITS (, 18, ACPI_1BIT_MASK)
ACPI_PLD_SET_REFERENCE(,) ACPI_SET_BITS (, 18, ACPI_1BIT_MASK, )
ACPI_PLD_GET_ROTATION() ACPI_GET_BITS (, 19, ACPI_4BIT_MASK)
ACPI_PLD_SET_ROTATION(,) ACPI_SET_BITS (, 19, ACPI_4BIT_MASK, )
ACPI_PLD_GET_ORDER() ACPI_GET_BITS (, 23, ACPI_5BIT_MASK)
ACPI_PLD_SET_ORDER(,) ACPI_SET_BITS (, 23, ACPI_5BIT_MASK, )
ACPI_PLD_GET_VERT_OFFSET() ACPI_GET_BITS (, 0, ACPI_16BIT_MASK)
ACPI_PLD_SET_VERT_OFFSET(,) ACPI_SET_BITS (, 0, ACPI_16BIT_MASK, )
ACPI_PLD_GET_HORIZ_OFFSET() ACPI_GET_BITS (, 16, ACPI_16BIT_MASK)
ACPI_PLD_SET_HORIZ_OFFSET(,) ACPI_SET_BITS (, 16, ACPI_16BIT_MASK, )
ACPI_GLOBAL(,) extern  
ACPI_INIT_GLOBAL(,,) extern  
ACPI_EXTERNAL_RETURN_STATUS() ;
ACPI_EXTERNAL_RETURN_OK() ;
ACPI_EXTERNAL_RETURN_VOID() ;
ACPI_EXTERNAL_RETURN_UINT32() ;
ACPI_EXTERNAL_RETURN_PTR() ;
ACPI_HW_DEPENDENT_RETURN_STATUS() ACPI_EXTERNAL_RETURN_STATUS()
ACPI_HW_DEPENDENT_RETURN_OK() ACPI_EXTERNAL_RETURN_OK()
ACPI_HW_DEPENDENT_RETURN_UINT32() ACPI_EXTERNAL_RETURN_UINT32()
ACPI_HW_DEPENDENT_RETURN_VOID() ACPI_EXTERNAL_RETURN_VOID()
ACPI_MSG_DEPENDENT_RETURN_VOID() ;
ACPI_DBG_DEPENDENT_RETURN_VOID() static ACPI_INLINE  {return;}
ACPI_APP_DEPENDENT_RETURN_VOID() static ACPI_INLINE  {return;}
ACPI_DBR_DEPENDENT_RETURN_OK() ACPI_EXTERNAL_RETURN_OK()
ACPI_DBR_DEPENDENT_RETURN_VOID() ACPI_EXTERNAL_RETURN_VOID()
ACPI_MAX_HANDLES 10
ACPI_INIT_DSM_ARGV4(,) { .package.type = ACPI_TYPE_PACKAGE, .package.count = (), .package.elements = () }
__WAIT_BIT_KEY_INITIALIZER(,) { .flags = , .bit_nr = , }
DEFINE_WAIT_BIT(,,) struct wait_bit_queue_entry  = { .key = __WAIT_BIT_KEY_INITIALIZER(, ), .wq_entry = { .private = current, .func = wake_bit_function, .entry = LIST_HEAD_INIT(().wq_entry.entry), }, }
___wait_var_event(,,,,,) \
({ __label__ __out; struct wait_queue_head *__wq_head = __var_waitqueue(); struct wait_bit_queue_entry __wbq_entry; long __ret = ; /* explicit shadow */ init_wait_var_entry(&__wbq_entry, ,  ? WQ_FLAG_EXCLUSIVE : 0); for (;;) { long __int = prepare_to_wait_event(__wq_head, &__wbq_entry.wq_entry, ); if () break; if (___wait_is_interruptible() && __int) { __ret = __int; goto __out; } ; } finish_wait(__wq_head, &__wbq_entry.wq_entry); __out: __ret; \
})
__wait_var_event(,) ___wait_var_event(, , TASK_UNINTERRUPTIBLE, 0, 0, schedule())
wait_var_event(,) do { might_sleep(); if () break; __wait_var_event(, ); \
} while (0)
__wait_var_event_killable(,) ___wait_var_event(, , TASK_KILLABLE, 0, 0, schedule())
wait_var_event_killable(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_var_event_killable(, ); __ret; \
})
__wait_var_event_timeout(,,) ___wait_var_event(, ___wait_cond_timeout(), TASK_UNINTERRUPTIBLE, 0, , __ret = schedule_timeout(__ret))
wait_var_event_timeout(,,) \
({ long __ret = ; might_sleep(); if (!___wait_cond_timeout()) __ret = __wait_var_event_timeout(, , ); __ret; \
})
__wait_var_event_interruptible(,) ___wait_var_event(, , TASK_INTERRUPTIBLE, 0, 0, schedule())
wait_var_event_interruptible(,) \
({ int __ret = 0; might_sleep(); if (!()) __ret = __wait_var_event_interruptible(, ); __ret; \
})
MINORBITS 20
MINORMASK ((1U << MINORBITS) - 1)
MAJOR() ((unsigned int) (() >> MINORBITS))
MINOR() ((unsigned int) (() & MINORMASK))
MKDEV(,) ((() << MINORBITS) | ())
print_dev_t(,) sprintf((), "%u:%u\n", MAJOR(), MINOR())
format_dev_t(,) ({ sprintf(, "%u:%u", MAJOR(), MINOR()); ; })
LIST_BL_LOCKMASK 1UL
LIST_BL_BUG_ON() 
INIT_HLIST_BL_HEAD() (()->first = NULL)
hlist_bl_entry(,,) container_of(,,)
hlist_bl_for_each_entry(,,,) for ( = hlist_bl_first();  && ({  = hlist_bl_entry(, typeof(*), ); 1;});  = ->next)
hlist_bl_for_each_entry_safe(,,,,) for ( = hlist_bl_first();  && ({  = ->next; 1; }) && ({  = hlist_bl_entry(, typeof(*), ); 1;});  = )
hlist_bl_for_each_entry_rcu(,,,) for ( = hlist_bl_first_rcu();  && ({  = hlist_bl_entry(, typeof(*), ); 1; });  = rcu_dereference_raw(->next))
USE_CMPXCHG_LOCKREF (IS_ENABLED(CONFIG_ARCH_USE_CMPXCHG_LOCKREF) && IS_ENABLED(CONFIG_SMP) && SPINLOCK_SIZE <= 4)
hash_long(,) hash_64(, )
GOLDEN_RATIO_PRIME GOLDEN_RATIO_64
GOLDEN_RATIO_32 0x61C88647
GOLDEN_RATIO_64 0x61C8864680B583EBull
__hash_32 __hash_32_generic
hash_32 hash_32_generic
hash_64 hash_64_generic
init_name_hash() (unsigned long)()
hashlen_hash() ((u32)())
hashlen_len() ((u32)(() >> 32))
hashlen_create(,) ((u64)()<<32 | (u32)())
IS_ROOT() (() == ()->d_parent)
HASH_LEN_DECLARE u32 hash; u32 len
bytemask_from_count() (~(~0ul << ()*8))
QSTR_INIT(,) { { { .len =  } }, .name =  }
DNAME_INLINE_LEN 32
d_lock d_lockref.lock
DCACHE_OP_HASH 0x00000001
DCACHE_OP_COMPARE 0x00000002
DCACHE_OP_REVALIDATE 0x00000004
DCACHE_OP_DELETE 0x00000008
DCACHE_OP_PRUNE 0x00000010
DCACHE_DISCONNECTED 0x00000020
DCACHE_REFERENCED 0x00000040
DCACHE_CANT_MOUNT 0x00000100
DCACHE_GENOCIDE 0x00000200
DCACHE_SHRINK_LIST 0x00000400
DCACHE_OP_WEAK_REVALIDATE 0x00000800
DCACHE_NFSFS_RENAMED 0x00001000
DCACHE_COOKIE 0x00002000
DCACHE_FSNOTIFY_PARENT_WATCHED 0x00004000
DCACHE_DENTRY_KILLED 0x00008000
DCACHE_MOUNTED 0x00010000
DCACHE_NEED_AUTOMOUNT 0x00020000
DCACHE_MANAGE_TRANSIT 0x00040000
DCACHE_MANAGED_DENTRY (DCACHE_MOUNTED|DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT)
DCACHE_LRU_LIST 0x00080000
DCACHE_ENTRY_TYPE 0x00700000
DCACHE_MISS_TYPE 0x00000000
DCACHE_WHITEOUT_TYPE 0x00100000
DCACHE_DIRECTORY_TYPE 0x00200000
DCACHE_AUTODIR_TYPE 0x00300000
DCACHE_REGULAR_TYPE 0x00400000
DCACHE_SPECIAL_TYPE 0x00500000
DCACHE_SYMLINK_TYPE 0x00600000
DCACHE_MAY_FREE 0x00800000
DCACHE_FALLTHRU 0x01000000
DCACHE_ENCRYPTED_NAME 0x02000000
DCACHE_OP_REAL 0x04000000
DCACHE_PAR_LOOKUP 0x10000000
DCACHE_DENTRY_CURSOR 0x20000000
DCACHE_NORCU 0x40000000
SHRINK_STOP (~0UL)
SHRINK_EMPTY (~0UL - 1)
DEFAULT_SEEKS 2
SHRINKER_NUMA_AWARE (1 << 0)
SHRINKER_MEMCG_AWARE (1 << 1)
SHRINKER_NONSLAB (1 << 2)
list_lru_init() __list_lru_init((), false, NULL, NULL)
list_lru_init_key(,) __list_lru_init((), false, (), NULL)
list_lru_init_memcg(,) __list_lru_init((), true, NULL, )
_LINUX_CAPABILITY_VERSION_1 0x19980330
_LINUX_CAPABILITY_U32S_1 1
_LINUX_CAPABILITY_VERSION_2 0x20071026
_LINUX_CAPABILITY_U32S_2 2
_LINUX_CAPABILITY_VERSION_3 0x20080522
_LINUX_CAPABILITY_U32S_3 2
VFS_CAP_REVISION_MASK 0xFF000000
VFS_CAP_REVISION_SHIFT 24
VFS_CAP_FLAGS_MASK ~VFS_CAP_REVISION_MASK
VFS_CAP_FLAGS_EFFECTIVE 0x000001
VFS_CAP_REVISION_1 0x01000000
VFS_CAP_U32_1 1
XATTR_CAPS_SZ_1 (sizeof(__le32)*(1 + 2*VFS_CAP_U32_1))
VFS_CAP_REVISION_2 0x02000000
VFS_CAP_U32_2 2
XATTR_CAPS_SZ_2 (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))
VFS_CAP_REVISION_3 0x03000000
VFS_CAP_U32_3 2
XATTR_CAPS_SZ_3 (sizeof(__le32)*(2 + 2*VFS_CAP_U32_3))
XATTR_CAPS_SZ XATTR_CAPS_SZ_3
VFS_CAP_U32 VFS_CAP_U32_3
VFS_CAP_REVISION VFS_CAP_REVISION_3
CAP_CHOWN 0
CAP_DAC_OVERRIDE 1
CAP_DAC_READ_SEARCH 2
CAP_FOWNER 3
CAP_FSETID 4
CAP_KILL 5
CAP_SETGID 6
CAP_SETUID 7
CAP_SETPCAP 8
CAP_LINUX_IMMUTABLE 9
CAP_NET_BIND_SERVICE 10
CAP_NET_BROADCAST 11
CAP_NET_ADMIN 12
CAP_NET_RAW 13
CAP_IPC_LOCK 14
CAP_IPC_OWNER 15
CAP_SYS_MODULE 16
CAP_SYS_RAWIO 17
CAP_SYS_CHROOT 18
CAP_SYS_PTRACE 19
CAP_SYS_PACCT 20
CAP_SYS_ADMIN 21
CAP_SYS_BOOT 22
CAP_SYS_NICE 23
CAP_SYS_RESOURCE 24
CAP_SYS_TIME 25
CAP_SYS_TTY_CONFIG 26
CAP_MKNOD 27
CAP_LEASE 28
CAP_AUDIT_WRITE 29
CAP_AUDIT_CONTROL 30
CAP_SETFCAP 31
CAP_MAC_OVERRIDE 32
CAP_MAC_ADMIN 33
CAP_SYSLOG 34
CAP_WAKE_ALARM 35
CAP_BLOCK_SUSPEND 36
CAP_AUDIT_READ 37
CAP_LAST_CAP CAP_AUDIT_READ
cap_valid() (() >= 0 && () <= CAP_LAST_CAP)
CAP_TO_INDEX() (() >> 5)
CAP_TO_MASK() (1U << (() & 31))
_KERNEL_CAPABILITY_VERSION _LINUX_CAPABILITY_VERSION_3
_KERNEL_CAPABILITY_U32S _LINUX_CAPABILITY_U32S_3
_USER_CAP_HEADER_SIZE (sizeof(struct __user_cap_header_struct))
_KERNEL_CAP_T_SIZE (sizeof(kernel_cap_t))
CAP_FOR_EACH_U32() for ( = 0;  < _KERNEL_CAPABILITY_U32S; ++)
CAP_FS_MASK_B0 (CAP_TO_MASK(CAP_CHOWN) | CAP_TO_MASK(CAP_MKNOD) | CAP_TO_MASK(CAP_DAC_OVERRIDE) | CAP_TO_MASK(CAP_DAC_READ_SEARCH) | CAP_TO_MASK(CAP_FOWNER) | CAP_TO_MASK(CAP_FSETID))
CAP_FS_MASK_B1 (CAP_TO_MASK(CAP_MAC_OVERRIDE))
CAP_LAST_U32 ((_KERNEL_CAPABILITY_U32S) - 1)
CAP_LAST_U32_VALID_MASK (CAP_TO_MASK(CAP_LAST_CAP + 1) -1)
CAP_EMPTY_SET ((kernel_cap_t){{ 0, 0 }})
CAP_FULL_SET ((kernel_cap_t){{ ~0, CAP_LAST_U32_VALID_MASK }})
CAP_FS_SET ((kernel_cap_t){{ CAP_FS_MASK_B0 | CAP_TO_MASK(CAP_LINUX_IMMUTABLE), CAP_FS_MASK_B1 } })
CAP_NFSD_SET ((kernel_cap_t){{ CAP_FS_MASK_B0 | CAP_TO_MASK(CAP_SYS_RESOURCE), CAP_FS_MASK_B1 } })
cap_clear() do { () = __cap_empty_set; } while (0)
cap_raise(,) (().cap[CAP_TO_INDEX()] |= CAP_TO_MASK())
cap_lower(,) (().cap[CAP_TO_INDEX()] &= ~CAP_TO_MASK())
cap_raised(,) (().cap[CAP_TO_INDEX()] & CAP_TO_MASK())
CAP_BOP_ALL(,,,) do { unsigned __capi; CAP_FOR_EACH_U32(__capi) { .cap[__capi] = .cap[__capi]  .cap[__capi]; } \
} while (0)
CAP_UOP_ALL(,,) do { unsigned __capi; CAP_FOR_EACH_U32(__capi) { .cap[__capi] =  .cap[__capi]; } \
} while (0)
__SEMAPHORE_INITIALIZER(,) \
{ .lock = __RAW_SPIN_LOCK_UNLOCKED(().lock), .count = , .wait_list = LIST_HEAD_INIT(().wait_list), \
}
DEFINE_SEMAPHORE() struct semaphore  = __SEMAPHORE_INITIALIZER(, 1)
O_ACCMODE 00000003
O_RDONLY 00000000
O_WRONLY 00000001
O_RDWR 00000002
O_CREAT 00000100
O_EXCL 00000200
O_NOCTTY 00000400
O_TRUNC 00001000
O_APPEND 00002000
O_NONBLOCK 00004000
O_DSYNC 00010000
FASYNC 00020000
O_DIRECT 00040000
O_LARGEFILE 00100000
O_DIRECTORY 00200000
O_NOFOLLOW 00400000
O_NOATIME 01000000
O_CLOEXEC 02000000
__O_SYNC 04000000
O_SYNC (__O_SYNC|O_DSYNC)
O_PATH 010000000
__O_TMPFILE 020000000
O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
O_TMPFILE_MASK (__O_TMPFILE | O_DIRECTORY | O_CREAT)
O_NDELAY O_NONBLOCK
F_DUPFD 0
F_GETFD 1
F_SETFD 2
F_GETFL 3
F_SETFL 4
F_GETLK 5
F_SETLK 6
F_SETLKW 7
F_SETOWN 8
F_GETOWN 9
F_SETSIG 10
F_GETSIG 11
F_SETOWN_EX 15
F_GETOWN_EX 16
F_GETOWNER_UIDS 17
F_OFD_GETLK 36
F_OFD_SETLK 37
F_OFD_SETLKW 38
F_OWNER_TID 0
F_OWNER_PID 1
F_OWNER_PGRP 2
FD_CLOEXEC 1
F_RDLCK 0
F_WRLCK 1
F_UNLCK 2
F_EXLCK 4
F_SHLCK 8
LOCK_SH 1
LOCK_EX 2
LOCK_NB 4
LOCK_UN 8
LOCK_MAND 32
LOCK_READ 64
LOCK_WRITE 128
LOCK_RW 192
F_LINUX_SPECIFIC_BASE 1024
__ARCH_FLOCK_PAD 
__ARCH_FLOCK64_PAD 
F_SETLEASE (F_LINUX_SPECIFIC_BASE + 0)
F_GETLEASE (F_LINUX_SPECIFIC_BASE + 1)
F_CANCELLK (F_LINUX_SPECIFIC_BASE + 5)
F_DUPFD_CLOEXEC (F_LINUX_SPECIFIC_BASE + 6)
F_NOTIFY (F_LINUX_SPECIFIC_BASE+2)
F_SETPIPE_SZ (F_LINUX_SPECIFIC_BASE + 7)
F_GETPIPE_SZ (F_LINUX_SPECIFIC_BASE + 8)
F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)
F_SEAL_SEAL 0x0001
F_SEAL_SHRINK 0x0002
F_SEAL_GROW 0x0004
F_SEAL_WRITE 0x0008
F_SEAL_FUTURE_WRITE 0x0010
F_GET_RW_HINT (F_LINUX_SPECIFIC_BASE + 11)
F_SET_RW_HINT (F_LINUX_SPECIFIC_BASE + 12)
F_GET_FILE_RW_HINT (F_LINUX_SPECIFIC_BASE + 13)
F_SET_FILE_RW_HINT (F_LINUX_SPECIFIC_BASE + 14)
RWF_WRITE_LIFE_NOT_SET 0
RWH_WRITE_LIFE_NONE 1
RWH_WRITE_LIFE_SHORT 2
RWH_WRITE_LIFE_MEDIUM 3
RWH_WRITE_LIFE_LONG 4
RWH_WRITE_LIFE_EXTREME 5
DN_ACCESS 0x00000001
DN_MODIFY 0x00000002
DN_CREATE 0x00000004
DN_DELETE 0x00000008
DN_RENAME 0x00000010
DN_ATTRIB 0x00000020
DN_MULTISHOT 0x80000000
AT_FDCWD -100
AT_SYMLINK_NOFOLLOW 0x100
AT_REMOVEDIR 0x200
AT_SYMLINK_FOLLOW 0x400
AT_NO_AUTOMOUNT 0x800
AT_EMPTY_PATH 0x1000
AT_STATX_SYNC_TYPE 0x6000
AT_STATX_SYNC_AS_STAT 0x0000
AT_STATX_FORCE_SYNC 0x2000
AT_STATX_DONT_SYNC 0x4000
AT_RECURSIVE 0x8000
VALID_OPEN_FLAGS (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
force_o_largefile() (!IS_ENABLED(CONFIG_ARCH_32BIT_OFF_T))
IS_GETLK32() (0)
IS_SETLK32() (0)
IS_SETLKW32() (0)
IS_GETLK64() (() == F_GETLK)
IS_SETLK64() (() == F_SETLK)
IS_SETLKW64() (() == F_SETLKW)
IS_GETLK() (IS_GETLK32() || IS_GETLK64())
IS_SETLK() (IS_SETLK32() || IS_SETLK64())
IS_SETLKW() (IS_SETLKW32() || IS_SETLKW64())
FIEMAP_MAX_OFFSET (~0ULL)
FIEMAP_FLAG_SYNC 0x00000001
FIEMAP_FLAG_XATTR 0x00000002
FIEMAP_FLAG_CACHE 0x00000004
FIEMAP_FLAGS_COMPAT (FIEMAP_FLAG_SYNC | FIEMAP_FLAG_XATTR)
FIEMAP_EXTENT_LAST 0x00000001
FIEMAP_EXTENT_UNKNOWN 0x00000002
FIEMAP_EXTENT_DELALLOC 0x00000004
FIEMAP_EXTENT_ENCODED 0x00000008
FIEMAP_EXTENT_DATA_ENCRYPTED 0x00000080
FIEMAP_EXTENT_NOT_ALIGNED 0x00000100
FIEMAP_EXTENT_DATA_INLINE 0x00000200
FIEMAP_EXTENT_DATA_TAIL 0x00000400
FIEMAP_EXTENT_UNWRITTEN 0x00000800
FIEMAP_EXTENT_MERGED 0x00001000
FIEMAP_EXTENT_SHARED 0x00002000
__RCUWAIT_INITIALIZER() { .task = NULL, }
rcuwait_wait_event(,) \
({ rcu_assign_pointer(()->task, current); for (;;) { /*							\
		 * Implicit barrier (A) pairs with (B) in		\
		 * rcuwait_wake_up().					\
		 */ set_current_state(TASK_UNINTERRUPTIBLE); if () break; schedule(); } WRITE_ONCE(()->task, NULL); __set_current_state(TASK_RUNNING); \
})
__RCU_SYNC_INITIALIZER() { .gp_state = 0, .gp_count = 0, .gp_wait = __WAIT_QUEUE_HEAD_INITIALIZER(.gp_wait), }
DEFINE_RCU_SYNC() struct rcu_sync  = __RCU_SYNC_INITIALIZER()
__DEFINE_PERCPU_RWSEM(,) static DEFINE_PER_CPU(unsigned int, __percpu_rwsem_rc_##);  struct percpu_rw_semaphore  = { .rss = __RCU_SYNC_INITIALIZER(.rss), .read_count = &__percpu_rwsem_rc_##, .rw_sem = __RWSEM_INITIALIZER(.rw_sem), .writer = __RCUWAIT_INITIALIZER(.writer), \
}
DEFINE_PERCPU_RWSEM() __DEFINE_PERCPU_RWSEM(, /* not static */)
DEFINE_STATIC_PERCPU_RWSEM() __DEFINE_PERCPU_RWSEM(, static)
percpu_init_rwsem() \
({ static struct lock_class_key rwsem_key; __percpu_init_rwsem(, #, &rwsem_key); \
})
percpu_rwsem_is_held() lockdep_is_held(&()->rw_sem)
percpu_rwsem_assert_held() lockdep_assert_held(&()->rw_sem)
DEFINE_DELAYED_CALL() struct delayed_call  = {NULL, NULL}
RR_TIMESLICE (100 * HZ / 1000)
IOPRIO_CLASS_SHIFT (13)
IOPRIO_PRIO_MASK ((1UL << IOPRIO_CLASS_SHIFT) - 1)
IOPRIO_PRIO_CLASS() (() >> IOPRIO_CLASS_SHIFT)
IOPRIO_PRIO_DATA() (() & IOPRIO_PRIO_MASK)
IOPRIO_PRIO_VALUE(,) ((() << IOPRIO_CLASS_SHIFT) | )
ioprio_valid() (IOPRIO_PRIO_CLASS(()) != IOPRIO_CLASS_NONE)
IOPRIO_BE_NR (8)
IOPRIO_NORM (4)
S_DT_SHIFT 12
S_DT() ((() & S_IFMT) >> S_DT_SHIFT)
S_DT_MASK (S_IFMT >> S_DT_SHIFT)
DT_UNKNOWN 0
DT_FIFO 1
DT_CHR 2
DT_DIR 4
DT_BLK 6
DT_REG 8
DT_LNK 10
DT_SOCK 12
DT_WHT 14
DT_MAX (S_DT_MASK + 1)
FT_UNKNOWN 0
FT_REG_FILE 1
FT_DIR 2
FT_CHRDEV 3
FT_BLKDEV 4
FT_FIFO 5
FT_SOCK 6
FT_SYMLINK 7
FT_MAX 8
INR_OPEN_CUR 1024
INR_OPEN_MAX 4096
BLOCK_SIZE_BITS 10
BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
SEEK_SET 0
SEEK_CUR 1
SEEK_END 2
SEEK_DATA 3
SEEK_HOLE 4
SEEK_MAX SEEK_HOLE
RENAME_NOREPLACE (1 << 0)
RENAME_EXCHANGE (1 << 1)
RENAME_WHITEOUT (1 << 2)
FILE_DEDUPE_RANGE_SAME 0
FILE_DEDUPE_RANGE_DIFFERS 1
NR_FILE 8192
FS_XFLAG_REALTIME 0x00000001
FS_XFLAG_PREALLOC 0x00000002
FS_XFLAG_IMMUTABLE 0x00000008
FS_XFLAG_APPEND 0x00000010
FS_XFLAG_SYNC 0x00000020
FS_XFLAG_NOATIME 0x00000040
FS_XFLAG_NODUMP 0x00000080
FS_XFLAG_RTINHERIT 0x00000100
FS_XFLAG_PROJINHERIT 0x00000200
FS_XFLAG_NOSYMLINKS 0x00000400
FS_XFLAG_EXTSIZE 0x00000800
FS_XFLAG_EXTSZINHERIT 0x00001000
FS_XFLAG_NODEFRAG 0x00002000
FS_XFLAG_FILESTREAM 0x00004000
FS_XFLAG_DAX 0x00008000
FS_XFLAG_COWEXTSIZE 0x00010000
FS_XFLAG_HASATTR 0x80000000
BLKROSET _IO(0x12,93)
BLKROGET _IO(0x12,94)
BLKRRPART _IO(0x12,95)
BLKGETSIZE _IO(0x12,96)
BLKFLSBUF _IO(0x12,97)
BLKRASET _IO(0x12,98)
BLKRAGET _IO(0x12,99)
BLKFRASET _IO(0x12,100)
BLKFRAGET _IO(0x12,101)
BLKSECTSET _IO(0x12,102)
BLKSECTGET _IO(0x12,103)
BLKSSZGET _IO(0x12,104)
BLKBSZGET _IOR(0x12,112,size_t)
BLKBSZSET _IOW(0x12,113,size_t)
BLKGETSIZE64 _IOR(0x12,114,size_t)
BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
BLKTRACESTART _IO(0x12,116)
BLKTRACESTOP _IO(0x12,117)
BLKTRACETEARDOWN _IO(0x12,118)
BLKDISCARD _IO(0x12,119)
BLKIOMIN _IO(0x12,120)
BLKIOOPT _IO(0x12,121)
BLKALIGNOFF _IO(0x12,122)
BLKPBSZGET _IO(0x12,123)
BLKDISCARDZEROES _IO(0x12,124)
BLKSECDISCARD _IO(0x12,125)
BLKROTATIONAL _IO(0x12,126)
BLKZEROOUT _IO(0x12,127)
BMAP_IOCTL 1
FIBMAP _IO(0x00,1)
FIGETBSZ _IO(0x00,2)
FIFREEZE _IOWR('X', 119, int)
FITHAW _IOWR('X', 120, int)
FITRIM _IOWR('X', 121, struct fstrim_range)
FICLONE _IOW(0x94, 9, int)
FICLONERANGE _IOW(0x94, 13, struct file_clone_range)
FIDEDUPERANGE _IOWR(0x94, 54, struct file_dedupe_range)
FSLABEL_MAX 256
FS_IOC_GETFLAGS _IOR('f', 1, long)
FS_IOC_SETFLAGS _IOW('f', 2, long)
FS_IOC_GETVERSION _IOR('v', 1, long)
FS_IOC_SETVERSION _IOW('v', 2, long)
FS_IOC_FIEMAP _IOWR('f', 11, struct fiemap)
FS_IOC32_GETFLAGS _IOR('f', 1, int)
FS_IOC32_SETFLAGS _IOW('f', 2, int)
FS_IOC32_GETVERSION _IOR('v', 1, int)
FS_IOC32_SETVERSION _IOW('v', 2, int)
FS_IOC_FSGETXATTR _IOR('X', 31, struct fsxattr)
FS_IOC_FSSETXATTR _IOW('X', 32, struct fsxattr)
FS_IOC_GETFSLABEL _IOR(0x94, 49, char[FSLABEL_MAX])
FS_IOC_SETFSLABEL _IOW(0x94, 50, char[FSLABEL_MAX])
FS_SECRM_FL 0x00000001
FS_UNRM_FL 0x00000002
FS_COMPR_FL 0x00000004
FS_SYNC_FL 0x00000008
FS_IMMUTABLE_FL 0x00000010
FS_APPEND_FL 0x00000020
FS_NODUMP_FL 0x00000040
FS_NOATIME_FL 0x00000080
FS_DIRTY_FL 0x00000100
FS_COMPRBLK_FL 0x00000200
FS_NOCOMP_FL 0x00000400
FS_ENCRYPT_FL 0x00000800
FS_BTREE_FL 0x00001000
FS_INDEX_FL 0x00001000
FS_IMAGIC_FL 0x00002000
FS_JOURNAL_DATA_FL 0x00004000
FS_NOTAIL_FL 0x00008000
FS_DIRSYNC_FL 0x00010000
FS_TOPDIR_FL 0x00020000
FS_HUGE_FILE_FL 0x00040000
FS_EXTENT_FL 0x00080000
FS_VERITY_FL 0x00100000
FS_EA_INODE_FL 0x00200000
FS_EOFBLOCKS_FL 0x00400000
FS_NOCOW_FL 0x00800000
FS_INLINE_DATA_FL 0x10000000
FS_PROJINHERIT_FL 0x20000000
FS_CASEFOLD_FL 0x40000000
FS_RESERVED_FL 0x80000000
FS_FL_USER_VISIBLE 0x0003DFFF
FS_FL_USER_MODIFIABLE 0x000380FF
SYNC_FILE_RANGE_WAIT_BEFORE 1
SYNC_FILE_RANGE_WRITE 2
SYNC_FILE_RANGE_WAIT_AFTER 4
SYNC_FILE_RANGE_WRITE_AND_WAIT (SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WAIT_AFTER)
RWF_HIPRI ((__force __kernel_rwf_t)0x00000001)
RWF_DSYNC ((__force __kernel_rwf_t)0x00000002)
RWF_SYNC ((__force __kernel_rwf_t)0x00000004)
RWF_NOWAIT ((__force __kernel_rwf_t)0x00000008)
RWF_APPEND ((__force __kernel_rwf_t)0x00000010)
RWF_SUPPORTED (RWF_HIPRI | RWF_DSYNC | RWF_SYNC | RWF_NOWAIT | RWF_APPEND)
MAY_EXEC 0x00000001
MAY_WRITE 0x00000002
MAY_READ 0x00000004
MAY_APPEND 0x00000008
MAY_ACCESS 0x00000010
MAY_OPEN 0x00000020
MAY_CHDIR 0x00000040
MAY_NOT_BLOCK 0x00000080
FMODE_READ ((__force fmode_t)0x1)
FMODE_WRITE ((__force fmode_t)0x2)
FMODE_LSEEK ((__force fmode_t)0x4)
FMODE_PREAD ((__force fmode_t)0x8)
FMODE_PWRITE ((__force fmode_t)0x10)
FMODE_EXEC ((__force fmode_t)0x20)
FMODE_NDELAY ((__force fmode_t)0x40)
FMODE_EXCL ((__force fmode_t)0x80)
FMODE_WRITE_IOCTL ((__force fmode_t)0x100)
FMODE_32BITHASH ((__force fmode_t)0x200)
FMODE_64BITHASH ((__force fmode_t)0x400)
FMODE_NOCMTIME ((__force fmode_t)0x800)
FMODE_RANDOM ((__force fmode_t)0x1000)
FMODE_UNSIGNED_OFFSET ((__force fmode_t)0x2000)
FMODE_PATH ((__force fmode_t)0x4000)
FMODE_ATOMIC_POS ((__force fmode_t)0x8000)
FMODE_WRITER ((__force fmode_t)0x10000)
FMODE_CAN_READ ((__force fmode_t)0x20000)
FMODE_CAN_WRITE ((__force fmode_t)0x40000)
FMODE_OPENED ((__force fmode_t)0x80000)
FMODE_CREATED ((__force fmode_t)0x100000)
FMODE_STREAM ((__force fmode_t)0x200000)
FMODE_NONOTIFY ((__force fmode_t)0x4000000)
FMODE_NOWAIT ((__force fmode_t)0x8000000)
FMODE_NEED_UNMOUNT ((__force fmode_t)0x10000000)
FMODE_NOACCOUNT ((__force fmode_t)0x20000000)
CHECK_IOVEC_ONLY -1
ATTR_MODE (1 << 0)
ATTR_UID (1 << 1)
ATTR_GID (1 << 2)
ATTR_SIZE (1 << 3)
ATTR_ATIME (1 << 4)
ATTR_MTIME (1 << 5)
ATTR_CTIME (1 << 6)
ATTR_ATIME_SET (1 << 7)
ATTR_MTIME_SET (1 << 8)
ATTR_FORCE (1 << 9)
ATTR_KILL_SUID (1 << 11)
ATTR_KILL_SGID (1 << 12)
ATTR_FILE (1 << 13)
ATTR_KILL_PRIV (1 << 14)
ATTR_OPEN (1 << 15)
ATTR_TIMES_SET (1 << 16)
ATTR_TOUCH (1 << 17)
WHITEOUT_MODE 0
WHITEOUT_DEV 0
percpu_counter_init(,,) ({ static struct lock_class_key __key; __percpu_counter_init(, , , &__key); })
XQM_CMD() (('X'<<8)+())
XQM_COMMAND() ((() & (0xff<<8)) == ('X'<<8))
XQM_USRQUOTA 0
XQM_GRPQUOTA 1
XQM_PRJQUOTA 2
XQM_MAXQUOTAS 3
Q_XQUOTAON XQM_CMD(1)
Q_XQUOTAOFF XQM_CMD(2)
Q_XGETQUOTA XQM_CMD(3)
Q_XSETQLIM XQM_CMD(4)
Q_XGETQSTAT XQM_CMD(5)
Q_XQUOTARM XQM_CMD(6)
Q_XQUOTASYNC XQM_CMD(7)
Q_XGETQSTATV XQM_CMD(8)
Q_XGETNEXTQUOTA XQM_CMD(9)
FS_DQUOT_VERSION 1
FS_DQ_ISOFT (1<<0)
FS_DQ_IHARD (1<<1)
FS_DQ_BSOFT (1<<2)
FS_DQ_BHARD (1<<3)
FS_DQ_RTBSOFT (1<<4)
FS_DQ_RTBHARD (1<<5)
FS_DQ_LIMIT_MASK (FS_DQ_ISOFT | FS_DQ_IHARD | FS_DQ_BSOFT | FS_DQ_BHARD | FS_DQ_RTBSOFT | FS_DQ_RTBHARD)
FS_DQ_BTIMER (1<<6)
FS_DQ_ITIMER (1<<7)
FS_DQ_RTBTIMER (1<<8)
FS_DQ_TIMER_MASK (FS_DQ_BTIMER | FS_DQ_ITIMER | FS_DQ_RTBTIMER)
FS_DQ_BWARNS (1<<9)
FS_DQ_IWARNS (1<<10)
FS_DQ_RTBWARNS (1<<11)
FS_DQ_WARNS_MASK (FS_DQ_BWARNS | FS_DQ_IWARNS | FS_DQ_RTBWARNS)
FS_DQ_BCOUNT (1<<12)
FS_DQ_ICOUNT (1<<13)
FS_DQ_RTBCOUNT (1<<14)
FS_DQ_ACCT_MASK (FS_DQ_BCOUNT | FS_DQ_ICOUNT | FS_DQ_RTBCOUNT)
FS_QUOTA_UDQ_ACCT (1<<0)
FS_QUOTA_UDQ_ENFD (1<<1)
FS_QUOTA_GDQ_ACCT (1<<2)
FS_QUOTA_GDQ_ENFD (1<<3)
FS_QUOTA_PDQ_ACCT (1<<4)
FS_QUOTA_PDQ_ENFD (1<<5)
FS_USER_QUOTA (1<<0)
FS_PROJ_QUOTA (1<<1)
FS_GROUP_QUOTA (1<<2)
FS_QSTAT_VERSION 1
FS_QSTATV_VERSION1 1
V1_INIT_ALLOC 1
V1_INIT_REWRITE 1
V1_DEL_ALLOC 0
V1_DEL_REWRITE 2
QTREE_INIT_ALLOC 4
QTREE_INIT_REWRITE 2
QTREE_DEL_ALLOC 0
QTREE_DEL_REWRITE 6
V2_INIT_ALLOC QTREE_INIT_ALLOC
V2_INIT_REWRITE QTREE_INIT_REWRITE
V2_DEL_ALLOC QTREE_DEL_ALLOC
V2_DEL_REWRITE QTREE_DEL_REWRITE
KPROJIDT_INIT() (kprojid_t){  }
INVALID_PROJID KPROJIDT_INIT(-1)
OVERFLOW_PROJID 65534
__DQUOT_VERSION__ "dquot_6.6.0"
MAXQUOTAS 3
USRQUOTA 0
GRPQUOTA 1
PRJQUOTA 2
INITQFNAMES { "user", /* USRQUOTA */ "group", /* GRPQUOTA */ "project", /* PRJQUOTA */ "undefined", \
};
SUBCMDMASK 0x00ff
SUBCMDSHIFT 8
QCMD(,) ((() << SUBCMDSHIFT) | (() & SUBCMDMASK))
Q_SYNC 0x800001
Q_QUOTAON 0x800002
Q_QUOTAOFF 0x800003
Q_GETFMT 0x800004
Q_GETINFO 0x800005
Q_SETINFO 0x800006
Q_GETQUOTA 0x800007
Q_SETQUOTA 0x800008
Q_GETNEXTQUOTA 0x800009
QFMT_VFS_OLD 1
QFMT_VFS_V0 2
QFMT_OCFS2 3
QFMT_VFS_V1 4
QIF_DQBLKSIZE_BITS 10
QIF_DQBLKSIZE (1 << QIF_DQBLKSIZE_BITS)
QIF_BLIMITS (1 << QIF_BLIMITS_B)
QIF_SPACE (1 << QIF_SPACE_B)
QIF_ILIMITS (1 << QIF_ILIMITS_B)
QIF_INODES (1 << QIF_INODES_B)
QIF_BTIME (1 << QIF_BTIME_B)
QIF_ITIME (1 << QIF_ITIME_B)
QIF_LIMITS (QIF_BLIMITS | QIF_ILIMITS)
QIF_USAGE (QIF_SPACE | QIF_INODES)
QIF_TIMES (QIF_BTIME | QIF_ITIME)
QIF_ALL (QIF_LIMITS | QIF_USAGE | QIF_TIMES)
IIF_BGRACE 1
IIF_IGRACE 2
IIF_FLAGS 4
IIF_ALL (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)
DQF_ROOT_SQUASH (1 << DQF_ROOT_SQUASH_B)
DQF_SYS_FILE (1 << DQF_SYS_FILE_B)
QUOTA_NL_NOWARN 0
QUOTA_NL_IHARDWARN 1
QUOTA_NL_ISOFTLONGWARN 2
QUOTA_NL_ISOFTWARN 3
QUOTA_NL_BHARDWARN 4
QUOTA_NL_BSOFTLONGWARN 5
QUOTA_NL_BSOFTWARN 6
QUOTA_NL_IHARDBELOW 7
QUOTA_NL_ISOFTBELOW 8
QUOTA_NL_BHARDBELOW 9
QUOTA_NL_BSOFTBELOW 10
QUOTA_NL_C_MAX (__QUOTA_NL_C_MAX - 1)
QUOTA_NL_A_MAX (__QUOTA_NL_A_MAX - 1)
QTYPE_MASK_USR (1 << USRQUOTA)
QTYPE_MASK_GRP (1 << GRPQUOTA)
QTYPE_MASK_PRJ (1 << PRJQUOTA)
DQUOT_INIT_ALLOC max(V1_INIT_ALLOC, V2_INIT_ALLOC)
DQUOT_INIT_REWRITE max(V1_INIT_REWRITE, V2_INIT_REWRITE)
DQUOT_DEL_ALLOC max(V1_DEL_ALLOC, V2_DEL_ALLOC)
DQUOT_DEL_REWRITE max(V1_DEL_REWRITE, V2_DEL_REWRITE)
DQF_GETINFO_MASK (DQF_ROOT_SQUASH | DQF_SYS_FILE)
DQF_SETINFO_MASK DQF_ROOT_SQUASH
DQF_INFO_DIRTY (1 << DQF_INFO_DIRTY_B)
DQ_MOD_B 0
DQ_BLKS_B 1
DQ_INODES_B 2
DQ_FAKE_B 3
DQ_READ_B 4
DQ_ACTIVE_B 5
DQ_LASTSET_B 6
QC_INO_SOFT (1<<0)
QC_INO_HARD (1<<1)
QC_SPC_SOFT (1<<2)
QC_SPC_HARD (1<<3)
QC_RT_SPC_SOFT (1<<4)
QC_RT_SPC_HARD (1<<5)
QC_LIMIT_MASK (QC_INO_SOFT | QC_INO_HARD | QC_SPC_SOFT | QC_SPC_HARD | QC_RT_SPC_SOFT | QC_RT_SPC_HARD)
QC_SPC_TIMER (1<<6)
QC_INO_TIMER (1<<7)
QC_RT_SPC_TIMER (1<<8)
QC_TIMER_MASK (QC_SPC_TIMER | QC_INO_TIMER | QC_RT_SPC_TIMER)
QC_SPC_WARNS (1<<9)
QC_INO_WARNS (1<<10)
QC_RT_SPC_WARNS (1<<11)
QC_WARNS_MASK (QC_SPC_WARNS | QC_INO_WARNS | QC_RT_SPC_WARNS)
QC_SPACE (1<<12)
QC_INO_COUNT (1<<13)
QC_RT_SPACE (1<<14)
QC_ACCT_MASK (QC_SPACE | QC_INO_COUNT | QC_RT_SPACE)
QC_FLAGS (1<<15)
QCI_SYSFILE (1 << 0)
QCI_ROOT_SQUASH (1 << 1)
QCI_ACCT_ENABLED (1 << 2)
QCI_LIMITS_ENFORCED (1 << 3)
DQUOT_USAGE_ENABLED (1 << _DQUOT_USAGE_ENABLED * MAXQUOTAS)
DQUOT_LIMITS_ENABLED (1 << _DQUOT_LIMITS_ENABLED * MAXQUOTAS)
DQUOT_SUSPENDED (1 << _DQUOT_SUSPENDED * MAXQUOTAS)
DQUOT_STATE_FLAGS (DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED | DQUOT_SUSPENDED)
DQUOT_STATE_LAST (_DQUOT_STATE_FLAGS * MAXQUOTAS)
DQUOT_QUOTA_SYS_FILE (1 << DQUOT_STATE_LAST)
DQUOT_NEGATIVE_USAGE (1 << (DQUOT_STATE_LAST + 1))
DQUOT_NOLIST_DIRTY (1 << (DQUOT_STATE_LAST + 2))
INIT_QUOTA_MODULE_NAMES { {QFMT_VFS_OLD, "quota_v1"}, {QFMT_VFS_V0, "quota_v2"}, {QFMT_VFS_V1, "quota_v2"}, {0, NULL}}
FILESYSTEM_MAX_STACK_DEPTH 2
AOP_FLAG_CONT_EXPAND 0x0001
AOP_FLAG_NOFS 0x0002
IOCB_EVENTFD (1 << 0)
IOCB_APPEND (1 << 1)
IOCB_DIRECT (1 << 2)
IOCB_HIPRI (1 << 3)
IOCB_DSYNC (1 << 4)
IOCB_SYNC (1 << 5)
IOCB_WRITE (1 << 6)
IOCB_NOWAIT (1 << 7)
PAGECACHE_TAG_DIRTY XA_MARK_0
PAGECACHE_TAG_WRITEBACK XA_MARK_1
PAGECACHE_TAG_TOWRITE XA_MARK_2
i_size_ordered_init() do { } while (0)
ACL_NOT_CACHED ((void *)(-1))
ACL_DONT_CACHE ((void *)(-3))
IOP_FASTPERM 0x0001
IOP_LOOKUP 0x0002
IOP_NOFOLLOW 0x0004
IOP_XATTR 0x0008
IOP_DEFAULT_READLINK 0x0010
get_file_rcu_many(,) atomic_long_add_unless(&()->f_count, (), 0)
get_file_rcu() get_file_rcu_many((), 1)
file_count() atomic_long_read(&()->f_count)
MAX_NON_LFS ((1UL<<31) - 1)
MAX_LFS_FILESIZE ((loff_t)LLONG_MAX)
FL_POSIX 1
FL_FLOCK 2
FL_DELEG 4
FL_ACCESS 8
FL_EXISTS 16
FL_LEASE 32
FL_CLOSE 64
FL_SLEEP 128
FL_DOWNGRADE_PENDING 256
FL_UNLOCK_PENDING 512
FL_OFDLCK 1024
FL_LAYOUT 2048
FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)
FILE_LOCK_DEFERRED 1
INT_LIMIT() (~(()1 << (sizeof()*8 - 1)))
OFFSET_MAX INT_LIMIT(loff_t)
OFFT_OFFSET_MAX INT_LIMIT(off_t)
locks_inode() file_inode()
FASYNC_MAGIC 0x4601
SB_RDONLY 1
SB_NOSUID 2
SB_NODEV 4
SB_NOEXEC 8
SB_SYNCHRONOUS 16
SB_MANDLOCK 64
SB_DIRSYNC 128
SB_NOATIME 1024
SB_NODIRATIME 2048
SB_SILENT 32768
SB_POSIXACL (1<<16)
SB_KERNMOUNT (1<<22)
SB_I_VERSION (1<<23)
SB_LAZYTIME (1<<25)
SB_SUBMOUNT (1<<26)
SB_FORCE (1<<27)
SB_NOSEC (1<<28)
SB_BORN (1<<29)
SB_ACTIVE (1<<30)
SB_NOUSER (1<<31)
MNT_FORCE 0x00000001
MNT_DETACH 0x00000002
MNT_EXPIRE 0x00000004
UMOUNT_NOFOLLOW 0x00000008
UMOUNT_UNUSED 0x80000000
SB_I_CGROUPWB 0x00000001
SB_I_NOEXEC 0x00000002
SB_I_NODEV 0x00000004
SB_I_MULTIROOT 0x00000008
SB_I_USERNS_VISIBLE 0x00000010
SB_I_IMA_UNVERIFIABLE_SIGNATURE 0x00000020
SB_I_UNTRUSTED_MOUNTER 0x00000040
SB_I_NOSUID 0x80000000
SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)
__sb_writers_acquired(,) percpu_rwsem_acquire(&()->s_writers.rw_sem[()-1], 1, _THIS_IP_)
__sb_writers_release(,) percpu_rwsem_release(&()->s_writers.rw_sem[()-1], 1, _THIS_IP_)
HAVE_COMPAT_IOCTL 1
HAVE_UNLOCKED_IOCTL 1
NOMMU_MAP_COPY 0x00000001
NOMMU_MAP_DIRECT 0x00000008
NOMMU_MAP_READ VM_MAYREAD
NOMMU_MAP_WRITE VM_MAYWRITE
NOMMU_MAP_EXEC VM_MAYEXEC
NOMMU_VMFLAGS (NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)
REMAP_FILE_DEDUP (1 << 0)
REMAP_FILE_CAN_SHORTEN (1 << 1)
REMAP_FILE_ADVISORY (REMAP_FILE_CAN_SHORTEN)
S_SYNC 1
S_NOATIME 2
S_APPEND 4
S_IMMUTABLE 8
S_DEAD 16
S_NOQUOTA 32
S_DIRSYNC 64
S_NOCMTIME 128
S_SWAPFILE 256
S_PRIVATE 512
S_IMA 1024
S_AUTOMOUNT 2048
S_NOSEC 4096
S_DAX 8192
S_ENCRYPTED 16384
S_CASEFOLD 32768
S_VERITY 65536
__IS_FLG(,) (()->i_sb->s_flags & ())
IS_RDONLY() sb_rdonly(()->i_sb)
IS_SYNC() (__IS_FLG(, SB_SYNCHRONOUS) || (()->i_flags & S_SYNC))
IS_DIRSYNC() (__IS_FLG(, SB_SYNCHRONOUS|SB_DIRSYNC) || (()->i_flags & (S_SYNC|S_DIRSYNC)))
IS_MANDLOCK() __IS_FLG(, SB_MANDLOCK)
IS_NOATIME() __IS_FLG(, SB_RDONLY|SB_NOATIME)
IS_I_VERSION() __IS_FLG(, SB_I_VERSION)
IS_NOQUOTA() (()->i_flags & S_NOQUOTA)
IS_APPEND() (()->i_flags & S_APPEND)
IS_IMMUTABLE() (()->i_flags & S_IMMUTABLE)
IS_POSIXACL() __IS_FLG(, SB_POSIXACL)
IS_DEADDIR() (()->i_flags & S_DEAD)
IS_NOCMTIME() (()->i_flags & S_NOCMTIME)
IS_SWAPFILE() (()->i_flags & S_SWAPFILE)
IS_PRIVATE() (()->i_flags & S_PRIVATE)
IS_IMA() (()->i_flags & S_IMA)
IS_AUTOMOUNT() (()->i_flags & S_AUTOMOUNT)
IS_NOSEC() (()->i_flags & S_NOSEC)
IS_DAX() (()->i_flags & S_DAX)
IS_ENCRYPTED() (()->i_flags & S_ENCRYPTED)
IS_CASEFOLDED() (()->i_flags & S_CASEFOLD)
IS_VERITY() (()->i_flags & S_VERITY)
IS_WHITEOUT() (S_ISCHR(->i_mode) && ()->i_rdev == WHITEOUT_DEV)
I_DIRTY_SYNC (1 << 0)
I_DIRTY_DATASYNC (1 << 1)
I_DIRTY_PAGES (1 << 2)
__I_NEW 3
I_NEW (1 << __I_NEW)
I_WILL_FREE (1 << 4)
I_FREEING (1 << 5)
I_CLEAR (1 << 6)
__I_SYNC 7
I_SYNC (1 << __I_SYNC)
I_REFERENCED (1 << 8)
__I_DIO_WAKEUP 9
I_DIO_WAKEUP (1 << __I_DIO_WAKEUP)
I_LINKABLE (1 << 10)
I_DIRTY_TIME (1 << 11)
I_WB_SWITCH (1 << 13)
I_OVL_INUSE (1 << 14)
I_CREATING (1 << 15)
I_SYNC_QUEUED (1 << 17)
I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)
I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)
I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)
FS_REQUIRES_DEV 1
FS_BINARY_MOUNTDATA 2
FS_HAS_SUBTYPE 4
FS_USERNS_MOUNT 8
FS_DISALLOW_NOTIFY_PERM 16
FS_RENAME_DOES_D_MOVE 32768
MODULE_ALIAS_FS() MODULE_ALIAS("fs-" )
fops_get() ((() && try_module_get(()->owner) ? () : NULL))
fops_put() do { if () module_put(()->owner); } while(0)
replace_fops(,) do { struct file *__file = (); fops_put(__file->f_op); BUG_ON(!(__file->f_op = ())); } while(0)
MAX_RW_COUNT (INT_MAX & PAGE_MASK)
__getname() kmem_cache_alloc(names_cachep, GFP_KERNEL)
__putname() kmem_cache_free(names_cachep, (void *)())
CHRDEV_MAJOR_MAX 512
CHRDEV_MAJOR_DYN_END 234
CHRDEV_MAJOR_DYN_EXT_START 511
CHRDEV_MAJOR_DYN_EXT_END 384
BDEVNAME_SIZE 32
BDEVT_SIZE 10
BLKDEV_MAJOR_MAX 512
__kernel_read_file_id() (UNKNOWN, unknown) (FIRMWARE, firmware) (FIRMWARE_PREALLOC_BUFFER, firmware) (MODULE, kernel-module) (KEXEC_IMAGE, kexec-image) (KEXEC_INITRAMFS, kexec-initramfs) (POLICY, security-policy) (X509_CERTIFICATE, x509-certificate) (MAX_ID, )
__fid_enumify(,) READING_ ## ,
__fid_stringify(,) #,
special_file() (S_ISCHR()||S_ISBLK()||S_ISFIFO()||S_ISSOCK())
SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))
DEFINE_SIMPLE_ATTRIBUTE_XSIGNED(,,,,) static int  ## _open(struct inode *inode, struct file *file) \
{ __simple_attr_check_format(, 0ull); return simple_attr_open(inode, file, , , ); \
} static const struct file_operations  = { .owner = THIS_MODULE, .open =  ## _open, .release = simple_attr_release, .read = simple_attr_read, .write = () ? simple_attr_write_signed : simple_attr_write, .llseek = generic_file_llseek, \
}
DEFINE_SIMPLE_ATTRIBUTE(,,,) DEFINE_SIMPLE_ATTRIBUTE_XSIGNED(, , , , false)
DEFINE_SIMPLE_ATTRIBUTE_SIGNED(,,,) DEFINE_SIMPLE_ATTRIBUTE_XSIGNED(, , , , true)
__FMODE_EXEC ((__force int) FMODE_EXEC)
__FMODE_NONOTIFY ((__force int) FMODE_NONOTIFY)
ACC_MODE() ("\004\002\006\006"[()&O_ACCMODE])
OPEN_FMODE() ((__force fmode_t)((( + 1) & O_ACCMODE) | ( & __FMODE_NONOTIFY)))
proc_create_seq_data(,,,,) proc_create_seq_private(, , , , 0, )
proc_create_seq(,,,) proc_create_seq_private(, , , , 0, NULL)
proc_create_single(,,,) proc_create_single_data(, , , , NULL)
proc_create_net(,,,,) proc_create_net_data(, , , , , NULL)
ACPI_BUS_FILE_ROOT "acpi"
ACPI_DRIVER_ALL_NOTIFY_EVENTS 0x1
acpi_device_dir() (()->dir.entry)
acpi_device_bid() (()->pnp.bus_id)
acpi_device_adr() (()->pnp.bus_address)
acpi_device_uid() (()->pnp.unique_id)
acpi_device_name() (()->pnp.device_name)
acpi_device_class() (()->pnp.device_class)
to_acpi_device_node() ({ typeof() __to_acpi_device_node_fwnode = ; is_acpi_device_node(__to_acpi_device_node_fwnode) ? container_of(__to_acpi_device_node_fwnode, struct acpi_device, fwnode) : NULL; })
to_acpi_data_node() ({ typeof() __to_acpi_data_node_fwnode = ; is_acpi_data_node(__to_acpi_data_node_fwnode) ? container_of(__to_acpi_data_node_fwnode, struct acpi_data_node, fwnode) : NULL; })
to_acpi_device() container_of(, struct acpi_device, dev)
to_acpi_driver() container_of(, struct acpi_driver, drv)
module_acpi_driver() module_driver(, acpi_bus_register_driver, acpi_bus_unregister_driver)
ACPI_MAX_STRING 80
ACPI_BUS_COMPONENT 0x00010000
ACPI_AC_COMPONENT 0x00020000
ACPI_BATTERY_COMPONENT 0x00040000
ACPI_BUTTON_COMPONENT 0x00080000
ACPI_SBS_COMPONENT 0x00100000
ACPI_FAN_COMPONENT 0x00200000
ACPI_PCI_COMPONENT 0x00400000
ACPI_POWER_COMPONENT 0x00800000
ACPI_CONTAINER_COMPONENT 0x01000000
ACPI_SYSTEM_COMPONENT 0x02000000
ACPI_THERMAL_COMPONENT 0x04000000
ACPI_MEMORY_DEVICE_COMPONENT 0x08000000
ACPI_VIDEO_COMPONENT 0x10000000
ACPI_PROCESSOR_COMPONENT 0x20000000
ACPI_POWER_HID "LNXPOWER"
ACPI_PROCESSOR_OBJECT_HID "LNXCPU"
ACPI_SYSTEM_HID "LNXSYSTM"
ACPI_THERMAL_HID "LNXTHERM"
ACPI_BUTTON_HID_POWERF "LNXPWRBN"
ACPI_BUTTON_HID_SLEEPF "LNXSLPBN"
ACPI_VIDEO_HID "LNXVIDEO"
ACPI_BAY_HID "LNXIOBAY"
ACPI_DOCK_HID "LNXDOCK"
ACPI_ECDT_HID "LNXEC"
ACPI_SMBUS_IBM_HID "SMBUSIBM"
ACPI_FIXED_HARDWARE_EVENT 0x100
ACPI_PROCESSOR_LIMIT_NONE 0x00
ACPI_PROCESSOR_LIMIT_INCREMENT 0x01
ACPI_PROCESSOR_LIMIT_DECREMENT 0x02
MAX_PXM_DOMAINS MAX_NUMNODES
IOMEM_ERR_PTR() (__force void __iomem *)ERR_PTR()
pci_remap_cfgspace pci_remap_cfgspace
arch_has_dev_port() (1)
ACPI_COMPANION() to_acpi_device_node(()->fwnode)
ACPI_COMPANION_SET(,) set_primary_fwnode(, () ? acpi_fwnode_handle() : NULL)
ACPI_HANDLE() acpi_device_handle(ACPI_COMPANION())
ACPI_HANDLE_FWNODE() acpi_device_handle(to_acpi_device_node())
ACPI_DEVICE_CLASS(,) .cls = (), .cls_msk = (),
ACPI_SPACE_MEM 0
BAD_MADT_ENTRY(,) ( (!) || (unsigned long) + sizeof(*) >  || ((struct acpi_subtable_header *))->length < sizeof(*))
PHYS_CPUID_INVALID (phys_cpuid_t)(-1)
INVALID_ACPI_IRQ ((unsigned)-1)
ACPI_VIDEO_OUTPUT_SWITCHING 0x0001
ACPI_VIDEO_DEVICE_POSTING 0x0002
ACPI_VIDEO_ROM_AVAILABLE 0x0004
ACPI_VIDEO_BACKLIGHT 0x0008
ACPI_VIDEO_BACKLIGHT_FORCE_VENDOR 0x0010
ACPI_VIDEO_BACKLIGHT_FORCE_VIDEO 0x0020
ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VENDOR 0x0040
ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VIDEO 0x0080
ACPI_VIDEO_BACKLIGHT_DMI_VENDOR 0x0100
ACPI_VIDEO_BACKLIGHT_DMI_VIDEO 0x0200
ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR 0x0400
ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO 0x0800
PXM_INVAL (-1)
OSC_QUERY_DWORD 0
OSC_SUPPORT_DWORD 1
OSC_CONTROL_DWORD 2
OSC_QUERY_ENABLE 0x00000001
OSC_REQUEST_ERROR 0x00000002
OSC_INVALID_UUID_ERROR 0x00000004
OSC_INVALID_REVISION_ERROR 0x00000008
OSC_CAPABILITIES_MASK_ERROR 0x00000010
OSC_SB_PAD_SUPPORT 0x00000001
OSC_SB_PPC_OST_SUPPORT 0x00000002
OSC_SB_PR3_SUPPORT 0x00000004
OSC_SB_HOTPLUG_OST_SUPPORT 0x00000008
OSC_SB_APEI_SUPPORT 0x00000010
OSC_SB_CPC_SUPPORT 0x00000020
OSC_SB_CPCV2_SUPPORT 0x00000040
OSC_SB_PCLPI_SUPPORT 0x00000080
OSC_SB_OSLPI_SUPPORT 0x00000100
OSC_SB_CPC_DIVERSE_HIGH_SUPPORT 0x00001000
OSC_PCI_EXT_CONFIG_SUPPORT 0x00000001
OSC_PCI_ASPM_SUPPORT 0x00000002
OSC_PCI_CLOCK_PM_SUPPORT 0x00000004
OSC_PCI_SEGMENT_GROUPS_SUPPORT 0x00000008
OSC_PCI_MSI_SUPPORT 0x00000010
OSC_PCI_HPX_TYPE_3_SUPPORT 0x00000100
OSC_PCI_SUPPORT_MASKS 0x0000011f
OSC_PCI_EXPRESS_NATIVE_HP_CONTROL 0x00000001
OSC_PCI_SHPC_NATIVE_HP_CONTROL 0x00000002
OSC_PCI_EXPRESS_PME_CONTROL 0x00000004
OSC_PCI_EXPRESS_AER_CONTROL 0x00000008
OSC_PCI_EXPRESS_CAPABILITY_CONTROL 0x00000010
OSC_PCI_EXPRESS_LTR_CONTROL 0x00000020
OSC_PCI_CONTROL_MASKS 0x0000003f
ACPI_GSB_ACCESS_ATTRIB_QUICK 0x00000002
ACPI_GSB_ACCESS_ATTRIB_SEND_RCV 0x00000004
ACPI_GSB_ACCESS_ATTRIB_BYTE 0x00000006
ACPI_GSB_ACCESS_ATTRIB_WORD 0x00000008
ACPI_GSB_ACCESS_ATTRIB_BLOCK 0x0000000A
ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE 0x0000000B
ACPI_GSB_ACCESS_ATTRIB_WORD_CALL 0x0000000C
ACPI_GSB_ACCESS_ATTRIB_BLOCK_CALL 0x0000000D
ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES 0x0000000E
ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS 0x0000000F
ACPI_HOTPLUG_OST 
ACPI_OST_EC_OSPM_SHUTDOWN 0x100
ACPI_OST_EC_OSPM_EJECT 0x103
ACPI_OST_EC_OSPM_INSERTION 0x200
ACPI_OST_SC_SUCCESS 0x0
ACPI_OST_SC_NON_SPECIFIC_FAILURE 0x1
ACPI_OST_SC_UNRECOGNIZED_NOTIFY 0x2
ACPI_OST_SC_OS_SHUTDOWN_DENIED 0x80
ACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS 0x81
ACPI_OST_SC_OS_SHUTDOWN_COMPLETED 0x82
ACPI_OST_SC_OS_SHUTDOWN_NOT_SUPPORTED 0x83
ACPI_OST_SC_EJECT_NOT_SUPPORTED 0x80
ACPI_OST_SC_DEVICE_IN_USE 0x81
ACPI_OST_SC_DEVICE_BUSY 0x82
ACPI_OST_SC_EJECT_DEPENDENCY_BUSY 0x83
ACPI_OST_SC_EJECT_IN_PROGRESS 0x84
ACPI_OST_SC_INSERT_IN_PROGRESS 0x80
ACPI_OST_SC_DRIVER_LOAD_FAILURE 0x81
ACPI_OST_SC_INSERT_NOT_SUPPORTED 0x82
ACPI_PTR() ()
acpi_handle_emerg(,) acpi_handle_printk(KERN_EMERG, , , ##__VA_ARGS__)
acpi_handle_alert(,) acpi_handle_printk(KERN_ALERT, , , ##__VA_ARGS__)
acpi_handle_crit(,) acpi_handle_printk(KERN_CRIT, , , ##__VA_ARGS__)
acpi_handle_err(,) acpi_handle_printk(KERN_ERR, , , ##__VA_ARGS__)
acpi_handle_warn(,) acpi_handle_printk(KERN_WARNING, , , ##__VA_ARGS__)
acpi_handle_notice(,) acpi_handle_printk(KERN_NOTICE, , , ##__VA_ARGS__)
acpi_handle_info(,) acpi_handle_printk(KERN_INFO, , , ##__VA_ARGS__)
acpi_handle_debug(,) _dynamic_func_call(, __acpi_handle_debug, , pr_fmt(), ##__VA_ARGS__)
ACPI_TABLE_ID_LEN 5
ACPI_DECLARE_PROBE_ENTRY(,,,,,,) static const struct acpi_probe_entry __acpi_probe_## __used __section(__####_acpi_probe_table) = { .id = , .type = , .subtable_valid = , .probe_table = (acpi_tbl_table_handler), .driver_data = , }
ACPI_PROBE_TABLE() __####_acpi_probe_table
ACPI_PROBE_TABLE_END() __####_acpi_probe_table_end
acpi_probe_device_table() ({ extern struct acpi_probe_entry ACPI_PROBE_TABLE(), ACPI_PROBE_TABLE_END(); __acpi_probe_device_table(&ACPI_PROBE_TABLE(), (&ACPI_PROBE_TABLE_END() - &ACPI_PROBE_TABLE())); })
IRQ_RETVAL() (() ? IRQ_HANDLED : IRQ_NONE)
for_each_irq_desc(,) for ( = 0,  = irq_to_desc();  < nr_irqs; ++,  = irq_to_desc()) if (!) ; else
for_each_irq_desc_reverse(,) for ( = nr_irqs - 1,  = irq_to_desc();  >= 0; --,  = irq_to_desc()) if (!) ; else
for_each_active_irq() for ( = irq_get_next_irq(0);  < nr_irqs;  = irq_get_next_irq( + 1))
for_each_irq_nr() for ( = 0;  < nr_irqs; ++)
__irq_enter() do { account_irq_enter_time(current); preempt_count_add(HARDIRQ_OFFSET); trace_hardirq_enter(); } while (0)
__irq_exit() do { trace_hardirq_exit(); account_irq_exit_time(current); preempt_count_sub(HARDIRQ_OFFSET); } while (0)
arch_nmi_enter() do { } while (0)
arch_nmi_exit() do { } while (0)
nmi_enter() do { arch_nmi_enter(); printk_nmi_enter(); lockdep_off(); ftrace_nmi_enter(); BUG_ON(in_nmi()); preempt_count_add(NMI_OFFSET + HARDIRQ_OFFSET); rcu_nmi_enter(); trace_hardirq_enter(); } while (0)
nmi_exit() do { trace_hardirq_exit(); rcu_nmi_exit(); BUG_ON(!in_nmi()); preempt_count_sub(NMI_OFFSET + HARDIRQ_OFFSET); ftrace_nmi_exit(); lockdep_on(); printk_nmi_exit(); arch_nmi_exit(); } while (0)
__ARCH_HAS_DO_SOFTIRQ 
arch_trigger_cpumask_backtrace arch_trigger_cpumask_backtrace
dereference_function_descriptor() ()
dereference_kernel_function_descriptor() ()
ARCH_HAS_RELATIVE_EXTABLE 
swap_ex_entry_fixup(,,,) do { ()->fixup = ()->fixup + (); ()->fixup = ().fixup - (); ()->handler = ()->handler + (); ()->handler = ().handler - (); } while (0)
IRQF_TRIGGER_NONE 0x00000000
IRQF_TRIGGER_RISING 0x00000001
IRQF_TRIGGER_FALLING 0x00000002
IRQF_TRIGGER_HIGH 0x00000004
IRQF_TRIGGER_LOW 0x00000008
IRQF_TRIGGER_MASK (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
IRQF_TRIGGER_PROBE 0x00000010
IRQF_SHARED 0x00000080
IRQF_PROBE_SHARED 0x00000100
__IRQF_TIMER 0x00000200
IRQF_PERCPU 0x00000400
IRQF_NOBALANCING 0x00000800
IRQF_IRQPOLL 0x00001000
IRQF_ONESHOT 0x00002000
IRQF_NO_SUSPEND 0x00004000
IRQF_FORCE_RESUME 0x00008000
IRQF_NO_THREAD 0x00010000
IRQF_EARLY_RESUME 0x00020000
IRQF_COND_SUSPEND 0x00040000
IRQF_TIMER (__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
IRQ_NOTCONNECTED (1U << 31)
local_irq_enable_in_hardirq() local_irq_enable()
IRQ_AFFINITY_MAX_SETS 4
local_softirq_pending_ref irq_stat.__softirq_pending
local_softirq_pending() (__this_cpu_read(local_softirq_pending_ref))
set_softirq_pending() (__this_cpu_write(local_softirq_pending_ref, ()))
or_softirq_pending() (__this_cpu_or(local_softirq_pending_ref, ()))
hard_irq_disable() do { } while(0)
SOFTIRQ_STOP_IDLE_MASK (~(1 << RCU_SOFTIRQ))
DECLARE_TASKLET_OLD(,) struct tasklet_struct  = { .count = ATOMIC_INIT(0), .func = , \
}
DECLARE_TASKLET_DISABLED_OLD(,) struct tasklet_struct  = { .count = ATOMIC_INIT(1), .func = , \
}
__irq_entry __attribute__((__section__(".irqentry.text")))
__softirq_entry __attribute__((__section__(".softirqentry.text")))
RTC_AIE_ON _IO('p', 0x01)
RTC_AIE_OFF _IO('p', 0x02)
RTC_UIE_ON _IO('p', 0x03)
RTC_UIE_OFF _IO('p', 0x04)
RTC_PIE_ON _IO('p', 0x05)
RTC_PIE_OFF _IO('p', 0x06)
RTC_WIE_ON _IO('p', 0x0f)
RTC_WIE_OFF _IO('p', 0x10)
RTC_ALM_SET _IOW('p', 0x07, struct rtc_time)
RTC_ALM_READ _IOR('p', 0x08, struct rtc_time)
RTC_RD_TIME _IOR('p', 0x09, struct rtc_time)
RTC_SET_TIME _IOW('p', 0x0a, struct rtc_time)
RTC_IRQP_READ _IOR('p', 0x0b, unsigned long)
RTC_IRQP_SET _IOW('p', 0x0c, unsigned long)
RTC_EPOCH_READ _IOR('p', 0x0d, unsigned long)
RTC_EPOCH_SET _IOW('p', 0x0e, unsigned long)
RTC_WKALM_SET _IOW('p', 0x0f, struct rtc_wkalrm)
RTC_WKALM_RD _IOR('p', 0x10, struct rtc_wkalrm)
RTC_PLL_GET _IOR('p', 0x11, struct rtc_pll_info)
RTC_PLL_SET _IOW('p', 0x12, struct rtc_pll_info)
RTC_VL_READ _IOR('p', 0x13, int)
RTC_VL_CLR _IO('p', 0x14)
RTC_IRQF 0x80
RTC_PF 0x40
RTC_AF 0x20
RTC_UF 0x10
RTC_MAX_FREQ 8192
ASSOC_ARRAY_KEY_CHUNK_SIZE BITS_PER_LONG
KEY_POS_VIEW 0x01000000
KEY_POS_READ 0x02000000
KEY_POS_WRITE 0x04000000
KEY_POS_SEARCH 0x08000000
KEY_POS_LINK 0x10000000
KEY_POS_SETATTR 0x20000000
KEY_POS_ALL 0x3f000000
KEY_USR_VIEW 0x00010000
KEY_USR_READ 0x00020000
KEY_USR_WRITE 0x00040000
KEY_USR_SEARCH 0x00080000
KEY_USR_LINK 0x00100000
KEY_USR_SETATTR 0x00200000
KEY_USR_ALL 0x003f0000
KEY_GRP_VIEW 0x00000100
KEY_GRP_READ 0x00000200
KEY_GRP_WRITE 0x00000400
KEY_GRP_SEARCH 0x00000800
KEY_GRP_LINK 0x00001000
KEY_GRP_SETATTR 0x00002000
KEY_GRP_ALL 0x00003f00
KEY_OTH_VIEW 0x00000001
KEY_OTH_READ 0x00000002
KEY_OTH_WRITE 0x00000004
KEY_OTH_SEARCH 0x00000008
KEY_OTH_LINK 0x00000010
KEY_OTH_SETATTR 0x00000020
KEY_OTH_ALL 0x0000003f
KEY_PERM_UNDEF 0xffffffff
KEY_FLAG_DEAD 0
KEY_FLAG_REVOKED 1
KEY_FLAG_IN_QUOTA 2
KEY_FLAG_USER_CONSTRUCT 3
KEY_FLAG_ROOT_CAN_CLEAR 4
KEY_FLAG_INVALIDATED 5
KEY_FLAG_BUILTIN 6
KEY_FLAG_ROOT_CAN_INVAL 7
KEY_FLAG_KEEP 8
KEY_FLAG_UID_KEYRING 9
KEY_ALLOC_IN_QUOTA 0x0000
KEY_ALLOC_QUOTA_OVERRUN 0x0001
KEY_ALLOC_NOT_IN_QUOTA 0x0002
KEY_ALLOC_BUILT_IN 0x0004
KEY_ALLOC_BYPASS_RESTRICTION 0x0008
KEY_ALLOC_UID_KEYRING 0x0010
KEY_ALLOC_SET_KEEP 0x0020
request_key_net(,,,) request_key_tag(, , ->key_domain, );
request_key_net_rcu(,,) request_key_rcu(, , ->key_domain);
KEY_NEED_VIEW 0x01
KEY_NEED_READ 0x02
KEY_NEED_WRITE 0x04
KEY_NEED_SEARCH 0x08
KEY_NEED_LINK 0x10
KEY_NEED_SETATTR 0x20
KEY_NEED_ALL 0x3f
dereference_key_rcu() (rcu_dereference(()->payload.rcu_data0))
dereference_key_locked() (rcu_dereference_protected(()->payload.rcu_data0, rwsem_is_locked(&((struct key *)())->sem)))
rcu_assign_keypointer(,) do { rcu_assign_pointer(()->payload.rcu_data0, ()); \
} while (0)
INIT_USER (&root_user)
put_group_info() do { if (atomic_dec_and_test(&()->usage)) groups_free(); \
} while (0)
current_cred() rcu_dereference_protected(current->cred, 1)
current_real_cred() rcu_dereference_protected(current->real_cred, 1)
__task_cred() rcu_dereference(()->real_cred)
get_current_cred() (get_cred(current_cred()))
get_current_user() \
({ struct user_struct *__u; const struct cred *__cred; __cred = current_cred(); __u = get_uid(__cred->user); __u; \
})
get_current_groups() \
({ struct group_info *__groups; const struct cred *__cred; __cred = current_cred(); __groups = get_group_info(__cred->group_info); __groups; \
})
task_cred_xxx(,) \
({ __typeof__(((struct cred *)NULL)->) ___val; rcu_read_lock(); ___val = __task_cred(())->; rcu_read_unlock(); ___val; \
})
task_uid() (task_cred_xxx((), uid))
task_euid() (task_cred_xxx((), euid))
current_cred_xxx() \
({ current_cred()->; \
})
current_uid() (current_cred_xxx(uid))
current_gid() (current_cred_xxx(gid))
current_euid() (current_cred_xxx(euid))
current_egid() (current_cred_xxx(egid))
current_suid() (current_cred_xxx(suid))
current_sgid() (current_cred_xxx(sgid))
current_fsuid() (current_cred_xxx(fsuid))
current_fsgid() (current_cred_xxx(fsgid))
current_cap() (current_cred_xxx(cap_effective))
current_user() (current_cred_xxx(user))
current_user_ns() (current_cred_xxx(user_ns))
current_uid_gid(,) do { const struct cred *__cred; __cred = current_cred(); *() = __cred->uid; *() = __cred->gid; \
} while(0)
current_euid_egid(,) do { const struct cred *__cred; __cred = current_cred(); *() = __cred->euid; *() = __cred->egid; \
} while(0)
current_fsuid_fsgid(,) do { const struct cred *__cred; __cred = current_cred(); *() = __cred->fsuid; *() = __cred->fsgid; \
} while(0)
SEQ_SKIP 1
DEFINE_SHOW_ATTRIBUTE() static int  ## _open(struct inode *inode, struct file *file) \
{ return single_open(file,  ## _show, inode->i_private); \
} static const struct file_operations  ## _fops = { .owner = THIS_MODULE, .open =  ## _open, .read = seq_read, .llseek = seq_lseek, .release = single_release, \
}
seq_show_option_n(,,,) { char val_buf[ + 1]; strncpy(val_buf, , ); val_buf[] = '\0'; seq_show_option(, , val_buf); \
}
SEQ_START_TOKEN ((void *)1)
uaccess_kernel() segment_eq(get_fs(), KERNEL_DS)
__ASM_CLAC ".byte 0x0f,0x01,0xca"
__ASM_STAC ".byte 0x0f,0x01,0xcb"
ASM_CLAC ALTERNATIVE("", __ASM_CLAC, X86_FEATURE_SMAP)
ASM_STAC ALTERNATIVE("", __ASM_STAC, X86_FEATURE_SMAP)
MAKE_MM_SEG() ((mm_segment_t) { () })
KERNEL_DS MAKE_MM_SEG(-1UL)
USER_DS MAKE_MM_SEG(TASK_SIZE_MAX)
get_fs() (current->thread.addr_limit)
segment_eq(,) (().seg == ().seg)
user_addr_max() (current->thread.addr_limit.seg)
__range_not_ok(,,) \
({ __chk_user_ptr(); __chk_range_not_ok((unsigned long __force)(), , ); \
})
WARN_ON_IN_IRQ() 
access_ok(,) \
({ WARN_ON_IN_IRQ(); likely(!__range_not_ok(, , user_addr_max())); \
})
__uaccess_begin() stac()
__uaccess_end() clac()
__uaccess_begin_nospec() \
({ stac(); barrier_nospec(); \
})
__inttype() __typeof__(__builtin_choose_expr(sizeof() > sizeof(0UL), 0ULL, 0UL))
get_user(,) \
({ int __ret_gu; register __inttype(*()) __val_gu asm("%"_ASM_DX); __chk_user_ptr(); might_fault(); asm volatile("call __get_user_%P4" : "=a" (__ret_gu), "=r" (__val_gu), ASM_CALL_CONSTRAINT : "0" (), "i" (sizeof(*()))); () = (__force __typeof__(*())) __val_gu; __builtin_expect(__ret_gu, 0); \
})
__put_user_x(,,,) asm volatile("call __put_user_" # : "=a" () : "0" ((typeof(*()))()), "c" () : "ebx")
__put_user_goto_u64(,,) __put_user_goto(, , "q", "", "er", )
__put_user_asm_ex_u64(,) __put_user_asm_ex(, , "q", "", "er")
__put_user_x8(,,) __put_user_x(8, , , )
put_user(,) \
({ int __ret_pu; __typeof__(*()) __pu_val; __chk_user_ptr(); might_fault(); __pu_val = ; switch (sizeof(*())) { case 1: __put_user_x(1, __pu_val, , __ret_pu); break; case 2: __put_user_x(2, __pu_val, , __ret_pu); break; case 4: __put_user_x(4, __pu_val, , __ret_pu); break; case 8: __put_user_x8(__pu_val, , __ret_pu); break; default: __put_user_x(X, __pu_val, , __ret_pu); break; } __builtin_expect(__ret_pu, 0); \
})
__put_user_size(,,,) do { __chk_user_ptr(); switch () { case 1: __put_user_goto(, , "b", "b", "iq", ); break; case 2: __put_user_goto(, , "w", "w", "ir", ); break; case 4: __put_user_goto(, , "l", "k", "ir", ); break; case 8: __put_user_goto_u64(, , ); break; default: __put_user_bad(); } \
} while (0)
__put_user_size_ex(,,) do { __chk_user_ptr(); switch () { case 1: __put_user_asm_ex(, , "b", "b", "iq"); break; case 2: __put_user_asm_ex(, , "w", "w", "ir"); break; case 4: __put_user_asm_ex(, , "l", "k", "ir"); break; case 8: __put_user_asm_ex_u64((__typeof__(*))(), ); break; default: __put_user_bad(); } \
} while (0)
__get_user_asm_u64(,,,) __get_user_asm(, , , "q", "", "=r", )
__get_user_asm_ex_u64(,) __get_user_asm_ex(, , "q", "", "=r")
__get_user_size(,,,,) do {  = 0; __chk_user_ptr(); switch () { case 1: __get_user_asm(, , , "b", "b", "=q", ); break; case 2: __get_user_asm(, , , "w", "w", "=r", ); break; case 4: __get_user_asm(, , , "l", "k", "=r", ); break; case 8: __get_user_asm_u64(, , , ); break; default: () = __get_user_bad(); } \
} while (0)
__get_user_asm(,,,,,,) asm volatile("\n" "1:	mov"" %2,%""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	mov %3,%0\n" "	xor"" %""1,%""1\n" "	jmp 2b\n" ".previous\n" _ASM_EXTABLE_UA(1b, 3b) : "=r" (), () : "m" (__m()), "i" (), "0" ())
__get_user_size_ex(,,) do { __chk_user_ptr(); switch () { case 1: __get_user_asm_ex(, , "b", "b", "=q"); break; case 2: __get_user_asm_ex(, , "w", "w", "=r"); break; case 4: __get_user_asm_ex(, , "l", "k", "=r"); break; case 8: __get_user_asm_ex_u64(, ); break; default: () = __get_user_bad(); } \
} while (0)
__get_user_asm_ex(,,,,) asm volatile("1:	mov"" %1,%""0\n" "2:\n" ".section .fixup,\"ax\"\n" "3:xor"" %""0,%""0\n" "  jmp 2b\n" ".previous\n" _ASM_EXTABLE_EX(1b, 3b) : () : "m" (__m()))
__put_user_nocheck(,,) \
({ __label__ __pu_label; int __pu_err = -EFAULT; __typeof__(*()) __pu_val = (); __typeof__() __pu_ptr = (); __typeof__() __pu_size = (); __uaccess_begin(); __put_user_size(__pu_val, __pu_ptr, __pu_size, __pu_label); __pu_err = 0; __pu_label: __uaccess_end(); __builtin_expect(__pu_err, 0); \
})
__get_user_nocheck(,,) \
({ int __gu_err; __inttype(*()) __gu_val; __typeof__() __gu_ptr = (); __typeof__() __gu_size = (); __uaccess_begin_nospec(); __get_user_size(__gu_val, __gu_ptr, __gu_size, __gu_err, -EFAULT); __uaccess_end(); () = (__force __typeof__(*()))__gu_val; __builtin_expect(__gu_err, 0); \
})
__try_cmpxchg_user_asm(,,,,,) ({ int __err = 0; bool success; __typeof__() _old = (__typeof__())(); __typeof__(*()) __old = *_old; __typeof__(*()) __new = (); asm volatile("\n" "1: " LOCK_PREFIX "cmpxchg"" %[new], %[ptr]\n" CC_SET(z) "2:\n" _ASM_EXTABLE_TYPE_REG(1b, 2b, EX_TYPE_EFAULT_REG, %[errout]) : CC_OUT(z) (success), [errout] "+r" (__err), [ptr] "+m" (*), [old] "+a" (__old) : [new]  (__new) : "memory"); if (unlikely(__err)) goto ; if (unlikely(!success)) *_old = __old; likely(success); })
__m() (*(struct __large_struct __user *)())
__put_user_goto(,,,,,) asm_volatile_goto("\n" "1:	mov"" %""0,%1\n" _ASM_EXTABLE_UA(1b, %l2) : : (), "m" (__m()) : : )
__put_user_failed(,,,,,) ({ __label__ __puflab; int __pufret = ; __put_user_goto(,,,,,__puflab); __pufret = 0; __puflab: __pufret; })
__put_user_asm(,,,,,,) do {  = __put_user_failed(, , , , , ); \
} while (0)
__put_user_asm_ex(,,,,) asm volatile("1:	mov"" %""0,%1\n" "2:\n" _ASM_EXTABLE_EX(1b, 2b) : : (), "m" (__m()))
uaccess_try do { current->thread.uaccess_err = 0; __uaccess_begin(); barrier();
uaccess_try_nospec do { current->thread.uaccess_err = 0; __uaccess_begin_nospec();
uaccess_catch() __uaccess_end(); () |= (current->thread.uaccess_err ? -EFAULT : 0); \
} while (0)
__get_user(,) __get_user_nocheck((), (), sizeof(*()))
__put_user(,) __put_user_nocheck((__typeof__(*()))(), (), sizeof(*()))
get_user_try uaccess_try_nospec
get_user_catch() uaccess_catch()
get_user_ex(,) do { unsigned long __gue_val; __get_user_size_ex((__gue_val), (), (sizeof(*()))); () = (__force __typeof__(*()))__gue_val; \
} while (0)
put_user_try uaccess_try
put_user_catch() uaccess_catch()
put_user_ex(,) __put_user_size_ex((__typeof__(*()))(), (), sizeof(*()))
__user_atomic_cmpxchg_inatomic(,,,,) \
({ int __ret = 0; __typeof__(*()) __old = (); __typeof__(*()) __new = (); __uaccess_begin_nospec(); switch () { case 1: { asm volatile("\n" "1:\t" LOCK_PREFIX "cmpxchgb %4, %2\n" "2:\n" "\t.section .fixup, \"ax\"\n" "3:\tmov     %3, %0\n" "\tjmp     2b\n" "\t.previous\n" _ASM_EXTABLE_UA(1b, 3b) : "+r" (__ret), "=a" (__old), "+m" (*()) : "i" (-EFAULT), "q" (__new), "1" (__old) : "memory" ); break; } case 2: { asm volatile("\n" "1:\t" LOCK_PREFIX "cmpxchgw %4, %2\n" "2:\n" "\t.section .fixup, \"ax\"\n" "3:\tmov     %3, %0\n" "\tjmp     2b\n" "\t.previous\n" _ASM_EXTABLE_UA(1b, 3b) : "+r" (__ret), "=a" (__old), "+m" (*()) : "i" (-EFAULT), "r" (__new), "1" (__old) : "memory" ); break; } case 4: { asm volatile("\n" "1:\t" LOCK_PREFIX "cmpxchgl %4, %2\n" "2:\n" "\t.section .fixup, \"ax\"\n" "3:\tmov     %3, %0\n" "\tjmp     2b\n" "\t.previous\n" _ASM_EXTABLE_UA(1b, 3b) : "+r" (__ret), "=a" (__old), "+m" (*()) : "i" (-EFAULT), "r" (__new), "1" (__old) : "memory" ); break; } case 8: { if (!IS_ENABLED(CONFIG_X86_64)) __cmpxchg_wrong_size(); asm volatile("\n" "1:\t" LOCK_PREFIX "cmpxchgq %4, %2\n" "2:\n" "\t.section .fixup, \"ax\"\n" "3:\tmov     %3, %0\n" "\tjmp     2b\n" "\t.previous\n" _ASM_EXTABLE_UA(1b, 3b) : "+r" (__ret), "=a" (__old), "+m" (*()) : "i" (-EFAULT), "r" (__new), "1" (__old) : "memory" ); break; } default: __cmpxchg_wrong_size(); } __uaccess_end(); *() = __old; __ret; \
})
user_atomic_cmpxchg_inatomic(,,,) \
({ access_ok((), sizeof(*())) ? __user_atomic_cmpxchg_inatomic((), (), (), (), sizeof(*())) : -EFAULT; \
})
ARCH_HAS_NOCACHE_UACCESS 1
__copy_from_user_nmi __copy_from_user_inatomic
user_access_begin(,) user_access_begin(,)
user_access_end() __uaccess_end()
user_access_save() smap_save()
user_access_restore() smap_restore()
unsafe_put_user(,,) __put_user_size((__typeof__(*()))(), (), sizeof(*()), )
unsafe_get_user(,,) do { int __gu_err; __inttype(*()) __gu_val; __get_user_size(__gu_val, (), sizeof(*()), __gu_err, -EFAULT); () = (__force __typeof__(*()))__gu_val; if (unlikely(__gu_err)) goto ; \
} while (0)
__try_cmpxchg64_user_asm(,,,) __try_cmpxchg_user_asm("q", "r", (), (), (), )
unsafe_try_cmpxchg_user(,,,) ({ bool __ret; __chk_user_ptr(); switch (sizeof(*())) { case 1: __ret = __try_cmpxchg_user_asm("b", "q", (__force u8 *)(), (), (), ); break; case 2: __ret = __try_cmpxchg_user_asm("w", "r", (__force u16 *)(), (), (), ); break; case 4: __ret = __try_cmpxchg_user_asm("l", "r", (__force u32 *)(), (), (), ); break; case 8: __ret = __try_cmpxchg64_user_asm((__force u64 *)(), (), (), ); break; default: __try_cmpxchg_user_wrong_size(); } __ret; })
__try_cmpxchg_user(,,,) ({ int __ret = -EFAULT; __uaccess_begin_nospec(); __ret = !unsafe_try_cmpxchg_user(, , , ); : __uaccess_end(); __ret; })
unsafe_copy_loop(,,,,) while ( >= sizeof()) { unsafe_put_user(*( *),( __user *),);  += sizeof();  += sizeof();  -= sizeof(); }
unsafe_copy_to_user(,,,) do { char __user *__ucu_dst = (); const char *__ucu_src = (); size_t __ucu_len = (); unsafe_copy_loop(__ucu_dst, __ucu_src, __ucu_len, u64, ); unsafe_copy_loop(__ucu_dst, __ucu_src, __ucu_len, u32, ); unsafe_copy_loop(__ucu_dst, __ucu_src, __ucu_len, u16, ); unsafe_copy_loop(__ucu_dst, __ucu_src, __ucu_len, u8, ); \
} while (0)
faulthandler_disabled() (pagefault_disabled() || in_atomic())
probe_kernel_address(,) probe_kernel_read(&, , sizeof())
POLLIN 0x0001
POLLPRI 0x0002
POLLOUT 0x0004
POLLERR 0x0008
POLLHUP 0x0010
POLLNVAL 0x0020
POLLRDNORM 0x0040
POLLRDBAND 0x0080
POLLWRNORM 0x0100
POLLWRBAND 0x0200
POLLMSG 0x0400
POLLREMOVE 0x1000
POLLRDHUP 0x2000
POLLFREE (__force __poll_t)0x4000
POLL_BUSY_LOOP (__force __poll_t)0x8000
EPOLL_CLOEXEC O_CLOEXEC
EPOLL_CTL_ADD 1
EPOLL_CTL_DEL 2
EPOLL_CTL_MOD 3
EPOLLIN (__force __poll_t)0x00000001
EPOLLPRI (__force __poll_t)0x00000002
EPOLLOUT (__force __poll_t)0x00000004
EPOLLERR (__force __poll_t)0x00000008
EPOLLHUP (__force __poll_t)0x00000010
EPOLLNVAL (__force __poll_t)0x00000020
EPOLLRDNORM (__force __poll_t)0x00000040
EPOLLRDBAND (__force __poll_t)0x00000080
EPOLLWRNORM (__force __poll_t)0x00000100
EPOLLWRBAND (__force __poll_t)0x00000200
EPOLLMSG (__force __poll_t)0x00000400
EPOLLRDHUP (__force __poll_t)0x00002000
EPOLLEXCLUSIVE ((__force __poll_t)(1U << 28))
EPOLLWAKEUP ((__force __poll_t)(1U << 29))
EPOLLONESHOT ((__force __poll_t)(1U << 30))
EPOLLET ((__force __poll_t)(1U << 31))
EPOLL_PACKED __attribute__((packed))
MAX_STACK_ALLOC 768
FRONTEND_STACK_ALLOC 256
SELECT_STACK_ALLOC FRONTEND_STACK_ALLOC
POLL_STACK_ALLOC FRONTEND_STACK_ALLOC
WQUEUES_STACK_ALLOC (MAX_STACK_ALLOC - FRONTEND_STACK_ALLOC)
N_INLINE_POLL_ENTRIES (WQUEUES_STACK_ALLOC / sizeof(struct poll_table_entry))
DEFAULT_POLLMASK (EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM)
MAX_INT64_SECONDS (((s64)(~((u64)0)>>1)/HZ)-1)
__MAP (v, from, to) (from < to ? (v & from) * (to/from) : (v & from) / (from/to))
M (X) __MAP(v, (__force __u16)EPOLL##X, POLL##X)
M (X) (__force __poll_t)__MAP(val, POLL##X, (__force __u16)EPOLL##X)
RTC_DEV_BUSY 0
to_rtc_device() container_of(, struct rtc_device, dev)
RTC_TIMESTAMP_BEGIN_1900 -2208988800LL
RTC_TIMESTAMP_BEGIN_2000 946684800LL
RTC_TIMESTAMP_END_2063 2966371199LL
RTC_TIMESTAMP_END_2099 4102444799LL
RTC_TIMESTAMP_END_9999 253402300799LL
rtc_register_device() __rtc_register_device(THIS_MODULE, )
PSTORE_FLAGS_DMESG BIT(0)
PSTORE_FLAGS_CONSOLE BIT(1)
PSTORE_FLAGS_FTRACE BIT(2)
PSTORE_FLAGS_PMSG BIT(3)
TS_CPU_SHIFT 8
TS_CPU_MASK (BIT(TS_CPU_SHIFT) - 1)
LINUX_REBOOT_MAGIC1 0xfee1dead
LINUX_REBOOT_MAGIC2 672274793
LINUX_REBOOT_MAGIC2A 85072278
LINUX_REBOOT_MAGIC2B 369367448
LINUX_REBOOT_MAGIC2C 537993216
LINUX_REBOOT_CMD_RESTART 0x01234567
LINUX_REBOOT_CMD_HALT 0xCDEF0123
LINUX_REBOOT_CMD_CAD_ON 0x89ABCDEF
LINUX_REBOOT_CMD_CAD_OFF 0x00000000
LINUX_REBOOT_CMD_POWER_OFF 0x4321FEDC
LINUX_REBOOT_CMD_RESTART2 0xA1B2C3D4
LINUX_REBOOT_CMD_SW_SUSPEND 0xD000FCE2
LINUX_REBOOT_CMD_KEXEC 0x45584543
SYS_DOWN 0x0001
SYS_RESTART SYS_DOWN
SYS_HALT 0x0002
SYS_POWER_OFF 0x0003
POWEROFF_CMD_PATH_LEN 256
EFI_SUCCESS 0
EFI_LOAD_ERROR ( 1 | (1UL << (BITS_PER_LONG-1)))
EFI_INVALID_PARAMETER ( 2 | (1UL << (BITS_PER_LONG-1)))
EFI_UNSUPPORTED ( 3 | (1UL << (BITS_PER_LONG-1)))
EFI_BAD_BUFFER_SIZE ( 4 | (1UL << (BITS_PER_LONG-1)))
EFI_BUFFER_TOO_SMALL ( 5 | (1UL << (BITS_PER_LONG-1)))
EFI_NOT_READY ( 6 | (1UL << (BITS_PER_LONG-1)))
EFI_DEVICE_ERROR ( 7 | (1UL << (BITS_PER_LONG-1)))
EFI_WRITE_PROTECTED ( 8 | (1UL << (BITS_PER_LONG-1)))
EFI_OUT_OF_RESOURCES ( 9 | (1UL << (BITS_PER_LONG-1)))
EFI_NOT_FOUND (14 | (1UL << (BITS_PER_LONG-1)))
EFI_ABORTED (21 | (1UL << (BITS_PER_LONG-1)))
EFI_SECURITY_VIOLATION (26 | (1UL << (BITS_PER_LONG-1)))
EFI_IS_ERROR() (() & (1UL << (BITS_PER_LONG-1)))
EFI_GUID(,,,) (efi_guid_t){ { () & 0xff, (() >> 8) & 0xff, (() >> 16) & 0xff, (() >> 24) & 0xff, () & 0xff, (() >> 8) & 0xff, () & 0xff, (() >> 8) & 0xff,  } }
EFI_RESERVED_TYPE 0
EFI_LOADER_CODE 1
EFI_LOADER_DATA 2
EFI_BOOT_SERVICES_CODE 3
EFI_BOOT_SERVICES_DATA 4
EFI_RUNTIME_SERVICES_CODE 5
EFI_RUNTIME_SERVICES_DATA 6
EFI_CONVENTIONAL_MEMORY 7
EFI_UNUSABLE_MEMORY 8
EFI_ACPI_RECLAIM_MEMORY 9
EFI_ACPI_MEMORY_NVS 10
EFI_MEMORY_MAPPED_IO 11
EFI_MEMORY_MAPPED_IO_PORT_SPACE 12
EFI_PAL_CODE 13
EFI_PERSISTENT_MEMORY 14
EFI_MAX_MEMORY_TYPE 15
EFI_MEMORY_UC ((u64)0x0000000000000001ULL)
EFI_MEMORY_WC ((u64)0x0000000000000002ULL)
EFI_MEMORY_WT ((u64)0x0000000000000004ULL)
EFI_MEMORY_WB ((u64)0x0000000000000008ULL)
EFI_MEMORY_UCE ((u64)0x0000000000000010ULL)
EFI_MEMORY_WP ((u64)0x0000000000001000ULL)
EFI_MEMORY_RP ((u64)0x0000000000002000ULL)
EFI_MEMORY_XP ((u64)0x0000000000004000ULL)
EFI_MEMORY_NV ((u64)0x0000000000008000ULL)
EFI_MEMORY_MORE_RELIABLE ((u64)0x0000000000010000ULL)
EFI_MEMORY_RO ((u64)0x0000000000020000ULL)
EFI_MEMORY_RUNTIME ((u64)0x8000000000000000ULL)
EFI_MEMORY_DESCRIPTOR_VERSION 1
EFI_PAGE_SHIFT 12
EFI_PAGE_SIZE (1UL << EFI_PAGE_SHIFT)
EFI_PAGES_MAX (U64_MAX >> EFI_PAGE_SHIFT)
EFI_CAPSULE_PERSIST_ACROSS_RESET 0x00010000
EFI_CAPSULE_POPULATE_SYSTEM_TABLE 0x00020000
EFI_CAPSULE_INITIATE_RESET 0x00040000
EFI_ALLOCATE_ANY_PAGES 0
EFI_ALLOCATE_MAX_ADDRESS 1
EFI_ALLOCATE_ADDRESS 2
EFI_MAX_ALLOCATE_TYPE 3
EFI_TIME_ADJUST_DAYLIGHT 0x1
EFI_TIME_IN_DAYLIGHT 0x2
EFI_UNSPECIFIED_TIMEZONE 0x07ff
EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
EFI_PCI_IO_ATTRIBUTE_IO 0x0100
EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
EFI_RESET_COLD 0
EFI_RESET_WARM 1
EFI_RESET_SHUTDOWN 2
EFI_RUNTIME_SERVICES_SIGNATURE ((u64)0x5652453544e5552ULL)
EFI_RUNTIME_SERVICES_REVISION 0x00010000
NULL_GUID EFI_GUID(0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
MPS_TABLE_GUID EFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
ACPI_TABLE_GUID EFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
ACPI_20_TABLE_GUID EFI_GUID(0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)
SMBIOS_TABLE_GUID EFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
SMBIOS3_TABLE_GUID EFI_GUID(0xf2fd1544, 0x9794, 0x4a2c, 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)
SAL_SYSTEM_TABLE_GUID EFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
HCDP_TABLE_GUID EFI_GUID(0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)
UGA_IO_PROTOCOL_GUID EFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b, 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)
EFI_GLOBAL_VARIABLE_GUID EFI_GUID(0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)
UV_SYSTEM_TABLE_GUID EFI_GUID(0x3b13a7d4, 0x633e, 0x11dd, 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)
LINUX_EFI_CRASH_GUID EFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc, 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)
LOADED_IMAGE_PROTOCOL_GUID EFI_GUID(0x5b1b31a1, 0x9562, 0x11d2, 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID EFI_GUID(0x9042a9de, 0x23dc, 0x4a38, 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)
EFI_UGA_PROTOCOL_GUID EFI_GUID(0x982c298b, 0xf4fa, 0x41cb, 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)
EFI_PCI_IO_PROTOCOL_GUID EFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5, 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)
EFI_FILE_INFO_ID EFI_GUID(0x09576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
EFI_SYSTEM_RESOURCE_TABLE_GUID EFI_GUID(0xb122a263, 0x3661, 0x4f68, 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)
EFI_FILE_SYSTEM_GUID EFI_GUID(0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
DEVICE_TREE_GUID EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5, 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)
EFI_PROPERTIES_TABLE_GUID EFI_GUID(0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)
EFI_RNG_PROTOCOL_GUID EFI_GUID(0x3152bca5, 0xeade, 0x433d, 0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
EFI_RNG_ALGORITHM_RAW EFI_GUID(0xe43176d7, 0xb6e8, 0x4827, 0xb7, 0x84, 0x7f, 0xfd, 0xc4, 0xb6, 0x85, 0x61)
EFI_MEMORY_ATTRIBUTES_TABLE_GUID EFI_GUID(0xdcfa911d, 0x26eb, 0x469f, 0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
EFI_CONSOLE_OUT_DEVICE_GUID EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, 0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
APPLE_PROPERTIES_PROTOCOL_GUID EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb, 0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
EFI_TCG2_PROTOCOL_GUID EFI_GUID(0x607f766c, 0x7455, 0x42be, 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
EFI_IMAGE_SECURITY_DATABASE_GUID EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596, 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
EFI_SHIM_LOCK_GUID EFI_GUID(0x605dab50, 0xe046, 0x4300, 0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
EFI_CERT_SHA256_GUID EFI_GUID(0xc1c41626, 0x504c, 0x4092, 0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28)
EFI_CERT_X509_GUID EFI_GUID(0xa5c059a1, 0x94e4, 0x4aa7, 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72)
EFI_CERT_X509_SHA256_GUID EFI_GUID(0x3bd2a492, 0x96c0, 0x4079, 0xb4, 0x20, 0xfc, 0xf9, 0x8e, 0xf1, 0x03, 0xed)
LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID EFI_GUID(0xe03fc20a, 0x85dc, 0x406e, 0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
LINUX_EFI_LOADER_ENTRY_GUID EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf, 0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
LINUX_EFI_RANDOM_SEED_TABLE_GUID EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2, 0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
LINUX_EFI_TPM_EVENT_LOG_GUID EFI_GUID(0xb7799cb0, 0xeca2, 0x4943, 0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
LINUX_EFI_TPM_FINAL_LOG_GUID EFI_GUID(0x1e2ed096, 0x30e2, 0x4254, 0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)
LINUX_EFI_MEMRESERVE_TABLE_GUID EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5, 0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
LINUX_EFI_MOK_VARIABLE_TABLE_GUID EFI_GUID(0xc451ed2b, 0x9694, 0x45d3, 0xba, 0xba, 0xed, 0x9f, 0x89, 0x88, 0xa3, 0x89)
DELLEMC_EFI_RCI2_TABLE_GUID EFI_GUID(0x2d9f28a2, 0xa886, 0x456a, 0x97, 0xa8, 0xf1, 0x1e, 0xf2, 0x4f, 0xf4, 0x55)
EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
EFI_2_30_SYSTEM_TABLE_REVISION ((2 << 16) | (30))
EFI_2_20_SYSTEM_TABLE_REVISION ((2 << 16) | (20))
EFI_2_10_SYSTEM_TABLE_REVISION ((2 << 16) | (10))
EFI_2_00_SYSTEM_TABLE_REVISION ((2 << 16) | (00))
EFI_1_10_SYSTEM_TABLE_REVISION ((1 << 16) | (10))
EFI_1_02_SYSTEM_TABLE_REVISION ((1 << 16) | (02))
EFI_FILE_MODE_READ 0x0000000000000001
EFI_FILE_MODE_WRITE 0x0000000000000002
EFI_FILE_MODE_CREATE 0x8000000000000000
EFI_PROPERTIES_TABLE_VERSION 0x00010000
EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA 0x1
EFI_INVALID_TABLE_ADDR (~0UL)
efi_early_memdesc_ptr(,,) (efi_memory_desc_t *)((void *)() + (() * ()))
for_each_efi_memory_desc_in_map(,) for (() = ()->map; () && ((void *)() + ()->desc_size) <= ()->map_end; () = (void *)() + ()->desc_size)
for_each_efi_memory_desc() for_each_efi_memory_desc_in_map(&efi.memmap, )
EFI_BOOT 0
EFI_CONFIG_TABLES 2
EFI_RUNTIME_SERVICES 3
EFI_MEMMAP 4
EFI_64BIT 5
EFI_PARAVIRT 6
EFI_ARCH_1 7
EFI_DBG 8
EFI_NX_PE_DATA 9
EFI_MEM_ATTR 10
EFI_SECURE_BOOT 11
EFI_VARIABLE_NON_VOLATILE 0x0000000000000001
EFI_VARIABLE_BOOTSERVICE_ACCESS 0x0000000000000002
EFI_VARIABLE_RUNTIME_ACCESS 0x0000000000000004
EFI_VARIABLE_HARDWARE_ERROR_RECORD 0x0000000000000008
EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS 0x0000000000000010
EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x0000000000000020
EFI_VARIABLE_APPEND_WRITE 0x0000000000000040
EFI_VARIABLE_MASK (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_HARDWARE_ERROR_RECORD | EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS | EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS | EFI_VARIABLE_APPEND_WRITE)
EFI_VARIABLE_GUID_LEN UUID_STRING_LEN
EFI_LOCATE_ALL_HANDLES 0
EFI_LOCATE_BY_REGISTER_NOTIFY 1
EFI_LOCATE_BY_PROTOCOL 2
EFI_DEV_HW 0x01
EFI_DEV_PCI 1
EFI_DEV_PCCARD 2
EFI_DEV_MEM_MAPPED 3
EFI_DEV_VENDOR 4
EFI_DEV_CONTROLLER 5
EFI_DEV_ACPI 0x02
EFI_DEV_BASIC_ACPI 1
EFI_DEV_EXPANDED_ACPI 2
EFI_DEV_MSG 0x03
EFI_DEV_MSG_ATAPI 1
EFI_DEV_MSG_SCSI 2
EFI_DEV_MSG_FC 3
EFI_DEV_MSG_1394 4
EFI_DEV_MSG_USB 5
EFI_DEV_MSG_USB_CLASS 15
EFI_DEV_MSG_I20 6
EFI_DEV_MSG_MAC 11
EFI_DEV_MSG_IPV4 12
EFI_DEV_MSG_IPV6 13
EFI_DEV_MSG_INFINIBAND 9
EFI_DEV_MSG_UART 14
EFI_DEV_MSG_VENDOR 10
EFI_DEV_MEDIA 0x04
EFI_DEV_MEDIA_HARD_DRIVE 1
EFI_DEV_MEDIA_CDROM 2
EFI_DEV_MEDIA_VENDOR 3
EFI_DEV_MEDIA_FILE 4
EFI_DEV_MEDIA_PROTOCOL 5
EFI_DEV_BIOS_BOOT 0x05
EFI_DEV_END_PATH 0x7F
EFI_DEV_END_PATH2 0xFF
EFI_DEV_END_INSTANCE 0x01
EFI_DEV_END_ENTIRE 0xFF
EFI_VAR_NAME_LEN 1024
PIXEL_RGB_RESERVED_8BIT_PER_COLOR 0
PIXEL_BGR_RESERVED_8BIT_PER_COLOR 1
PIXEL_BIT_MASK 2
PIXEL_BLT_ONLY 3
PIXEL_FORMAT_MAX 4
EFIVARS_DATA_SIZE_MAX 1024
efi_call_virt_pointer(,,) \
({ efi_status_t __s; unsigned long __flags; arch_efi_call_virt_setup(); __flags = efi_call_virt_save_flags(); __s = arch_efi_call_virt(, , ); efi_call_virt_check_flags(__flags, __stringify()); arch_efi_call_virt_teardown(); __s; \
})
__efi_call_virt_pointer(,,) \
({ unsigned long __flags; arch_efi_call_virt_setup(); __flags = efi_call_virt_save_flags(); arch_efi_call_virt(, , ); efi_call_virt_check_flags(__flags, __stringify()); arch_efi_call_virt_teardown(); \
})
EFI_RANDOM_SEED_SIZE 32U
EFI_MEMRESERVE_SIZE() (sizeof(struct linux_efi_memreserve) + () * sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
EFI_MEMRESERVE_COUNT() ((() - sizeof(struct linux_efi_memreserve)) / sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
BPF_CLASS() (() & 0x07)
BPF_LD 0x00
BPF_LDX 0x01
BPF_ST 0x02
BPF_STX 0x03
BPF_ALU 0x04
BPF_JMP 0x05
BPF_RET 0x06
BPF_MISC 0x07
BPF_SIZE() (() & 0x18)
BPF_W 0x00
BPF_H 0x08
BPF_B 0x10
BPF_MODE() (() & 0xe0)
BPF_IMM 0x00
BPF_ABS 0x20
BPF_IND 0x40
BPF_MEM 0x60
BPF_LEN 0x80
BPF_MSH 0xa0
BPF_OP() (() & 0xf0)
BPF_ADD 0x00
BPF_SUB 0x10
BPF_MUL 0x20
BPF_DIV 0x30
BPF_OR 0x40
BPF_AND 0x50
BPF_LSH 0x60
BPF_RSH 0x70
BPF_NEG 0x80
BPF_MOD 0x90
BPF_XOR 0xa0
BPF_JA 0x00
BPF_JEQ 0x10
BPF_JGT 0x20
BPF_JGE 0x30
BPF_JSET 0x40
BPF_SRC() (() & 0x08)
BPF_K 0x00
BPF_X 0x08
BPF_MAXINSNS 4096
BPF_JMP32 0x06
BPF_ALU64 0x07
BPF_DW 0x18
BPF_XADD 0xc0
BPF_MOV 0xb0
BPF_ARSH 0xc0
BPF_END 0xd0
BPF_TO_LE 0x00
BPF_TO_BE 0x08
BPF_FROM_LE BPF_TO_LE
BPF_FROM_BE BPF_TO_BE
BPF_JNE 0x50
BPF_JLT 0xa0
BPF_JLE 0xb0
BPF_JSGT 0x60
BPF_JSGE 0x70
BPF_JSLT 0xc0
BPF_JSLE 0xd0
BPF_CALL 0x80
BPF_EXIT 0x90
MAX_BPF_REG __MAX_BPF_REG
MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE
BPF_F_ALLOW_OVERRIDE (1U << 0)
BPF_F_ALLOW_MULTI (1U << 1)
BPF_F_STRICT_ALIGNMENT (1U << 0)
BPF_F_ANY_ALIGNMENT (1U << 1)
BPF_F_TEST_RND_HI32 (1U << 2)
BPF_F_TEST_STATE_FREQ (1U << 3)
BPF_PSEUDO_MAP_FD 1
BPF_PSEUDO_MAP_VALUE 2
BPF_PSEUDO_CALL 1
BPF_ANY 0
BPF_NOEXIST 1
BPF_EXIST 2
BPF_F_LOCK 4
BPF_F_NO_PREALLOC (1U << 0)
BPF_F_NO_COMMON_LRU (1U << 1)
BPF_F_NUMA_NODE (1U << 2)
BPF_OBJ_NAME_LEN 16U
BPF_F_RDONLY (1U << 3)
BPF_F_WRONLY (1U << 4)
BPF_F_STACK_BUILD_ID (1U << 5)
BPF_F_ZERO_SEED (1U << 6)
BPF_F_RDONLY_PROG (1U << 7)
BPF_F_WRONLY_PROG (1U << 8)
BPF_F_CLONE (1U << 9)
BPF_F_QUERY_EFFECTIVE (1U << 0)
BPF_BUILD_ID_SIZE 20
__BPF_FUNC_MAPPER() (unspec), (map_lookup_elem), (map_update_elem), (map_delete_elem), (probe_read), (ktime_get_ns), (trace_printk), (get_prandom_u32), (get_smp_processor_id), (skb_store_bytes), (l3_csum_replace), (l4_csum_replace), (tail_call), (clone_redirect), (get_current_pid_tgid), (get_current_uid_gid), (get_current_comm), (get_cgroup_classid), (skb_vlan_push), (skb_vlan_pop), (skb_get_tunnel_key), (skb_set_tunnel_key), (perf_event_read), (redirect), (get_route_realm), (perf_event_output), (skb_load_bytes), (get_stackid), (csum_diff), (skb_get_tunnel_opt), (skb_set_tunnel_opt), (skb_change_proto), (skb_change_type), (skb_under_cgroup), (get_hash_recalc), (get_current_task), (probe_write_user), (current_task_under_cgroup), (skb_change_tail), (skb_pull_data), (csum_update), (set_hash_invalid), (get_numa_node_id), (skb_change_head), (xdp_adjust_head), (probe_read_str), (get_socket_cookie), (get_socket_uid), (set_hash), (setsockopt), (skb_adjust_room), (redirect_map), (sk_redirect_map), (sock_map_update), (xdp_adjust_meta), (perf_event_read_value), (perf_prog_read_value), (getsockopt), (override_return), (sock_ops_cb_flags_set), (msg_redirect_map), (msg_apply_bytes), (msg_cork_bytes), (msg_pull_data), (bind), (xdp_adjust_tail), (skb_get_xfrm_state), (get_stack), (skb_load_bytes_relative), (fib_lookup), (sock_hash_update), (msg_redirect_hash), (sk_redirect_hash), (lwt_push_encap), (lwt_seg6_store_bytes), (lwt_seg6_adjust_srh), (lwt_seg6_action), (rc_repeat), (rc_keydown), (skb_cgroup_id), (get_current_cgroup_id), (get_local_storage), (sk_select_reuseport), (skb_ancestor_cgroup_id), (sk_lookup_tcp), (sk_lookup_udp), (sk_release), (map_push_elem), (map_pop_elem), (map_peek_elem), (msg_push_data), (msg_pop_data), (rc_pointer_rel), (spin_lock), (spin_unlock), (sk_fullsock), (tcp_sock), (skb_ecn_set_ce), (get_listener_sock), (skc_lookup_tcp), (tcp_check_syncookie), (sysctl_get_name), (sysctl_get_current_value), (sysctl_get_new_value), (sysctl_set_new_value), (strtol), (strtoul), (sk_storage_get), (sk_storage_delete), (send_signal), (tcp_gen_syncookie),
__BPF_ENUM_FN (x) BPF_FUNC_ ## x
BPF_F_RECOMPUTE_CSUM (1ULL << 0)
BPF_F_INVALIDATE_HASH (1ULL << 1)
BPF_F_HDR_FIELD_MASK 0xfULL
BPF_F_PSEUDO_HDR (1ULL << 4)
BPF_F_MARK_MANGLED_0 (1ULL << 5)
BPF_F_MARK_ENFORCE (1ULL << 6)
BPF_F_INGRESS (1ULL << 0)
BPF_F_TUNINFO_IPV6 (1ULL << 0)
BPF_F_SKIP_FIELD_MASK 0xffULL
BPF_F_USER_STACK (1ULL << 8)
BPF_F_FAST_STACK_CMP (1ULL << 9)
BPF_F_REUSE_STACKID (1ULL << 10)
BPF_F_USER_BUILD_ID (1ULL << 11)
BPF_F_ZERO_CSUM_TX (1ULL << 1)
BPF_F_DONT_FRAGMENT (1ULL << 2)
BPF_F_SEQ_NUMBER (1ULL << 3)
BPF_F_INDEX_MASK 0xffffffffULL
BPF_F_CURRENT_CPU BPF_F_INDEX_MASK
BPF_F_CTXLEN_MASK (0xfffffULL << 32)
BPF_F_CURRENT_NETNS (-1L)
BPF_F_ADJ_ROOM_FIXED_GSO (1ULL << 0)
BPF_ADJ_ROOM_ENCAP_L2_MASK 0xff
BPF_ADJ_ROOM_ENCAP_L2_SHIFT 56
BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 (1ULL << 1)
BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 (1ULL << 2)
BPF_F_ADJ_ROOM_ENCAP_L4_GRE (1ULL << 3)
BPF_F_ADJ_ROOM_ENCAP_L4_UDP (1ULL << 4)
BPF_F_ADJ_ROOM_ENCAP_L2() (((__u64) & BPF_ADJ_ROOM_ENCAP_L2_MASK) << BPF_ADJ_ROOM_ENCAP_L2_SHIFT)
BPF_F_SYSCTL_BASE_NAME (1ULL << 0)
BPF_SK_STORAGE_GET_F_CREATE (1ULL << 0)
__bpf_md_ptr(,) union {  ; __u64 :64; \
} __attribute__((aligned(8)))
XDP_PACKET_HEADROOM 256
BPF_TAG_SIZE 8
BPF_SOCK_OPS_RTO_CB_FLAG (1<<0)
BPF_SOCK_OPS_RETRANS_CB_FLAG (1<<1)
BPF_SOCK_OPS_STATE_CB_FLAG (1<<2)
BPF_SOCK_OPS_RTT_CB_FLAG (1<<3)
BPF_SOCK_OPS_ALL_CB_FLAGS 0xF
TCP_BPF_IW 1001
TCP_BPF_SNDCWND_CLAMP 1002
BPF_DEVCG_ACC_MKNOD (1ULL << 0)
BPF_DEVCG_ACC_READ (1ULL << 1)
BPF_DEVCG_ACC_WRITE (1ULL << 2)
BPF_DEVCG_DEV_BLOCK (1ULL << 0)
BPF_DEVCG_DEV_CHAR (1ULL << 1)
BPF_FIB_LOOKUP_DIRECT (1U << 0)
BPF_FIB_LOOKUP_OUTPUT (1U << 1)
BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG (1U << 0)
BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL (1U << 1)
BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP (1U << 2)
BPF_LINE_INFO_LINE_NUM() (() >> 10)
BPF_LINE_INFO_LINE_COL() (() & 0x3ff)
FDPUT_FPUT 1
FDPUT_POS_UNLOCK 2
MAX_BPF_CGROUP_STORAGE_TYPE __BPF_CGROUP_STORAGE_MAX
BPF_COMPLEXITY_LIMIT_INSNS 1000000
MAX_TAIL_CALL_CNT 32
BPF_F_ACCESS_MASK (BPF_F_RDONLY | BPF_F_RDONLY_PROG | BPF_F_WRONLY | BPF_F_WRONLY_PROG)
BPF_MAP_CAN_READ BIT(0)
BPF_MAP_CAN_WRITE BIT(1)
__BPF_PROG_RUN_ARRAY(,,,,) ({ struct bpf_prog_array_item *_item; struct bpf_prog *_prog; struct bpf_prog_array *_array; u32 _ret = 1; preempt_disable(); rcu_read_lock(); _array = rcu_dereference(); if (unlikely( && !_array)) goto _out; _item = &_array->items[0]; while ((_prog = READ_ONCE(_item->prog))) { if () bpf_cgroup_storage_set(_item->cgroup_storage); _ret &= (_prog, ); _item++; } _out: rcu_read_unlock(); preempt_enable(); _ret; })
BPF_PROG_CGROUP_INET_EGRESS_RUN_ARRAY(,,) ({ struct bpf_prog_array_item *_item; struct bpf_prog *_prog; struct bpf_prog_array *_array; u32 ret; u32 _ret = 1; u32 _cn = 0; preempt_disable(); rcu_read_lock(); _array = rcu_dereference(); _item = &_array->items[0]; while ((_prog = READ_ONCE(_item->prog))) { bpf_cgroup_storage_set(_item->cgroup_storage); ret = (_prog, ); _ret &= (ret & 1); _cn |= (ret & 2); _item++; } rcu_read_unlock(); preempt_enable(); if (_ret) _ret = (_cn ? NET_XMIT_CN : NET_XMIT_SUCCESS); else _ret = (_cn ? NET_XMIT_DROP : -EPERM); _ret; })
BPF_PROG_RUN_ARRAY(,,) __BPF_PROG_RUN_ARRAY(, , , false, true)
BPF_PROG_RUN_ARRAY_CHECK(,,) __BPF_PROG_RUN_ARRAY(, , , true, false)
BPF_PROG_TYPE (_id, _name) extern const struct bpf_prog_ops _name ## _prog_ops; extern const struct bpf_verifier_ops _name ## _verifier_ops;
BPF_MAP_TYPE (_id, _ops) extern const struct bpf_map_ops _ops;
USB_DIR_OUT 0
USB_DIR_IN 0x80
USB_TYPE_MASK (0x03 << 5)
USB_TYPE_STANDARD (0x00 << 5)
USB_TYPE_CLASS (0x01 << 5)
USB_TYPE_VENDOR (0x02 << 5)
USB_TYPE_RESERVED (0x03 << 5)
USB_RECIP_MASK 0x1f
USB_RECIP_DEVICE 0x00
USB_RECIP_INTERFACE 0x01
USB_RECIP_ENDPOINT 0x02
USB_RECIP_OTHER 0x03
USB_RECIP_PORT 0x04
USB_RECIP_RPIPE 0x05
USB_REQ_GET_STATUS 0x00
USB_REQ_CLEAR_FEATURE 0x01
USB_REQ_SET_FEATURE 0x03
USB_REQ_SET_ADDRESS 0x05
USB_REQ_GET_DESCRIPTOR 0x06
USB_REQ_SET_DESCRIPTOR 0x07
USB_REQ_GET_CONFIGURATION 0x08
USB_REQ_SET_CONFIGURATION 0x09
USB_REQ_GET_INTERFACE 0x0A
USB_REQ_SET_INTERFACE 0x0B
USB_REQ_SYNCH_FRAME 0x0C
USB_REQ_SET_SEL 0x30
USB_REQ_SET_ISOCH_DELAY 0x31
USB_REQ_SET_ENCRYPTION 0x0D
USB_REQ_GET_ENCRYPTION 0x0E
USB_REQ_RPIPE_ABORT 0x0E
USB_REQ_SET_HANDSHAKE 0x0F
USB_REQ_RPIPE_RESET 0x0F
USB_REQ_GET_HANDSHAKE 0x10
USB_REQ_SET_CONNECTION 0x11
USB_REQ_SET_SECURITY_DATA 0x12
USB_REQ_GET_SECURITY_DATA 0x13
USB_REQ_SET_WUSB_DATA 0x14
USB_REQ_LOOPBACK_DATA_WRITE 0x15
USB_REQ_LOOPBACK_DATA_READ 0x16
USB_REQ_SET_INTERFACE_DS 0x17
USB_REQ_GET_PARTNER_PDO 20
USB_REQ_GET_BATTERY_STATUS 21
USB_REQ_SET_PDO 22
USB_REQ_GET_VDM 23
USB_REQ_SEND_VDM 24
USB_DEVICE_SELF_POWERED 0
USB_DEVICE_REMOTE_WAKEUP 1
USB_DEVICE_TEST_MODE 2
USB_DEVICE_BATTERY 2
USB_DEVICE_B_HNP_ENABLE 3
USB_DEVICE_WUSB_DEVICE 3
USB_DEVICE_A_HNP_SUPPORT 4
USB_DEVICE_A_ALT_HNP_SUPPORT 5
USB_DEVICE_DEBUG_MODE 6
TEST_J 1
TEST_K 2
TEST_SE0_NAK 3
TEST_PACKET 4
TEST_FORCE_EN 5
USB_STATUS_TYPE_STANDARD 0
USB_STATUS_TYPE_PTM 1
USB_DEVICE_U1_ENABLE 48
USB_DEVICE_U2_ENABLE 49
USB_DEVICE_LTM_ENABLE 50
USB_INTRF_FUNC_SUSPEND 0
USB_INTR_FUNC_SUSPEND_OPT_MASK 0xFF00
USB_INTRF_FUNC_SUSPEND_LP (1 << (8 + 0))
USB_INTRF_FUNC_SUSPEND_RW (1 << (8 + 1))
USB_INTRF_STAT_FUNC_RW_CAP 1
USB_INTRF_STAT_FUNC_RW 2
USB_ENDPOINT_HALT 0
USB_DEV_STAT_U1_ENABLED 2
USB_DEV_STAT_U2_ENABLED 3
USB_DEV_STAT_LTM_ENABLED 4
USB_DEVICE_BATTERY_WAKE_MASK 40
USB_DEVICE_OS_IS_PD_AWARE 41
USB_DEVICE_POLICY_MODE 42
USB_PORT_PR_SWAP 43
USB_PORT_GOTO_MIN 44
USB_PORT_RETURN_POWER 45
USB_PORT_ACCEPT_PD_REQUEST 46
USB_PORT_REJECT_PD_REQUEST 47
USB_PORT_PORT_PD_RESET 48
USB_PORT_C_PORT_PD_CHANGE 49
USB_PORT_CABLE_PD_RESET 50
USB_DEVICE_CHARGING_POLICY 54
USB_DT_DEVICE 0x01
USB_DT_CONFIG 0x02
USB_DT_STRING 0x03
USB_DT_INTERFACE 0x04
USB_DT_ENDPOINT 0x05
USB_DT_DEVICE_QUALIFIER 0x06
USB_DT_OTHER_SPEED_CONFIG 0x07
USB_DT_INTERFACE_POWER 0x08
USB_DT_OTG 0x09
USB_DT_DEBUG 0x0a
USB_DT_INTERFACE_ASSOCIATION 0x0b
USB_DT_SECURITY 0x0c
USB_DT_KEY 0x0d
USB_DT_ENCRYPTION_TYPE 0x0e
USB_DT_BOS 0x0f
USB_DT_DEVICE_CAPABILITY 0x10
USB_DT_WIRELESS_ENDPOINT_COMP 0x11
USB_DT_WIRE_ADAPTER 0x21
USB_DT_RPIPE 0x22
USB_DT_CS_RADIO_CONTROL 0x23
USB_DT_PIPE_USAGE 0x24
USB_DT_SS_ENDPOINT_COMP 0x30
USB_DT_SSP_ISOC_ENDPOINT_COMP 0x31
USB_DT_CS_DEVICE (USB_TYPE_CLASS | USB_DT_DEVICE)
USB_DT_CS_CONFIG (USB_TYPE_CLASS | USB_DT_CONFIG)
USB_DT_CS_STRING (USB_TYPE_CLASS | USB_DT_STRING)
USB_DT_CS_INTERFACE (USB_TYPE_CLASS | USB_DT_INTERFACE)
USB_DT_CS_ENDPOINT (USB_TYPE_CLASS | USB_DT_ENDPOINT)
USB_DT_DEVICE_SIZE 18
USB_CLASS_PER_INTERFACE 0
USB_CLASS_AUDIO 1
USB_CLASS_COMM 2
USB_CLASS_HID 3
USB_CLASS_PHYSICAL 5
USB_CLASS_STILL_IMAGE 6
USB_CLASS_PRINTER 7
USB_CLASS_MASS_STORAGE 8
USB_CLASS_HUB 9
USB_CLASS_CDC_DATA 0x0a
USB_CLASS_CSCID 0x0b
USB_CLASS_CONTENT_SEC 0x0d
USB_CLASS_VIDEO 0x0e
USB_CLASS_WIRELESS_CONTROLLER 0xe0
USB_CLASS_MISC 0xef
USB_CLASS_APP_SPEC 0xfe
USB_CLASS_VENDOR_SPEC 0xff
USB_SUBCLASS_VENDOR_SPEC 0xff
USB_DT_CONFIG_SIZE 9
USB_CONFIG_ATT_ONE (1 << 7)
USB_CONFIG_ATT_SELFPOWER (1 << 6)
USB_CONFIG_ATT_WAKEUP (1 << 5)
USB_CONFIG_ATT_BATTERY (1 << 4)
USB_MAX_STRING_LEN 126
USB_DT_INTERFACE_SIZE 9
USB_DT_ENDPOINT_SIZE 7
USB_DT_ENDPOINT_AUDIO_SIZE 9
USB_ENDPOINT_NUMBER_MASK 0x0f
USB_ENDPOINT_DIR_MASK 0x80
USB_ENDPOINT_XFERTYPE_MASK 0x03
USB_ENDPOINT_XFER_CONTROL 0
USB_ENDPOINT_XFER_ISOC 1
USB_ENDPOINT_XFER_BULK 2
USB_ENDPOINT_XFER_INT 3
USB_ENDPOINT_MAX_ADJUSTABLE 0x80
USB_ENDPOINT_MAXP_MASK 0x07ff
USB_EP_MAXP_MULT_SHIFT 11
USB_EP_MAXP_MULT_MASK (3 << USB_EP_MAXP_MULT_SHIFT)
USB_EP_MAXP_MULT() ((() & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)
USB_ENDPOINT_INTRTYPE 0x30
USB_ENDPOINT_INTR_PERIODIC (0 << 4)
USB_ENDPOINT_INTR_NOTIFICATION (1 << 4)
USB_ENDPOINT_SYNCTYPE 0x0c
USB_ENDPOINT_SYNC_NONE (0 << 2)
USB_ENDPOINT_SYNC_ASYNC (1 << 2)
USB_ENDPOINT_SYNC_ADAPTIVE (2 << 2)
USB_ENDPOINT_SYNC_SYNC (3 << 2)
USB_ENDPOINT_USAGE_MASK 0x30
USB_ENDPOINT_USAGE_DATA 0x00
USB_ENDPOINT_USAGE_FEEDBACK 0x10
USB_ENDPOINT_USAGE_IMPLICIT_FB 0x20
USB_DT_SSP_ISOC_EP_COMP_SIZE 8
USB_DT_SS_EP_COMP_SIZE 6
USB_SS_MULT() (1 + (() & 0x3))
USB_SS_SSP_ISOC_COMP() (() & (1 << 7))
USB_OTG_SRP (1 << 0)
USB_OTG_HNP (1 << 1)
USB_OTG_ADP (1 << 2)
OTG_STS_SELECTOR 0xF000
USB_DT_INTERFACE_ASSOCIATION_SIZE 8
USB_ENC_TYPE_UNSECURE 0
USB_ENC_TYPE_WIRED 1
USB_ENC_TYPE_CCM_1 2
USB_ENC_TYPE_RSA_1 3
USB_DT_BOS_SIZE 5
USB_CAP_TYPE_WIRELESS_USB 1
USB_WIRELESS_P2P_DRD (1 << 1)
USB_WIRELESS_BEACON_MASK (3 << 2)
USB_WIRELESS_BEACON_SELF (1 << 2)
USB_WIRELESS_BEACON_DIRECTED (2 << 2)
USB_WIRELESS_BEACON_NONE (3 << 2)
USB_WIRELESS_PHY_53 (1 << 0)
USB_WIRELESS_PHY_80 (1 << 1)
USB_WIRELESS_PHY_107 (1 << 2)
USB_WIRELESS_PHY_160 (1 << 3)
USB_WIRELESS_PHY_200 (1 << 4)
USB_WIRELESS_PHY_320 (1 << 5)
USB_WIRELESS_PHY_400 (1 << 6)
USB_WIRELESS_PHY_480 (1 << 7)
USB_DT_USB_WIRELESS_CAP_SIZE 11
USB_CAP_TYPE_EXT 2
USB_LPM_SUPPORT (1 << 1)
USB_BESL_SUPPORT (1 << 2)
USB_BESL_BASELINE_VALID (1 << 3)
USB_BESL_DEEP_VALID (1 << 4)
USB_SET_BESL_BASELINE() ((() & 0xf) << 8)
USB_SET_BESL_DEEP() ((() & 0xf) << 12)
USB_GET_BESL_BASELINE() ((() & (0xf << 8)) >> 8)
USB_GET_BESL_DEEP() ((() & (0xf << 12)) >> 12)
USB_DT_USB_EXT_CAP_SIZE 7
USB_SS_CAP_TYPE 3
USB_LTM_SUPPORT (1 << 1)
USB_LOW_SPEED_OPERATION (1)
USB_FULL_SPEED_OPERATION (1 << 1)
USB_HIGH_SPEED_OPERATION (1 << 2)
USB_5GBPS_OPERATION (1 << 3)
USB_DT_USB_SS_CAP_SIZE 10
CONTAINER_ID_TYPE 4
USB_DT_USB_SS_CONTN_ID_SIZE 20
USB_SSP_CAP_TYPE 0xa
USB_SSP_SUBLINK_SPEED_ATTRIBS (0x1f << 0)
USB_SSP_SUBLINK_SPEED_IDS (0xf << 5)
USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID (0xf)
USB_SSP_MIN_RX_LANE_COUNT (0xf << 8)
USB_SSP_MIN_TX_LANE_COUNT (0xf << 12)
USB_SSP_SUBLINK_SPEED_SSID (0xf)
USB_SSP_SUBLINK_SPEED_LSE (0x3 << 4)
USB_SSP_SUBLINK_SPEED_ST (0x3 << 6)
USB_SSP_SUBLINK_SPEED_RSVD (0x3f << 8)
USB_SSP_SUBLINK_SPEED_LP (0x3 << 14)
USB_SSP_SUBLINK_SPEED_LSM (0xff << 16)
USB_PD_POWER_DELIVERY_CAPABILITY 0x06
USB_PD_BATTERY_INFO_CAPABILITY 0x07
USB_PD_PD_CONSUMER_PORT_CAPABILITY 0x08
USB_PD_PD_PROVIDER_PORT_CAPABILITY 0x09
USB_PD_CAP_BATTERY_CHARGING (1 << 1)
USB_PD_CAP_USB_PD (1 << 2)
USB_PD_CAP_PROVIDER (1 << 3)
USB_PD_CAP_CONSUMER (1 << 4)
USB_PD_CAP_CHARGING_POLICY (1 << 5)
USB_PD_CAP_TYPE_C_CURRENT (1 << 6)
USB_PD_CAP_PWR_AC (1 << 8)
USB_PD_CAP_PWR_BAT (1 << 9)
USB_PD_CAP_PWR_USE_V_BUS (1 << 14)
USB_PD_CAP_CONSUMER_BC (1 << 0)
USB_PD_CAP_CONSUMER_PD (1 << 1)
USB_PD_CAP_CONSUMER_TYPE_C (1 << 2)
USB_PD_CAP_CONSUMER_UNKNOWN_PEAK_POWER_TIME 0xffff
USB_PD_CAP_PROVIDER_BC (1 << 0)
USB_PD_CAP_PROVIDER_PD (1 << 1)
USB_PD_CAP_PROVIDER_TYPE_C (1 << 2)
USB_PTM_CAP_TYPE 0xb
USB_DT_USB_PTM_ID_SIZE 3
USB_DT_USB_SSP_CAP_SIZE() (12 + ( + 1) * 4)
USB_ENDPOINT_SWITCH_MASK 0x03
USB_ENDPOINT_SWITCH_NO 0
USB_ENDPOINT_SWITCH_SWITCH 1
USB_ENDPOINT_SWITCH_SCALE 2
USB3_LPM_DISABLED 0x0
USB3_LPM_U1_MAX_TIMEOUT 0x7F
USB3_LPM_U2_MAX_TIMEOUT 0xFE
USB3_LPM_DEVICE_INITIATED 0xFF
USB3_LPM_MAX_U1_SEL_PEL 0xFF
USB3_LPM_MAX_U2_SEL_PEL 0xFFFF
USB_SELF_POWER_VBUS_MAX_DRAW 100
USB_MAJOR 180
USB_DEVICE_MAJOR 189
udelay() ({ if (__builtin_constant_p()) { if (() / 20000 >= 1) __bad_udelay(); else __const_udelay(() * 0x10c7ul); } else { __udelay(); } })
ndelay() ({ if (__builtin_constant_p()) { if (() / 20000 >= 1) __bad_ndelay(); else __const_udelay(() * 5ul); } else { __ndelay(); } })
MAX_UDELAY_MS 5
mdelay() ( (__builtin_constant_p() && ()<=MAX_UDELAY_MS) ? udelay(()*1000) : ({unsigned long __ms=(); while (__ms--) udelay(1000);}))
RPM_ASYNC 0x01
RPM_NOWAIT 0x02
RPM_GET_PUT 0x04
RPM_AUTO 0x08
to_usb_interface() container_of(, struct usb_interface, dev)
USB_MAXENDPOINTS 30
USB_MAXINTERFACES 32
USB_MAXIADS (USB_MAXINTERFACES/2)
USB_RESUME_TIMEOUT 40
ref_to_usb_interface_cache() container_of(, struct usb_interface_cache, ref)
altsetting_to_usb_interface_cache() container_of(, struct usb_interface_cache, altsetting[0])
usb_get_extra_descriptor(,,) __usb_get_extra_descriptor(()->extra, ()->extralen, , (void **), sizeof(**()))
USB_PORT_QUIRK_OLD_SCHEME BIT(0)
USB_PORT_QUIRK_FAST_ENUM BIT(1)
to_usb_device() container_of(, struct usb_device, dev)
usb_hub_for_each_child(,,) for ( = 1,  = usb_hub_find_child(, );  <= ->maxchild;  = usb_hub_find_child(, ++)) if (!) continue; else
usb_lock_device() device_lock(&()->dev)
usb_unlock_device() device_unlock(&()->dev)
usb_lock_device_interruptible() device_lock_interruptible(&()->dev)
usb_trylock_device() device_trylock(&()->dev)
USB_DEVICE_ID_MATCH_DEVICE (USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
USB_DEVICE_ID_MATCH_DEV_RANGE (USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION (USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
USB_DEVICE_ID_MATCH_DEV_INFO (USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
USB_DEVICE_ID_MATCH_INT_INFO (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
USB_DEVICE(,) .match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (), .idProduct = ()
USB_DEVICE_VER(,,,) .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (), .idProduct = (), .bcdDevice_lo = (), .bcdDevice_hi = ()
USB_DEVICE_INTERFACE_CLASS(,,) .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_CLASS, .idVendor = (), .idProduct = (), .bInterfaceClass = ()
USB_DEVICE_INTERFACE_PROTOCOL(,,) .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_PROTOCOL, .idVendor = (), .idProduct = (), .bInterfaceProtocol = ()
USB_DEVICE_INTERFACE_NUMBER(,,) .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_NUMBER, .idVendor = (), .idProduct = (), .bInterfaceNumber = ()
USB_DEVICE_INFO(,,) .match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (), .bDeviceSubClass = (), .bDeviceProtocol = ()
USB_INTERFACE_INFO(,,) .match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (), .bInterfaceSubClass = (), .bInterfaceProtocol = ()
USB_DEVICE_AND_INTERFACE_INFO(,,,,) .match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (), .idProduct = (), .bInterfaceClass = (), .bInterfaceSubClass = (), .bInterfaceProtocol = ()
USB_VENDOR_AND_INTERFACE_INFO(,,,) .match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_VENDOR, .idVendor = (), .bInterfaceClass = (), .bInterfaceSubClass = (), .bInterfaceProtocol = ()
to_usb_driver() container_of(, struct usb_driver, drvwrap.driver)
to_usb_device_driver() container_of(, struct usb_device_driver, drvwrap.driver)
usb_register() usb_register_driver(, THIS_MODULE, KBUILD_MODNAME)
module_usb_driver() module_driver(, usb_register, usb_deregister)
URB_SHORT_NOT_OK 0x0001
URB_ISO_ASAP 0x0002
URB_NO_TRANSFER_DMA_MAP 0x0004
URB_ZERO_PACKET 0x0040
URB_NO_INTERRUPT 0x0080
URB_FREE_BUFFER 0x0100
URB_DIR_IN 0x0200
URB_DIR_OUT 0
URB_DIR_MASK URB_DIR_IN
URB_DMA_MAP_SINGLE 0x00010000
URB_DMA_MAP_PAGE 0x00020000
URB_DMA_MAP_SG 0x00040000
URB_MAP_LOCAL 0x00080000
URB_SETUP_MAP_SINGLE 0x00100000
URB_SETUP_MAP_LOCAL 0x00200000
URB_DMA_SG_COMBINED 0x00400000
URB_ALIGNED_TEMP_BUFFER 0x00800000
usb_put_urb usb_free_urb
usb_unblock_urb usb_unpoison_urb
USB_CTRL_GET_TIMEOUT 5000
USB_CTRL_SET_TIMEOUT 5000
PIPE_ISOCHRONOUS 0
PIPE_INTERRUPT 1
PIPE_CONTROL 2
PIPE_BULK 3
usb_pipein() (() & USB_DIR_IN)
usb_pipeout() (!usb_pipein())
usb_pipedevice() ((() >> 8) & 0x7f)
usb_pipeendpoint() ((() >> 15) & 0xf)
usb_pipetype() ((() >> 30) & 3)
usb_pipeisoc() (usb_pipetype(()) == PIPE_ISOCHRONOUS)
usb_pipeint() (usb_pipetype(()) == PIPE_INTERRUPT)
usb_pipecontrol() (usb_pipetype(()) == PIPE_CONTROL)
usb_pipebulk() (usb_pipetype(()) == PIPE_BULK)
usb_sndctrlpipe(,) ((PIPE_CONTROL << 30) | __create_pipe(, ))
usb_rcvctrlpipe(,) ((PIPE_CONTROL << 30) | __create_pipe(, ) | USB_DIR_IN)
usb_sndisocpipe(,) ((PIPE_ISOCHRONOUS << 30) | __create_pipe(, ))
usb_rcvisocpipe(,) ((PIPE_ISOCHRONOUS << 30) | __create_pipe(, ) | USB_DIR_IN)
usb_sndbulkpipe(,) ((PIPE_BULK << 30) | __create_pipe(, ))
usb_rcvbulkpipe(,) ((PIPE_BULK << 30) | __create_pipe(, ) | USB_DIR_IN)
usb_sndintpipe(,) ((PIPE_INTERRUPT << 30) | __create_pipe(, ))
usb_rcvintpipe(,) ((PIPE_INTERRUPT << 30) | __create_pipe(, ) | USB_DIR_IN)
USB_DEVICE_ADD 0x0001
USB_DEVICE_REMOVE 0x0002
USB_BUS_ADD 0x0003
USB_BUS_REMOVE 0x0004
UNNAMED_MAJOR 0
MEM_MAJOR 1
RAMDISK_MAJOR 1
FLOPPY_MAJOR 2
PTY_MASTER_MAJOR 2
IDE0_MAJOR 3
HD_MAJOR IDE0_MAJOR
PTY_SLAVE_MAJOR 3
TTY_MAJOR 4
TTYAUX_MAJOR 5
LP_MAJOR 6
VCS_MAJOR 7
LOOP_MAJOR 7
SCSI_DISK0_MAJOR 8
SCSI_TAPE_MAJOR 9
MD_MAJOR 9
MISC_MAJOR 10
SCSI_CDROM_MAJOR 11
MUX_MAJOR 11
XT_DISK_MAJOR 13
INPUT_MAJOR 13
SOUND_MAJOR 14
CDU31A_CDROM_MAJOR 15
JOYSTICK_MAJOR 15
GOLDSTAR_CDROM_MAJOR 16
OPTICS_CDROM_MAJOR 17
SANYO_CDROM_MAJOR 18
CYCLADES_MAJOR 19
CYCLADESAUX_MAJOR 20
MITSUMI_X_CDROM_MAJOR 20
MFM_ACORN_MAJOR 21
SCSI_GENERIC_MAJOR 21
IDE1_MAJOR 22
DIGICU_MAJOR 22
DIGI_MAJOR 23
MITSUMI_CDROM_MAJOR 23
CDU535_CDROM_MAJOR 24
STL_SERIALMAJOR 24
MATSUSHITA_CDROM_MAJOR 25
STL_CALLOUTMAJOR 25
MATSUSHITA_CDROM2_MAJOR 26
QIC117_TAPE_MAJOR 27
MATSUSHITA_CDROM3_MAJOR 27
MATSUSHITA_CDROM4_MAJOR 28
STL_SIOMEMMAJOR 28
ACSI_MAJOR 28
AZTECH_CDROM_MAJOR 29
FB_MAJOR 29
MTD_BLOCK_MAJOR 31
CM206_CDROM_MAJOR 32
IDE2_MAJOR 33
IDE3_MAJOR 34
Z8530_MAJOR 34
XPRAM_MAJOR 35
NETLINK_MAJOR 36
PS2ESDI_MAJOR 36
IDETAPE_MAJOR 37
Z2RAM_MAJOR 37
APBLOCK_MAJOR 38
DDV_MAJOR 39
NBD_MAJOR 43
RISCOM8_NORMAL_MAJOR 48
DAC960_MAJOR 48
RISCOM8_CALLOUT_MAJOR 49
MKISS_MAJOR 55
DSP56K_MAJOR 55
IDE4_MAJOR 56
IDE5_MAJOR 57
SCSI_DISK1_MAJOR 65
SCSI_DISK2_MAJOR 66
SCSI_DISK3_MAJOR 67
SCSI_DISK4_MAJOR 68
SCSI_DISK5_MAJOR 69
SCSI_DISK6_MAJOR 70
SCSI_DISK7_MAJOR 71
COMPAQ_SMART2_MAJOR 72
COMPAQ_SMART2_MAJOR1 73
COMPAQ_SMART2_MAJOR2 74
COMPAQ_SMART2_MAJOR3 75
COMPAQ_SMART2_MAJOR4 76
COMPAQ_SMART2_MAJOR5 77
COMPAQ_SMART2_MAJOR6 78
COMPAQ_SMART2_MAJOR7 79
SPECIALIX_NORMAL_MAJOR 75
SPECIALIX_CALLOUT_MAJOR 76
AURORA_MAJOR 79
I2O_MAJOR 80
SHMIQ_MAJOR 85
SCSI_CHANGER_MAJOR 86
IDE6_MAJOR 88
IDE7_MAJOR 89
IDE8_MAJOR 90
MTD_CHAR_MAJOR 90
IDE9_MAJOR 91
DASD_MAJOR 94
MDISK_MAJOR 95
UBD_MAJOR 98
PP_MAJOR 99
JSFD_MAJOR 99
PHONE_MAJOR 100
COMPAQ_CISS_MAJOR 104
COMPAQ_CISS_MAJOR1 105
COMPAQ_CISS_MAJOR2 106
COMPAQ_CISS_MAJOR3 107
COMPAQ_CISS_MAJOR4 108
COMPAQ_CISS_MAJOR5 109
COMPAQ_CISS_MAJOR6 110
COMPAQ_CISS_MAJOR7 111
VIODASD_MAJOR 112
VIOCD_MAJOR 113
ATARAID_MAJOR 114
SCSI_DISK8_MAJOR 128
SCSI_DISK9_MAJOR 129
SCSI_DISK10_MAJOR 130
SCSI_DISK11_MAJOR 131
SCSI_DISK12_MAJOR 132
SCSI_DISK13_MAJOR 133
SCSI_DISK14_MAJOR 134
SCSI_DISK15_MAJOR 135
UNIX98_PTY_MASTER_MAJOR 128
UNIX98_PTY_MAJOR_COUNT 8
UNIX98_PTY_SLAVE_MAJOR (UNIX98_PTY_MASTER_MAJOR+UNIX98_PTY_MAJOR_COUNT)
DRBD_MAJOR 147
RTF_MAJOR 150
RAW_MAJOR 162
USB_ACM_MAJOR 166
USB_ACM_AUX_MAJOR 167
USB_CHAR_MAJOR 180
MMC_BLOCK_MAJOR 179
VXVM_MAJOR 199
VXSPEC_MAJOR 200
VXDMP_MAJOR 201
XENVBD_MAJOR 202
MSR_MAJOR 202
CPUID_MAJOR 203
OSST_MAJOR 206
IBM_TTY3270_MAJOR 227
IBM_FS3270_MAJOR 228
VIOTAPE_MAJOR 230
BLOCK_EXT_MAJOR 259
SCSI_OSD_MAJOR 260
page_ref_tracepoint_active() false
PGMAP_ALTMAP_VALID (1 << 0)
SZ_1 0x00000001
SZ_2 0x00000002
SZ_4 0x00000004
SZ_8 0x00000008
SZ_16 0x00000010
SZ_32 0x00000020
SZ_64 0x00000040
SZ_128 0x00000080
SZ_256 0x00000100
SZ_512 0x00000200
SZ_1K 0x00000400
SZ_2K 0x00000800
SZ_4K 0x00001000
SZ_8K 0x00002000
SZ_16K 0x00004000
SZ_32K 0x00008000
SZ_64K 0x00010000
SZ_128K 0x00020000
SZ_256K 0x00040000
SZ_512K 0x00080000
SZ_1M 0x00100000
SZ_2M 0x00200000
SZ_4M 0x00400000
SZ_8M 0x00800000
SZ_16M 0x01000000
SZ_32M 0x02000000
SZ_64M 0x04000000
SZ_128M 0x08000000
SZ_256M 0x10000000
SZ_512M 0x20000000
SZ_1G 0x40000000
SZ_2G 0x80000000
SZ_4G _AC(0x100000000, ULL)
SZ_64T _AC(0x400000000000, ULL)
pgprot_noncached() ((boot_cpu_data.x86 > 3) ? (__pgprot(pgprot_val() | cachemode2protval(_PAGE_CACHE_MODE_UC_MINUS))) : ())
pgprot_encrypted() __pgprot(__sme_set(pgprot_val()))
pgprot_decrypted() __pgprot(__sme_clr(pgprot_val()))
XFEATURE_MASK_EXTEND (~(XFEATURE_MASK_FPSSE | (1ULL << 63)))
XSTATE_CPUID 0x0000000d
FXSAVE_SIZE 512
XSAVE_HDR_SIZE 64
XSAVE_HDR_OFFSET FXSAVE_SIZE
XSAVE_YMM_SIZE 256
XSAVE_YMM_OFFSET (XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET)
XFEATURE_MASK_SUPERVISOR (XFEATURE_MASK_PT)
XCNTXT_MASK (XFEATURE_MASK_FP | XFEATURE_MASK_SSE | XFEATURE_MASK_YMM | XFEATURE_MASK_OPMASK | XFEATURE_MASK_ZMM_Hi256 | XFEATURE_MASK_Hi16_ZMM | XFEATURE_MASK_PKRU | XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR)
REX_PREFIX "0x48, "
KFPU_387 _BITUL(0)
KFPU_MXCSR _BITUL(1)
debug_checkwx() ptdump_walk_pgd_level_checkwx()
debug_checkwx_user() ptdump_walk_user_pgd_level_checkwx()
ZERO_PAGE() ((void)(),virt_to_page(empty_zero_page))
pte_page() pfn_to_page(pte_pfn())
has_transparent_hugepage has_transparent_hugepage
pgprot_modify pgprot_modify
pte_pgprot() __pgprot(pte_flags())
pmd_pgprot() __pgprot(pmd_flags())
pud_pgprot() __pgprot(pud_flags())
p4d_pgprot() __pgprot(p4d_flags())
canon_pgprot() __pgprot(massage_pgprot())
swapper_pg_dir init_top_pgt
pte_ERROR() pr_err("%s:%d: bad pte %p(%016lx)\n", __FILE__, __LINE__, &(), pte_val())
pmd_ERROR() pr_err("%s:%d: bad pmd %p(%016lx)\n", __FILE__, __LINE__, &(), pmd_val())
pud_ERROR() pr_err("%s:%d: bad pud %p(%016lx)\n", __FILE__, __LINE__, &(), pud_val())
pgd_ERROR() pr_err("%s:%d: bad pgd %p(%016lx)\n", __FILE__, __LINE__, &(), pgd_val())
mk_kernel_pgd() __pgd(() | _KERNPG_TABLE)
pte_offset_map(,) pte_offset_kernel((), ())
pte_unmap() ((void)())
SWP_TYPE_BITS 5
SWP_OFFSET_FIRST_BIT (_PAGE_BIT_PROTNONE + 1)
SWP_OFFSET_SHIFT (SWP_OFFSET_FIRST_BIT+SWP_TYPE_BITS)
MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > SWP_TYPE_BITS)
__swp_type() (().val >> (64 - SWP_TYPE_BITS))
__swp_offset() (~().val << SWP_TYPE_BITS >> SWP_OFFSET_SHIFT)
__swp_entry(,) ((swp_entry_t) { (~(unsigned long)() << SWP_OFFSET_SHIFT >> SWP_TYPE_BITS) | ((unsigned long)() << (64-SWP_TYPE_BITS)) })
__pte_to_swp_entry() ((swp_entry_t) { pte_val(()) })
__pmd_to_swp_entry() ((swp_entry_t) { pmd_val(()) })
__swp_entry_to_pte() ((pte_t) { .pte = ().val })
__swp_entry_to_pmd() ((pmd_t) { .pmd = ().val })
HAVE_ARCH_UNMAPPED_AREA 
HAVE_ARCH_UNMAPPED_AREA_TOPDOWN 
PAGE_AGP PAGE_KERNEL_NOCACHE
HAVE_PAGE_AGP 1
kc_vaddr_to_offset() (() & __VIRTUAL_MASK)
kc_offset_to_vaddr() (() | ~__VIRTUAL_MASK)
__HAVE_ARCH_PTE_SAME 
vmemmap ((struct page *)VMEMMAP_START)
gup_fast_permitted gup_fast_permitted
__HAVE_ARCH_PTE_SAME 
pte_accessible pte_accessible
pmd_page() pfn_to_page(pmd_pfn())
mk_pte(,) pfn_pte(page_to_pfn(), ())
pud_page() pfn_to_page(pud_pfn())
p4d_page() pfn_to_page(p4d_pfn())
pgd_index() ((() >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
pgd_offset_pgd(,) ( + pgd_index(()))
pgd_offset(,) pgd_offset_pgd(()->pgd, ())
pgd_offset_k() pgd_offset(&init_mm, ())
KERNEL_PGD_BOUNDARY pgd_index(PAGE_OFFSET)
KERNEL_PGD_PTRS (PTRS_PER_PGD - KERNEL_PGD_BOUNDARY)
__HAVE_ARCH_PTEP_SET_ACCESS_FLAGS 
__HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG 
__HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH 
__HAVE_ARCH_PTEP_GET_AND_CLEAR 
__HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL 
__HAVE_ARCH_PTEP_SET_WRPROTECT 
flush_tlb_fix_spurious_fault(,) do { } while (0)
mk_pmd(,) pfn_pmd(page_to_pfn(), ())
__HAVE_ARCH_PMDP_SET_ACCESS_FLAGS 
__HAVE_ARCH_PMDP_TEST_AND_CLEAR_YOUNG 
__HAVE_ARCH_PMDP_CLEAR_YOUNG_FLUSH 
pmd_write pmd_write
__HAVE_ARCH_PMDP_HUGE_GET_AND_CLEAR 
__HAVE_ARCH_PUDP_HUGE_GET_AND_CLEAR 
__HAVE_ARCH_PMDP_SET_WRPROTECT 
pud_write pud_write
pmdp_establish pmdp_establish
PTI_PGTABLE_SWITCH_BIT PAGE_SHIFT
PTE_SHIFT ilog2(PTRS_PER_PTE)
PKRU_AD_BIT 0x1u
PKRU_WD_BIT 0x2u
PKRU_BITS_PER_PKEY 2
pte_access_permitted pte_access_permitted
pmd_access_permitted pmd_access_permitted
pud_access_permitted pud_access_permitted
__HAVE_ARCH_PFN_MODIFY_ALLOWED 1
USER_PGTABLES_CEILING 0UL
pte_savedwrite pte_write
pte_mk_savedwrite pte_mkwrite
pte_clear_savedwrite pte_wrprotect
pmd_savedwrite pmd_write
pmd_mk_savedwrite pmd_mkwrite
pmd_clear_savedwrite pmd_wrprotect
p4d_access_permitted(,) (p4d_present() && (!() || p4d_write()))
pgd_access_permitted(,) (pgd_present() && (!() || pgd_write()))
set_pte_safe(,) \
({ WARN_ON_ONCE(pte_present(*) && !pte_same(*, )); set_pte(, ); \
})
set_pmd_safe(,) \
({ WARN_ON_ONCE(pmd_present(*) && !pmd_same(*, )); set_pmd(, ); \
})
set_pud_safe(,) \
({ WARN_ON_ONCE(pud_present(*) && !pud_same(*, )); set_pud(, ); \
})
set_p4d_safe(,) \
({ WARN_ON_ONCE(p4d_present(*) && !p4d_same(*, )); set_p4d(, ); \
})
set_pgd_safe(,) \
({ WARN_ON_ONCE(pgd_present(*) && !pgd_same(*, )); set_pgd(, ); \
})
pgd_offset_gate(,) pgd_offset(, )
move_pte(,,,) ()
pgprot_device pgprot_noncached
pgd_addr_end(,) \
({ unsigned long __boundary = (() + PGDIR_SIZE) & PGDIR_MASK; (__boundary - 1 < () - 1)? __boundary: (); \
})
pud_addr_end(,) \
({ unsigned long __boundary = (() + PUD_SIZE) & PUD_MASK; (__boundary - 1 < () - 1)? __boundary: (); \
})
pmd_addr_end(,) \
({ unsigned long __boundary = (() + PMD_SIZE) & PMD_MASK; (__boundary - 1 < () - 1)? __boundary: (); \
})
arch_needs_pgtable_deposit() (false)
flush_pmd_tlb_range(,,) flush_tlb_range(, , )
flush_pud_tlb_range(,,) flush_tlb_range(, , )
p4d_offset_lockless(,,) p4d_offset(&(), )
pud_offset_lockless(,,) pud_offset(&(), )
pmd_offset_lockless(,,) pmd_offset(&(), )
mm_p4d_folded() __is_defined(__PAGETABLE_P4D_FOLDED)
mm_pud_folded() __is_defined(__PAGETABLE_PUD_FOLDED)
mm_pmd_folded() __is_defined(__PAGETABLE_PMD_FOLDED)
untagged_addr() ()
page_to_virt() __va(PFN_PHYS(page_to_pfn()))
lm_alias() __va(__pa_symbol())
mm_forbids_zeropage() (0)
mm_zero_struct_page() __mm_zero_struct_page()
MAPCOUNT_ELF_CORE_MARGIN (5)
DEFAULT_MAX_MAP_COUNT (USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
nth_page(,) pfn_to_page(page_to_pfn(()) + ())
PAGE_ALIGN() ALIGN(, PAGE_SIZE)
PAGE_ALIGNED() IS_ALIGNED((unsigned long)(), PAGE_SIZE)
lru_to_page() (list_entry(()->prev, struct page, lru))
VM_NONE 0x00000000
VM_READ 0x00000001
VM_WRITE 0x00000002
VM_EXEC 0x00000004
VM_SHARED 0x00000008
VM_MAYREAD 0x00000010
VM_MAYWRITE 0x00000020
VM_MAYEXEC 0x00000040
VM_MAYSHARE 0x00000080
VM_GROWSDOWN 0x00000100
VM_UFFD_MISSING 0x00000200
VM_PFNMAP 0x00000400
VM_DENYWRITE 0x00000800
VM_UFFD_WP 0x00001000
VM_LOCKED 0x00002000
VM_IO 0x00004000
VM_SEQ_READ 0x00008000
VM_RAND_READ 0x00010000
VM_DONTCOPY 0x00020000
VM_DONTEXPAND 0x00040000
VM_LOCKONFAULT 0x00080000
VM_ACCOUNT 0x00100000
VM_NORESERVE 0x00200000
VM_HUGETLB 0x00400000
VM_SYNC 0x00800000
VM_ARCH_1 0x01000000
VM_WIPEONFORK 0x02000000
VM_DONTDUMP 0x04000000
VM_SOFTDIRTY 0x08000000
VM_MIXEDMAP 0x10000000
VM_HUGEPAGE 0x20000000
VM_NOHUGEPAGE 0x40000000
VM_MERGEABLE 0x80000000
VM_HIGH_ARCH_BIT_0 32
VM_HIGH_ARCH_BIT_1 33
VM_HIGH_ARCH_BIT_2 34
VM_HIGH_ARCH_BIT_3 35
VM_HIGH_ARCH_BIT_4 36
VM_HIGH_ARCH_0 BIT(VM_HIGH_ARCH_BIT_0)
VM_HIGH_ARCH_1 BIT(VM_HIGH_ARCH_BIT_1)
VM_HIGH_ARCH_2 BIT(VM_HIGH_ARCH_BIT_2)
VM_HIGH_ARCH_3 BIT(VM_HIGH_ARCH_BIT_3)
VM_HIGH_ARCH_4 BIT(VM_HIGH_ARCH_BIT_4)
VM_PKEY_SHIFT VM_HIGH_ARCH_BIT_0
VM_PKEY_BIT0 VM_HIGH_ARCH_0
VM_PKEY_BIT1 VM_HIGH_ARCH_1
VM_PKEY_BIT2 VM_HIGH_ARCH_2
VM_PKEY_BIT3 VM_HIGH_ARCH_3
VM_PKEY_BIT4 0
VM_PAT VM_ARCH_1
VM_MPX VM_HIGH_ARCH_4
VM_GROWSUP VM_NONE
VM_STACK_INCOMPLETE_SETUP (VM_RAND_READ | VM_SEQ_READ)
VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
VM_STACK VM_GROWSDOWN
VM_STACK_FLAGS (VM_STACK | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)
VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_PFNMAP | VM_MIXEDMAP)
VM_INIT_DEF_MASK VM_NOHUGEPAGE
VM_LOCKED_CLEAR_MASK (~(VM_LOCKED | VM_LOCKONFAULT))
VM_ARCH_CLEAR VM_NONE
VM_FLAGS_CLEAR (ARCH_VM_PKEY_FLAGS | VM_ARCH_CLEAR)
FAULT_FLAG_WRITE 0x01
FAULT_FLAG_MKWRITE 0x02
FAULT_FLAG_ALLOW_RETRY 0x04
FAULT_FLAG_RETRY_NOWAIT 0x08
FAULT_FLAG_KILLABLE 0x10
FAULT_FLAG_TRIED 0x20
FAULT_FLAG_USER 0x40
FAULT_FLAG_REMOTE 0x80
FAULT_FLAG_INSTRUCTION 0x100
FAULT_FLAG_TRACE { FAULT_FLAG_WRITE, "WRITE" }, { FAULT_FLAG_MKWRITE, "MKWRITE" }, { FAULT_FLAG_ALLOW_RETRY, "ALLOW_RETRY" }, { FAULT_FLAG_RETRY_NOWAIT, "RETRY_NOWAIT" }, { FAULT_FLAG_KILLABLE, "KILLABLE" }, { FAULT_FLAG_TRIED, "TRIED" }, { FAULT_FLAG_USER, "USER" }, { FAULT_FLAG_REMOTE, "REMOTE" }, { FAULT_FLAG_INSTRUCTION, "INSTRUCTION" }
TLB_FLUSH_VMA(,) { .vm_mm = (), .vm_flags = () }
SUID_DUMP_DISABLE 0
SUID_DUMP_USER 1
SUID_DUMP_ROOT 2
MMF_DUMPABLE_BITS 2
MMF_DUMPABLE_MASK ((1 << MMF_DUMPABLE_BITS) - 1)
MMF_DUMP_ANON_PRIVATE 2
MMF_DUMP_ANON_SHARED 3
MMF_DUMP_MAPPED_PRIVATE 4
MMF_DUMP_MAPPED_SHARED 5
MMF_DUMP_ELF_HEADERS 6
MMF_DUMP_HUGETLB_PRIVATE 7
MMF_DUMP_HUGETLB_SHARED 8
MMF_DUMP_DAX_PRIVATE 9
MMF_DUMP_DAX_SHARED 10
MMF_DUMP_FILTER_SHIFT MMF_DUMPABLE_BITS
MMF_DUMP_FILTER_BITS 9
MMF_DUMP_FILTER_MASK (((1 << MMF_DUMP_FILTER_BITS) - 1) << MMF_DUMP_FILTER_SHIFT)
MMF_DUMP_FILTER_DEFAULT ((1 << MMF_DUMP_ANON_PRIVATE) | (1 << MMF_DUMP_ANON_SHARED) | (1 << MMF_DUMP_HUGETLB_PRIVATE) | MMF_DUMP_MASK_DEFAULT_ELF)
MMF_DUMP_MASK_DEFAULT_ELF (1 << MMF_DUMP_ELF_HEADERS)
MMF_VM_MERGEABLE 16
MMF_VM_HUGEPAGE 17
MMF_HAS_UPROBES 19
MMF_RECALC_UPROBES 20
MMF_OOM_SKIP 21
MMF_UNSTABLE 22
MMF_HUGE_ZERO_PAGE 23
MMF_DISABLE_THP 24
MMF_OOM_VICTIM 25
MMF_OOM_REAP_QUEUED 26
MMF_MULTIPROCESS 27
MMF_DISABLE_THP_MASK (1 << MMF_DISABLE_THP)
MMF_INIT_MASK (MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK | MMF_DISABLE_THP_MASK)
HPAGE_PMD_ORDER (HPAGE_PMD_SHIFT-PAGE_SHIFT)
HPAGE_PMD_NR (1<<HPAGE_PMD_ORDER)
HPAGE_PMD_SHIFT PMD_SHIFT
HPAGE_PMD_SIZE ((1UL) << HPAGE_PMD_SHIFT)
HPAGE_PMD_MASK (~(HPAGE_PMD_SIZE - 1))
HPAGE_PUD_SHIFT PUD_SHIFT
HPAGE_PUD_SIZE ((1UL) << HPAGE_PUD_SHIFT)
HPAGE_PUD_MASK (~(HPAGE_PUD_SIZE - 1))
HPAGE_CACHE_INDEX_MASK (HPAGE_PMD_NR - 1)
transparent_hugepage_use_zero_page() (transparent_hugepage_flags & (1<<TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG))
transparent_hugepage_debug_cow() 0
split_huge_pmd(,,) do { pmd_t *____pmd = (); if (is_swap_pmd(*____pmd) || pmd_trans_huge(*____pmd) || pmd_devmap(*____pmd)) __split_huge_pmd(, , , false, NULL); } while (0)
split_huge_pud(,,) do { pud_t *____pud = (); if (pud_trans_huge(*____pud) || pud_devmap(*____pud)) __split_huge_pud(, , ); } while (0)
mk_huge_pmd(,) pmd_mkhuge(mk_pmd(, ))
is_ioremap_addr() is_vmalloc_addr()
SECTIONS_PGOFF ((sizeof(unsigned long)*8) - SECTIONS_WIDTH)
NODES_PGOFF (SECTIONS_PGOFF - NODES_WIDTH)
ZONES_PGOFF (NODES_PGOFF - ZONES_WIDTH)
LAST_CPUPID_PGOFF (ZONES_PGOFF - LAST_CPUPID_WIDTH)
KASAN_TAG_PGOFF (LAST_CPUPID_PGOFF - KASAN_TAG_WIDTH)
SECTIONS_PGSHIFT (SECTIONS_PGOFF * (SECTIONS_WIDTH != 0))
NODES_PGSHIFT (NODES_PGOFF * (NODES_WIDTH != 0))
ZONES_PGSHIFT (ZONES_PGOFF * (ZONES_WIDTH != 0))
LAST_CPUPID_PGSHIFT (LAST_CPUPID_PGOFF * (LAST_CPUPID_WIDTH != 0))
KASAN_TAG_PGSHIFT (KASAN_TAG_PGOFF * (KASAN_TAG_WIDTH != 0))
ZONEID_SHIFT (NODES_SHIFT + ZONES_SHIFT)
ZONEID_PGOFF ((NODES_PGOFF < ZONES_PGOFF)? NODES_PGOFF : ZONES_PGOFF)
ZONEID_PGSHIFT (ZONEID_PGOFF * (ZONEID_SHIFT != 0))
ZONES_MASK ((1UL << ZONES_WIDTH) - 1)
NODES_MASK ((1UL << NODES_WIDTH) - 1)
SECTIONS_MASK ((1UL << SECTIONS_WIDTH) - 1)
LAST_CPUPID_MASK ((1UL << LAST_CPUPID_SHIFT) - 1)
KASAN_TAG_MASK ((1UL << KASAN_TAG_WIDTH) - 1)
ZONEID_MASK ((1UL << ZONEID_SHIFT) - 1)
page_ref_zero_or_close_to_overflow() ((unsigned int) page_ref_count() + 127u <= 127u)
cpupid_match_pid(,) __cpupid_match_pid(->pid, )
DMA_ZONE() ##_DMA,
DMA32_ZONE() ##_DMA32,
HIGHMEM_ZONE() 
FOR_ALL_ZONES() DMA_ZONE() DMA32_ZONE() ##_NORMAL, HIGHMEM_ZONE() ##_MOVABLE
ENABLE_NUMA_STAT 1
DISABLE_NUMA_STAT 0
count_vm_numa_event() count_vm_event()
count_vm_numa_events(,) count_vm_events(, )
count_vm_tlb_event() do {} while (0)
count_vm_tlb_events(,) do { (void)(); } while (0)
count_vm_vmacache_event() do {} while (0)
__count_zid_vm_events(,,) __count_vm_events(##_NORMAL - ZONE_NORMAL + , )
page_address() lowmem_page_address()
set_page_address(,) do { } while(0)
page_address_init() do { } while(0)
offset_in_page() ((unsigned long)() & ~PAGE_MASK)
SHOW_MEM_FILTER_NODES (0x0001u)
vma_file_update_time() vma_do_file_update_time(, __func__, __LINE__)
vma_pr_or_file() vma_do_pr_or_file(, __func__, __LINE__)
vma_get_file() vma_do_get_file(, __func__, __LINE__)
vma_fput() vma_do_fput(, __func__, __LINE__)
pte_offset_map_lock(,,,) \
({ spinlock_t *__ptl = pte_lockptr(, ); pte_t *__pte = pte_offset_map(, ); *() = __ptl; spin_lock(__ptl); __pte; \
})
pte_unmap_unlock(,) do { spin_unlock(); pte_unmap(); \
} while (0)
pte_alloc(,) (unlikely(pmd_none(*())) && __pte_alloc(, ))
pte_alloc_map(,,) (pte_alloc(, ) ? NULL : pte_offset_map(, ))
pte_alloc_map_lock(,,,) (pte_alloc(, ) ? NULL : pte_offset_map_lock(, , , ))
pte_alloc_kernel(,) ((unlikely(pmd_none(*())) && __pte_alloc_kernel())? NULL: pte_offset_kernel(, ))
pmd_huge_pte(,) (pmd_to_page()->pmd_huge_pte)
vma_interval_tree_foreach(,,,) for ( = vma_interval_tree_iter_first(, , ); ;  = vma_interval_tree_iter_next(, , ))
anon_vma_interval_tree_foreach(,,,) for ( = anon_vma_interval_tree_iter_first(, , ); ;  = anon_vma_interval_tree_iter_next(, , ))
VM_UNMAPPED_AREA_TOPDOWN 1
VM_READAHEAD_PAGES (SZ_128K / PAGE_SIZE)
expand_upwards(,) (0)
FOLL_WRITE 0x01
FOLL_TOUCH 0x02
FOLL_GET 0x04
FOLL_DUMP 0x08
FOLL_FORCE 0x10
FOLL_NOWAIT 0x20
FOLL_POPULATE 0x40
FOLL_SPLIT 0x80
FOLL_HWPOISON 0x100
FOLL_NUMA 0x200
FOLL_MIGRATION 0x400
FOLL_TRIED 0x800
FOLL_MLOCK 0x1000
FOLL_REMOTE 0x2000
FOLL_COW 0x4000
FOLL_ANON 0x8000
FOLL_LONGTERM 0x10000
FOLL_SPLIT_PMD 0x20000
put_hwpoison_page() put_page()
__bvec_iter_bvec(,) (&()[().bi_idx])
mp_bvec_iter_page(,) (__bvec_iter_bvec((), ())->bv_page)
mp_bvec_iter_len(,) min(().bi_size, __bvec_iter_bvec((), ())->bv_len - ().bi_bvec_done)
mp_bvec_iter_offset(,) (__bvec_iter_bvec((), ())->bv_offset + ().bi_bvec_done)
mp_bvec_iter_page_idx(,) (mp_bvec_iter_offset((), ()) / PAGE_SIZE)
mp_bvec_iter_bvec(,) \
((struct bio_vec) { .bv_page = mp_bvec_iter_page((), ()), .bv_len = mp_bvec_iter_len((), ()), .bv_offset = mp_bvec_iter_offset((), ()), \
})
bvec_iter_offset(,) (mp_bvec_iter_offset((), ()) % PAGE_SIZE)
bvec_iter_len(,) min_t(unsigned, mp_bvec_iter_len((), ()), PAGE_SIZE - bvec_iter_offset((), ()))
bvec_iter_page(,) (mp_bvec_iter_page((), ()) + mp_bvec_iter_page_idx((), ()))
bvec_iter_bvec(,) \
((struct bio_vec) { .bv_page = bvec_iter_page((), ()), .bv_len = bvec_iter_len((), ()), .bv_offset = bvec_iter_offset((), ()), \
})
for_each_bvec(,,,) for ( = (); ().bi_size && (( = bvec_iter_bvec((), ())), 1); ().bv_len ? (void)bvec_iter_advance((), &(), ().bv_len) : bvec_iter_skip_zero_bvec(&()))
BVEC_ITER_ALL_INIT (struct bvec_iter) \
{ .bi_sector = 0, .bi_size = UINT_MAX, .bi_idx = 0, .bi_bvec_done = 0, \
}
BLK_STS_OK 0
BLK_STS_NOTSUPP ((__force blk_status_t)1)
BLK_STS_TIMEOUT ((__force blk_status_t)2)
BLK_STS_NOSPC ((__force blk_status_t)3)
BLK_STS_TRANSPORT ((__force blk_status_t)4)
BLK_STS_TARGET ((__force blk_status_t)5)
BLK_STS_NEXUS ((__force blk_status_t)6)
BLK_STS_MEDIUM ((__force blk_status_t)7)
BLK_STS_PROTECTION ((__force blk_status_t)8)
BLK_STS_RESOURCE ((__force blk_status_t)9)
BLK_STS_IOERR ((__force blk_status_t)10)
BLK_STS_DM_REQUEUE ((__force blk_status_t)11)
BLK_STS_AGAIN ((__force blk_status_t)12)
BLK_STS_DEV_RESOURCE ((__force blk_status_t)13)
BIO_ISSUE_RES_BITS 1
BIO_ISSUE_SIZE_BITS 12
BIO_ISSUE_RES_SHIFT (64 - BIO_ISSUE_RES_BITS)
BIO_ISSUE_SIZE_SHIFT (BIO_ISSUE_RES_SHIFT - BIO_ISSUE_SIZE_BITS)
BIO_ISSUE_TIME_MASK ((1ULL << BIO_ISSUE_SIZE_SHIFT) - 1)
BIO_ISSUE_SIZE_MASK (((1ULL << BIO_ISSUE_SIZE_BITS) - 1) << BIO_ISSUE_SIZE_SHIFT)
BIO_ISSUE_RES_MASK (~((1ULL << BIO_ISSUE_RES_SHIFT) - 1))
BIO_ISSUE_THROTL_SKIP_LATENCY (1ULL << 63)
BIO_RESET_BYTES offsetof(struct bio, bi_max_vecs)
BVEC_POOL_NR 6
BVEC_POOL_MAX (BVEC_POOL_NR - 1)
BVEC_POOL_BITS (3)
BVEC_POOL_OFFSET (16 - BVEC_POOL_BITS)
BVEC_POOL_IDX() (()->bi_flags >> BVEC_POOL_OFFSET)
BIO_RESET_BITS BVEC_POOL_OFFSET
REQ_OP_BITS 8
REQ_OP_MASK ((1 << REQ_OP_BITS) - 1)
REQ_FLAG_BITS 24
REQ_FAILFAST_DEV (1ULL << __REQ_FAILFAST_DEV)
REQ_FAILFAST_TRANSPORT (1ULL << __REQ_FAILFAST_TRANSPORT)
REQ_FAILFAST_DRIVER (1ULL << __REQ_FAILFAST_DRIVER)
REQ_SYNC (1ULL << __REQ_SYNC)
REQ_META (1ULL << __REQ_META)
REQ_PRIO (1ULL << __REQ_PRIO)
REQ_NOMERGE (1ULL << __REQ_NOMERGE)
REQ_IDLE (1ULL << __REQ_IDLE)
REQ_INTEGRITY (1ULL << __REQ_INTEGRITY)
REQ_FUA (1ULL << __REQ_FUA)
REQ_PREFLUSH (1ULL << __REQ_PREFLUSH)
REQ_RAHEAD (1ULL << __REQ_RAHEAD)
REQ_BACKGROUND (1ULL << __REQ_BACKGROUND)
REQ_NOWAIT (1ULL << __REQ_NOWAIT)
REQ_NOWAIT_INLINE (1ULL << __REQ_NOWAIT_INLINE)
REQ_CGROUP_PUNT (1ULL << __REQ_CGROUP_PUNT)
REQ_NOUNMAP (1ULL << __REQ_NOUNMAP)
REQ_HIPRI (1ULL << __REQ_HIPRI)
REQ_DRV (1ULL << __REQ_DRV)
REQ_SWAP (1ULL << __REQ_SWAP)
REQ_FAILFAST_MASK (REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER)
REQ_NOMERGE_FLAGS (REQ_NOMERGE | REQ_PREFLUSH | REQ_FUA)
bio_op() (()->bi_opf & REQ_OP_MASK)
req_op() (()->cmd_flags & REQ_OP_MASK)
BLK_QC_T_NONE -1U
BLK_QC_T_EAGAIN -2U
BLK_QC_T_SHIFT 16
BLK_QC_T_INTERNAL (1U << 31)
LOCAL_INIT() { ATOMIC_LONG_INIT() }
local_read() atomic_long_read(&()->a)
local_set(,) atomic_long_set(&()->a, ())
local_inc_return() (local_add_return(1, ))
local_dec_return() (local_sub_return(1, ))
local_cmpxchg(,,) (cmpxchg_local(&(()->a.counter), (), ()))
local_xchg(,) (xchg(&(()->a.counter), ()))
local_add_unless(,,) \
({ long c, old; c = local_read(()); for (;;) { if (unlikely(c == ())) break; old = local_cmpxchg((), c, c + ()); if (likely(old == c)) break; c = old; } c != (); \
})
local_inc_not_zero() local_add_unless((), 1, 0)
__local_inc() local_inc()
__local_dec() local_dec()
__local_add(,) local_add((), ())
__local_sub(,) local_sub((), ())
dev_to_disk() container_of((), struct gendisk, part0.__dev)
dev_to_part() container_of((), struct hd_struct, __dev)
disk_to_dev() (&()->part0.__dev)
part_to_dev() (&(()->__dev))
DISK_MAX_PARTS 256
DISK_NAME_LEN 32
PARTITION_META_INFO_VOLNAMELTH 64
PARTITION_META_INFO_UUIDLTH (UUID_STRING_LEN + 1)
GENHD_FL_REMOVABLE 1
GENHD_FL_MEDIA_CHANGE_NOTIFY 4
GENHD_FL_CD 8
GENHD_FL_UP 16
GENHD_FL_SUPPRESS_PARTITION_INFO 32
GENHD_FL_EXT_DEVT 64
GENHD_FL_NATIVE_CAPACITY 128
GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE 256
GENHD_FL_NO_PART_SCAN 512
GENHD_FL_HIDDEN 1024
DISK_PITER_REVERSE (1 << 0)
DISK_PITER_INCL_EMPTY (1 << 1)
DISK_PITER_INCL_PART0 (1 << 2)
DISK_PITER_INCL_EMPTY_PART0 (1 << 3)
part_stat_lock() ({ rcu_read_lock(); get_cpu(); })
part_stat_unlock() do { put_cpu(); rcu_read_unlock(); } while (0)
part_stat_get_cpu(,,) (per_cpu_ptr(()->dkstats, ())->)
part_stat_get(,) part_stat_get_cpu(, , smp_processor_id())
part_stat_read(,) \
({ typeof(()->dkstats->) res = 0; unsigned int _cpu; for_each_possible_cpu(_cpu) res += per_cpu_ptr(()->dkstats, _cpu)->; res; \
})
part_stat_read_msecs(,) div_u64(part_stat_read(, nsecs[]), NSEC_PER_MSEC)
part_stat_read_accum(,) (part_stat_read(, [STAT_READ]) + part_stat_read(, [STAT_WRITE]) + part_stat_read(, [STAT_DISCARD]))
__part_stat_add(,,) (part_stat_get(, ) += ())
part_stat_add(,,) do { __part_stat_add((), , ); if (()->partno) __part_stat_add(&part_to_disk(())->part0, , ); \
} while (0)
part_stat_dec(,) part_stat_add(, , -1)
part_stat_inc(,) part_stat_add(, , 1)
part_stat_sub(,,) part_stat_add(, , -)
part_stat_local_dec(,) local_dec(&(part_stat_get(, )))
part_stat_local_inc(,) local_inc(&(part_stat_get(, )))
part_stat_local_read(,) local_read(&(part_stat_get(, )))
part_stat_local_read_cpu(,,) local_read(&(part_stat_get_cpu(, , )))
SOLARIS_X86_NUMSLICE 16
SOLARIS_X86_VTOC_SANE (0x600DDEEEUL)
BSD_DISKMAGIC (0x82564557UL)
BSD_MAXPARTITIONS 16
OPENBSD_MAXPARTITIONS 16
BSD_FS_UNUSED 0
NDDATA 5
NSPARE 5
UNIXWARE_DISKMAGIC (0xCA5E600DUL)
UNIXWARE_DISKMAGIC2 (0x600DDEEEUL)
UNIXWARE_NUMSLICE 16
UNIXWARE_FS_UNUSED 0
MINIX_NR_SUBPARTITIONS 4
ADDPART_FLAG_NONE 0
ADDPART_FLAG_RAID 1
ADDPART_FLAG_WHOLEDISK 2
alloc_disk_node(,) \
({ static struct lock_class_key __key; const char *__name; struct gendisk *__disk; __name = "(gendisk_completion)"#"("#")"; __disk = __alloc_disk_node(, ); if (__disk) lockdep_init_map(&__disk->lockdep_map, __name, &__key, 0); __disk; \
})
alloc_disk() alloc_disk_node(, NUMA_NO_NODE)
ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 0
copy_to_user_page(,,,,,) do { memcpy(, , ); flush_icache_user_range(, , , ); } while (0)
copy_from_user_page(,,,,,) memcpy(, , )
kmap_atomic_prot(,) kmap_atomic()
kmap_atomic_pfn() kmap_atomic(pfn_to_page())
kmap_flush_unused() do {} while(0)
kunmap_atomic() do { BUILD_BUG_ON(__same_type((), struct page *)); __kunmap_atomic(); \
} while (0)
FGP_ACCESSED 0x00000001
FGP_LOCK 0x00000002
FGP_CREAT 0x00000004
FGP_WRITE 0x00000008
FGP_NOFS 0x00000010
FGP_NOWAIT 0x00000020
FGP_FOR_MMAP 0x00000040
FPROP_FRAC_SHIFT 10
FPROP_FRAC_BASE (1UL << FPROP_FRAC_SHIFT)
INIT_FPROP_LOCAL_SINGLE() \
{ .lock = __RAW_SPIN_LOCK_UNLOCKED(.lock), \
}
WB_STAT_BATCH (8*(1+ilog2(nr_cpu_ids)))
__WB_COMPLETION_INIT() (struct wb_completion){ .cnt = ATOMIC_INIT(1), .waitq = () }
WB_COMPLETION_INIT() __WB_COMPLETION_INIT(&()->wb_waitq)
DEFINE_WB_COMPLETION(,) struct wb_completion  = WB_COMPLETION_INIT()
BIO_DEBUG 
BIO_BUG_ON BUG_ON
BIO_MAX_PAGES 256
bio_prio() ()->bi_ioprio
bio_set_prio(,) (()->bi_ioprio = )
bio_iter_iovec(,) bvec_iter_bvec(()->bi_io_vec, ())
bio_iter_page(,) bvec_iter_page(()->bi_io_vec, ())
bio_iter_len(,) bvec_iter_len(()->bi_io_vec, ())
bio_iter_offset(,) bvec_iter_offset(()->bi_io_vec, ())
bio_page() bio_iter_page((), ()->bi_iter)
bio_offset() bio_iter_offset((), ()->bi_iter)
bio_iovec() bio_iter_iovec((), ()->bi_iter)
bvec_iter_sectors() (().bi_size >> 9)
bvec_iter_end_sector() (().bi_sector + bvec_iter_sectors(()))
bio_sectors() bvec_iter_sectors(()->bi_iter)
bio_end_sector() bvec_iter_end_sector(()->bi_iter)
bio_data_dir() (op_is_write(bio_op()) ? WRITE : READ)
bio_for_each_segment_all(,,) for ( = bvec_init_iter_all(&); bio_next_segment((), &); )
__bio_for_each_segment(,,,) for ( = (); ().bi_size && (( = bio_iter_iovec((), ())), 1); bio_advance_iter((), &(), ().bv_len))
bio_for_each_segment(,,) __bio_for_each_segment(, , , ()->bi_iter)
__bio_for_each_bvec(,,,) for ( = (); ().bi_size && (( = mp_bvec_iter_bvec(()->bi_io_vec, ())), 1); bio_advance_iter((), &(), ().bv_len))
bio_for_each_bvec(,,) __bio_for_each_bvec(, , , ()->bi_iter)
bio_iter_last(,) (().bi_size == ().bv_len)
bio_set_dev(,) do { if (()->bi_disk != ()->bd_disk) bio_clear_flag(, BIO_THROTTLED); ()->bi_disk = ()->bd_disk; ()->bi_partno = ()->bd_partno; bio_associate_blkg(); \
} while (0)
bio_copy_dev(,) do { ()->bi_disk = ()->bi_disk; ()->bi_partno = ()->bi_partno; bio_clone_blkg_association(, ); \
} while (0)
bio_dev() disk_devt(()->bi_disk)
BIO_EMPTY_LIST { NULL, NULL }
bio_list_for_each(,) for ( = ()->head; ;  = ->bi_next)
BIO_POOL_SIZE 2
BIO_SPLIT_ENTRIES 2
bip_for_each_vec(,,) for_each_bvec(, ()->bip_vec, , ()->bip_iter)
bio_for_each_integrity_vec(,,) for_each_bio() bip_for_each_vec(, ->bi_integrity, )
BSG_PROTOCOL_SCSI 0
BSG_SUB_PROTOCOL_SCSI_CMD 0
BSG_SUB_PROTOCOL_SCSI_TMF 1
BSG_SUB_PROTOCOL_SCSI_TRANSPORT 2
BSG_FLAG_Q_AT_TAIL 0x10
BSG_FLAG_Q_AT_HEAD 0x20
SCATTERLIST_MAX_SEGMENT (UINT_MAX & PAGE_MASK)
sg_dma_address() (()->dma_address)
sg_dma_len() (()->dma_length)
SG_CHAIN 0x01UL
SG_END 0x02UL
sg_is_chain() (()->page_link & SG_CHAIN)
sg_is_last() (()->page_link & SG_END)
sg_chain_ptr() ((struct scatterlist *) (()->page_link & ~(SG_CHAIN | SG_END)))
for_each_sg(,,,) for ( = 0,  = ();  < (); ++,  = sg_next())
for_each_sgtable_sg(,,) for_each_sg(->sgl, , ->orig_nents, )
for_each_sgtable_dma_sg(,,) for_each_sg(->sgl, , ->nents, )
SG_MAX_SINGLE_ALLOC (PAGE_SIZE / sizeof(struct scatterlist))
SG_CHUNK_SIZE 128
SG_MAX_SEGMENTS 2048
for_each_sg_page(,,,) for (__sg_page_iter_start((), (), (), ()); __sg_page_iter_next();)
for_each_sg_dma_page(,,,) for (__sg_page_iter_start(&()->base, , , ); __sg_page_iter_dma_next();)
for_each_sgtable_page(,,) for_each_sg_page(->sgl, , ->orig_nents, )
for_each_sgtable_dma_page(,,) for_each_sg_dma_page(->sgl, , ->nents, )
SG_MITER_ATOMIC (1 << 0)
SG_MITER_TO_SG (1 << 1)
SG_MITER_FROM_SG (1 << 2)
BLKREPORTZONE _IOWR(0x12, 130, struct blk_zone_report)
BLKRESETZONE _IOW(0x12, 131, struct blk_zone_range)
BLKGETZONESZ _IOR(0x12, 132, __u32)
BLKGETNRZONES _IOR(0x12, 133, __u32)
BLKDEV_MIN_RQ 4
BLKDEV_MAX_RQ 128
BLK_MQ_POLL_STATS_BKTS 16
BLK_MQ_POLL_CLASSIC -1
BLKCG_MAX_POLS 5
RQF_SORTED ((__force req_flags_t)(1 << 0))
RQF_STARTED ((__force req_flags_t)(1 << 1))
RQF_SOFTBARRIER ((__force req_flags_t)(1 << 3))
RQF_FLUSH_SEQ ((__force req_flags_t)(1 << 4))
RQF_MIXED_MERGE ((__force req_flags_t)(1 << 5))
RQF_MQ_INFLIGHT ((__force req_flags_t)(1 << 6))
RQF_DONTPREP ((__force req_flags_t)(1 << 7))
RQF_PREEMPT ((__force req_flags_t)(1 << 8))
RQF_COPY_USER ((__force req_flags_t)(1 << 9))
RQF_FAILED ((__force req_flags_t)(1 << 10))
RQF_QUIET ((__force req_flags_t)(1 << 11))
RQF_ELVPRIV ((__force req_flags_t)(1 << 12))
RQF_IO_STAT ((__force req_flags_t)(1 << 13))
RQF_ALLOCED ((__force req_flags_t)(1 << 14))
RQF_PM ((__force req_flags_t)(1 << 15))
RQF_HASHED ((__force req_flags_t)(1 << 16))
RQF_STATS ((__force req_flags_t)(1 << 17))
RQF_SPECIAL_PAYLOAD ((__force req_flags_t)(1 << 18))
RQF_ZONE_WRITE_LOCKED ((__force req_flags_t)(1 << 19))
RQF_MQ_POLL_SLEPT ((__force req_flags_t)(1 << 20))
RQF_TIMED_OUT ((__force req_flags_t)(1 << 21))
RQF_NOMERGE_FLAGS (RQF_STARTED | RQF_SOFTBARRIER | RQF_FLUSH_SEQ | RQF_SPECIAL_PAYLOAD)
DEFINE_HASHTABLE(,) struct hlist_head [1 << ()] = { [0 ... ((1 << ()) - 1)] = HLIST_HEAD_INIT }
DEFINE_READ_MOSTLY_HASHTABLE(,) struct hlist_head [1 << ()] __read_mostly = { [0 ... ((1 << ()) - 1)] = HLIST_HEAD_INIT }
DECLARE_HASHTABLE(,) struct hlist_head [1 << ()]
HASH_SIZE() (ARRAY_SIZE())
HASH_BITS() ilog2(HASH_SIZE())
hash_min(,) (sizeof() <= 4 ? hash_32(, ) : hash_long(, ))
hash_init() __hash_init(, HASH_SIZE())
hash_add(,,) hlist_add_head(, &[hash_min(, HASH_BITS())])
hash_add_rcu(,,) hlist_add_head_rcu(, &[hash_min(, HASH_BITS())])
hash_empty() __hash_empty(, HASH_SIZE())
hash_for_each(,,,) for (() = 0,  = NULL;  == NULL && () < HASH_SIZE(); ()++) hlist_for_each_entry(, &[], )
hash_for_each_rcu(,,,) for (() = 0,  = NULL;  == NULL && () < HASH_SIZE(); ()++) hlist_for_each_entry_rcu(, &[], )
hash_for_each_safe(,,,,) for (() = 0,  = NULL;  == NULL && () < HASH_SIZE(); ()++) hlist_for_each_entry_safe(, , &[], )
hash_for_each_possible(,,,) hlist_for_each_entry(, &[hash_min(, HASH_BITS())], )
hash_for_each_possible_rcu(,,,) hlist_for_each_entry_rcu(, &[hash_min(, HASH_BITS())], )
hash_for_each_possible_rcu_notrace(,,,) hlist_for_each_entry_rcu_notrace(, &[hash_min(, HASH_BITS())], )
hash_for_each_possible_safe(,,,,) hlist_for_each_entry_safe(, , &[hash_min(, HASH_BITS())], )
ELV_NAME_MAX (16)
ELV_HASH_BITS 6
ELEVATOR_INSERT_FRONT 1
ELEVATOR_INSERT_BACK 2
ELEVATOR_INSERT_SORT 3
ELEVATOR_INSERT_REQUEUE 4
ELEVATOR_INSERT_FLUSH 5
ELEVATOR_INSERT_SORT_MERGE 6
rq_end_sector() (blk_rq_pos() + blk_rq_sectors())
rb_entry_rq() rb_entry((), struct request, rb_node)
rq_entry_fifo() list_entry((), struct request, queuelist)
rq_fifo_clear() list_del_init(&()->queuelist)
ELEVATOR_F_ZBD_SEQ_WRITE (1U << 0)
BLK_TAG_ALLOC_FIFO 0
BLK_TAG_ALLOC_RR 1
BLK_SCSI_MAX_CMDS (256)
BLK_SCSI_CMD_PER_LONG (BLK_SCSI_MAX_CMDS / (sizeof(long) * 8))
BLK_ZONED_REPORT_MAX_ZONES 8192U
BLK_MAX_WRITE_HINTS 5
QUEUE_FLAG_STOPPED 0
QUEUE_FLAG_DYING 1
QUEUE_FLAG_NOMERGES 3
QUEUE_FLAG_SAME_COMP 4
QUEUE_FLAG_FAIL_IO 5
QUEUE_FLAG_NONROT 6
QUEUE_FLAG_VIRT QUEUE_FLAG_NONROT
QUEUE_FLAG_IO_STAT 7
QUEUE_FLAG_DISCARD 8
QUEUE_FLAG_NOXMERGES 9
QUEUE_FLAG_ADD_RANDOM 10
QUEUE_FLAG_SECERASE 11
QUEUE_FLAG_SAME_FORCE 12
QUEUE_FLAG_DEAD 13
QUEUE_FLAG_INIT_DONE 14
QUEUE_FLAG_POLL 16
QUEUE_FLAG_WC 17
QUEUE_FLAG_FUA 18
QUEUE_FLAG_DAX 19
QUEUE_FLAG_STATS 20
QUEUE_FLAG_POLL_STATS 21
QUEUE_FLAG_REGISTERED 22
QUEUE_FLAG_SCSI_PASSTHROUGH 23
QUEUE_FLAG_QUIESCED 24
QUEUE_FLAG_PCI_P2PDMA 25
QUEUE_FLAG_ZONE_RESETALL 26
QUEUE_FLAG_RQ_ALLOC_TIME 27
QUEUE_FLAG_MQ_DEFAULT ((1 << QUEUE_FLAG_IO_STAT) | (1 << QUEUE_FLAG_SAME_COMP))
blk_queue_stopped() test_bit(QUEUE_FLAG_STOPPED, &()->queue_flags)
blk_queue_dying() test_bit(QUEUE_FLAG_DYING, &()->queue_flags)
blk_queue_dead() test_bit(QUEUE_FLAG_DEAD, &()->queue_flags)
blk_queue_init_done() test_bit(QUEUE_FLAG_INIT_DONE, &()->queue_flags)
blk_queue_nomerges() test_bit(QUEUE_FLAG_NOMERGES, &()->queue_flags)
blk_queue_noxmerges() test_bit(QUEUE_FLAG_NOXMERGES, &()->queue_flags)
blk_queue_nonrot() test_bit(QUEUE_FLAG_NONROT, &()->queue_flags)
blk_queue_io_stat() test_bit(QUEUE_FLAG_IO_STAT, &()->queue_flags)
blk_queue_add_random() test_bit(QUEUE_FLAG_ADD_RANDOM, &()->queue_flags)
blk_queue_discard() test_bit(QUEUE_FLAG_DISCARD, &()->queue_flags)
blk_queue_zone_resetall() test_bit(QUEUE_FLAG_ZONE_RESETALL, &()->queue_flags)
blk_queue_secure_erase() (test_bit(QUEUE_FLAG_SECERASE, &()->queue_flags))
blk_queue_dax() test_bit(QUEUE_FLAG_DAX, &()->queue_flags)
blk_queue_scsi_passthrough() test_bit(QUEUE_FLAG_SCSI_PASSTHROUGH, &()->queue_flags)
blk_queue_pci_p2pdma() test_bit(QUEUE_FLAG_PCI_P2PDMA, &()->queue_flags)
blk_queue_rq_alloc_time() test_bit(QUEUE_FLAG_RQ_ALLOC_TIME, &()->queue_flags)
blk_noretry_request() (()->cmd_flags & (REQ_FAILFAST_DEV|REQ_FAILFAST_TRANSPORT| REQ_FAILFAST_DRIVER))
blk_queue_quiesced() test_bit(QUEUE_FLAG_QUIESCED, &()->queue_flags)
blk_queue_pm_only() atomic_read(&()->pm_only)
blk_queue_fua() test_bit(QUEUE_FLAG_FUA, &()->queue_flags)
blk_queue_registered() test_bit(QUEUE_FLAG_REGISTERED, &()->queue_flags)
list_entry_rq() list_entry((), struct request, queuelist)
rq_data_dir() (op_is_write(req_op()) ? WRITE : READ)
rq_dma_dir() (op_is_write(req_op()) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
dma_map_bvec(,,,) dma_map_page_attrs(, ()->bv_page, ()->bv_offset, ()->bv_len, (), ())
BLK_BOUNCE_HIGH -1ULL
BLK_BOUNCE_ANY (-1ULL)
BLK_BOUNCE_ISA (DMA_BIT_MASK(24))
BLK_DEFAULT_SG_TIMEOUT (60 * HZ)
BLK_MIN_SG_TIMEOUT (7 * HZ)
for_each_bio() for (; ;  = ->bi_next)
__rq_for_each_bio(,) if ((->bio)) for ( = ()->bio; ;  = ->bi_next)
rq_for_each_segment(,,) __rq_for_each_bio(.bio, ) bio_for_each_segment(, .bio, .iter)
rq_for_each_bvec(,,) __rq_for_each_bio(.bio, ) bio_for_each_bvec(, .bio, .iter)
rq_iter_last(,) (.bio->bi_next == NULL && bio_iter_last(, .iter))
SECTOR_SHIFT 9
SECTOR_SIZE (1 << SECTOR_SHIFT)
BLK_MAX_REQUEST_COUNT 16
BLK_PLUG_FLUSH_SIZE (128 * 1024)
BLKDEV_DISCARD_SECURE (1 << 0)
BLKDEV_ZERO_NOUNMAP (1 << 0)
BLKDEV_ZERO_NOFALLBACK (1 << 1)
MODULE_ALIAS_BLOCKDEV(,) MODULE_ALIAS("block-major-" __stringify() "-" __stringify())
MODULE_ALIAS_BLOCKDEV_MAJOR() MODULE_ALIAS("block-major-" __stringify() "-*")

Total 7888 symbols, 2347 types, 20307 macros
